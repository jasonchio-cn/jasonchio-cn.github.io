<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>树莓派4B启动配置</title>
      <link href="/posts/59454.html"/>
      <url>/posts/59454.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-镜像及工具"><a href="#1-镜像及工具" class="headerlink" title="1. 镜像及工具"></a>1. 镜像及工具</h2><h3 id="1-1-系统镜像"><a href="#1-1-系统镜像" class="headerlink" title="1.1. 系统镜像"></a>1.1. 系统镜像</h3><h4 id="1-1-1-Raspberry-Pi-OS"><a href="#1-1-1-Raspberry-Pi-OS" class="headerlink" title="1.1.1. Raspberry Pi OS"></a>1.1.1. Raspberry Pi OS</h4><p>官方镜像，基于Debian的一个发行版，针对树莓派做了优化。</p><p>一共提供了三个版本，镜像大小逐个递减。</p><ol><li>Raspberry Pi OS with desktop and recommended software：有图形界面，内置各种软件，比如我的世界、Python、游戏等；</li><li>Raspberry Pi OS with desktop：有图形界面、浏览器，没有一些乱七八糟的软件；</li><li>Raspberry Pi OS Lite：无图形界面，有核心依赖，比如Python等。</li></ol><p>需要图形化界面的更推荐Raspberry Pi OS with desktop这个版本，不大不小。不过<strong>官网默认提供的是32bit的版本</strong>，树莓派RaspBerry4B的CPU是博通的BCM2711，一颗ARM Cortex-A72架构的64位处理器，所以使用64位系统才能更好释放性能。</p><blockquote><p><a href="https://downloads.raspberrypi.org/raspios_armhf/images/">32bit镜像官网链接</a></p><p><a href="https://downloads.raspberrypi.org/raspios_arm64/images">64bit镜像官网链接</a></p><p><a href="https://www.raspberrypi.com/software/operating-systems/">镜像的官方介绍及各个版本</a></p></blockquote><h3 id="1-2-SD卡格式化工具"><a href="#1-2-SD卡格式化工具" class="headerlink" title="1.2. SD卡格式化工具"></a>1.2. SD卡格式化工具</h3><p>SD Card Formatter</p><p><a href="https://www.sdcard.org/downloads/formatter/sd-memory-card-formatter-for-windows-download/">官网下载链接</a></p><h3 id="1-3-写镜像工具"><a href="#1-3-写镜像工具" class="headerlink" title="1.3. 写镜像工具"></a>1.3. 写镜像工具</h3><p>Win32DiskImager</p><p><a href="https://sourceforge.net/projects/win32diskimager/files/latest/download">官方下载链接</a></p><h3 id="1-4-远程桌面工具"><a href="#1-4-远程桌面工具" class="headerlink" title="1.4. 远程桌面工具"></a>1.4. 远程桌面工具</h3><h5 id="VNC-Viewer"><a href="#VNC-Viewer" class="headerlink" title="VNC Viewer"></a>VNC Viewer</h5><p><a href="https://www.realvnc.com/en/connect/download/viewer/">官方下载链接</a></p><h2 id="2-刷写系统"><a href="#2-刷写系统" class="headerlink" title="2. 刷写系统"></a>2. 刷写系统</h2><h3 id="2-1-下载镜像"><a href="#2-1-下载镜像" class="headerlink" title="2.1. 下载镜像"></a>2.1. 下载镜像</h3><p>此处我下载的是64位的最新镜像，官方文件名为：2021-05-07-raspios-buster-arm64</p><p>下载之后可以Windows 10终端里输入下面命令来计算SHA256进行完整性校验。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">certutil -hashfile 镜像存放路径\2021-05-07-raspios-buster-arm64.zip SHA256</span><br></pre></td></tr></table></figure><p>BTW，可选哈希算法参数有MD2 MD4 MD5 SHA1 SHA256 SHA384 SHA512</p><p><img src="https://images.961110.xyz/images/2021/10/19/Raspberry-Pi-OS-with-desktop-.png" alt="image-20211016201407578" style="zoom:50%;" /><img src="https://images.961110.xyz/images/2021/10/19/Raspberry-Pi-OS-with-desktop-dc4e0e6197208ff1.png" alt="image-20211016201252081" style="zoom:50%;" /></p><p>两个不同的下载通道都可以看到SHA256的值，最好校验一下。</p><p>校验无误后，解压得到<code>.img</code>镜像文件，待会写到SD卡中。</p><h3 id="2-2-格式化SD卡"><a href="#2-2-格式化SD卡" class="headerlink" title="2.2. 格式化SD卡"></a>2.2. 格式化SD卡</h3><p>选择好SD卡对应的盘符，选择Quick format，点击右下角Format，稍等片刻即可。<strong>注意不要选择错了盘符，否则后果不堪设想。</strong></p><p><img src="https://images.961110.xyz/images/2021/10/19/SD-Card-Formatter.png" alt="image-20211016201935243" style="zoom: 67%;" /><img src="https://images.961110.xyz/images/2021/10/19/SD.png" alt="image-20211016202211668" style="zoom:67%;" /></p><h3 id="2-3-刷写镜像"><a href="#2-3-刷写镜像" class="headerlink" title="2.3. 刷写镜像"></a>2.3. 刷写镜像</h3><p>选择刚刚解压出来的镜像文件，选择好盘符，然后点击写入即可，完成速度取决于SD卡及读卡器的速度。</p><p><img src="https://images.961110.xyz/images/2021/10/19/f28e57496b9b60234c05963587aebae3.png" alt="image-20211016202444369" style="zoom:67%;" /><img src="https://images.961110.xyz/images/2021/10/19/1163840ac01b2da689eb0dc2686f4eb3.png" alt="image-20211016203816344" style="zoom:67%;" /></p><h2 id="3-启动"><a href="#3-启动" class="headerlink" title="3. 启动"></a>3. 启动</h2><h3 id="3-1-准备工作"><a href="#3-1-准备工作" class="headerlink" title="3.1. 准备工作"></a>3.1. 准备工作</h3><h4 id="3-1-1-开启ssh"><a href="#3-1-1-开启ssh" class="headerlink" title="3.1.1. 开启ssh"></a>3.1.1. 开启ssh</h4><p>写入镜像后，会有一个boot分区，在boot分区下新建一个<strong>删掉格式后缀</strong>的名为ssh的<strong>文件</strong>，以便启动后使用ssh连接树莓派。</p><h4 id="3-1-2-通过网线共享电脑的网络"><a href="#3-1-2-通过网线共享电脑的网络" class="headerlink" title="3.1.2. 通过网线共享电脑的网络"></a>3.1.2. 通过网线共享电脑的网络</h4><blockquote><p>设置–&gt;状态–&gt;高级网络设置：更改适配器选项–&gt;选择电脑联网的适配器–&gt;右键选择属性，点击共享–&gt;打开下图中的选项–&gt;选择树莓派要连接的适配器–&gt;确定</p></blockquote><img src="https://images.961110.xyz/images/2021/10/19/2d3ddc0a200c6e2f6386bbfe718cb969.png" alt="image-20211017133126324" style="zoom:50%;" /><p>此种方式的默认的网关IP是192.168.137.1，所以分配给树莓派的IP是192.168.137.XXX，具体查看方式见下文。</p><h4 id="3-1-3-通过配置WiFi上网"><a href="#3-1-3-通过配置WiFi上网" class="headerlink" title="3.1.3. 通过配置WiFi上网"></a>3.1.3. 通过配置WiFi上网</h4><p>在boot分区新建一个wpa_supplicant.conf文件，内容如下:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">country=CN</span><br><span class="line">ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev</span><br><span class="line">update_config=1</span><br><span class="line"></span><br><span class="line">network=&#123;</span><br><span class="line">       ssid=&quot;XXXXXXX&quot;</span><br><span class="line">       psk=&quot;password&quot;</span><br><span class="line">       key_mgmt=WPA-PSK</span><br><span class="line">       priority=1</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>ssid</code>就是WIFI名，<code>psk</code>就是WiFi密码，<code>key_mgmt</code>就是WiFi的加密方式，一般在路由器管理界面的WiFi设置中可以看到。</p><h4 id="3-1-4-连接风扇"><a href="#3-1-4-连接风扇" class="headerlink" title="3.1.4. 连接风扇"></a>3.1.4. 连接风扇</h4><img src="https://images.961110.xyz/images/2021/10/19/4B-.jpg" alt="树莓派4B 连接风扇" style="zoom:50%;" /><p>树莓派4B的GPIO口外侧是偶数口，内侧是奇数口，如图示从左到右需要依次增大。风扇需要连接在第4和6号引脚上，正极（红线）连接在4号引脚，负极（黑线）连接在6号引脚。</p><h3 id="3-2-通电"><a href="#3-2-通电" class="headerlink" title="3.2. 通电"></a>3.2. 通电</h3><h4 id="3-2-1-状态检查"><a href="#3-2-1-状态检查" class="headerlink" title="3.2.1. 状态检查"></a>3.2.1. 状态检查</h4><p>插入SD卡，插入网线，连接电源自动开机：</p><ul><li>红灯常亮：未能检测到TF卡；</li><li>双灯常亮：未能检测到系统；</li><li>绿灯闪烁：系统运行正常。、</li></ul><p>等个几十秒进行下一步</p><h4 id="3-2-2-通过网线联网，查看树莓派Raspberry-4B的IP"><a href="#3-2-2-通过网线联网，查看树莓派Raspberry-4B的IP" class="headerlink" title="3.2.2. 通过网线联网，查看树莓派Raspberry 4B的IP"></a>3.2.2. 通过网线联网，查看树莓派Raspberry 4B的IP</h4><p>打开cmd或其他shell工具，通过<code>arp -a</code>查看本机的arp表，找到接口为192.168.137.1下的内容</p><p>可以看到树莓派Raspberry 4B获得的IP: 192.168.137.XXX</p><h4 id="3-2-3-通过配置WiFi上网，查看树莓派Raspberry-4B的IP"><a href="#3-2-3-通过配置WiFi上网，查看树莓派Raspberry-4B的IP" class="headerlink" title="3.2.3. 通过配置WiFi上网，查看树莓派Raspberry 4B的IP"></a>3.2.3. 通过配置WiFi上网，查看树莓派Raspberry 4B的IP</h4><p>进入路由器后台，查看接入网络的设备列表，记录其IP即可。</p><h3 id="3-3-ssh连接"><a href="#3-3-ssh连接" class="headerlink" title="3.3. ssh连接"></a>3.3. ssh连接</h3><p>获取IP后，直接 <code>ssh pi@IP</code> 即可</p><p>密码是 raspberry</p><h3 id="3-4-VNC连接"><a href="#3-4-VNC连接" class="headerlink" title="3.4. VNC连接"></a>3.4. VNC连接</h3><h4 id="3-4-1-开启VNC"><a href="#3-4-1-开启VNC" class="headerlink" title="3.4.1. 开启VNC"></a>3.4.1. 开启VNC</h4><p>使用ssh登录之后，输入<code>sudo raspi-config</code>进行配置</p><h4 id="3-4-2-使用VNC连接"><a href="#3-4-2-使用VNC连接" class="headerlink" title="3.4.2. 使用VNC连接"></a>3.4.2. 使用VNC连接</h4><h3 id="3-5-使用微软远程桌面连接"><a href="#3-5-使用微软远程桌面连接" class="headerlink" title="3.5. 使用微软远程桌面连接"></a>3.5. 使用微软远程桌面连接</h3><h4 id="3-5-1-安装依赖包"><a href="#3-5-1-安装依赖包" class="headerlink" title="3.5.1. 安装依赖包"></a>3.5.1. 安装依赖包</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装 xrdp</span></span><br><span class="line">sudo apt-get install xrdp</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动xrdp</span></span><br><span class="line">sudo /etc/init.d/xrdp start</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将Xrdp服务添加到系统默认启动服务中</span></span><br><span class="line">sudo update-rc.d xrdp defaults</span><br></pre></td></tr></table></figure><h3 id="3-5-2-连接"><a href="#3-5-2-连接" class="headerlink" title="3.5.2. 连接"></a>3.5.2. 连接</h3><p>打开Windows远程桌面，输入树莓派4B的IP，连接即可。默认用户名：pi，默认密码：raspberry。</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 树莓派 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker安装chevereto图床并解除上传图片大小限制、自定义图片上传用户和相册</title>
      <link href="/posts/36360.html"/>
      <url>/posts/36360.html</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>直接用官方的推荐安装方式，修改后的docker-compose.yaml如下</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mariadb</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">database:/var/lib/mysql:rw</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">private</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">xxx</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">chevereto</span></span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="string">jason</span></span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="string">xxx</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">chevereto:</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nmtan/chevereto</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">private</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">CHEVERETO_DB_HOST:</span> <span class="string">db</span></span><br><span class="line">      <span class="attr">CHEVERETO_DB_USERNAME:</span> <span class="string">jason</span></span><br><span class="line">      <span class="attr">CHEVERETO_DB_PASSWORD:</span> <span class="string">xxx</span></span><br><span class="line">      <span class="attr">CHEVERETO_DB_NAME:</span> <span class="string">chevereto</span></span><br><span class="line">      <span class="attr">CHEVERETO_DB_PREFIX:</span> <span class="string">chv_</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/home/Jason/chv_images:/var/www/html/images:rw</span>  <span class="comment">#将照片存放路径映射到了本地存储中</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span><span class="string">:80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">private:</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">database:</span></span><br><span class="line">  <span class="attr">chevereto_images:</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后<code>docker-compose up -d</code>就可以启动，通过8080端口访问chevereto。</p><h2 id="解除上传图片的大小限制"><a href="#解除上传图片的大小限制" class="headerlink" title="解除上传图片的大小限制"></a>解除上传图片的大小限制</h2><h3 id="复制到服务器本地路径下"><a href="#复制到服务器本地路径下" class="headerlink" title="复制到服务器本地路径下"></a>复制到服务器本地路径下</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">docker cp  containerID:<span class="regexp">/var/</span>www/html/.htaccess /volume1/docker/</span><br></pre></td></tr></table></figure><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /volume1/docker/.htaccess</span><br><span class="line"></span><br><span class="line"># Disable server signature</span><br><span class="line">ServerSignature Off</span><br><span class="line"></span><br><span class="line"># Disable directory listing (-indexes), Multiviews (-MultiViews) and enable Follow system links (+FollowSymLinks)</span><br><span class="line">Options -Indexes</span><br><span class="line">Options -MultiViews</span><br><span class="line"></span><br><span class="line">&lt;IfModule mod_rewrite.c&gt;</span><br><span class="line"></span><br><span class="line">    RewriteEngine On</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    RewriteRule . index.php [L]</span><br><span class="line">    #修改上传文件大小增加以下 配置  最大支持 32M 根据自己情况配置</span><br><span class="line">    php_value post_max_size 64M</span><br><span class="line">    php_value upload_max_filesize 32M</span><br><span class="line"></span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure><h3 id="复制到容器目录里面"><a href="#复制到容器目录里面" class="headerlink" title="复制到容器目录里面"></a>复制到容器目录里面</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">docker cp /volume1/docker/.htaccess containerID:<span class="regexp">/var/</span>www/html/</span><br></pre></td></tr></table></figure><h2 id="修改上传API"><a href="#修改上传API" class="headerlink" title="修改上传API"></a>修改上传API</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp containerID:/var/www/html/app/routes/route.api.php ./</span><br></pre></td></tr></table></figure><p>将PHP文件复制出来，相应位置增加如下代码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$version</span> = <span class="variable">$handler</span>-&gt;request[<span class="number">0</span>];</span><br><span class="line"><span class="variable">$action</span> = <span class="variable">$handler</span>-&gt;request[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增下面两行</span></span><br><span class="line"><span class="variable">$user</span> = <span class="variable">$_REQUEST</span>[<span class="string">&#x27;user&#x27;</span>];</span><br><span class="line"><span class="variable">$album</span> = <span class="variable">$_REQUEST</span>[<span class="string">&#x27;album&#x27;</span>];</span><br></pre></td></tr></table></figure><p>更改如下代码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将这行代码增加 user 和 album 两个参数</span></span><br><span class="line"><span class="variable">$uploaded_id</span> = CHV\Image::uploadToWebsite(<span class="variable">$source</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更改后的代码如下</span></span><br><span class="line"><span class="variable">$uploaded_id</span> = CHV\Image::uploadToWebsite(<span class="variable">$source</span>, <span class="variable">$user</span>, <span class="keyword">array</span>(<span class="string">&#x27;album_id&#x27;</span>=&gt;<span class="variable">$album</span>));</span><br></pre></td></tr></table></figure><p>将修改后的文件复制到容器中替换</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp ./route.api.php  containerID:/var/www/html/app/routes/route.api.php</span><br></pre></td></tr></table></figure><h2 id="配置Typora和PicGo"><a href="#配置Typora和PicGo" class="headerlink" title="配置Typora和PicGo"></a>配置Typora和PicGo</h2><p>在PicGo中下载插件web-uploader，填入如下配置</p><img src="https://images.961110.xyz/images/2021/10/20/image-20211020120134965.png" alt="image-20211020120134965" style="zoom: 50%;" /><ul><li>API地址：http或https(根据自身情况)://域名/api/1/upload</li><li>POST参数名：source</li><li>JSON路径：image.url</li><li>自定义Body：<code>&#123;&quot;key&quot;:&quot;your key&quot;, &quot;user&quot;:&quot;username&quot;, &quot;album&quot;:&quot;albumid&quot;&#125;</code></li></ul><p>key在用户名–&gt;仪表盘–&gt;设置–&gt;API可以找到</p><img src="https://images.961110.xyz/images/2021/10/20/image-20211020120705106.png" alt="image-20211020120705106" style="zoom:50%;" /><p>username就在chevereto网站右上角<img src="https://images.961110.xyz/images/2021/10/20/image-20211020120603290.png" alt="image-20211020120603290"></p><p>albumid在用户的相册详细信息中可以找到。</p><img src="https://images.961110.xyz/images/2021/10/20/image-20211020120843573.png" alt="image-20211020120843573" style="zoom: 50%;" /><p>配置完成后设置为默认图床，进行上传测试。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://blog.csdn.net/qq_25005601/article/details/110532477?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&spm=1001.2101.3001.4242">Typora + PicGo 自动上传图片到 Chevereto 图床_张大炮来巡山-CSDN博客</a></li><li><a href="https://blog.csdn.net/qq_19564393/article/details/108506062">修改Chevereto的API上传相册和用户_飞逝17的博客-CSDN博客</a></li><li><a href="https://blog.csdn.net/weixin_29343153/article/details/113534943">docker修改文件夹权限_群晖通过Docker安装图床工具Chevereto的步骤_藏美者阿远的博客-CSDN博客</a></li><li><a href="https://www.orcy.net.cn/775.html">Docker容器报错处理:AH00558: apache2: Could not reliably determine the server’s fully qualified domain name, using 172.17.0.5. Set the ‘ServerName’ directive globally to suppress this message – 下一朵云 (orcy.net.cn)</a></li><li><a href="https://cloud.tencent.com/developer/article/1645239">群晖Docker安装chevereto图床</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 图床 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lambda表达式</title>
      <link href="/posts/40489.html"/>
      <url>/posts/40489.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h2><p>lambda 表达式有如下的一些优点：</p><ul><li>  声明式的编程风格：就地匿名定义目标函数或函数对象，不需要额外写一个命名函数或函数对象。</li><li>  简洁：避免了代码膨胀和功能分散，让开发更加高效。</li><li>  在需要的时间和地点实现功能闭包，使程序更加灵活。</li></ul><p>lambda 表达式定义了一个匿名函数，并且可以捕获一定范围内的变量。lambda 表达式的语法形式简单归纳如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[capture](params) opt -&gt; ret &#123;body;&#125;;</span><br></pre></td></tr></table></figure><p>其中 <code>capture</code> 是捕获列表，<code>params</code> 是参数列表，<code>opt</code> 是函数选项，<code>ret</code> 是返回值类型，<code>body</code> 是函数体。</p><ol><li>捕获列表 []: 捕获一定范围内的变量</li><li>参数列表 (): 和普通函数的参数列表一样，如果没有参数参数列表可以省略不写。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = []()&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;<span class="comment">// 没有参数, 参数列表为空</span></span><br><span class="line"><span class="keyword">auto</span> f = []&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;<span class="comment">// 没有参数, 参数列表省略不写</span></span><br></pre></td></tr></table></figure></li><li>opt 选项， <code>不需要可以省略</code><ul><li>  mutable: 可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）</li><li>exception: 指定函数抛出的异常，如抛出整数类型的异常，可以使用 throw ();</li></ul></li><li>返回值类型：在 C++11 中，lambda 表达式的返回值是通过返回值后置语法来定义的。</li><li>函数体：函数的实现，这部分不能省略，但函数体可以为空。</li></ol><h2 id="2-捕获列表"><a href="#2-捕获列表" class="headerlink" title="2. 捕获列表"></a>2. 捕获列表</h2><p>lambda 表达式的捕获列表可以捕获一定范围内的变量，具体使用方式如下：</p><ul><li>  <code>[]</code> - 不捕捉任何变量</li><li>  <code>[&amp;]</code> - 捕获外部作用域中所有变量，并作为引用在函数体内使用 (<code>按引用捕获</code>)</li><li><code>[=]</code> - 捕获外部作用域中所有变量，并作为副本在函数体内使用 (<code>按值捕获</code>)<ul><li>  <code>拷贝的副本在匿名函数体内部是只读的</code></li></ul></li><li>  <code>[=, &amp;foo]</code> - 按值捕获外部作用域中所有变量，并按照引用捕获外部变量 foo</li><li>  <code>[bar]</code> - 按值捕获 bar 变量，同时不捕获其他变量</li><li>  <code>[&amp;bar]</code> - 按引用捕获 bar 变量，同时不捕获其他变量</li><li><code>[this]</code> - 捕获当前类中的 this 指针<ul><li>  让 lambda 表达式拥有和当前类成员函数同样的访问权限</li><li>  <strong>如果已经使用了 &amp; 或者 =, 默认添加 this 指针</strong></li></ul></li></ul><p>下面通过一个例子，看一下初始化列表的具体用法：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> x1 = [] &#123;<span class="keyword">return</span> m_number; &#125;;                      <span class="comment">// error，没有捕获外部变量，不能使用类成员 m_number</span></span><br><span class="line">        <span class="keyword">auto</span> x2 = [=] &#123;<span class="keyword">return</span> m_number + x + y; &#125;;             <span class="comment">// ok，以值拷贝的方式捕获所有外部变量</span></span><br><span class="line">        <span class="keyword">auto</span> x3 = [&amp;] &#123;<span class="keyword">return</span> m_number + x + y; &#125;;             <span class="comment">// ok，以引用的方式捕获所有外部变量</span></span><br><span class="line">        <span class="keyword">auto</span> x4 = [<span class="keyword">this</span>] &#123;<span class="keyword">return</span> m_number; &#125;;                  <span class="comment">// ok，捕获 this 指针，可访问对象内部成员</span></span><br><span class="line">        <span class="keyword">auto</span> x5 = [<span class="keyword">this</span>] &#123;<span class="keyword">return</span> m_number + x + y; &#125;;          <span class="comment">// error，捕获 this 指针，可访问类内部成员，没有捕获到变量 x，y，因此不能访问。</span></span><br><span class="line">        <span class="keyword">auto</span> x6 = [<span class="keyword">this</span>, x, y] &#123;<span class="keyword">return</span> m_number + x + y; &#125;;    <span class="comment">// ok，捕获 this 指针，x，y</span></span><br><span class="line">        <span class="keyword">auto</span> x7 = [<span class="keyword">this</span>] &#123;<span class="keyword">return</span> m_number++; &#125;;                <span class="comment">// ok，捕获 this 指针，并且可以修改对象内部变量的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m_number = <span class="number">100</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>在匿名函数内部，需要通过 lambda 表达式的捕获列表控制如何捕获外部变量，以及访问哪些变量。默认状态下 lambda 表达式无法修改通过复制方式捕获外部变量，如果希望修改这些外部变量，需要通过引用的方式进行捕获。</p></blockquote><h2 id="3-返回值"><a href="#3-返回值" class="headerlink" title="3. 返回值"></a>3. 返回值</h2><p>一般情况下，不指定 lambda 表达式的返回值，编译器会根据 return 语句自动推导返回值的类型，但需要注意的是 <code>labmda表达式不能通过列表初始化自动推导出返回值类型。</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ok，可以自动推导出返回值类型</span></span><br><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">int</span> a) -&gt; <span class="keyword">int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+<span class="number">10</span>;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">int</span> a)&#123;</span><br><span class="line">    <span class="keyword">return</span> a+<span class="number">10</span>;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error，不能推导出返回值类型</span></span><br><span class="line"><span class="keyword">auto</span> f1 = []()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;<span class="comment">// 基于列表初始化推导返回值，错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-函数本质"><a href="#4-函数本质" class="headerlink" title="4. 函数本质"></a>4. 函数本质</h2><p>使用 lambda 表达式捕获列表捕获外部变量，如果希望去修改按值捕获的外部变量，那么应该如何处理呢？这就需要使用 mutable 选项，<code>被mutable修改是lambda表达式就算没有参数也要写明参数列表，并且可以去掉按值捕获的外部变量的只读（const）属性。</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f1 = [=] &#123;<span class="keyword">return</span> a++; &#125;;              <span class="comment">// error, 按值捕获外部变量, a是只读的</span></span><br><span class="line"><span class="keyword">auto</span> f2 = [=]()<span class="keyword">mutable</span> &#123;<span class="keyword">return</span> a++; &#125;;     <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>最后再剖析一下为什么通过值拷贝的方式捕获的外部变量是只读的:</p><ol><li> <code>lambda表达式的类型在C++11中会被看做是一个带operator()的类，即仿函数。</code></li><li> <code>按照C++标准，lambda表达式的operator()默认是const的，一个const成员函数是无法修改成员变量值的。</code></li></ol><p>mutable 选项的作用就在于取消 operator () 的 const 属性。</p><p>因为 lambda 表达式在 C++ 中会被看做是一个仿函数，因此<code>可以使用std::function和std::bind来存储和操作lambda表达式</code>：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 包装可调用函数</span></span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>)&gt; f1 = [](<span class="keyword">int</span> a) &#123;<span class="keyword">return</span> a; &#125;;</span><br><span class="line">    <span class="comment">// 绑定可调用函数</span></span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>)&gt; f2 = <span class="built_in">bind</span>([](<span class="keyword">int</span> a) &#123;<span class="keyword">return</span> a; &#125;, placeholders::_1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数调用</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">f1</span>(<span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">f2</span>(<span class="number">200</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于没有捕获任何变量的 lambda 表达式，还可以转换成一个普通的函数指针：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> func_ptr = <span class="built_in"><span class="keyword">int</span></span>(*)(<span class="keyword">int</span>);</span><br><span class="line"><span class="comment">// 没有捕获任何外部变量的匿名函数</span></span><br><span class="line">func_ptr f = [](<span class="keyword">int</span> a)&#123;</span><br><span class="line">    <span class="keyword">return</span> a;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 函数调用</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">1314</span>);</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://subingwen.cn/cpp/lambda/">Lambda表达式 | 爱编程的大丙 (subingwen.cn)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> C++ </tag>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux进程管理</title>
      <link href="/posts/25357.html"/>
      <url>/posts/25357.html</url>
      
        <content type="html"><![CDATA[<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h3><p><img src="https://images.961110.xyz/images/2021/10/20/Linux0.12.png" alt="Linux0.12创建进程的流程"></p><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p><img src="https://images.961110.xyz/images/2021/10/20/Linux0.1211029ed5dd197bbc.png" alt="Linux0.12进程调度流程图"></p><h3 id="退出进程"><a href="#退出进程" class="headerlink" title="退出进程"></a>退出进程</h3><p><img src="https://images.961110.xyz/images/2021/10/20/exit.c.png" alt="Linux0.12退出进程流程图"></p><p>退出进程</p><h2 id="进程0和进程1"><a href="#进程0和进程1" class="headerlink" title="进程0和进程1"></a>进程0和进程1</h2><h3 id="进程-0"><a href="#进程-0" class="headerlink" title="进程 0"></a>进程 0</h3><p> 首先，进程 0 也叫做空闲进程，是一个内核进程，它的主要作用是进入一个死循环，为了解决 cpu 空闲时刻的问题，所做的工作就是在 cpu 空闲时给 cpu 一个死循环从而使 cpu 工作。特殊性在于它是系统创建的第一个进程。</p><h3 id="进程-1"><a href="#进程-1" class="headerlink" title="进程 1"></a>进程 1</h3><p>进程 1 也叫做 init 进程，开始时它在内核态所做的工作就是挂载根文件系统，将根文件系统挂载上之后，进行一系列的环境配置，最后创建用户交互 shell环境</p><p> 进程 1 的最主要的作用就是对操作系统来说，其他所有的用户进程都是由进程 1 直接或间接创建的，也就是说所有的用户进程都是进程 1 的子孙进程。</p><h2 id="孤儿进程、孤儿进程组、僵尸进程"><a href="#孤儿进程、孤儿进程组、僵尸进程" class="headerlink" title="孤儿进程、孤儿进程组、僵尸进程"></a>孤儿进程、孤儿进程组、僵尸进程</h2><h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p>其父进程已经终止的进程。但是它会被 init 进程 “收养”，init 进程 ID 为 1，因此被收养的孤儿进程的父进程会更新为 1。</p><h3 id="孤儿进程组"><a href="#孤儿进程组" class="headerlink" title="孤儿进程组"></a>孤儿进程组</h3><p>一个进程组中的所有进程的父进程要么是该进程组的一个进程，要么不是该进程组所在的会话中的进程。 一个进程组不是孤儿进程组的条件是，该组中有一个进程其父进程在属于同一个会话的另一个组中。</p><p>一个进程组到其组外的父进程之间的联系依赖于该父进程和其子进程两者，所以会有两种产生孤儿进程组的情况：</p><ol><li>父进程终止</li><li>子进程终止</li></ol><p>在任何一种情況下，如果进程的终止导致进程组变成孤儿进程组，那么进程组中的所有进程就会与它们的作业控制 shell 断开联系，作业控制 shell 将不再具有该进程组存在的任何信息。而该进程组中处于停止状态的进程将会永远消失。为了解决这个问题，含有停止状态进程的新近产生的孤儿进程组就需要接收到一个SIGHIUP信号和一个SIGCONT信号，用于指示它们已经从它们的会话（session）中断开联系。SIGHUP信号将导致进程组中成员被终止，除非它们捕获或忽略了SIGHUP信号。而SIGCONT信号将使那些没有被SIGHUP信号终止的进程继续运行。但在大多数情況下，如果组中有一个进程处于停止状态，那么组中所有的进程可能都处于停止状态。</p><h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p>子进程先于父进程退出，而父进程并没有调用 wait 或 waitpid 获取子进程的状态信息并释放子进程资源，那么其的进程描述符仍然保存在系统中。</p><h2 id="进程、进程组、会话、前台进程组、后台进程组"><a href="#进程、进程组、会话、前台进程组、后台进程组" class="headerlink" title="进程、进程组、会话、前台进程组、后台进程组"></a>进程、进程组、会话、前台进程组、后台进程组</h2><h3 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h3><p>一个或者多个进程的集合。</p><p>每个进程组都有一个唯一的进程组标识号gid，一个称为组长的进程，gid等于组长进程的pid。</p><h3 id="会话（Session）"><a href="#会话（Session）" class="headerlink" title="会话（Session）"></a>会话（Session）</h3><p>一个或多个进程组的集合。</p><p>通常情况下，用户登录后所执行的所有程序都属于一个会话期，而其登录 shell 则是<strong>会话首进程</strong>，并且它所使用的终端就是会话期的控制终端，因此会话期首进程通常也被称为<strong>控制进程</strong>。当用户退出登录时，所有属于这个会话期的进程都将被终止。</p><h3 id="前台进程组"><a href="#前台进程组" class="headerlink" title="前台进程组"></a>前台进程组</h3><p>会话中拥有控制终端的一个进程组。</p><h3 id="后台进程组"><a href="#后台进程组" class="headerlink" title="后台进程组"></a>后台进程组</h3><p>会话期中除前台进程组外的其他进程组。</p><p><img src="https://images.961110.xyz/images/2021/10/20/Untitled.png" alt="进程、进程组和会话期之间的关系"></p><p>进程、进程组和会话期之间的关系</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 任务(进程)数据结构，或称为进程描述符 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line"><span class="comment">/* these are hardcoded - don&#x27;t touch */</span></span><br><span class="line"><span class="comment">/* 硬编码字段 */</span></span><br><span class="line"><span class="keyword">long</span> state;<span class="comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span></span><br><span class="line"><span class="comment">/* 任务运行状态 -1 不可运行，0 可运行(就绪)， &gt;0 已停止 */</span></span><br><span class="line"><span class="keyword">long</span> counter;<span class="comment">/* 任务运行时间计数(递减)(滴答数)，运行时间片 */</span></span><br><span class="line"><span class="keyword">long</span> priority;<span class="comment">/* 优先级 */</span></span><br><span class="line"><span class="keyword">long</span> signal;<span class="comment">/* 信号位图 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sigaction</span>[32];</span><span class="comment">/* 信号执行属性结构,对应信号将要执行的操作和标志信息 */</span></span><br><span class="line"><span class="keyword">long</span> blocked;<span class="comment">/* 进程信号屏蔽码(对应信号位图) */</span> <span class="comment">/* bitmap of masked signals */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* various fields */</span></span><br><span class="line"><span class="comment">/* 可变字段 */</span></span><br><span class="line"><span class="keyword">int</span> exit_code;<span class="comment">/* 退出码 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> start_code;<span class="comment">/* 代码段地址 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> end_code;<span class="comment">/* 代码段长度（字节数） */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> end_data;<span class="comment">/* 代码段加数据段的长度 （字节数）*/</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> brk;<span class="comment">/* 总长度(字节数) */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> start_stack;<span class="comment">/* 堆栈段地址 */</span></span><br><span class="line"><span class="keyword">long</span> pid;<span class="comment">/* 进程标识号(进程号) */</span></span><br><span class="line"><span class="keyword">long</span> pgrp;<span class="comment">/* 进程组号 */</span></span><br><span class="line"><span class="keyword">long</span> session;<span class="comment">/* 会话号 */</span></span><br><span class="line"><span class="keyword">long</span> leader;<span class="comment">/* 会话首领 */</span></span><br><span class="line"><span class="keyword">int</span>groups[NGROUPS];<span class="comment">/* 进程所属组号（一个进程可属于多个组） */</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * pointers to parent process, youngest child, younger sibling,</span></span><br><span class="line"><span class="comment"> * older sibling, respectively.  (p-&gt;father can be replaced with </span></span><br><span class="line"><span class="comment"> * p-&gt;p_pptr-&gt;pid)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p_pptr</span>;</span><span class="comment">/* 指向父进程的指针 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p_cptr</span>;</span><span class="comment">/* 指向最新子进程的指针 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p_ysptr</span>;</span><span class="comment">/* 指向比自己后创建的相邻进程的指针 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p_osptr</span>;</span><span class="comment">/* 指向比自己早创建的相邻进程的指针 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> uid;<span class="comment">/* 用户id */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> euid;<span class="comment">/* 有效用户id */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> suid;<span class="comment">/* 保存的设置用户id */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> gid;<span class="comment">/* 组id */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> egid;<span class="comment">/* 有效组id */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> sgid;<span class="comment">/* 保存的设置组id */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> timeout;<span class="comment">/* 内核定时超时值 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> alarm;<span class="comment">/* 报警定时值(滴答数) */</span></span><br><span class="line"><span class="keyword">long</span> utime;<span class="comment">/* 用户态运行时间(滴答数) */</span></span><br><span class="line"><span class="keyword">long</span> stime;<span class="comment">/* 内核态运行时间(滴答数) */</span></span><br><span class="line"><span class="keyword">long</span> cutime;<span class="comment">/* 子进程用户态运行时间 */</span></span><br><span class="line"><span class="keyword">long</span> cstime;<span class="comment">/* 子进程内核态运行时间 */</span></span><br><span class="line"><span class="keyword">long</span> start_time;<span class="comment">/* 进程开始运行时刻 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rlim</span>[<span class="title">RLIM_NLIMITS</span>];</span><span class="comment">/* 进程资源使用统计数组 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> flags;<span class="comment">/* 各进程的标志，还未使用*/</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> used_math;<span class="comment">/* 是否使用了协处理器的标志 */</span></span><br><span class="line"><span class="comment">/* file system info */</span></span><br><span class="line"><span class="keyword">int</span> tty;<span class="comment">/* -1 if no tty, so it must be signed */</span></span><br><span class="line"><span class="comment">/* 进程使用tty终端的子设备号。-1表示没有使用 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> umask;<span class="comment">/* 文件创建属性屏蔽位 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">pwd</span>;</span><span class="comment">/* 当前工作目录i节点结构指针 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">root</span>;</span><span class="comment">/* 根目录i节点结构指针 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">executable</span>;</span><span class="comment">/* 执行文件i节点结构指针 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">library</span>;</span><span class="comment">/* 被加载库文件i节点结构指针 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> close_on_exec;<span class="comment">/* 执行时关闭文件句柄位图标志 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">filp</span>[<span class="title">NR_OPEN</span>];</span><span class="comment">/* 文件结构指针表，最多32项。表项号即是文件描述符的值 */</span></span><br><span class="line"><span class="comment">/* ldt for this task 0 - zero 1 - cs 2 - ds&amp;ss */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> <span class="title">ldt</span>[3];</span><span class="comment">/* 局部描述符表, 0 - 空，1 - 代码段cs，2 - 数据和堆栈段ds&amp;ss */</span></span><br><span class="line"><span class="comment">/* tss for this task */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tss_struct</span> <span class="title">tss</span>;</span><span class="comment">/* 进程的任务状态段信息结构 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">任务状态</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_RUNNING0<span class="comment">/* 任务正在运行或已准备就绪 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_INTERRUPTIBLE1<span class="comment">/* 任务处于可中断等待状态 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_UNINTERRUPTIBLE2<span class="comment">/* 任务处于不可中断等待状态 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_ZOMBIE3<span class="comment">/* 任务处于僵死状态，已经停止，但父进程还没发出信号 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_STOPPED4<span class="comment">/* 任务已停止 */</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGHUP 1<span class="comment">/* Hang Up-- 挂起控制终端或进程 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGINT 2<span class="comment">/* Interrupt -- 来自键盘的中断 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGQUIT 3<span class="comment">/* Quit-- 来自键盘的退出 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGILL 4<span class="comment">/* Illeagle-- 非法指令 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGTRAP 5<span class="comment">/* Trap -- 跟踪断点 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGABRT 6<span class="comment">/* Abort-- 异常结束 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGIOT 6<span class="comment">/* IO Trap-- 同上 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGUNUSED 7<span class="comment">/* Unused-- 没有使用 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGFPE 8<span class="comment">/* FPE-- 协处理器出错 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGKILL 9<span class="comment">/* Kill-- 强迫进程终止 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGUSR110<span class="comment">/* User1-- 用户信号 1，进程可使用 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGSEGV11<span class="comment">/* Segment Violation -- 无效内存引用 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGUSR212<span class="comment">/* User2    -- 用户信号 2，进程可使用 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGPIPE13<span class="comment">/* Pipe-- 管道写出错，无读者 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGALRM14<span class="comment">/* Alarm-- 实时定时器报警 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGTERM15<span class="comment">/* Terminate -- 进程终止 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGSTKFLT16<span class="comment">/* Stack Fault -- 栈出错（协处理器） */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGCHLD17<span class="comment">/* Child-- 子进程停止或被终止 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGCONT18<span class="comment">/* Continue-- 恢复进程继续执行 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGSTOP19<span class="comment">/* Stop-- 停止进程的执行 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGTSTP20<span class="comment">/* TTY Stop-- tty 发出停止进程，可忽略 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGTTIN21<span class="comment">/* TTY In-- 后台进程请求输入 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGTTOU22<span class="comment">/* TTY Out-- 后台进程请求输出 */</span></span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://blog.csdn.net/qq_29503203/article/details/54618275">https://blog.csdn.net/qq_29503203/article/details/54618275</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 进程管理 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《智能网联汽车技术》读书笔记</title>
      <link href="/posts/29265.html"/>
      <url>/posts/29265.html</url>
      
        <content type="html"><![CDATA[<h3 id="第一章-智能网联汽车概述"><a href="#第一章-智能网联汽车概述" class="headerlink" title="第一章 智能网联汽车概述"></a>第一章 智能网联汽车概述</h3><p>这一章主要讲了智能网联汽车的一些基本概念、分级以及分阶段的发展目标。</p><h3 id="第二章-中国智能网联汽车发展及标准法规演变趋势"><a href="#第二章-中国智能网联汽车发展及标准法规演变趋势" class="headerlink" title="第二章 中国智能网联汽车发展及标准法规演变趋势"></a>第二章 中国智能网联汽车发展及标准法规演变趋势</h3><p>这一章主要介绍了智能网联汽车的发展路线，产业生态、主机厂、用户接受度的发展趋势，各企业的布局，国内外的系列政策。</p><h3 id="第三章-智能网联汽车产业链及商业模式"><a href="#第三章-智能网联汽车产业链及商业模式" class="headerlink" title="第三章 智能网联汽车产业链及商业模式"></a>第三章 智能网联汽车产业链及商业模式</h3><p>这一章主要介绍了智能网联汽车产业链、价值链、商业化技术服务和商业模式。</p><h3 id="第四章-驾驶场景数据技术"><a href="#第四章-驾驶场景数据技术" class="headerlink" title="第四章 驾驶场景数据技术"></a>第四章 驾驶场景数据技术</h3><p>这一张主要介绍了驾驶场景数据的采集、分类、处理、存储和应用的一系列流程，以及所用到的硬件设备的标定方法。</p><h3 id="第五章-驾驶场景虚拟仿真技术"><a href="#第五章-驾驶场景虚拟仿真技术" class="headerlink" title="第五章 驾驶场景虚拟仿真技术"></a>第五章 驾驶场景虚拟仿真技术</h3><p>这一章主要介绍了仿真测试系统、仿真平台、仿真数据体系、虚拟试验场建设、仿真测试工具和仿真验证与评价。</p><h3 id="第六章-自动驾驶感知融合算法实现与应用"><a href="#第六章-自动驾驶感知融合算法实现与应用" class="headerlink" title="第六章 自动驾驶感知融合算法实现与应用"></a>第六章 自动驾驶感知融合算法实现与应用</h3><p>这一章主要介绍了自动驾驶的相关算法，包括感知、融合、算法验证等，以及会用到的硬件设备，比如激光雷达、毫米波雷达、超声波雷达、摄像头等。</p><h3 id="第七章-自动驾驶工程技术验证与实现"><a href="#第七章-自动驾驶工程技术验证与实现" class="headerlink" title="第七章 自动驾驶工程技术验证与实现"></a>第七章 自动驾驶工程技术验证与实现</h3><p>这一章主要介绍了工程验证的关键技术包括环境感知、决策规划的相关技术，以及车辆改装、功能实现方法和软硬件发展思路。</p><p><img src="https://images.961110.xyz/images/2021/10/20/6a4a580a242f4d97ebe64463412dc677.png" alt="《智能网联汽车技术》关键技术点"></p><p>《智能网联汽车技术》关键技术点</p>]]></content>
      
      
      <categories>
          
          <category> 智能网联汽车 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 智能网联汽车 </tag>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核模块</title>
      <link href="/posts/62642.html"/>
      <url>/posts/62642.html</url>
      
        <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>Linux的内核模块机制允许开发者动态的向内核添加功能，常见的文件系统、驱动程序等都可以通过模块的方式添加到内核而无需对内核重新编译，这在很大程度上减少了操作的复杂度。</p><p>模块机制使内核预编译时不必包含很多无关功能，把内核做到最精简，后期可以根据需要进行添加。针对驱动程序，因为涉及到具体的硬件，很难使通用的，且其中可能包含了各个厂商的私密接口，厂商几乎不会允许开发者把源代码公开，模块机制很好的解决了这个冲突。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>使用模块的优点：</p><ol><li>使得内核更加紧凑和灵活</li><li>修改内核时，不必全部重新编译整个内核，可节省不少时间，避免人工操作的错误。系统中如果需要使用新模块，只要编译相应的模块然后使用特定用户空间的程序将模块插入即可。</li><li>模块可以不依赖于某个固定的硬件平台。</li><li>模块的目标代码一旦被链接到内核，它的作用和静态链接的内核目标代码完全等价。 所以，当调用模块的函数时，无须显式的消息传递。</li></ol><p>缺点：</p><ol><li>由于模块所占用的内存是不会被换出的，所以链接进内核的模块会给整个系统带来一定的性能和内存利用方面的损失。</li><li>装入内核的模块就成为内核的一部分，可以修改内核中的其他部分，因此，模块的使用不当会导致系统崩溃。</li><li>为了让内核模块能访问所有内核资源，内核必须维护符号表，并在装入和卸载模块时修改符号表。</li><li>模块会要求利用其它模块的功能，所以，内核要维护模块之间的依赖性。</li></ol><h3 id="内核符号表"><a href="#内核符号表" class="headerlink" title="内核符号表"></a>内核符号表</h3><p>内核符号表是一个用来存放所有模块可以访问的那些符号以及相应地址的特殊的表。模块的连接就是将模块插入到内核的过程。模块所声明的任何全局符号都成为内核符号表的一部分。内核模块根据系统符号表从内核空间中获取符号的地址，从而确保在内核空间中正确地运行。存放路径：<code>/proc/kallsyms</code></p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h3><ol><li><p>模块装载到内核中，首先调用初始化函数<code>proc_module_init()</code><br>打印初始化提示信息；</p></li><li><p>在查看<code>proc_info</code>文件之前，如右图可见文件是空的，说明代码里的<code>proc_info_show()</code>是在文件被查看时调用的；</p></li><li><p><code>proc_info_show()</code>在执行时首先打印提示信息，然后通过<code>seq_printf()</code>函数分别写入内核版本号和进程数；</p><p>内核版本号保存在结构体ustname中，可以直接调用，proc下verison也是</p></li><li><p>模块卸载的时候，调用出口函数<code>proc_module_exit()</code>，打印退出提示信息。</p></li></ol><p><img src="https://images.961110.xyz/images/2021/10/20/proc_info.png" alt="proc_info文件内容为空"></p><p><img src="https://images.961110.xyz/images/2021/10/20/proc_info69158ed329c16d70.png" alt="proc_info文件里的内容"></p><h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><p><code>create_proc_entry()</code>这个函数在3.x或4.x的时候已经被弃用，用<code>proc_create()</code>代替即可。</p><p><img src="https://images.961110.xyz/images/2021/10/20/my_module.png" alt="my_module模块编译出错"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">proc_dir = proc_mkdir(<span class="string">&quot;my_proc&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">proc_info = proc_create(<span class="string">&quot;proc_info&quot;</span>, <span class="number">0644</span>, proc_dir, &amp;proc_module_fops);</span><br></pre></td></tr></table></figure><h2 id="size-t"><a href="#size-t" class="headerlink" title="size_t"></a>size_t</h2><p>size_t的提出主要是为了解决可移植性问题，方便在处理器位数不同的平台使用。</p><p>size_t一般用来计数，代表C中任何对象所能达到的最大长度，比如：</p><ol><li><code>void *malloc(size_t n);</code> </li><li><code>void *memcpy(void *s1, void const *s2, size_t n);</code></li><li><code>size_t strlen(char const *s);</code></li></ol><p>习惯性地用<code>int</code>类型肯定是有问题的，因为<code>int</code>是带符号的，而且并不一定能覆盖到对象的最大长度。</p><p>int类型对应平台的大小是这样的：</p><ul><li>16位系统中，int型为16位大小，2字节</li><li>32位系统中，int型为32位大小，4字节</li><li>64位系统中，int型为32位大小，4字节</li></ul><p>long类型对应平台的大小是这样的：</p><ul><li>16位系统中，long型为32位大小，4字节</li><li>32位系统中，long型为32位大小，4字节</li><li>64位系统中，long型为64位大小，8字节</li></ul><p>因此猜想size_t在16位架构上应该是2字节，32位架构上是4字节，在64位架构上是8字节。</p><p>size_t在32位架构中被定义为<code>typedef unsigned int size_t;</code>而在64位架构中被定义为<code>typedef unsigned long size_t;</code>符合猜想，16位架构中的定义可能也是<code>typedef unsigned int size_t;</code></p><h2 id="seq-file-操作函数"><a href="#seq-file-操作函数" class="headerlink" title="seq_file 操作函数"></a>seq_file 操作函数</h2><p><code>seq_file</code> 系列函数是为了方便内核导出信息到 sysfs、debugfs、procfs 实现的。简化了文件操作的实现，内部维护缓冲区，内部的当前位置，不用驱动开发者自己实现缓冲区操作，对于驱动开发人员只需要实现相关的数据操作函数回调即可。<br>它包含了如下一些接口：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seq_open</span><span class="params">(struct file *file, <span class="keyword">const</span> struct seq_operations *op)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seq_release</span><span class="params">(struct inode *inode, struct file *file)</span></span>;</span><br><span class="line"><span class="comment">//seq_read 操作是系列函数中最为重要的一个函数，它负责从内部buffer缓冲区中读取数据并 copy_to_user 返回给应用层</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">seq_read</span><span class="params">(struct file *file, <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> size, <span class="keyword">loff_t</span> *ppos)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seq_write</span><span class="params">(struct seq_file *seq, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">loff_t</span> <span class="title">seq_lseek</span><span class="params">(struct file *file, <span class="keyword">loff_t</span> offset, <span class="keyword">int</span> whence)</span>；</span></span><br></pre></td></tr></table></figure><p>在实验过程中就是通过封装好的函数，把内核版本号和进程数写到proc文件里的。</p><h2 id="Linux内核模块参数传递及函数调用"><a href="#Linux内核模块参数传递及函数调用" class="headerlink" title="Linux内核模块参数传递及函数调用"></a>Linux内核模块参数传递及函数调用</h2><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>模块的参数传递也是一个宏，定义在<code>linux/moduleparam.h</code>中，type支持<code>byte, short, ushort,int, uint, long, ulong, bool</code></p><ul><li><p>单个参数传递<code>moudle_param(name,type,perm)</code></p></li><li><p>参数组传递<code>module_param_array(name, type, nump, perm)</code></p><p><strong><code>name</code>数组必须静态分配</strong></p></li><li><p>源文件内外参数名可以不同：<br><code>module_param_named(name, variable, type, perm)</code></p><p>  其中<code>name</code>是外部可见的参数名，<code>variable</code>是源文件内部的全局变量名</p></li><li><p>另一种字符串传递方法<code>module_param_string(name, string, len, perm)</code><br>name是外部的参数名，string是内部的变量名，len是以string命名的buffer大小（可以小于buffer的大小，但是没有意义）。</p></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *msg;</span><br><span class="line">module_param(msg, charp, <span class="number">0644</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> para[<span class="number">8</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> n_para = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> species[BUF_LEN]；</span><br><span class="line">module_param_string(specifies, species, BUF_LEN, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">module_param_array(para , <span class="keyword">int</span> , &amp;n_para , S_IRUGO);</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">module_init</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">module_exit</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在装载模块时指定参数即可</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sudo insmod <span class="keyword">module</span>.ko msg=<span class="string">&quot;test&quot;</span> para=<span class="number">4</span>，<span class="number">5</span>，<span class="number">6</span>，<span class="number">1</span>，<span class="number">8</span> specifies=<span class="string">&quot;test_string&quot;</span></span><br></pre></td></tr></table></figure><h3 id="模块间函数调用"><a href="#模块间函数调用" class="headerlink" title="模块间函数调用"></a>模块间函数调用</h3><p>模块的函数导出到符号表才可以供其他函数使用，需要用到宏：<code>EXPORT_SYMBOL(sym)</code>，该宏在<code>linux/export.h</code>里面。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fun1.c</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;fun() is called\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">EXPORT_SYMBOL(fun);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fun2.c</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;fun_1.h&quot;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mod_init</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;mod_init() start\n&quot;</span>);</span><br><span class="line">    fun();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fun_1.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> KERNEL_FUN_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNEL_FUN_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><img src="https://images.961110.xyz/images/2021/10/20/45bb76418d7ff50f34511fb7e26d23a3.png" alt="实验结果"></p><p>根据日志可以看出，被调用的函数已经打印出了提示信息。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><p>两个不同的模块不能导出相同的的函数，否则会在装载模块的时候报错。</p><p>在<code>/proc/kallsyms</code> 文件中保存对应着内核符号表，它记录了符号以及符号所在的内存地址，所以不能导出相同的函数。</p></li></ol><p><img src="https://images.961110.xyz/images/2021/10/20/79d0e8fb90a66cdebe819d07db6b492a.png" alt="导出相同函数报错"></p><p>导出相同函数报错</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核裁剪</title>
      <link href="/posts/2771.html"/>
      <url>/posts/2771.html</url>
      
        <content type="html"><![CDATA[<h3 id="Kconfig和menuconfig文件"><a href="#Kconfig和menuconfig文件" class="headerlink" title="Kconfig和menuconfig文件"></a>Kconfig和menuconfig文件</h3><p>内核源码的每一级目录下都会有 <strong>Kconfig</strong> 文件，文件里的<code>menu</code>对应<code>make menuconfig</code>中的菜单项，菜单中包含若干子选项，由 <code>source</code>引入各级子目录下的 <code>Kconfig</code>文件，由此构成了<code>menuconfig</code>。</p><p><img src="https://images.961110.xyz/images/2021/10/20/Kconfigmenuconfig.png" alt="Kconfig和menuconfig文件.png"></p><p>每一个子选项在代码中对应的是一个个的<code>config</code></p><p>其中选项中<code>bool</code>代表二选一(编译、不编译)</p><p><code>trastate</code>代表三选一(编译、不编译、编译成模块)</p><p><code>depends on</code>代表其依赖的配置。</p><p><img src="https://images.961110.xyz/images/2021/10/20/config.png" alt="config的构成.png"></p><h3 id="config文件"><a href="#config文件" class="headerlink" title=".config文件"></a>.config文件</h3><p><code>menuconfig</code>又会生成源码根目录下的<code>.config</code>文件，由各个<code>Kconfig</code>中的<code>config</code>宏定义构成。</p><h3 id="makefile文件"><a href="#makefile文件" class="headerlink" title="makefile文件"></a>makefile文件</h3><p>编译内核依赖的makefile文件会根据<code>.config</code>文件来决定是否将对应部分编译进内核。</p><h3 id="四者的关系图如下"><a href="#四者的关系图如下" class="headerlink" title="四者的关系图如下"></a>四者的关系图如下</h3><p><img src="https://images.961110.xyz/images/2021/10/20/menuconfig-Kconfig-.config-makefile.png" alt="menuconfig相关文件的关系"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 内核裁剪 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM目标代码优化</title>
      <link href="/posts/64925.html"/>
      <url>/posts/64925.html</url>
      
        <content type="html"><![CDATA[<h2 id="速度优化"><a href="#速度优化" class="headerlink" title="速度优化"></a>速度优化</h2><h3 id="通用优化方法"><a href="#通用优化方法" class="headerlink" title="通用优化方法"></a>通用优化方法</h3><p><strong>减少计算强度</strong></p><ol><li>左右位移代替乘除2运算: <code>i = i * 5 = (i &lt;&lt; 2) + 1</code> ，位移有桶形位移器，执行比乘除快。</li><li>乘法代替乘方运算: <code>i = pow(i, 3) = i * i * i</code>，ARM中有乘法器，所以比调用函数更快。</li><li>与运算代替求余运算: <code>i = i % 8 = i &amp; 0x07</code>，ARM中没有求余指令，但是有与指令。</li></ol><p><strong>优化循环终止条件</strong></p><p>使用减计数代替惯用的加计数，使用<code>i != 0</code>作循环终止条件。加法计数在循环判断的时候是用CMP和BLE实现的，而用<code>i != 0</code>可以用BNE一条指令代替。</p><p><strong>使用<code>inline</code>函数</strong></p><p><code>inline</code>函数主要节省了调用函数所占用的时间。缺点就是被频繁调用时，代码量将增大，以空间换时间。</p><p><strong>利用已有结果</strong></p><p><code>tmp = a * b;</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i = a * b + c;</span><br><span class="line">j = a * b * d;</span><br></pre></td></tr></table></figure><p><strong>避免循环</strong></p><p>拆开小循环</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">x[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">x[<span class="number">0</span>] = <span class="number">0</span>; x[<span class="number">1</span>] = <span class="number">1</span>; x[<span class="number">2</span>] = <span class="number">2</span>;...;x[<span class="number">9</span>] = <span class="number">9</span>;</span><br></pre></td></tr></table></figure><h3 id="处理器相关的优化方法"><a href="#处理器相关的优化方法" class="headerlink" title="处理器相关的优化方法"></a>处理器相关的优化方法</h3><p><strong>保持流水线畅通</strong></p><p>将循环拆解来<strong>减小跳转指令在循环指令中所占的比重。</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memcopy</span><span class="params">(<span class="keyword">char</span> *to, <span class="keyword">char</span> *from, <span class="keyword">unsigned</span> <span class="keyword">int</span> nbytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p_to = (<span class="keyword">int</span> *)to;</span><br><span class="line"><span class="keyword">int</span> *p_from = (<span class="keyword">int</span> *)from;</span><br><span class="line"><span class="keyword">while</span>(nbytes) &#123;</span><br><span class="line">*p_to++ = *p_from++;</span><br><span class="line">*p_to++ = *p_from++;</span><br><span class="line">*p_to++ = *p_from++;</span><br><span class="line">*p_to++ = *p_from++;</span><br><span class="line">nbytes - = <span class="number">16</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过优化后，一次循环可以处理16 个字节。</p><p><strong>使用寄存器变量</strong></p><p>整型、指针、浮点等类型的变量都可以分配寄存器；一个结构的部分或者全部也可以分配寄存器。给循环体中需要频繁访问的变量分配寄存器也能在一定程度上提高程序效率。</p><h3 id="指令集相关的优化方法"><a href="#指令集相关的优化方法" class="headerlink" title="指令集相关的优化方法"></a>指令集相关的优化方法</h3><p><strong>避免除法</strong></p><p>ARM7 指令集中没有除法指令，其除法是通过调用 C 库函数实现的。一个32 位的除法通常需要20~140 个时钟周期。</p><ul><li>例如<code>if((x/y) &gt; z)</code>可变通为<code>if(x &gt; (y × z))</code></li><li>在能满足精度，且存储器空间冗余的情况下， 也可考虑使用查表法代替除法。</li><li>当除数为2 的幂次方时， 应用移位操作代替除法。</li></ul><p><strong>在后来支持硬件除法的芯片（Cortex-M3）中，用<code>SDIV</code>指令代替了库函数的调用。</strong></p><p><strong>利用条件执行</strong></p><p>ARM 指令集的一个重要特征就是<strong>所有的指令均可包含一个可选的条件码</strong>。当程序状态寄存器(PSR)中的条件码标志满足指定条件时，指令才能执行，因此可以省去单独的判断指令。</p><p><strong>使用合适的变量类型</strong></p><p>在操作char、short型的ARM局部变量，往往比操作32 位变量需要更多指令，所以应该尽可能地避免使用。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wordinc</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">ADD a1,a1,#<span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> a + <span class="number">1</span>; MOV pc,lr</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">short</span> <span class="title">shortinc</span><span class="params">(<span class="keyword">short</span> a)</span> </span>&#123;</span><br><span class="line">ADD a1,a1,#<span class="number">1</span></span><br><span class="line">MOV a1,a1,LSL #<span class="number">16</span></span><br><span class="line"><span class="keyword">return</span> a + <span class="number">1</span>; MOV a1,a1,ASR #<span class="number">16</span>ARM</span><br><span class="line">&#125; MOV pc,<span class="function">lr</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">charinc</span><span class="params">(<span class="keyword">char</span> a)</span></span>&#123;</span><br><span class="line">ADD a1,a1,#<span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> a + <span class="number">1</span>; </span><br><span class="line">AND a1,a1,#&amp;ff</span><br><span class="line">&#125; MOV pc,lr</span><br></pre></td></tr></table></figure><h3 id="存储器相关的优化方法"><a href="#存储器相关的优化方法" class="headerlink" title="存储器相关的优化方法"></a>存储器相关的优化方法</h3><p><strong>用查表代替计算</strong></p><p>用空间换速度：例如需要频繁计算正弦或余弦函数值时，可预先将函数值计算出来置于内存中供以后ARM查找。</p><p><strong>充分利用片内RAM</strong></p><p>一些厂商出产的ARM 芯片内集成有一定容量的RAM，处理器对片内RAM 的访问速度要快于对外部RAM 的访问。</p><h3 id="编译器相关的优化方法"><a href="#编译器相关的优化方法" class="headerlink" title="编译器相关的优化方法"></a>编译器相关的优化方法</h3><p>根据编译器提供的优化选项进行设置。多数编译器都支持对程序速度和程序大小的优化，有些编译器还允许用户选择可供优化的内容及优化的程度。</p><h2 id="尺寸优化"><a href="#尺寸优化" class="headerlink" title="尺寸优化"></a>尺寸优化</h2><h3 id="使用多寄存器操作指令"><a href="#使用多寄存器操作指令" class="headerlink" title="使用多寄存器操作指令"></a>使用多寄存器操作指令</h3><p>ARM 指令集中的多寄存器操作指令LDM/STM 可以加载/ 存储多个寄存器，这在保存/ 恢复寄存器组的状态及进行大块数据复制时非常有效。例如要将寄存器R4~R12 及R14 的内容保存到堆栈中，若用<code>STR</code> 指令共需要10 条，而一条<code>STMEA R13!, &#123;R4 ?? R12, R14&#125;</code> 指令就能达到相同的目的，虽然在执行速度上不一定有提高。</p><h3 id="合理安排变量顺序"><a href="#合理安排变量顺序" class="headerlink" title="合理安排变量顺序"></a>合理安排变量顺序</h3><p>ARM程序中的32 位/16 位变量必须按字/ 半字对齐</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>  i1 ~ i4;</span><br><span class="line"><span class="keyword">char</span> c1 ~ c4;</span><br><span class="line"></span><br><span class="line">按照i1、c1、i2、c2、i3、c3、i4、c4的顺序排列的话，<span class="number">8</span>位的<span class="keyword">char</span>型变量实际上占用的是一个<span class="number">32</span>位寄存器，空间浪费</span><br><span class="line">所以应将 <span class="keyword">int</span> 型变量和 <span class="keyword">char</span> 型变量按类似i1、i2、i3、i4、c1、c2、c3、c4 的顺序连续存放。</span><br></pre></td></tr></table></figure><h3 id="使用Thumb指令"><a href="#使用Thumb指令" class="headerlink" title="使用Thumb指令"></a>使用Thumb指令</h3><p>16 位的 Thumb 指令是ARM 体系结构的扩充。Thumb 指令集是大多数常用32 位ARM 指令压缩成16 位宽指令的集合。</p>]]></content>
      
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> ARM </tag>
            
            <tag> 代码优化 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
