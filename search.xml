<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>树莓派4B启动配置</title>
      <link href="/posts/59454.html"/>
      <url>/posts/59454.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-镜像及工具"><a href="#1-镜像及工具" class="headerlink" title="1. 镜像及工具"></a>1. 镜像及工具</h2><h3 id="1-1-系统镜像"><a href="#1-1-系统镜像" class="headerlink" title="1.1. 系统镜像"></a>1.1. 系统镜像</h3><h4 id="1-1-1-Raspberry-Pi-OS"><a href="#1-1-1-Raspberry-Pi-OS" class="headerlink" title="1.1.1. Raspberry Pi OS"></a>1.1.1. Raspberry Pi OS</h4><p>官方镜像，基于Debian的一个发行版，针对树莓派做了优化。</p><p>一共提供了三个版本，镜像大小逐个递减。</p><ol><li>Raspberry Pi OS with desktop and recommended software：有图形界面，内置各种软件，比如我的世界、Python、游戏等；</li><li>Raspberry Pi OS with desktop：有图形界面、浏览器，没有一些乱七八糟的软件；</li><li>Raspberry Pi OS Lite：无图形界面，有核心依赖，比如Python等。</li></ol><p>需要图形化界面的更推荐Raspberry Pi OS with desktop这个版本，不大不小。不过<strong>官网默认提供的是32bit的版本</strong>，树莓派RaspBerry4B的CPU是博通的BCM2711，一颗ARM Cortex-A72架构的64位处理器，所以使用64位系统才能更好释放性能。</p><blockquote><p><a href="https://downloads.raspberrypi.org/raspios_armhf/images/">32bit镜像官网链接</a></p><p><a href="https://downloads.raspberrypi.org/raspios_arm64/images">64bit镜像官网链接</a></p><p><a href="https://www.raspberrypi.com/software/operating-systems/">镜像的官方介绍及各个版本</a></p></blockquote><h3 id="1-2-SD卡格式化工具"><a href="#1-2-SD卡格式化工具" class="headerlink" title="1.2. SD卡格式化工具"></a>1.2. SD卡格式化工具</h3><p>SD Card Formatter</p><p><a href="https://www.sdcard.org/downloads/formatter/sd-memory-card-formatter-for-windows-download/">官网下载链接</a></p><h3 id="1-3-写镜像工具"><a href="#1-3-写镜像工具" class="headerlink" title="1.3. 写镜像工具"></a>1.3. 写镜像工具</h3><p>Win32DiskImager</p><p><a href="https://sourceforge.net/projects/win32diskimager/files/latest/download">官方下载链接</a></p><h3 id="1-4-远程桌面工具"><a href="#1-4-远程桌面工具" class="headerlink" title="1.4. 远程桌面工具"></a>1.4. 远程桌面工具</h3><h5 id="VNC-Viewer"><a href="#VNC-Viewer" class="headerlink" title="VNC Viewer"></a>VNC Viewer</h5><p><a href="https://www.realvnc.com/en/connect/download/viewer/">官方下载链接</a></p><h2 id="2-刷写系统"><a href="#2-刷写系统" class="headerlink" title="2. 刷写系统"></a>2. 刷写系统</h2><h3 id="2-1-下载镜像"><a href="#2-1-下载镜像" class="headerlink" title="2.1. 下载镜像"></a>2.1. 下载镜像</h3><p>此处我下载的是64位的最新镜像，官方文件名为：2021-05-07-raspios-buster-arm64</p><p>下载之后可以Windows 10终端里输入下面命令来计算SHA256进行完整性校验。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">certutil -hashfile 镜像存放路径\2021-05-07-raspios-buster-arm64.zip SHA256</span><br></pre></td></tr></table></figure><p>BTW，可选哈希算法参数有MD2 MD4 MD5 SHA1 SHA256 SHA384 SHA512</p><p><img src="https://images.961110.xyz/images/2021/10/19/Raspberry-Pi-OS-with-desktop-.png" alt="image-20211016201407578" style="zoom:50%;" /><img src="https://images.961110.xyz/images/2021/10/19/Raspberry-Pi-OS-with-desktop-dc4e0e6197208ff1.png" alt="image-20211016201252081" style="zoom:50%;" /></p><p>两个不同的下载通道都可以看到SHA256的值，最好校验一下。</p><p>校验无误后，解压得到<code>.img</code>镜像文件，待会写到SD卡中。</p><h3 id="2-2-格式化SD卡"><a href="#2-2-格式化SD卡" class="headerlink" title="2.2. 格式化SD卡"></a>2.2. 格式化SD卡</h3><p>选择好SD卡对应的盘符，选择Quick format，点击右下角Format，稍等片刻即可。<strong>注意不要选择错了盘符，否则后果不堪设想。</strong></p><p><img src="https://images.961110.xyz/images/2021/10/19/SD-Card-Formatter.png" alt="image-20211016201935243" style="zoom: 67%;" /><img src="https://images.961110.xyz/images/2021/10/19/SD.png" alt="image-20211016202211668" style="zoom:67%;" /></p><h3 id="2-3-刷写镜像"><a href="#2-3-刷写镜像" class="headerlink" title="2.3. 刷写镜像"></a>2.3. 刷写镜像</h3><p>选择刚刚解压出来的镜像文件，选择好盘符，然后点击写入即可，完成速度取决于SD卡及读卡器的速度。</p><p><img src="https://images.961110.xyz/images/2021/10/19/f28e57496b9b60234c05963587aebae3.png" alt="image-20211016202444369" style="zoom:67%;" /><img src="https://images.961110.xyz/images/2021/10/19/1163840ac01b2da689eb0dc2686f4eb3.png" alt="image-20211016203816344" style="zoom:67%;" /></p><h2 id="3-启动"><a href="#3-启动" class="headerlink" title="3. 启动"></a>3. 启动</h2><h3 id="3-1-准备工作"><a href="#3-1-准备工作" class="headerlink" title="3.1. 准备工作"></a>3.1. 准备工作</h3><h4 id="3-1-1-开启ssh"><a href="#3-1-1-开启ssh" class="headerlink" title="3.1.1. 开启ssh"></a>3.1.1. 开启ssh</h4><p>写入镜像后，会有一个boot分区，在boot分区下新建一个<strong>删掉格式后缀</strong>的名为ssh的<strong>文件</strong>，以便启动后使用ssh连接树莓派。</p><h4 id="3-1-2-通过网线共享电脑的网络"><a href="#3-1-2-通过网线共享电脑的网络" class="headerlink" title="3.1.2. 通过网线共享电脑的网络"></a>3.1.2. 通过网线共享电脑的网络</h4><blockquote><p>设置–&gt;状态–&gt;高级网络设置：更改适配器选项–&gt;选择电脑联网的适配器–&gt;右键选择属性，点击共享–&gt;打开下图中的选项–&gt;选择树莓派要连接的适配器–&gt;确定</p></blockquote><img src="https://images.961110.xyz/images/2021/10/19/2d3ddc0a200c6e2f6386bbfe718cb969.png" alt="image-20211017133126324" style="zoom:50%;" /><p>此种方式的默认的网关IP是192.168.137.1，所以分配给树莓派的IP是192.168.137.XXX，具体查看方式见下文。</p><h4 id="3-1-3-通过配置WiFi上网"><a href="#3-1-3-通过配置WiFi上网" class="headerlink" title="3.1.3. 通过配置WiFi上网"></a>3.1.3. 通过配置WiFi上网</h4><p>在boot分区新建一个wpa_supplicant.conf文件，内容如下:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">country=CN</span><br><span class="line">ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev</span><br><span class="line">update_config=1</span><br><span class="line"></span><br><span class="line">network=&#123;</span><br><span class="line">       ssid=&quot;XXXXXXX&quot;</span><br><span class="line">       psk=&quot;password&quot;</span><br><span class="line">       key_mgmt=WPA-PSK</span><br><span class="line">       priority=1</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>ssid</code>就是WIFI名，<code>psk</code>就是WiFi密码，<code>key_mgmt</code>就是WiFi的加密方式，一般在路由器管理界面的WiFi设置中可以看到。</p><h4 id="3-1-4-连接风扇"><a href="#3-1-4-连接风扇" class="headerlink" title="3.1.4. 连接风扇"></a>3.1.4. 连接风扇</h4><img src="https://images.961110.xyz/images/2021/10/19/4B-.jpg" alt="树莓派4B 连接风扇" style="zoom:50%;" /><p>树莓派4B的GPIO口外侧是偶数口，内侧是奇数口，如图示从左到右需要依次增大。风扇需要连接在第4和6号引脚上，正极（红线）连接在4号引脚，负极（黑线）连接在6号引脚。</p><h3 id="3-2-通电"><a href="#3-2-通电" class="headerlink" title="3.2. 通电"></a>3.2. 通电</h3><h4 id="3-2-1-状态检查"><a href="#3-2-1-状态检查" class="headerlink" title="3.2.1. 状态检查"></a>3.2.1. 状态检查</h4><p>插入SD卡，插入网线，连接电源自动开机：</p><ul><li>红灯常亮：未能检测到TF卡；</li><li>双灯常亮：未能检测到系统；</li><li>绿灯闪烁：系统运行正常。、</li></ul><p>等个几十秒进行下一步</p><h4 id="3-2-2-通过网线联网，查看树莓派Raspberry-4B的IP"><a href="#3-2-2-通过网线联网，查看树莓派Raspberry-4B的IP" class="headerlink" title="3.2.2. 通过网线联网，查看树莓派Raspberry 4B的IP"></a>3.2.2. 通过网线联网，查看树莓派Raspberry 4B的IP</h4><p>打开cmd或其他shell工具，通过<code>arp -a</code>查看本机的arp表，找到接口为192.168.137.1下的内容</p><p>可以看到树莓派Raspberry 4B获得的IP: 192.168.137.XXX</p><h4 id="3-2-3-通过配置WiFi上网，查看树莓派Raspberry-4B的IP"><a href="#3-2-3-通过配置WiFi上网，查看树莓派Raspberry-4B的IP" class="headerlink" title="3.2.3. 通过配置WiFi上网，查看树莓派Raspberry 4B的IP"></a>3.2.3. 通过配置WiFi上网，查看树莓派Raspberry 4B的IP</h4><p>进入路由器后台，查看接入网络的设备列表，记录其IP即可。</p><h3 id="3-3-ssh连接"><a href="#3-3-ssh连接" class="headerlink" title="3.3. ssh连接"></a>3.3. ssh连接</h3><p>获取IP后，直接 <code>ssh pi@IP</code> 即可</p><p>密码是 raspberry</p><h3 id="3-4-VNC连接"><a href="#3-4-VNC连接" class="headerlink" title="3.4. VNC连接"></a>3.4. VNC连接</h3><h4 id="3-4-1-开启VNC"><a href="#3-4-1-开启VNC" class="headerlink" title="3.4.1. 开启VNC"></a>3.4.1. 开启VNC</h4><p>使用ssh登录之后，输入<code>sudo raspi-config</code>进行配置</p><h4 id="3-4-2-使用VNC连接"><a href="#3-4-2-使用VNC连接" class="headerlink" title="3.4.2. 使用VNC连接"></a>3.4.2. 使用VNC连接</h4><h3 id="3-5-使用微软远程桌面连接"><a href="#3-5-使用微软远程桌面连接" class="headerlink" title="3.5. 使用微软远程桌面连接"></a>3.5. 使用微软远程桌面连接</h3><h4 id="3-5-1-安装依赖包"><a href="#3-5-1-安装依赖包" class="headerlink" title="3.5.1. 安装依赖包"></a>3.5.1. 安装依赖包</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装 xrdp</span></span><br><span class="line">sudo apt-get install xrdp</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动xrdp</span></span><br><span class="line">sudo /etc/init.d/xrdp start</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将Xrdp服务添加到系统默认启动服务中</span></span><br><span class="line">sudo update-rc.d xrdp defaults</span><br></pre></td></tr></table></figure><h3 id="3-5-2-连接"><a href="#3-5-2-连接" class="headerlink" title="3.5.2. 连接"></a>3.5.2. 连接</h3><p>打开Windows远程桌面，输入树莓派4B的IP，连接即可。默认用户名：pi，默认密码：raspberry。</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 树莓派 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker安装chevereto图床并解除上传图片大小限制、自定义图片上传用户和相册</title>
      <link href="/posts/36360.html"/>
      <url>/posts/36360.html</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>直接用官方的推荐安装方式，修改后的docker-compose.yaml如下</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mariadb</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">database:/var/lib/mysql:rw</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">private</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">xxx</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">chevereto</span></span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="string">jason</span></span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="string">xxx</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">chevereto:</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nmtan/chevereto</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">private</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">CHEVERETO_DB_HOST:</span> <span class="string">db</span></span><br><span class="line">      <span class="attr">CHEVERETO_DB_USERNAME:</span> <span class="string">jason</span></span><br><span class="line">      <span class="attr">CHEVERETO_DB_PASSWORD:</span> <span class="string">xxx</span></span><br><span class="line">      <span class="attr">CHEVERETO_DB_NAME:</span> <span class="string">chevereto</span></span><br><span class="line">      <span class="attr">CHEVERETO_DB_PREFIX:</span> <span class="string">chv_</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/home/Jason/chv_images:/var/www/html/images:rw</span>  <span class="comment">#将照片存放路径映射到了本地存储中</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span><span class="string">:80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">private:</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">database:</span></span><br><span class="line">  <span class="attr">chevereto_images:</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后<code>docker-compose up -d</code>就可以启动，通过8080端口访问chevereto。</p><h2 id="解除上传图片的大小限制"><a href="#解除上传图片的大小限制" class="headerlink" title="解除上传图片的大小限制"></a>解除上传图片的大小限制</h2><h3 id="复制到服务器本地路径下"><a href="#复制到服务器本地路径下" class="headerlink" title="复制到服务器本地路径下"></a>复制到服务器本地路径下</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">docker cp  containerID:<span class="regexp">/var/</span>www/html/.htaccess /volume1/docker/</span><br></pre></td></tr></table></figure><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /volume1/docker/.htaccess</span><br><span class="line"></span><br><span class="line"># Disable server signature</span><br><span class="line">ServerSignature Off</span><br><span class="line"></span><br><span class="line"># Disable directory listing (-indexes), Multiviews (-MultiViews) and enable Follow system links (+FollowSymLinks)</span><br><span class="line">Options -Indexes</span><br><span class="line">Options -MultiViews</span><br><span class="line"></span><br><span class="line">&lt;IfModule mod_rewrite.c&gt;</span><br><span class="line"></span><br><span class="line">    RewriteEngine On</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    RewriteRule . index.php [L]</span><br><span class="line">    #修改上传文件大小增加以下 配置  最大支持 32M 根据自己情况配置</span><br><span class="line">    php_value post_max_size 64M</span><br><span class="line">    php_value upload_max_filesize 32M</span><br><span class="line"></span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure><h3 id="复制到容器目录里面"><a href="#复制到容器目录里面" class="headerlink" title="复制到容器目录里面"></a>复制到容器目录里面</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">docker cp /volume1/docker/.htaccess containerID:<span class="regexp">/var/</span>www/html/</span><br></pre></td></tr></table></figure><h2 id="修改上传API"><a href="#修改上传API" class="headerlink" title="修改上传API"></a>修改上传API</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp containerID:/var/www/html/app/routes/route.api.php ./</span><br></pre></td></tr></table></figure><p>将PHP文件复制出来，相应位置增加如下代码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$version</span> = <span class="variable">$handler</span>-&gt;request[<span class="number">0</span>];</span><br><span class="line"><span class="variable">$action</span> = <span class="variable">$handler</span>-&gt;request[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增下面两行</span></span><br><span class="line"><span class="variable">$user</span> = <span class="variable">$_REQUEST</span>[<span class="string">&#x27;user&#x27;</span>];</span><br><span class="line"><span class="variable">$album</span> = <span class="variable">$_REQUEST</span>[<span class="string">&#x27;album&#x27;</span>];</span><br></pre></td></tr></table></figure><p>更改如下代码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将这行代码增加 user 和 album 两个参数</span></span><br><span class="line"><span class="variable">$uploaded_id</span> = CHV\Image::uploadToWebsite(<span class="variable">$source</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更改后的代码如下</span></span><br><span class="line"><span class="variable">$uploaded_id</span> = CHV\Image::uploadToWebsite(<span class="variable">$source</span>, <span class="variable">$user</span>, <span class="keyword">array</span>(<span class="string">&#x27;album_id&#x27;</span>=&gt;<span class="variable">$album</span>));</span><br></pre></td></tr></table></figure><p>将修改后的文件复制到容器中替换</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp ./route.api.php  containerID:/var/www/html/app/routes/route.api.php</span><br></pre></td></tr></table></figure><h2 id="配置Typora和PicGo"><a href="#配置Typora和PicGo" class="headerlink" title="配置Typora和PicGo"></a>配置Typora和PicGo</h2><p>在PicGo中下载插件web-uploader，填入如下配置</p><img src="https://images.961110.xyz/images/2021/10/20/image-20211020120134965.png" alt="image-20211020120134965" style="zoom: 50%;" /><ul><li>API地址：http或https(根据自身情况)://域名/api/1/upload</li><li>POST参数名：source</li><li>JSON路径：image.url</li><li>自定义Body：<code>&#123;&quot;key&quot;:&quot;your key&quot;, &quot;user&quot;:&quot;username&quot;, &quot;album&quot;:&quot;albumid&quot;&#125;</code></li></ul><p>key在用户名–&gt;仪表盘–&gt;设置–&gt;API可以找到</p><img src="https://images.961110.xyz/images/2021/10/20/image-20211020120705106.png" alt="image-20211020120705106" style="zoom:50%;" /><p>username就在chevereto网站右上角<img src="https://images.961110.xyz/images/2021/10/20/image-20211020120603290.png" alt="image-20211020120603290"></p><p>albumid在用户的相册详细信息中可以找到。</p><img src="https://images.961110.xyz/images/2021/10/20/image-20211020120843573.png" alt="image-20211020120843573" style="zoom: 50%;" /><p>配置完成后设置为默认图床，进行上传测试。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://blog.csdn.net/qq_25005601/article/details/110532477?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&spm=1001.2101.3001.4242">Typora + PicGo 自动上传图片到 Chevereto 图床_张大炮来巡山-CSDN博客</a></li><li><a href="https://blog.csdn.net/qq_19564393/article/details/108506062">修改Chevereto的API上传相册和用户_飞逝17的博客-CSDN博客</a></li><li><a href="https://blog.csdn.net/weixin_29343153/article/details/113534943">docker修改文件夹权限_群晖通过Docker安装图床工具Chevereto的步骤_藏美者阿远的博客-CSDN博客</a></li><li><a href="https://www.orcy.net.cn/775.html">Docker容器报错处理:AH00558: apache2: Could not reliably determine the server’s fully qualified domain name, using 172.17.0.5. Set the ‘ServerName’ directive globally to suppress this message – 下一朵云 (orcy.net.cn)</a></li><li><a href="https://cloud.tencent.com/developer/article/1645239">群晖Docker安装chevereto图床</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 图床 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lambda表达式</title>
      <link href="/posts/40489.html"/>
      <url>/posts/40489.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h2><p>lambda 表达式有如下的一些优点：</p><ul><li>  声明式的编程风格：就地匿名定义目标函数或函数对象，不需要额外写一个命名函数或函数对象。</li><li>  简洁：避免了代码膨胀和功能分散，让开发更加高效。</li><li>  在需要的时间和地点实现功能闭包，使程序更加灵活。</li></ul><p>lambda 表达式定义了一个匿名函数，并且可以捕获一定范围内的变量。lambda 表达式的语法形式简单归纳如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[capture](params) opt -&gt; ret &#123;body;&#125;;</span><br></pre></td></tr></table></figure><p>其中 <code>capture</code> 是捕获列表，<code>params</code> 是参数列表，<code>opt</code> 是函数选项，<code>ret</code> 是返回值类型，<code>body</code> 是函数体。</p><ol><li>捕获列表 []: 捕获一定范围内的变量</li><li>参数列表 (): 和普通函数的参数列表一样，如果没有参数参数列表可以省略不写。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = []()&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;<span class="comment">// 没有参数, 参数列表为空</span></span><br><span class="line"><span class="keyword">auto</span> f = []&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;<span class="comment">// 没有参数, 参数列表省略不写</span></span><br></pre></td></tr></table></figure></li><li>opt 选项， <code>不需要可以省略</code><ul><li>  mutable: 可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）</li><li>exception: 指定函数抛出的异常，如抛出整数类型的异常，可以使用 throw ();</li></ul></li><li>返回值类型：在 C++11 中，lambda 表达式的返回值是通过返回值后置语法来定义的。</li><li>函数体：函数的实现，这部分不能省略，但函数体可以为空。</li></ol><h2 id="2-捕获列表"><a href="#2-捕获列表" class="headerlink" title="2. 捕获列表"></a>2. 捕获列表</h2><p>lambda 表达式的捕获列表可以捕获一定范围内的变量，具体使用方式如下：</p><ul><li>  <code>[]</code> - 不捕捉任何变量</li><li>  <code>[&amp;]</code> - 捕获外部作用域中所有变量，并作为引用在函数体内使用 (<code>按引用捕获</code>)</li><li><code>[=]</code> - 捕获外部作用域中所有变量，并作为副本在函数体内使用 (<code>按值捕获</code>)<ul><li>  <code>拷贝的副本在匿名函数体内部是只读的</code></li></ul></li><li>  <code>[=, &amp;foo]</code> - 按值捕获外部作用域中所有变量，并按照引用捕获外部变量 foo</li><li>  <code>[bar]</code> - 按值捕获 bar 变量，同时不捕获其他变量</li><li>  <code>[&amp;bar]</code> - 按引用捕获 bar 变量，同时不捕获其他变量</li><li><code>[this]</code> - 捕获当前类中的 this 指针<ul><li>  让 lambda 表达式拥有和当前类成员函数同样的访问权限</li><li>  <strong>如果已经使用了 &amp; 或者 =, 默认添加 this 指针</strong></li></ul></li></ul><p>下面通过一个例子，看一下初始化列表的具体用法：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> x1 = [] &#123;<span class="keyword">return</span> m_number; &#125;;                      <span class="comment">// error，没有捕获外部变量，不能使用类成员 m_number</span></span><br><span class="line">        <span class="keyword">auto</span> x2 = [=] &#123;<span class="keyword">return</span> m_number + x + y; &#125;;             <span class="comment">// ok，以值拷贝的方式捕获所有外部变量</span></span><br><span class="line">        <span class="keyword">auto</span> x3 = [&amp;] &#123;<span class="keyword">return</span> m_number + x + y; &#125;;             <span class="comment">// ok，以引用的方式捕获所有外部变量</span></span><br><span class="line">        <span class="keyword">auto</span> x4 = [<span class="keyword">this</span>] &#123;<span class="keyword">return</span> m_number; &#125;;                  <span class="comment">// ok，捕获 this 指针，可访问对象内部成员</span></span><br><span class="line">        <span class="keyword">auto</span> x5 = [<span class="keyword">this</span>] &#123;<span class="keyword">return</span> m_number + x + y; &#125;;          <span class="comment">// error，捕获 this 指针，可访问类内部成员，没有捕获到变量 x，y，因此不能访问。</span></span><br><span class="line">        <span class="keyword">auto</span> x6 = [<span class="keyword">this</span>, x, y] &#123;<span class="keyword">return</span> m_number + x + y; &#125;;    <span class="comment">// ok，捕获 this 指针，x，y</span></span><br><span class="line">        <span class="keyword">auto</span> x7 = [<span class="keyword">this</span>] &#123;<span class="keyword">return</span> m_number++; &#125;;                <span class="comment">// ok，捕获 this 指针，并且可以修改对象内部变量的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m_number = <span class="number">100</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>在匿名函数内部，需要通过 lambda 表达式的捕获列表控制如何捕获外部变量，以及访问哪些变量。默认状态下 lambda 表达式无法修改通过复制方式捕获外部变量，如果希望修改这些外部变量，需要通过引用的方式进行捕获。</p></blockquote><h2 id="3-返回值"><a href="#3-返回值" class="headerlink" title="3. 返回值"></a>3. 返回值</h2><p>一般情况下，不指定 lambda 表达式的返回值，编译器会根据 return 语句自动推导返回值的类型，但需要注意的是 <code>labmda表达式不能通过列表初始化自动推导出返回值类型。</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ok，可以自动推导出返回值类型</span></span><br><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">int</span> a) -&gt; <span class="keyword">int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+<span class="number">10</span>;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">int</span> a)&#123;</span><br><span class="line">    <span class="keyword">return</span> a+<span class="number">10</span>;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error，不能推导出返回值类型</span></span><br><span class="line"><span class="keyword">auto</span> f1 = []()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;<span class="comment">// 基于列表初始化推导返回值，错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-函数本质"><a href="#4-函数本质" class="headerlink" title="4. 函数本质"></a>4. 函数本质</h2><p>使用 lambda 表达式捕获列表捕获外部变量，如果希望去修改按值捕获的外部变量，那么应该如何处理呢？这就需要使用 mutable 选项，<code>被mutable修改是lambda表达式就算没有参数也要写明参数列表，并且可以去掉按值捕获的外部变量的只读（const）属性。</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f1 = [=] &#123;<span class="keyword">return</span> a++; &#125;;              <span class="comment">// error, 按值捕获外部变量, a是只读的</span></span><br><span class="line"><span class="keyword">auto</span> f2 = [=]()<span class="keyword">mutable</span> &#123;<span class="keyword">return</span> a++; &#125;;     <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>最后再剖析一下为什么通过值拷贝的方式捕获的外部变量是只读的:</p><ol><li> <code>lambda表达式的类型在C++11中会被看做是一个带operator()的类，即仿函数。</code></li><li> <code>按照C++标准，lambda表达式的operator()默认是const的，一个const成员函数是无法修改成员变量值的。</code></li></ol><p>mutable 选项的作用就在于取消 operator () 的 const 属性。</p><p>因为 lambda 表达式在 C++ 中会被看做是一个仿函数，因此<code>可以使用std::function和std::bind来存储和操作lambda表达式</code>：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 包装可调用函数</span></span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>)&gt; f1 = [](<span class="keyword">int</span> a) &#123;<span class="keyword">return</span> a; &#125;;</span><br><span class="line">    <span class="comment">// 绑定可调用函数</span></span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>)&gt; f2 = <span class="built_in">bind</span>([](<span class="keyword">int</span> a) &#123;<span class="keyword">return</span> a; &#125;, placeholders::_1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数调用</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">f1</span>(<span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">f2</span>(<span class="number">200</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于没有捕获任何变量的 lambda 表达式，还可以转换成一个普通的函数指针：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> func_ptr = <span class="built_in"><span class="keyword">int</span></span>(*)(<span class="keyword">int</span>);</span><br><span class="line"><span class="comment">// 没有捕获任何外部变量的匿名函数</span></span><br><span class="line">func_ptr f = [](<span class="keyword">int</span> a)&#123;</span><br><span class="line">    <span class="keyword">return</span> a;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 函数调用</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">1314</span>);</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://subingwen.cn/cpp/lambda/">Lambda表达式 | 爱编程的大丙 (subingwen.cn)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 基础知识 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
