<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>重拾 MySQL</title>
      <link href="/posts/48304.html"/>
      <url>/posts/48304.html</url>
      
        <content type="html"><![CDATA[<h3 id="常规"><a href="#常规" class="headerlink" title="常规"></a>常规</h3><ol><li><p>判断是否为空，应该使用 IS NOT null，而不是 &lt;&gt; null</p></li><li><p>null + 非空 = null</p></li><li><p>分组前用 where， 分组后用 having</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(sal) <span class="keyword">as</span> avg_sal, deptno <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> dept_no <span class="keyword">having</span> avg_sal <span class="operator">&lt;</span> <span class="number">2000</span>;</span><br></pre></td></tr></table></figure></li><li><p>FROM DUAL  DUAL 是一张虚拟表，可以看成占位符</p></li><li><p>查询第三个字母为 O </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ename, sal <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> ename <span class="keyword">LIKE</span> <span class="string">&#x27;__O%&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>如果 select 语句同时包含有group by, having, limit, order by,那么他们的顺序是group by, having, order by, limit</p></li><li><p>自连接的含义</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> worker.ename <span class="keyword">AS</span> <span class="string">&#x27;职员名&#x27;</span>, boss.ename <span class="keyword">AS</span> <span class="string">&#x27;上级名&#x27;</span> <span class="keyword">FROM</span> emp worker, emp boss <span class="keyword">WHERE</span> worker.mgr <span class="operator">=</span> boss.empno;</span><br></pre></td></tr></table></figure></li><li><p>多列子查询</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> (deptno, job) <span class="operator">=</span> （<span class="keyword">SELECT</span> deptno, job <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> ename <span class="operator">=</span> <span class="string">&#x27;ALLEN&#x27;</span>） <span class="keyword">AND</span> ename <span class="operator">!=</span> <span class="string">&#x27;ALLEN&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>UNION ALL 查询结果合并，不去重(8)</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ename, sal, job <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> sa1<span class="operator">&gt;</span><span class="number">2500</span>  <span class="comment">--- 5</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> ename, sal, job <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> job<span class="operator">=</span><span class="string">&#x27;MANAGER&#x27;</span> <span class="comment">--- 3</span></span><br></pre></td></tr></table></figure></li><li><p>UNION 查询结果合并去重(3)</p></li></ol>   <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ename, sal, job <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> sa1<span class="operator">&gt;</span><span class="number">2500</span> <span class="comment">--- 5</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> ename, sal, job <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> job<span class="operator">=</span><span class="string">&#x27;MANAGER&#x27;</span> <span class="comment">--- 3</span></span><br></pre></td></tr></table></figure><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><ol><li>主键索引：主键自动为主索引</li><li>唯一索引：UNIQUE</li><li>普通索引：INDEX</li><li>全文索引：FULLTEXT，适用于 MyISAM（存储引擎），全文搜索：Solr 和 ElasticSearch</li></ol><h4 id="创建规则"><a href="#创建规则" class="headerlink" title="创建规则"></a>创建规则</h4><ol><li>频繁查询的字段；</li><li>唯一性太差的字段；</li><li>更新非常频繁的字段不适合创建索引；</li><li>不会出现在 WHERE 子句中的字段不该创建索引；</li></ol><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>查询表是否有索引</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> table_name;</span><br><span class="line"><span class="keyword">SHOW</span> INDEXS <span class="keyword">FROM</span> table_name;</span><br><span class="line"><span class="keyword">SHOW</span> KEYS <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>用于保证数据的一致性，由一组相关的 DML 语句组成。组中的语句要么全都成功，要么全都失败。应用场景：转账。。。</p><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction</span><br><span class="line"><span class="keyword">savepoint</span> 保存点名</span><br><span class="line"><span class="keyword">rollback</span> <span class="keyword">to</span> 保存点名</span><br><span class="line"><span class="keyword">rollback</span> ——回退所有事务</span><br><span class="line"><span class="keyword">commit</span></span><br></pre></td></tr></table></figure><ul><li>使用 commit 语句提交结束事务之后，其他会话将可以看到变化后的新数据。</li><li>在不显式开启事务的情况下， DML 操作是自动提交的，不能回滚</li></ul><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><ul><li>脏读：当一个事务读取另一个事务<strong>尚未提交的语句</strong>时，产生脏读</li><li>不可重复读：同一查询在同一事务中多次进行，由于其他提交事务所做的<strong>修改或删除</strong>，每次返回不同的结果集，此时发生不可重复读。</li><li>幻读：同一查询在同一事务中多次进行，由于其他提交事务所做的<strong>插入操作</strong>，每次返回不同的结果集，此时发生幻读。</li></ul><p><img src="https://images.961110.xyz/images/2022/12/05/mysql_isolation_level.png" alt="image-20221205230217639"></p><p>默认隔离级别：可重复读</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><img src="https://images.961110.xyz/images/2022/12/01/str_func.png" alt="image-20221201231417724"></p><p><img src="https://images.961110.xyz/images/2022/12/01/math_func.png" alt="image-20221201232053347"></p><p><img src="https://images.961110.xyz/images/2022/12/01/date_func.png" alt="image-20221201232348525"></p><p><img src="https://images.961110.xyz/images/2022/12/01/process_control_func.png" alt="image-20221201233745857"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重拾 Java 系列 —— 其他</title>
      <link href="/posts/2290.html"/>
      <url>/posts/2290.html</url>
      
        <content type="html"><![CDATA[<h2 id="重拾-Java-系列-——-其他"><a href="#重拾-Java-系列-——-其他" class="headerlink" title="重拾 Java 系列 —— 其他"></a>重拾 Java 系列 —— 其他</h2><h3 id="JDK-工具"><a href="#JDK-工具" class="headerlink" title="JDK 工具"></a>JDK 工具</h3><h4 id="javap"><a href="#javap" class="headerlink" title="javap"></a>javap</h4><p>JDK 提供的命令行工具，反编译 class 字节码文件</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>三元运算符要看作整体</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Objdect obj = <span class="keyword">true</span>? <span class="keyword">new</span> Interge(<span class="number">1</span>): <span class="keyword">new</span> Double(<span class="number">2.0</span>);</span><br><span class="line">System.out.println(obj); <span class="comment">// 1.0(自动提升精度)</span></span><br></pre></td></tr></table></figure><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h4 id="类加载流程图"><a href="#类加载流程图" class="headerlink" title="类加载流程图"></a>类加载流程图</h4><p><img src="https://images.961110.xyz/images/2022/12/17/class_loading_process.png" alt="image-20221217205330201"></p><h4 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h4><p>JVM 将字节码从不同数据源（可能是 class 文件，可能是 jar 包，也可能来源于网络）转化为二进制字节流加载到内存（方法区）中，并生成一个代表该类的 java.lang.Class 对象（堆中）。</p><h4 id="连接阶段——验证"><a href="#连接阶段——验证" class="headerlink" title="连接阶段——验证"></a>连接阶段——验证</h4><ul><li>目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。<ul><li>在类加载过程中会创建一个 securityManager 进行验证工作，包括：文件格式验证（是否以魔数 0xcafebabe 开头，固定格式）、元数据验证、字节码验证和符号引用验证</li></ul></li><li>可以考虑使用<code>-Xverify:none</code>参数来关闭大部分的类验证措施，缩短虚拟机类加载的时间。</li></ul><h4 id="连接阶段——准备"><a href="#连接阶段——准备" class="headerlink" title="连接阶段——准备"></a>连接阶段——准备</h4><p>JVM 对<strong>静态变量</strong>分配内存并进行默认初始化（0 0L null false 等），分配的内存位于方法区。</p><p> <img src="https://images.961110.xyz/images/2022/12/17/static_varibale.png" alt="image-20221217211238620"></p><h4 id="连接阶段——解析"><a href="#连接阶段——解析" class="headerlink" title="连接阶段——解析"></a>连接阶段——解析</h4><p>JVM 将常量池内的符号引用替换为直接引用（内存地址）</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>真正开始执行类中定义的 Java 代码。</p><p>该阶段是执行<code>&lt;clinit&gt;()</code>方法的阶段</p><ul><li><code>&lt;clinit&gt;()</code>方法是由编译器按语句在源文件中出现的顺序，依次自动收集类中的所有静态变量的赋值动作和静态代码块中的语句，并进行合并。<ul><li>同一个静态变量赋值两次，以最后一个为准</li></ul></li><li>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程都需要阻塞等待，直到活动线程执行<code>&lt;clinit&gt;()</code>方法完毕。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重拾 Java 系列 —— 面向对象</title>
      <link href="/posts/30000.html"/>
      <url>/posts/30000.html</url>
      
        <content type="html"><![CDATA[<h2 id="重拾-Java-系列-——-面向对象"><a href="#重拾-Java-系列-——-面向对象" class="headerlink" title="重拾 Java 系列 —— 面向对象"></a>重拾 Java 系列 —— 面向对象</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><h4 id="类和对象的内存分配机制"><a href="#类和对象的内存分配机制" class="headerlink" title="类和对象的内存分配机制"></a>类和对象的内存分配机制</h4><ol><li>栈：一般存放基本数据类型（局部变量）</li><li>堆：存放对象（自定义类、数组等）</li><li>方法区：常量池（常量，比如字符串常量）、类加载信息</li></ol><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ol><li><p>Java 中允许方法重载，方法名相同，形参列表不同（类型或个数或顺序），返回值类型无要求</p></li><li><p>可变参数的实参可以为数组，其本质就是数组</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">sum(arr);</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>... nums)</span></span>&#123;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="构造方法-构造器"><a href="#构造方法-构造器" class="headerlink" title="构造方法/构造器"></a>构造方法/构造器</h4><p>构造方法的主要作用是完成新对象的初始化，并不是创建对象。</p><ol><li>构造方法没有返回值；</li><li>方法名必须和类名字一样；</li><li>构造方法由系统自动调用；</li><li>构造方法可以重载；</li><li>没有显式定义构造方法，系统会生成默认无参构造方法。一旦显式定义了构造方法，默认构造方法就被覆盖；</li></ol><h4 id="Java-创建对象的流程"><a href="#Java-创建对象的流程" class="headerlink" title="Java 创建对象的流程"></a>Java 创建对象的流程</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">90</span>;</span><br><span class="line">    String name;</span><br><span class="line">    Person(String n, <span class="keyword">int</span> a)&#123;</span><br><span class="line">        name = n;</span><br><span class="line">        age = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Person p = <span class="keyword">new</span> Person(<span class="string">&quot;小倩&quot;</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><ol><li>先在方法区加载类信息（属性和方法信息，只会加载一次）</li><li>在堆中给对象分配空间；</li><li>完成对象初始化<ol><li>默认值初始化（<code>int = 0 string = null</code>）；</li><li>显式初始化；</li><li>使用构造器进行初始化；</li></ol></li><li>把地址赋给类的实例；</li></ol><h4 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h4><p>this 指向类实例的地址</p><p><code>this(参数列表)</code> 可以直接访问构造器（只能在构造器中访问另一个构造器，且必须放在第一条语句）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">T</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="string">&quot;jack&quot;</span>,<span class="number">9</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;T() 构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">T</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; T(String name, int age) 构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="包"><a href="#包" class="headerlink" title="包"></a>包</h4><p>命名规范：com.公司名.项目名.业务模块名 com.alibaba.oa.model; com.alibaba.oa.controller</p><p>package 只能放在一个文件的第一行</p><h4 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h4><ul><li>public: 同类、同包、子类、不同包都可以访问；</li><li>protected: 同类、同包、子类都可以访问，不同包不能访问；</li><li>private: 同类可以访问，同包、子类、不同包均不能访问；</li><li>没有修饰符：同类、同包都可以访问，子类、不同包不能访问；</li></ul><p>只有 默认 和 public 可以修饰类</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>非私有属性和方法可以在子类直接访问</li><li>子类必须调用父类的构造器，完成父类的初始化。</li><li>不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器。如果父类没有提供无参构造器，则必须在子类的构造器中用<code>super</code>去指定使用父类的哪个构造器。</li><li><code>super</code>在使用时，需要放置在构造器第一行</li><li>Java 所有类都是<code>Object</code>类的子类，父类构造器的调用一直往上追溯到<code>Object</code>类</li><li>Java 是单继承机制</li></ol><h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><p>先加载顶级类，再逐层加载，最后加载<code>Son</code></p><p><img src="https://images.961110.xyz/images/2022/11/23/image-20221123232237272.png" alt="image-20221123232237272"></p><h4 id="super"><a href="#super" class="headerlink" title="super"></a>super</h4><p><code>super</code>代表父类的引用，用于访问父类的属性、方法、构造器。</p><p>分工明确：父类属性由父类初始化，子类属性由子类初始化</p><p>子类和父类中的属性、方法没有重名时，使用<code>super</code>、<code>this</code>、直接访问都是一样的效果</p><p>多个上级类由同名的成员时，<code>super</code>遵循就近原则，同时需要遵守访问权限的规则<img src="https://images.961110.xyz/images/2022/11/23/super--this-.png" alt="image-20221123233430891"></p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> 接口名</span>&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 方法（抽象方法、默认实现方法、静态方法）</span></span><br><span class="line">    <span class="comment">// 抽象方法可以省略 abstract 关键字</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hi</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ok</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ...;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ...;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接口不能被实例化</li><li>接口中所有的方法都是 public 的</li><li>接口中抽象方法可以省略 abstract 关键字</li><li>一个普通类实现接口，必须实现接口的所有方法</li><li>抽象类实现接口，可以不用实现接口的方法</li><li>一个类可以同时实现多个接口</li><li>接口的属性，默认是 public static final 的，必须初始化</li><li>接口不能继承其他类，但是可以继承多个别的接口</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">USBInterface</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Camera</span> <span class="keyword">implements</span> <span class="title">USBInterface</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ...;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ...;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(USBInterface usbInterface)</span></span>&#123;</span><br><span class="line">        usbInterface.start();</span><br><span class="line">        usbInterface.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>注解（Annotation）也被称为元数据（metadata），用于修饰包、类、方法、属性、构造器、局部变量等信息</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>子类抛出的异常类型应该和父类抛出的异常保持一致或是其子类</p><h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p>所有包装类都是不可继承的</p><p><img src="https://images.961110.xyz/images/2022/12/07/wrapper_class.png" alt="image-20221207222520140"></p><ul><li>装箱：基本类型-&gt;包装类型</li><li>拆箱：基本类型&lt;-包装类型</li></ul><p>自动装箱底层调用的是 <code>valueOf()</code> 方法</p><h4 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i= <span class="number">100</span>;</span><br><span class="line">String str1 = i+<span class="string">&quot;&quot;</span>; <span class="comment">// &quot;100&quot;</span></span><br><span class="line">String str2 = i.toString(); <span class="comment">// &quot;100&quot;</span></span><br><span class="line">String str3 = String.valueOf(i); <span class="comment">// &quot;100&quot;</span></span><br><span class="line"></span><br><span class="line">String str4 = <span class="string">&quot;12345&quot;</span>;</span><br><span class="line">Integer i2 = Integer.parseInt(str4);</span><br><span class="line">Integer i3 = <span class="keyword">new</span> Integer(str4);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer i = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">    Integer j = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">    System.out.println(i == j);  <span class="comment">//False</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    //1. 如果i 在 IntegerCache.low(-128)~IntegerCache.high(127),就直接从数组返回</span></span><br><span class="line"><span class="comment">    //2. 如果不在 -128~127,就直接 new Integer(i)</span></span><br><span class="line"><span class="comment">     public static Integer valueOf(int i) &#123;</span></span><br><span class="line"><span class="comment">        if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span></span><br><span class="line"><span class="comment">            return IntegerCache.cache[i + (-IntegerCache.low)];</span></span><br><span class="line"><span class="comment">        return new Integer(i);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Integer m = <span class="number">1</span>; <span class="comment">//底层 Integer.valueOf(1); -&gt; 阅读源码</span></span><br><span class="line">    Integer n = <span class="number">1</span>;<span class="comment">//底层 Integer.valueOf(1);</span></span><br><span class="line">    System.out.println(m == n); <span class="comment">//T</span></span><br><span class="line">    <span class="comment">//所以，这里主要是看范围 -128 ~ 127 就是直接返回</span></span><br><span class="line">    <span class="comment">//，否则，就new Integer(xx);</span></span><br><span class="line">    Integer x = <span class="number">128</span>;<span class="comment">//底层Integer.valueOf(1);</span></span><br><span class="line">    Integer y = <span class="number">128</span>;<span class="comment">//底层Integer.valueOf(1);</span></span><br><span class="line">    System.out.println(x == y);<span class="comment">//False</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><ol><li>String 不能被其他类继承</li><li>String 有属性<code>private final char Value []</code>用于存放字符串内容<br><code>value</code>不可修改，即<code>value</code>不能指向新的地址，但是单个字符内容是可以变化</li></ol><p>String 两种构造方法的不同内存布局</p><p>方式一：先从常量池查看是否有”hsp”数据空间，如果有则直接指向；如果<br>没有则重新创建，然后指向。<code>s</code>最终指向的是常量池的空间地址<br>方式二：先在堆中创建空间，里面维护了value属性，指向常量池的hsp空间。<br>如果常量池没有”hsp”，重新创建，如果有则直接通过value指向。最终指向<br>的是堆中的空间地址。</p><p><img src="https://images.961110.xyz/images/2022/12/07/string_create.png" alt="image-20221208001347768"></p><ul><li>String c = “ab”+”cd” c 指向的是常量池中 “abcd” 的地址</li><li>String d = a + b，实际是在新建了一个 String 对象。</li><li>String str = “hello” 取”h”不能用 str[0]</li></ul><h4 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h4><ul><li>StringBuffer是可变字符序列，长度可变，是一个容器。</li><li>final 类，不可被继承</li><li>在父类 AbstractStringBuilder 中有属性 char[] value，存放字符串内容，可以被修改。</li><li>StringBuffer 的修改不用每次都更新地址，效率更高</li><li>默认构造器中初始容量设定为 16 个字符</li><li>线程安全 </li></ul><h4 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h4><ul><li>可变字符序列，类似 StringBuffer，不同的是 StringBuilder 不是线程安全的。在单线程下，性能比 StringBuffer 好。</li><li>final 类</li></ul><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p><img src="https://images.961110.xyz/images/2022/12/08/collection.png" alt="image-20221208231622527"></p><p>实现了 Iterable 接口的，都可以被迭代器迭代</p><p>实现了 List 接口的，集合中元素有序且可以重复</p><p><img src="https://images.961110.xyz/images/2022/12/08/map.png" alt="image-20221208231711219"></p><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionIterator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Collection col = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        col.add(<span class="keyword">new</span> Book(<span class="string">&quot;三国演义&quot;</span>, <span class="string">&quot;罗贯中&quot;</span>, <span class="number">10.1</span>));</span><br><span class="line">        col.add(<span class="keyword">new</span> Book(<span class="string">&quot;小李飞刀&quot;</span>, <span class="string">&quot;古龙&quot;</span>, <span class="number">5.1</span>));</span><br><span class="line">        col.add(<span class="keyword">new</span> Book(<span class="string">&quot;红楼梦&quot;</span>, <span class="string">&quot;曹雪芹&quot;</span>, <span class="number">34.6</span>));</span><br><span class="line"></span><br><span class="line">        Iterator iterator = col.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Object obj = iterator.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;obj=&quot;</span> + obj);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 当退出while循环后 , 这时iterator迭代器，指向最后的元素</span></span><br><span class="line">        <span class="comment">//   iterator.next();//NoSuchElementException</span></span><br><span class="line">        <span class="comment">//4. 如果希望再次遍历，需要重置我们的迭代器</span></span><br><span class="line">        iterator = col.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 增强 for，底层也是 iterator</span></span><br><span class="line">        <span class="keyword">for</span> (Object book: col)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;obj=&quot;</span> + obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重拾 Java 系列 —— 基础</title>
      <link href="/posts/13522.html"/>
      <url>/posts/13522.html</url>
      
        <content type="html"><![CDATA[<h2 id="重拾-Java-系列-——-杂七杂八"><a href="#重拾-Java-系列-——-杂七杂八" class="headerlink" title="重拾 Java 系列 —— 杂七杂八"></a>重拾 Java 系列 —— 杂七杂八</h2><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><ol><li>一个源文件中<strong>最多有一个 public 类</strong>；</li><li>如果一个源文件包含一个 public 类，则<strong>文件名必须按该类命名</strong>；</li><li><code>\r</code> 回车：回到当前行首 <code>\n</code> 换行：另起一行；</li></ol><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><ol><li><p>多行注释不能嵌套；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">comments</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li><li><p>文档注释</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> JasonChio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h4><ol><li>源文件使用 utf-8 编码，大小可变（字母用一个字节，汉字用三个字节）</li></ol><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><ol><li><p>默认浮点类型为<code>float</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> = <span class="number">1.1</span>; <span class="comment">// 错误，1.1 为 double 类型</span></span><br><span class="line"><span class="keyword">float</span> = <span class="number">1.1f</span>; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></li><li><p><strong>浮点数运算注意事项</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> num11 = <span class="number">2.7</span>;</span><br><span class="line"><span class="keyword">double</span> num12 = <span class="number">8.1</span> / <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在比较两个浮点数时，通过其差值的绝对值来判断</span></span><br><span class="line"><span class="keyword">if</span> (Math.abs(num11 - num12 ) &lt; <span class="number">0.000001</span> )&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>char 类型赋值用单引号，双引号的含义是字符串</p></li><li><p>char 的本质是一个整数，输出的是 unicode 对应的字符，可以进行运算</p></li><li><p>String 的默认是为 null</p></li></ol><h4 id="基本数据类型转换"><a href="#基本数据类型转换" class="headerlink" title="基本数据类型转换"></a>基本数据类型转换</h4><ol><li><p>进行复制或者预算时，精度小的类型自动转为精度大的类型</p><p>byte - short - int - long - float - double</p></li><li><p>```<br>int n = 10;<br>float d = n + 1.1 // 报错，1.1 是 double 类型，运算结果也为 double 类型</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. (byte, short) 和 char 之间不会相互自动转换</span><br><span class="line"></span><br><span class="line">4. byte, short, char 三者可以做运算，计算前先转为 int 类型</span><br><span class="line"></span><br><span class="line">#### 强制类型转换</span><br><span class="line"></span><br><span class="line">1. 将容量大的数据类型转为容量小的数据类型，可能会造成精度降低甚至溢出</span><br><span class="line"></span><br><span class="line">2. 强转符号只针对最近的操作数有效</span><br><span class="line"></span><br><span class="line">   ```java</span><br><span class="line">   int x = (int)10 * 3.5 + 6 * 1.5;// 报错</span><br></pre></td></tr></table></figure></li></ol><h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><ol><li>算术右移<code>&gt;&gt;</code>: 低位溢出（丢弃），符号位不变，并用符号位补溢出的高位</li><li>算术左移<code>&lt;&lt;</code>: 符号位不变，低位补 0</li><li><code>&gt;&gt;&gt;</code>逻辑右移也叫无符号右移，运算规则是：低位溢出，高位补 0</li><li>特别说明：没有<code>&lt;&lt;&lt;</code>符号</li></ol><h4 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h4><ol><li>switch 条件表达式的返回值必须是： byte, short, int, char, enum, String</li></ol><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ol><li>数组是引用类型；</li><li>String 类型的数组创建后如果没有赋值，其默认值是 null；</li><li>数组在默认情况下是引用传递，赋的值是地址。数组复制注意要深拷贝。</li></ol><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><ol><li>全局变量有默认值，局部变量没有默认值，必须赋值后使用；</li></ol><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ol><li><a href="https://www.bilibili.com/video/BV1fh411y7R8">零基础30天学会Java</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转载】Go init 顺序</title>
      <link href="/posts/16643.html"/>
      <url>/posts/16643.html</url>
      
        <content type="html"><![CDATA[<h2 id="Go-程序初始化顺序"><a href="#Go-程序初始化顺序" class="headerlink" title="Go 程序初始化顺序"></a>Go 程序初始化顺序</h2><p>Go 程序的初始化和执行总是从<code>main.main</code>函数开始的。但是如果<code>main</code>包里导入了其它的包，则会按照顺序将它们包含进<code>main</code>包里（这里的导入顺序依赖具体实现，一般可能是以文件名或包路径名的字符串顺序导入）。如果某个包被多次导入的话，在执行的时候只会导入一次。当一个包被导入时，如果它还导入了其它的包，则先将其它的包包含进来，然后创建和初始化这个包的常量和变量。然后就是调用包里的<code>init</code>函数，如果一个包有多个<code>init</code>函数的话，实现可能是以文件名的顺序调用，同一个文件内的多个<code>init</code>则是以出现的顺序依次调用（<code>init</code>不是普通函数，可以定义有多个，所以不能被其它函数调用）。最终，在<code>main</code>包的所有包常量、包变量被创建和初始化，并且<code>init</code>函数被执行后，才会进入<code>main.main</code>函数，程序开始正常执行。下图是 Go 程序函数启动顺序的示意图：</p><p><img src="https://images.961110.xyz/images/2022/10/09/go_init_order.png"></p><p>要注意的是，在<code>main.main</code>函数执行之前所有代码都运行在同一个Goroutine中，也是运行在程序的主系统线程中。如果某个<code>init</code>函数内部用go关键字启动了新的Goroutine的话，新的Goroutine和<code>main.main</code>函数是并发执行的。</p><p>因为所有的<code>init</code>函数和<code>main</code>函数都是在主线程完成，它们也是满足顺序一致性模型的。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ol><li><a href="https://chai2010.gitbooks.io/advanced-go-programming-book/content/ch1-basic/ch1-05-mem.html">1.5 面向并发的内存模型 · Go语言高级编程 (gitbooks.io)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 定时任务执行时间大于定时器间隔</title>
      <link href="/posts/36855.html"/>
      <url>/posts/36855.html</url>
      
        <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>当<code>time.NewTicker()</code>定时任务执行的时间比<code>ticker</code>设定的时间间隔长时，会发生什么事情？</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>有如下代码</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ScheduledTask()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SleepTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">    time.Sleep(<span class="number">6</span> * time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;睡醒了&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ScheduledTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ticker := time.NewTicker(time.Second * <span class="number">3</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;ScheduledTask start.&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> _ = <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;三秒到了&quot;</span>)</span><br><span class="line">        SleepTask()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">2022</span>/<span class="number">08</span>/<span class="number">28</span> <span class="number">21</span>:<span class="number">49</span>:<span class="number">33.293</span> [I]  三秒到了 </span><br><span class="line"><span class="number">2022</span>/<span class="number">08</span>/<span class="number">28</span> <span class="number">21</span>:<span class="number">49</span>:<span class="number">39.306</span> [I]  睡醒了 </span><br><span class="line"><span class="number">2022</span>/<span class="number">08</span>/<span class="number">28</span> <span class="number">21</span>:<span class="number">49</span>:<span class="number">39.308</span> [I]  三秒到了 </span><br><span class="line"><span class="number">2022</span>/<span class="number">08</span>/<span class="number">28</span> <span class="number">21</span>:<span class="number">49</span>:<span class="number">45.309</span> [I]  睡醒了 </span><br><span class="line"><span class="number">2022</span>/<span class="number">08</span>/<span class="number">28</span> <span class="number">21</span>:<span class="number">49</span>:<span class="number">45.310</span> [I]  三秒到了 </span><br><span class="line"><span class="number">2022</span>/<span class="number">08</span>/<span class="number">28</span> <span class="number">21</span>:<span class="number">49</span>:<span class="number">51.322</span> [I]  睡醒了 </span><br><span class="line"><span class="number">2022</span>/<span class="number">08</span>/<span class="number">28</span> <span class="number">21</span>:<span class="number">49</span>:<span class="number">51.323</span> [I]  三秒到了</span><br></pre></td></tr></table></figure><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><p>当定时任务执行时间超过定时器设定时间时，定时任务执行结束后会立即执行定时任务。</p>]]></content>
      
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客从 GitHub 迁移到个人服务器</title>
      <link href="/posts/61140.html"/>
      <url>/posts/61140.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>因为之前的服务器到期了，所以换了一台新的服务器，同时之前的写过的博客需要跟着迁移。</p><p>博客框架选择的是 Hexo，主题是 Butterfly，本教程理论上跟框架和主题无关。</p><h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><h3 id="前置条件（已有请跳过）"><a href="#前置条件（已有请跳过）" class="headerlink" title="前置条件（已有请跳过）"></a>前置条件（已有请跳过）</h3><ol><li>在本地已经搭建好了 Hexo 环境，<a href="https://www.nesxc.com/119/">参考链接</a></li><li>服务器有公网 IP</li><li>安装 Git <code>sudo apt install git</code></li></ol><h3 id="服务器创建博客仓库"><a href="#服务器创建博客仓库" class="headerlink" title="服务器创建博客仓库"></a>服务器创建博客仓库</h3><ol><li><p>创建裸库</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /home/jason/Blog</span><br><span class="line"><span class="built_in">cd</span> /home/jason/Blog</span><br><span class="line">git init --bare blog.git</span><br></pre></td></tr></table></figure></li><li><p>创建博客页面存放目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /home/jason/Blog/hexo</span><br></pre></td></tr></table></figure></li><li><p>创建 Git 钩子</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim blog.git/hooks/post-receive</span><br></pre></td></tr></table></figure><p>输入以下内容</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">git --work-tree=/home/jason/Blog/hexo --git-dir=/home/jason/Blog/blog.git checkout -f</span><br></pre></td></tr></table></figure><p>给钩子赋予权限</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod +x /home/jason/Blog/blog.git/hooks/post-receive</span><br></pre></td></tr></table></figure></li><li><p>至此，服务器博客的仓库已经创建完毕了。</p></li></ol><h3 id="本地配置"><a href="#本地配置" class="headerlink" title="本地配置"></a>本地配置</h3><ol><li><p>打开位于Hexo博客根目录下的<code>_config.yml</code>文件，找到<code>deploy</code>并增加部署链接</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line">deploy:</span><br><span class="line">- <span class="built_in">type</span>: git</span><br><span class="line">  repo:</span><br><span class="line">    github: https://github.com/jasonchio-cn/jasonchio-cn.github.io</span><br><span class="line">    AliServer: LabAliServer:/home/jason/Blog/blog.git</span><br><span class="line">  branch: master</span><br><span class="line">  message: 更新博客</span><br><span class="line">- <span class="built_in">type</span>: baidu_url_submitter</span><br></pre></td></tr></table></figure><p><code>AliServer</code>是部署端的名字，LabAliServer 是我在本地<code>.ssh</code>文件夹下<code>config</code>文件中配置的</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Host LabAliServer</span><br><span class="line">  HostName 服务器 IP</span><br><span class="line">  User jason</span><br><span class="line">  IdentityFile C:\Users\JasonChio\.ssh\jason_aliyun.aliyun</span><br></pre></td></tr></table></figure></li><li><p>测试能否推送到服务器博客仓库。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><p><img src="https://images.961110.xyz/images/2022/04/29/blog_repo.png" alt="image-20220429214554004"></p></li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://blog.csdn.net/zss192/article/details/105376347">从github迁移hexo博客到服务器</a></li><li><a href="https://blog.51cto.com/u_15400016/4287649#docker_163">记录本地Hexo博客部署到服务器上</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客美化记录</title>
      <link href="/posts/7990.html"/>
      <url>/posts/7990.html</url>
      
        <content type="html"><![CDATA[<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="Gitcalendar"><a href="#Gitcalendar" class="headerlink" title="Gitcalendar"></a>Gitcalendar</h3><p>参考链接：<a href="https://akilar.top/posts/1f9c68c9/">♪(^∇^*)欢迎回来！Gitcalendar | Akilarの糖果屋</a></p><p>效果图如下：</p><p><img src="https://images.961110.xyz/images/2022/04/28/Gitcalendar6f53266a44281ccf.png" alt="image-20220428222240724"></p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ol><li><p>在博客根目录下执行下面指令。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-filter-gitcalendar --save</span><br></pre></td></tr></table></figure></li><li><p>添加配置信息。在站点配置文件<code>_config.yml</code> 或者主题配置文件如<code>_config.butterfly.yml</code> 中添加</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hexo-filter-gitcalendar</span></span><br><span class="line"><span class="comment"># see https://akilar.top/posts/1f9c68c9/</span></span><br><span class="line"><span class="attr">gitcalendar:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 开关</span></span><br><span class="line">  <span class="attr">priority:</span> <span class="number">5</span> <span class="comment">#过滤器优先权</span></span><br><span class="line">  <span class="attr">enable_page:</span> <span class="string">/</span> <span class="comment"># 应用页面</span></span><br><span class="line">  <span class="comment"># butterfly挂载容器</span></span><br><span class="line">  <span class="attr">layout:</span> <span class="comment"># 挂载容器类型</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">id</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">recent-posts</span></span><br><span class="line">    <span class="attr">index:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">user:</span> <span class="string">jasonchio-cn</span> <span class="comment">#git用户名</span></span><br><span class="line">  <span class="attr">apiurl:</span> <span class="string">https://github-calendar-red.vercel.app</span></span><br><span class="line">  <span class="attr">minheight:</span></span><br><span class="line">    <span class="attr">pc:</span> <span class="string">280px</span> <span class="comment">#桌面端最小高度</span></span><br><span class="line">    <span class="attr">mibile:</span> <span class="string">0px</span> <span class="comment">#移动端最小高度</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">&quot;[&#x27;#e4dfd7&#x27;, &#x27;#f9f4dc&#x27;, &#x27;#f7e8aa&#x27;, &#x27;#f7e8aa&#x27;, &#x27;#f8df72&#x27;, &#x27;#fcd217&#x27;, &#x27;#fcc515&#x27;, &#x27;#f28e16&#x27;, &#x27;#fb8b05&#x27;, &#x27;#d85916&#x27;, &#x27;#f43e06&#x27;]&quot;</span> <span class="comment">#橘黄色调</span></span><br><span class="line">  <span class="comment"># color: &quot;[&#x27;#ebedf0&#x27;, &#x27;#fdcdec&#x27;, &#x27;#fc9bd9&#x27;, &#x27;#fa6ac5&#x27;, &#x27;#f838b2&#x27;, &#x27;#f5089f&#x27;, &#x27;#c4067e&#x27;, &#x27;#92055e&#x27;, &#x27;#540336&#x27;, &#x27;#48022f&#x27;, &#x27;#30021f&#x27;]&quot; #浅紫色调</span></span><br><span class="line">  <span class="comment"># color: &quot;[&#x27;#ebedf0&#x27;, &#x27;#f0fff4&#x27;, &#x27;#dcffe4&#x27;, &#x27;#bef5cb&#x27;, &#x27;#85e89d&#x27;, &#x27;#34d058&#x27;, &#x27;#28a745&#x27;, &#x27;#22863a&#x27;, &#x27;#176f2c&#x27;, &#x27;#165c26&#x27;, &#x27;#144620&#x27;]&quot; #翠绿色调</span></span><br><span class="line">  <span class="comment"># color: &quot;[&#x27;#ebedf0&#x27;, &#x27;#f1f8ff&#x27;, &#x27;#dbedff&#x27;, &#x27;#c8e1ff&#x27;, &#x27;#79b8ff&#x27;, &#x27;#2188ff&#x27;, &#x27;#0366d6&#x27;, &#x27;#005cc5&#x27;, &#x27;#044289&#x27;, &#x27;#032f62&#x27;, &#x27;#05264c&#x27;]&quot; #天青色调</span></span><br><span class="line">  <span class="attr">container:</span> <span class="string">.recent-post-item(style=&#x27;width:100%;height:auto;padding:10px;&#x27;)</span> <span class="comment">#父元素容器，需要使用pug语法</span></span><br><span class="line">  <span class="attr">gitcalendar_css:</span> <span class="string">https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css</span></span><br><span class="line">  <span class="attr">gitcalendar_js:</span> <span class="string">https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js</span></span><br></pre></td></tr></table></figure></li><li><p>其中 API 推荐自建，教程：<a href="https://akilar.top/posts/1f9c68c9/#%E8%87%AA%E5%BB%BAAPI%E9%83%A8%E7%BD%B2">Gitcalendar | Akilarの糖果屋</a></p></li></ol><h3 id="Sidebar-Card-Clock"><a href="#Sidebar-Card-Clock" class="headerlink" title="Sidebar Card Clock"></a>Sidebar Card Clock</h3><p>参考链接：<a href="https://akilar.top/posts/4e39cf4a/">Sidebar Card Clock | Akilarの糖果屋</a></p><p>效果如下：</p><p><img src="https://images.961110.xyz/images/2022/04/28/Sidebar-Card-Clock.png" alt="image-20220428235053657"></p><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><ol><li><p>在博客根目录下执行下面指令。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-butterfly-clock --save</span><br></pre></td></tr></table></figure></li><li><p>添加配置信息。在站点配置文件<code>_config.yml</code> 或者主题配置文件如<code>_config.butterfly.yml</code> 中添加</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># electric_clock</span></span><br><span class="line"><span class="comment"># see https://akilar.top/posts/4e39cf4a/</span></span><br><span class="line"><span class="attr">electric_clock:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 开关</span></span><br><span class="line">  <span class="attr">priority:</span> <span class="number">5</span> <span class="comment">#过滤器优先权</span></span><br><span class="line">  <span class="attr">enable_page:</span> <span class="string">all</span> <span class="comment"># 应用页面</span></span><br><span class="line">  <span class="attr">exclude:</span></span><br><span class="line">    <span class="comment"># - /posts/</span></span><br><span class="line">    <span class="comment"># - /about/</span></span><br><span class="line">  <span class="attr">layout:</span> <span class="comment"># 挂载容器类型</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">class</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">sticky_layout</span></span><br><span class="line">    <span class="attr">index:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">loading:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-clock/lib/loading.gif</span> <span class="comment">#加载动画自定义</span></span><br><span class="line">  <span class="attr">clock_css:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-clock/lib/clock.min.css</span></span><br><span class="line">  <span class="attr">clock_js:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-clock/lib/clock.min.js</span></span><br><span class="line">  <span class="attr">ip_api:</span> <span class="string">https://pv.sohu.com/cityjson?ie=utf-8</span></span><br></pre></td></tr></table></figure></li><li><p>仅限于国内 IP，挂着代理加载不出来。</p></li></ol><h3 id="Swiper-Bar"><a href="#Swiper-Bar" class="headerlink" title="Swiper Bar"></a>Swiper Bar</h3><p>参考链接：<a href="https://akilar.top/posts/8e1264d1/">♪(^∇^*)欢迎回来！Swiper Bar | Akilarの糖果屋</a></p><p>效果图如下：</p><p><img src="https://images.961110.xyz/images/2022/04/29/Swiper-Bar.png" alt="image-20220429172341824"></p><h4 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h4><ol><li><p>在博客根目录下执行下面指令。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-butterfly-swiper --save</span><br></pre></td></tr></table></figure></li><li><p>添加配置信息。在站点配置文件<code>_config.yml</code> 或者主题配置文件如<code>_config.butterfly.yml</code> 中添加</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hexo-butterfly-swiper</span></span><br><span class="line"><span class="comment"># see https://akilar.top/posts/8e1264d1/</span></span><br><span class="line"><span class="attr">swiper:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 开关</span></span><br><span class="line">  <span class="attr">priority:</span> <span class="number">5</span> <span class="comment">#过滤器优先权</span></span><br><span class="line">  <span class="attr">enable_page:</span> <span class="string">all</span> <span class="comment"># 应用页面 （根目录就填’/‘, 分类页面就填’/categories/‘。若要应用于所有页面，就填’all’，默认为 all）</span></span><br><span class="line">  <span class="attr">timemode:</span> <span class="string">date</span> <span class="comment">#date/updated</span></span><br><span class="line">  <span class="attr">layout:</span> <span class="comment"># 挂载容器类型</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">id</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">recent-posts</span></span><br><span class="line">    <span class="attr">index:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">default_descr:</span> <span class="string">再怎么看我也不知道怎么描述它的啦！</span></span><br><span class="line">  <span class="attr">swiper_css:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css</span> <span class="comment">#swiper css依赖</span></span><br><span class="line">  <span class="attr">swiper_js:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js</span> <span class="comment">#swiper js依赖</span></span><br><span class="line">  <span class="attr">custom_css:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css</span> <span class="comment"># 适配主题样式补丁</span></span><br><span class="line">  <span class="attr">custom_js:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js</span> <span class="comment"># swiper初始化方法</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="友链朋友圈"><a href="#友链朋友圈" class="headerlink" title="友链朋友圈"></a>友链朋友圈</h3><p>参考链接：<a href="https://fcircle-doc.js.cool/#/">友链朋友圈</a></p><p>效果图如下（原博文示意图）：</p><p><img src="https://images.961110.xyz/images/2022/04/28/Swiper-Bar.png"></p><h4 id="安装-3"><a href="#安装-3" class="headerlink" title="安装"></a>安装</h4><ol><li><p>api 搭建方法参考：<a href="https://fcircle-doc.js.cool/#/backenddeploy">后端部署及基本配置</a></p></li><li><p>后端部署完之后，需要在前端部署，参考：<a href="https://fcircle-doc.js.cool/#/frontenddeploy">前端部署 (js.cool)</a></p></li><li><p>注意事项：如果能保证后端部署没有问题，而前端展示不出来的时候，F12看一下请求能否正确获取数据</p><p><img src="https://images.961110.xyz/images/2022/05/21/firends-circle.png" alt="image-20220521130642099"></p><p>如果把<code>end</code>改成 10，就会返回正确的数据。bug 已经提了 issue，等待作者回复。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 18.04 安装新版 nodejs</title>
      <link href="/posts/42019.html"/>
      <url>/posts/42019.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Ubuntu 18.04 上 apt 能安装的 nodejs 版本是 10.19.0，而官方早就更新到了 18.x，所以会有一些新的 module 不兼容。</p><table>    <tr>        <td>            <center><img src="https://images.961110.xyz/images/2022/04/25/apt_nodejs_version.png">                </center>        </td>        <td>            <center><img src="https://images.961110.xyz/images/2022/04/25/nodejs_offical_version.png" style="zoom:75%;">                 </center>        </td>    </tr></table><h2 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>根据官方 docs 的方法，需要增加 nodejs 的 repo 源</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://deb.nodesource.com/setup_lts.x | sudo -E bash -</span><br><span class="line">sudo apt install nodejs</span><br></pre></td></tr></table></figure><img src="https://images.961110.xyz/images/2022/04/25/install_nodejs_repo.png" style="zoom:50%;" /><p>安装完成后查看版本号</p><p><img src="https://images.961110.xyz/images/2022/04/25/current_nodejs_versione24699e3fcebb9b6.png" alt="image-20220425215020563"></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ol><li><p>建立 npm 包安装及缓存文件夹（如果建在/usr/local 目录下，后面运行安装的包会有权限问题）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/.npm/node_global</span><br><span class="line">mkdir -p ~/.npm/node_cache</span><br></pre></td></tr></table></figure></li><li><p>配置 npm</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm config set prefix &quot;/home/jason/.npm/node_global&quot;</span><br><span class="line">npm config set cache &quot;/home/jason/.npm/node_cache&quot;</span><br></pre></td></tr></table></figure></li><li><p>因为 npm 在国内比较慢，所以可以安装 cnpm，之后安装其他包可以使用 <code>cnpm install -g</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install cnpm -g --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>安装完成后建立 cnpm 的软链接</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ln -s /home/jason/.npm/node_global/lib/node_modules/cnpm/bin/* /usr/bin/</span><br></pre></td></tr></table></figure></li><li><p>配置环境变量</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim ~/.bashrc</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 增加 nodejs 的环境变量</span></span><br><span class="line">export NODE_PATH=/home/jason/.npm/node_global/bin</span><br><span class="line">export PATH=$PATH:$NODE_PATH</span><br><span class="line"></span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure></li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://github.com/nodesource/distributions/blob/master/README.md">distributions/README.md at master · nodesource/distributions (github.com)</a></li><li><a href="https://blog.csdn.net/ggq89/article/details/107469808">Linux下Node.js的安装和配置_AlbertGou的博客-CSDN博客</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>群晖 Raid1 转 Basic</title>
      <link href="/posts/53233.html"/>
      <url>/posts/53233.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>博主没有公网 IP，所以两个常用 PT 站的分享率都不算很高。提高分享率只能靠赚魔力值，需要挂一些大文件的种子，因此对硬盘空间要求较大。群晖里两块 4T 的硬盘以 Raid1 的方式保障数据安全，也因此损失了接近 4T 的空间，于是就有了将其转为 Basic 的想法。</p><h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><h3 id="友情提示"><a href="#友情提示" class="headerlink" title="友情提示"></a>友情提示</h3><p>理论上无损，但是没有人能保证 100% 成功，<strong>备份好重要文件再进行下面的操作</strong>。</p><h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><ol><li><p>群晖中插了两块硬盘，关机并拔出硬盘 2</p></li><li><p>开机，存储池会显示为<strong>堪用</strong>，不用慌，接着往下看。如果有报警可以在【控制面板】【硬件和电源】中【停止哔声】。</p><p><img src="https://images.961110.xyz/images/2022/04/25/stop_hdd.png" alt="image-20220425193501824"></p></li><li><p>SSH 连接到群晖，输入如下命令查看硬盘的分区信息</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /proc/mdstat</span><br></pre></td></tr></table></figure><p>由于在操作时没有做记录，此处引用的是参考博文中的图。</p><p><img src="https://images.961110.xyz/images/2022/04/25/partition_info.jpg"></p><p>第1个分区 md0 为群晖系统分区，第2个分区 md1 为群晖交换分区，第3个分区 md2 为群晖存储分区（不知道为什么，博主的第三个分区是 md3）</p></li><li><p>输入如下命令，将存储分区转为 Basic。可能需要的时间较长，耐心等待.</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mdadm --grow --raid-devices=1 --force /dev/md2</span><br></pre></td></tr></table></figure></li><li><p>刷新网页，存储池已经变成了良好，类型是 Basic，原来的文件也没有丢失。</p><p><img src="https://images.961110.xyz/images/2022/04/25/Basic_4T.png" alt="image-20220425194822028"></p></li><li><p>将拔出的硬盘再插上，新建存储池就可以正常使用了。</p></li></ol><h3 id="数据安全保障"><a href="#数据安全保障" class="headerlink" title="数据安全保障"></a>数据安全保障</h3><p>博主分别用 Synology Drive 和 Moment 备份电脑和手机的重要资料，所有的资料都会在群晖的 home 目录下。Raid1 转为 Basic 之后，用 Cloud Sync 将 home 目录下的备份文件实时同步到了 OneDrive 中，相当于是又上了一道保险。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://wp.gxnas.com/11613.html">简单两条命令让群晖存储空间类型为RAID1或者SHR无损转换成Basic - GXNAS博客</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 群晖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修改、合并、丢弃已push的commit message</title>
      <link href="/posts/26938.html"/>
      <url>/posts/26938.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>对于某些重复性的提交（例如更新Readme），为了保持 commit message 的整洁，博主想把这些相同的内容合并成一份。</p><h2 id="commit-未-push"><a href="#commit-未-push" class="headerlink" title="commit 未 push"></a>commit 未 push</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --soft HEAD~1</span><br></pre></td></tr></table></figure><p>HEAD^ 的意思是上一个版本，也可以写成HEAD<del>1。如果进行了2次commit，想都修改，可以使用HEAD</del>2（也可以直接使用 commitID）</p><ul><li><code>--mixed</code> 意思是：不删除工作空间改动代码，撤销 commit，并且撤销 git add 操作。</li><li><code>--soft</code> 意思是：不删除工作空间改动代码，撤销commit，不撤销 git add 操作。</li><li><code>--hard</code> 意思是：<strong>删除工作空间改动代码</strong>，撤销commit，并且撤销 git add 操作。</li></ul><h2 id="commit-已-push"><a href="#commit-已-push" class="headerlink" title="commit 已 push"></a>commit 已 push</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase -i commitID</span><br></pre></td></tr></table></figure><p><code>git log</code>有如下 commit（按照提交时间顺序排列）</p><img src="https://images.961110.xyz/images/2022/05/04/git_log.png" style="zoom:50%;" /><p>假设想要修改中间那条 commit(b20527091aa9cf6ea7116dd992a376a4b0ac647b)，可以输入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rebase -i 22f9aad873d155af6e354c8d92492a12015fcc11</span><br></pre></td></tr></table></figure><p><code>22f9aad873d155af6e354c8d92492a12015fcc11</code>是想要修改的 commit 的前一个 commitID，执行该条命令会出现如下内容（按照提交时间倒序排列）。</p><img src="https://images.961110.xyz/images/2022/05/04/git_rebase55992eadca1d1afb.png" style="zoom:50%;" /><p>各个命令的含义如下：</p><ol><li><p><code>p, pick</code> </p><p>保留 commit（默认）</p></li><li><p><code>r, reword</code></p><p>使用 commit，但修改 commit message。<code>:x</code>保存并退出后，执行 <code>git rebase continue</code>会再次打开一个文件，以对 commit message 进行修改。修改完保存之后继续进行 rebase。</p></li><li><p><code>e, edit</code></p><p>使用 commit，但修改提交</p></li><li><p><code>s, squash</code></p><p>使用该 commit，但和前一个 commit 合并，如果要合并多个 commit，需要将对应 commit 前的命令都改成 <code>squash</code>，合并的 commit 对应的 message 也会合并到一起。<code>:x</code>保存并退出后，执行 <code>git rebase continue</code>会再次打开一个文件，可以对合并后的 commit message 进行修改。</p></li><li><p><code>f, fixup</code></p><p>类似于 “squash”，但丢弃 commit message，即不合并 commit message。</p></li><li><p><code>x, exec</code></p><p>执行 shell 命令，这个没用过。</p></li><li><p><code>d, drop</code></p><p>丢弃该 commit，或者用删除这一行代替 <code>drop</code>。</p></li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://blog.csdn.net/realDonaldTrump/article/details/85050779">git丢弃、删除已经提交的commit</a></li><li><a href="https://www.jianshu.com/p/3f8664bb0a19">如何撤销未push的commit</a></li><li><a href="https://swumao.github.io/swumao/update/git/rebase/pick/edit/reword/drop/squash/fixup/2016/08/31/Git-rebase-%E5%90%88%E5%B9%B6%E5%A4%9A%E4%B8%AAcommit.html">git rebase 用来合并多个commit 使用介绍</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OSS-Fuzz介绍</title>
      <link href="/posts/51425.html"/>
      <url>/posts/51425.html</url>
      
        <content type="html"><![CDATA[<h2 id="软件漏洞挖掘技术"><a href="#软件漏洞挖掘技术" class="headerlink" title="软件漏洞挖掘技术"></a>软件漏洞挖掘技术</h2><p>进行软件漏洞挖掘时，通常有静态分析(static analysis)、动态分析(dynamic analysis)、符号执行(symbolic execution)、模糊测试(fuzzing)这几种技术手段。</p><h3 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h3><p>静态分析就是不真正的运行目标程序，但是通过对其进行各种语法、语义、数据流等的分析，来进行漏洞发掘。静态分析是由静态分析软件完成的，速度快，但是误报率高。</p><h3 id="动态分析"><a href="#动态分析" class="headerlink" title="动态分析"></a>动态分析</h3><p>动态分析就是一步步跟踪程序运行进行的分析。准确率很高，但是需要调试人员丰富的知识储备，而且很难进行大规模的程序漏洞挖掘。</p><h3 id="符号执行"><a href="#符号执行" class="headerlink" title="符号执行"></a>符号执行</h3><p>符号执行简单来说，就是试图找到什么输入对应什么样的运行状态，去覆盖所有的执行路径。因此，当被分析的程序比较复杂，有很多执行路径时，就会遇到路径爆炸的问题。</p><h3 id="模糊测试"><a href="#模糊测试" class="headerlink" title="模糊测试"></a>模糊测试</h3><p>模糊测试不需要人过多的参与，也不像动态分析那样要求分析人员有丰富的知识。简单来讲就是用大量的输入数据自动去执行程序，从而发现哪些输入能够使程序发生异常，进而分析可能存在的漏洞。当前比较成功的 fuzzer (执行模糊测试的程序）有 AFL、libFuzzer、OSS-Fuzz 等。</p><h2 id="OSS-Fuzz-介绍"><a href="#OSS-Fuzz-介绍" class="headerlink" title="OSS-Fuzz 介绍"></a>OSS-Fuzz 介绍</h2><p>OSS-Fuzz 能够针对开源软件进行持续的模糊测试，利用现代模糊测试技术与可拓展的分布式执行相结合，提高通用开源软件的安全性与稳定性。OSS-Fuzz 结合了多种模糊测试技术/漏洞捕捉技术（libfuzzer）与清洗技术（AddressSanitizer），并且通过 ClusterFuzz 为大规模可分布式执行提供了测试环境。闭源项目可以运行私有的 ClusterFuzz 或 ClusterFuzzLite 实例进行模糊测试。</p><p>目前，OSS Fuzz支持 C/C++、Rust、Go、Python和 Java/JVM 以及其他 LLVM 支持的语言，支持对 x86_64 和 i386 平台的程序进行模糊化。</p><img src="https://github.com/google/oss-fuzz/raw/master/docs/images/process.png" style="zoom:50%;" /><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://github.com/google/oss-fuzz">OSS-Fuzz - continuous fuzzing for open source software</a></li><li><a href="https://www.jianshu.com/p/6fcdf0f9b370">从AFL开始FUZZ之旅</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转载】Markdown嵌入B站视频</title>
      <link href="/posts/64427.html"/>
      <url>/posts/64427.html</url>
      
        <content type="html"><![CDATA[<h2 id="嵌入代码"><a href="#嵌入代码" class="headerlink" title="嵌入代码"></a>嵌入代码</h2><p>首先在B站视频详情页找到分享界面，点击下图中“嵌入代码”，会将iframe复制到剪切板</p><p><img src="https://images.961110.xyz/images/2022/03/29/B.png"></p><p>在 Markdown 文档中插入如下代码，将代码中<code>video_url</code>替换为对应视频的<code>src</code>，结尾加一个<code>&amp;high_quality=1</code>可以将默认画质设置为最高</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div style=&quot;position: relative; width: 100%; height: 0; padding-bottom: 75%;&quot;&gt;</span><br><span class="line">&lt;iframe src=&quot;video_url&amp;page=1&amp;high_quality=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; style=&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot;&gt; &lt;/iframe&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>插入的效果如下图</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=97136120&bvid=BV1F7411o7Q6&cid=165826337&page=1&page=1&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://www.tamsiree.com/TechnicalResearch/Hexo/Hexo%E6%8F%92%E5%85%A5Bilibili%E8%A7%86%E9%A2%91%E8%87%AA%E9%80%82%E5%BA%94/">Hexo插入Bilibili视频自适应 | Tamsiree</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转载】装机注意事项</title>
      <link href="/posts/16750.html"/>
      <url>/posts/16750.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>【转载】以下内容均来源于B站UP主乌尔巴工作室，详细内容请直接观看视频。</p></blockquote><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=296985388&bvid=BV1bF411b7Uc&cid=700524206&page=1&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><ol><li>检查CPU和主板型号是否匹配及合理</li><li>检查CPU是否自带核显</li></ol><h2 id="散热器"><a href="#散热器" class="headerlink" title="散热器"></a>散热器</h2><ol><li>检查散热器是否对应CPU平台型号</li><li>检查散热器是否能够压住CPU发热量</li><li>检查散热器是否附带导热硅脂</li><li>检查散热器是否匹配机箱尺寸</li><li>检查主板是否有足够的风扇供电接口及灯光接口</li></ol><h2 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h2><ol><li>检查主板能否和机箱尺寸匹配</li></ol><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><ol><li>检查主板支持的内存数量以及型号</li><li>检查CPU主板支持的内存频率</li></ol><h2 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h2><ol><li>检查主板是否有足够的硬盘插槽和接口</li><li>检查主板支持的硬盘协议</li><li>检查硬盘数据线数量</li><li>检查机箱硬盘位与硬盘数量是否匹配</li></ol><h2 id="显卡"><a href="#显卡" class="headerlink" title="显卡"></a>显卡</h2><ol><li>检查机箱支持的显卡尺寸</li><li>检查显示器接口与显卡接口是否相匹配</li></ol><h2 id="电源"><a href="#电源" class="headerlink" title="电源"></a>电源</h2><ol><li>检查机箱支持的电源尺寸</li><li>检查电源功率是否满足整机功率</li><li>检查电源供电接口是否满足硬件条件</li></ol><h2 id="机箱风扇"><a href="#机箱风扇" class="headerlink" title="机箱风扇"></a>机箱风扇</h2><ol><li>检查机箱风扇位能否满足风扇尺寸及数量</li><li>检查主板接口是否满足风扇供电及灯效控制</li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 装机 </tag>
            
            <tag> 桌搭 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转载】树莓派4B 的系统备份方法大全（全卡+压缩备份）</title>
      <link href="/posts/28657.html"/>
      <url>/posts/28657.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>【转载】原文地址 <a href="https://post.smzdm.com/p/apzkgne7/#cl_0">树莓派学习笔记 篇四：树莓派 4B 的系统备份方法大全（全卡 + 压缩备份）</a></p></blockquote><h1 id="树莓派-4B-的系统备份方法大全（全卡-压缩备份）"><a href="#树莓派-4B-的系统备份方法大全（全卡-压缩备份）" class="headerlink" title="树莓派 4B 的系统备份方法大全（全卡 + 压缩备份）"></a>树莓派 4B 的系统备份方法大全（全卡 + 压缩备份）</h1><p>2019-12-09 10:23:52 29 点赞 192 收藏 12 评论</p><p>在 Windows 上用 VMware 安装 Linux 虚拟机有个「快照」的功能，就是把你当前的系统做个备份，一旦后来误操作把系统搞挂了之后可以恢复到备份的那个时间节点。Linux 系统开放的权限比较高，以 root 权限操作的话很有可能就会误删一些系统文件导致系统崩溃。我就曾把树莓派的系统搞挂过好几次，每次只能重新刷入镜像，开机后还得重复一大堆操作，所以备份树莓派的系统就很重要了。还可以把已经部署好的树莓派系统，批量复制到更多的树莓派上。  </p><p><a href="https://post.smzdm.com/p/apzkgne7/pic_2/"><img src="https://images.961110.xyz/images/2022/01/25/5ded02bcbf8901506.jpg_e1080.jpg"></a></p><p>系统备份分为<strong>「全卡备份」</strong>和<strong>「压缩备份」</strong>两种。「全卡备份」就是将 SD 卡整体备份，操作简单，SD 卡是多大空间的备份的镜像就有多大，系统还原时需要更大的 SD 卡才行。「压缩备份」只备份 SD 卡中有内容的分区，备份出来的镜像大小基本和原来的镜像文件差不多，方法有点复杂，备份的镜像体积大大减小。原始的树莓派官方镜像第一次启动后会自动扩展整个 SD 卡空间，恢复备份镜像后首次开机需要 sudo raspi-config 扩展 SD 卡使用空间。  </p><blockquote><p>本文需要用到 Linux 系统的挂载和分区的一些知识，相关内容可以查看该系列的第三篇。</p></blockquote><p><a href="https://post.smzdm.com/p/a25rzkxn"><img src="https://images.961110.xyz/images/2022/01/25/5dda52fd02d8348.jpg_a200.jpg"></a><a href="https://post.smzdm.com/p/a25rzkxn">树莓派学习笔记 篇三：树莓派 4B 与移动存储设备的那些事儿</a>本文是「树莓派学习笔记」系列的第三篇，将学习下 Linux 系统分区的基础知识，在树莓派上如何挂载与卸载外接的移动存储设备，不同分区格式的硬盘速度测试以及如何在一张 TF 卡上实现多系统启动。1.SD 卡与 TF 卡内存卡是生活中很常见的一种存储设备，之前常常分不清楚 SD 卡和 TF 卡的区别，SD 卡是 SecureDi<a href="https://zhiyou.smzdm.com/member/1000390420/">BigBubbleGum</a>| _赞_40 _评论_14 _收藏_284 <a href="https://post.smzdm.com/p/a25rzkxn">查看详情</a></p><h2 id="一、全卡备份"><a href="#一、全卡备份" class="headerlink" title="一、全卡备份"></a>一、全卡备份</h2><h3 id="1-Win32DiskImager"><a href="#1-Win32DiskImager" class="headerlink" title="1. Win32DiskImager"></a>1. Win32DiskImager</h3><p>全卡备份是最简单的一种，首先在硬盘上创建一 img 后缀的空文件，打开 Win32DiskImager，选择刚刚创建的空 img 文件和 SD 卡盘符，点击 read 既可。</p><p><a href="https://post.smzdm.com/p/apzkgne7/pic_3/"><img src="https://images.961110.xyz/images/2022/01/25/5ded02bcc031f2090.jpg_e1080.jpg"></a></p><p>等待几分钟后就得到了备份的 img 文件，用 Win32DiskImager 来制作镜像时因为无法读取到 Linux 分区，所以是全卡备份，该方法的缺点是备份文件会和 SD 卡的容量一致，而且在还原的时候必须使用比镜像更大容量的 SD 卡。  </p><p><a href="https://post.smzdm.com/p/apzkgne7/pic_4/"><img src="https://images.961110.xyz/images/2022/01/25/5ded02bcbea997501.jpg_e1080.jpg"></a></p><p>可以看到 Raspbian 原系统只有 3.5G，备份文件是 7.4G（8G 的 SD 卡）。  </p><h3 id="2-树莓派上直接复制系统"><a href="#2-树莓派上直接复制系统" class="headerlink" title="2. 树莓派上直接复制系统"></a>2. 树莓派上直接复制系统</h3><p>准备一张空白 SD 卡，格式化 SD 卡插入<a href="https://www.smzdm.com/fenlei/dukaqi/">读卡器</a>，然后插入树莓派上，使用 umount 卸载该挂载，使用命令 dd bs=4M if=/dev/mmcblk0 of=/dev/sda 就可以把树莓派系统内容全部拷贝到 SD 卡上，mmcblk0 就是树莓派上系统 TF 卡，sda 就是插入的 SD 卡（使用 lsblk 查看），等待完成后既可以关机插入新卡重启。</p><p><a href="https://post.smzdm.com/p/apzkgne7/pic_5/"><img src="https://images.961110.xyz/images/2022/01/25/5ded02bcbc42e4870.jpg_e1080.jpg"></a></p><p>除了将原系统拷贝到 SD 卡外，也可以拷贝到 U 盘之类的移动<a href="https://www.smzdm.com/fenlei/cunchushebei/">存储设备</a>，树莓派 3B+ 支持直接从 USB 启动系统，树莓派 4B 暂时还不支持。  </p><p>通过 sudo blkid 获取已烧录好系统的 U 盘或者<a href="https://www.smzdm.com/fenlei/yidongyingpan/">移动硬盘</a>的 PARTUUID。</p><p><a href="https://post.smzdm.com/p/apzkgne7/pic_6/"><img src="https://images.961110.xyz/images/2022/01/25/5ded02bcbcce07160.jpg_e1080.jpg"></a></p><p>将系统 TF 卡中 / boot/cmdline.txt 中 rootpartuuid 修改为上述 uuid 重启，即可从 USB 设备启动系统。  </p><p><a href="https://post.smzdm.com/p/apzkgne7/pic_7/"><img src="https://images.961110.xyz/images/2022/01/25/5ded02bd4671f891.jpg_e1080.jpg"></a></p><p>该方法本质上是将原系统镜像写入另外一张 SD 卡，适合将你的系统复制给小伙伴用，不适合用作备份。  </p><p><a href="https://post.smzdm.com/p/apzkgne7/pic_8/"><img src="https://images.961110.xyz/images/2022/01/25/5ded02bd7548a5458.jpg_e1080.jpg"></a></p><p>树莓派的桌面系统自带 SD Card copier，无需输入命令，也可完成复制过程。  </p><h3 id="3-dd-命令"><a href="#3-dd-命令" class="headerlink" title="3. dd 命令"></a>3. dd 命令</h3><p>在树莓派上 mount 一个共享目录（空间大于系统的 TF 卡），然后直接用 dd 就可以备份树莓派 dd if=/dev/mmcblk0 of=raspberrypi.img bs=1M 共享目录在电脑上的话建议用网线连接，无线网会很慢。</p><p>或者在 Ubuntu 虚拟机中操作（会自动挂载 SD 卡，未自动挂载 SD 卡则需要先手动挂载）。下图中的 /dev/sdb1 /dev/sdb2 就是树莓派的 SD 卡，其中 256M 的分区 sdb1 是 boot 分区，7.1G 的分区 sdb2 是树莓派的系统文件分区。</p><p><a href="https://post.smzdm.com/p/apzkgne7/pic_9/"><img src="https://images.961110.xyz/images/2022/01/25/5ded02bd7e83f7141.jpg_e1080.jpg"></a></p><p>使用 dd 命令可以直接备份 SD 卡。这里树莓派的 SD 卡的路径是 /dev/sdb1 和 /dev/sdb2 ，所以备份整个 SD 卡的路径就是 /dev/sdb。  </p><p>输入备份命令：sudo dd if=/dev/sdb | gzip&gt;/home/hanson/Documents/rpi-back2.gz，其中备份文件要保存的位置、文件名和 SD 卡的路径要根据实际选择。备份的时候终端没有进度条，像卡死一样，等着就行。可以另开一个终端，运行如下命令，可以观察到目标文件大小的变化。</p><p>watch -d -n 5 ls -lh /home/hanson/Documents/rpi-back2.gz</p><p><a href="https://post.smzdm.com/p/apzkgne7/pic_10/"><img src="https://images.961110.xyz/images/2022/01/25/5ded02bd8cce9245.jpg_e1080.jpg"></a></p><p>这个命令可以在备份的同时打包文件，压缩完成后的 .gz 文件只有 1.9G，解压后是 7.5G，本质上也是全卡复制。  </p><p>还原的时候在 Windows 下解压文件需要加上. img 后缀。Linux 下的还原方法 sudo gzip -dc /home/hanson/Documents/rpi-back2.gz | sudo dd of=/dev/sda</p><h2 id="二、压缩备份"><a href="#二、压缩备份" class="headerlink" title="二、压缩备份"></a>二、压缩备份</h2><h3 id="1-原理"><a href="#1-原理" class="headerlink" title="1. 原理"></a>1. 原理</h3><p>树莓派的官方系统是基于 Debian 的，主要是两个分区：启动分区（boot）、根分区（root），烧录系统的时候就是将这两个分区写入 SD 卡。首次开机后需使用 raspi-config 来扩展 root 分区的大小，boot 分区不变，来达到使用所有 SD 卡内容量的目的（最新的系统已经不需要扩展操作）。</p><blockquote><p>boot 分区：fat32 格式，挂载点 / boot，存放一些系统启动需要的基本文件，包括内核、驱动、firmware、启动脚本等，可以在 Windows 上打开读取。</p><p>root 分区：ext4 格式，挂载点 /，存放一些安装的软件和库文件、系统配置、用户数据等。 另外当系统启动时会自动生成和挂载一些必要的其他<a href="https://www.smzdm.com/fenlei/wenjianjia/">文件夹</a>，包括 temfs、sysfs、proc、debugfs、configfs 等虚拟文件系统，由操作系统自动管理，备份时不需要关注。root 分区在 Windows 上无法识别，所以每次将 SD 卡插到 Windows 电脑上会弹出来格式化的选项，千万不要点。</p></blockquote><p><strong>对于树莓派系统的备份，主要就是对 boot 和 root 分区的备份。</strong>而 root 分区里面只有一部分空间存储有内容，剩下的部分是空的，如果直接备份的话那就是整个 SD 卡空间备份，也就是上面所说的全卡备份。而压缩备份则是备份 boot 分区和 root 分区中有内容的空间。  </p><p><a href="https://post.smzdm.com/p/apzkgne7/pic_11/"><img src="https://images.961110.xyz/images/2022/01/25/5ded02bdb43917481.jpg_e1080.jpg"></a></p><h3 id="2-PiShrink-裁剪"><a href="#2-PiShrink-裁剪" class="headerlink" title="2. PiShrink 裁剪"></a>2. PiShrink 裁剪</h3><p>PiShrink 是 Github 上开源的树莓派压缩工具，通过裁剪上面用 Win32DiskImager 或者 dd 命令全卡备份的镜像，去掉没有内容的分区，从而减小备份镜像的大小。</p><p><a href="https://post.smzdm.com/p/apzkgne7/pic_12/"><img src="https://images.961110.xyz/images/2022/01/25/5ded02bdc2b9d2092.jpg_e1080.jpg"></a></p><p>先将全卡备份的镜像文件复制到 Linux 中，打开终端执行 wget <a href="https://raw.githubusercontent.com/Drewsif/PiShrink/master/pishrink.sh">https://raw.githubusercontent.com/Drewsif/PiShrink/master/pishrink.sh</a> 下载 sh 脚本文件，默认存到 / home/user 目录下，将其拷贝到镜像所在文件夹下。执行 chmod +x pishrink.sh 增加执行权限，然后执行 sudo bash pishrink.sh rpi-back.img 即可。  </p><p><a href="https://post.smzdm.com/p/apzkgne7/pic_13/"><img src="https://images.961110.xyz/images/2022/01/25/5ded02bdd80dd1093.jpg_e1080.jpg"></a></p><p>原来 7.5GB 的备份文件就被缩减到 3.4GB。  </p><p>如果你的 linux 系统是语言是中文，可能会报错，需要制定英文运行 sudo pishrink.sh raspberrypi.img</p><p>sh 脚本文件裁剪的方法比较简单，比如果你想要在 Linux 单纯使用命令行方式裁剪全卡备份文件，可以参考<a href="https://blog.csdn.net/talkxin/article/details/50464313">使用 linux 裁剪树莓派完整 sd 卡镜像</a></p><h3 id="3-gparted"><a href="#3-gparted" class="headerlink" title="3. gparted"></a>3. gparted</h3><p>根据上述压缩备份原理，先在 Linux 环境中将 root 分区拆分内容空间和空白空间，然后在 Windows 上用 Win32DiskImager 软件仅读取内容空间进行备份。以下以 Windows 10 64 位 + 虚拟机 Ubuntu 19.10 为例，对树莓派 4B 的 Raspbian 系统进行压缩备份。</p><p>(1). 打开虚拟机，在终端输入 sudo apt install gparted 安装 gparted</p><p>(2). 将需要备份的 SD 卡插入读卡器然后插入电脑，等待 Linux 读取成功。</p><p>(3). 输入 sudo gparted 启动 gparted，在右上角选择 SD 卡，可以看到 ext4 分区当中置使用了 3.78G，剩余 10.88G 都是空白的。</p><p><a href="https://post.smzdm.com/p/apzkgne7/pic_14/"><img src="https://images.961110.xyz/images/2022/01/25/5ded02be260035082.jpg_e1080.jpg"></a></p><p>(4). 在 ext4 分区上右击点击 umount 卸载，然后继续右键点击更改大小。  </p><p><a href="https://post.smzdm.com/p/apzkgne7/pic_15/"><img src="https://images.961110.xyz/images/2022/01/25/5ded02be552ef2427.jpg_e1080.jpg"></a></p><p>(5). 在弹出的窗口中重新分配大小，在新大小一栏填入比最小值（3689）大上三四百就行，我这里大 300M，在点击空余空间会自动计算，然后点击右下角 Resize，之后可以看到原来的分区只剩下 4.07G，剩下的 10.58G 空间未分配。</p><p><a href="https://post.smzdm.com/p/apzkgne7/pic_16/"><img src="https://images.961110.xyz/images/2022/01/25/5ded02be49db03575.jpg_e1080.jpg"></a></p><p>(6). 然后点击绿色的对号键确认，在弹出的对话框中点应用。  </p><p><a href="https://post.smzdm.com/p/apzkgne7/pic_17/"><img src="https://images.961110.xyz/images/2022/01/25/5ded02be5e3b74763.jpg_e1080.jpg"></a></p><p>(7). 等待执行完成，可以看到分区由 14.66G 缩小到 4.07G，然后弹出 SD 卡，到这里 Linux 上的操作完成。  </p><p><a href="https://post.smzdm.com/p/apzkgne7/pic_18/"><img src="https://images.961110.xyz/images/2022/01/25/5ded02be6d4ec1683.jpg_e1080.jpg"></a></p><p>(8). 将 SD 卡重新插到 Windows 上，新建一个空白 img 文件，打开 Win32DiskImager 软件，选中该文件，然后勾选‘’仅读取已分配分区‘’（注意要最新版，旧版本没有这个功能）。  </p><p><a href="https://post.smzdm.com/p/apzkgne7/pic_19/"><img src="https://images.961110.xyz/images/2022/01/25/5ded02becea5d6117.jpg_e1080.jpg"></a></p><p>(9). 等待读取完成，压缩的镜像备份就制作完成了，源镜像文件 3.9GB，备份的镜像文件 4.5GB，如果压缩一下的话就只有 1.8GB 了，适合存储。  </p><p><a href="https://post.smzdm.com/p/apzkgne7/pic_20/"><img src="https://images.961110.xyz/images/2022/01/25/5ded02bee0b1b245.jpg_e1080.jpg"></a></p><h3 id="4-树莓派-Linux-命令行"><a href="#4-树莓派-Linux-命令行" class="headerlink" title="4. 树莓派 / Linux 命令行"></a>4. 树莓派 / Linux 命令行</h3><p>这种方法完全利用 Linux 命令操作，使用 dump 和 restore 来制作树莓派的 img 镜像，具体过程来自 <a href="https://blog.csdn.net/zhufu86/article/details/78821056">CSDN 的 Blog</a>，我按照文中步骤实际操作了一番。</p><p><a href="https://post.smzdm.com/p/apzkgne7/pic_21/"><img src="https://images.961110.xyz/images/2022/01/25/5ded02bf1f4551865.jpg_e1080.jpg"></a></p><p>(1). 查看系统所占容量  </p><p>先用 df -h 命令查看当前系统所占容量，以确定将来要生成备份镜像的大小，若树莓派所占空间小于 SD 卡空间的 50%，就可以在树莓派内部直接生成镜像。否则要将备份的镜像生成到挂载的外置 SD 卡里面。</p><p><a href="https://post.smzdm.com/p/apzkgne7/pic_22/"><img src="https://images.961110.xyz/images/2022/01/25/5ded02bf23b9d2742.jpg_e1080.jpg"></a></p><p>可以看到树莓派有 boot 和 root 两个分区，所占大小为 3.5G+253M=3.8G，因为格式转换，所以会损耗 5%~10%，总大小大约 3.8*1.1=4.2G。如果 SD 卡剩余空间大于这么多就可以接着往下进行了。  </p><p>(2) 安装所需的软件</p><p>sudo apt-get install dosfstools dump parted kpartx</p><p>dosfstools：fat32 分区格式化工具 dump：dump &amp; restore 备份工具 parted &amp; kpartx：虚拟磁盘工具</p><p>(3). 根据第一步计算的系统所占用空间，用 dd 命令创建一个大约 4.5G 的空白镜像 raspberrypi.img，这个过程大约几分钟完成。 sudo dd if=/dev/zero of=raspberrypi.img bs=1M count=4500</p><p>注意这里 bs=1M（1M=1024x1024Bytes）。</p><p><a href="https://post.smzdm.com/p/apzkgne7/pic_23/"><img src="https://images.961110.xyz/images/2022/01/25/5ded02bf1db801044.jpg_e1080.jpg"></a></p><p>(4). 分割虚拟磁盘  </p><p>通过 sudo fdisk -l /dev/mmcblk0 得知：第一个分区为 boot 分区，采用 FAT32 格式，由 sector 8192 开始到 sector 532480；第二个分区采用 EXT4，由 sector 540672 开始到空白 img 结尾。</p><p><a href="https://post.smzdm.com/p/apzkgne7/pic_24/"><img src="https://images.961110.xyz/images/2022/01/25/5ded02bf5255c9057.jpg_e1080.jpg"></a></p><p>sudo parted raspberrypi.img –script – mklabel msdos  </p><p>sudo parted raspberrypi.img –script – mkpart primary fat32 8192s 532480s</p><p>sudo parted raspberrypi.img –script – mkpart primary ext4 540672s -1</p><p>分区的起始扇区数都是 8192 的倍数，上述命令中 8192 基本是固定的，532480 和 540672 根据你自己的实际查询情况修改，-l 表示到文件末尾。</p><p>检查分区是否成功 sudo parted raspberrypi.img, 在 parted 程序中，输入 print free 命令可以显示分区内容，输入 quit 退出。</p><p><a href="https://post.smzdm.com/p/apzkgne7/pic_25/"><img src="https://images.961110.xyz/images/2022/01/25/5ded02bf99bc19328.jpg_e1080.jpg"></a></p><p>(5). 挂载虚拟磁盘并格式化  </p><p>设置 img 文件对应的 Loop device：sudo losetup -f –show raspberrypi.img 下一行命令输出了 /dev/loop0。（如果不是 loop0 的话以后的各个步骤里的 loop0 都要改成和这里一样的）。</p><p><a href="https://post.smzdm.com/p/apzkgne7/pic_26/"><img src="https://images.961110.xyz/images/2022/01/25/5ded02bfa5c101523.jpg_e1080.jpg"></a></p><p>接着 sudo kpartx -va /dev/loop0  </p><p><a href="https://post.smzdm.com/p/apzkgne7/pic_27/"><img src="https://images.961110.xyz/images/2022/01/25/5ded02bfa57284077.jpg_e1080.jpg"></a></p><p>此时 loop device 就设置好了，loop0p1 对应的是 img 文件分区上的 /boot，loop0p2 对应的是 /（根）。  </p><p>然后格式化 img 文件中的两个分区。</p><p>sudo mkfs.vfat -n boot /dev/mapper/loop0p1</p><p>sudo mkfs.ext4 /dev/mapper/loop0p2</p><p><a href="https://post.smzdm.com/p/apzkgne7/pic_28/"><img src="https://images.961110.xyz/images/2022/01/25/5ded02bfbe2c16347.jpg_e1080.jpg"></a></p><p>挂载目标 img 文件 loop device 到新建的目录下。  </p><p>mkdir tgt_boot tgt_Root sudo mount -t vfat -o uid=pi,gid=pi,umask=0000 /dev/mapper/loop0p1 ./tgt_boot/ sudo mount -t ext4 /dev/mapper/loop0p2 ./tgt_Root/</p><p>这里是在树莓派系统里面做备份操作的，如果是用其他 Linux 系统，请注意 uid 和 gid 的设置。</p><p>(6). 开始备份</p><p><strong>【备份 / boot】</strong></p><p>首先备份 /boot，直接拷贝即可 sudo cp -rfp /boot/* ./tgt_boot/（如果是用其他 Linux 系统，/boot/* 换成你挂载的 SD 卡，比如 dev/sdb1）</p><p><a href="https://post.smzdm.com/p/apzkgne7/pic_29/"><img src="https://images.961110.xyz/images/2022/01/25/5ded02bfd394b7938.jpg_e1080.jpg"></a></p><p>运行完出来一堆提示：failed to preserve ownership for…，进图形界面查看了下：  </p><p><a href="https://post.smzdm.com/p/apzkgne7/pic_30/"><img src="https://images.961110.xyz/images/2022/01/25/5ded02bff42073339.jpg_e1080.jpg"></a></p><p>文件都复制成功了，只是文件的权限没有复制过来，影响不大。  </p><p><strong>【备份 “/”】</strong></p><p>备份根文件系统用 dump/restore 方法，首先对目标挂载点设置合适的权限，并清空。（如果是用其他 Linux 系统，将 pi.pi 替换成对应的用户名和用户组）</p><p>sudo chmod 777 tgt_Root sudo chown pi.pi tgt_Root sudo rm -rf ./tgt_Root/* cd tgt_Root/</p><p>然后开始备份</p><p>sudo dump -0uaf - / | sudo restore -rf - （如果是用其他 Linux 系统，/ 换成你挂载的 SD 卡，比如 dev/sdb2）</p><p><a href="https://post.smzdm.com/p/apzkgne7/pic_31/"><img src="https://images.961110.xyz/images/2022/01/25/5ded02c04fd9a6007.jpg_e1080.jpg"></a></p><p>整个 dump/restore 过程需要几分钟时间，看到 DUMP IS DONE 就说明备份成功了。  </p><p>如果上述方法的 sudo dump … 那一步出现 Broken pipe、 Illegal instruction 等错误而失败的话，可以使用 tar 方法，把源 SD 卡的根文件系统打包，所以在本机系统空间里需要额外的和源 SD 卡的根文件系统已用空间大小一样的可用空间，详细过程见原作者。</p><p>(7). 修改相应的 PARTUUID</p><p>此时备份已经完成，还需要修改下 Raspbian 启动对应分区的 PARTUUID，也就是修改目标 img 文件里的下面两个文件：./tgt_boot/cmdline.txt 和./tgt_Root/etc/fstab</p><p>首先查看 img 文件对应的 loop device 的两个分区的 PARTUUID： sudo blkid</p><p><a href="https://post.smzdm.com/p/apzkgne7/pic_32/"><img src="https://images.961110.xyz/images/2022/01/25/5ded02c072cee9137.jpg_e1080.jpg"></a></p><p>这里可以看到 /boot 对应的是 594e62d6-01 ， / 对应的是 594e62d6-02  </p><p>修改 cmdline.txt 文件 sudo vi ./tgt_boot/cmdline.txt</p><p><a href="https://post.smzdm.com/p/apzkgne7/pic_33/"><img src="https://images.961110.xyz/images/2022/01/25/5ded02c07dced5950.jpg_e1080.jpg"></a></p><p>修改 fstab 文件 sudo vim ./tgt_Root/etc/fstab  </p><p><a href="https://post.smzdm.com/p/apzkgne7/pic_34/"><img src="https://images.961110.xyz/images/2022/01/25/5ded02c096be89431.jpg_e1080.jpg"></a></p><p>(8). 收尾工作  </p><p>卸载各个挂载的分区： sudo umount tgt_boot tgt_Root</p><p>删除 loop device：sudo kpartx -d /dev/loop0 和 sudo losetup -d /dev/loop0</p><p>删除挂载点目录：rmdir tgt_boot tgt_Root</p><p>最后只剩下 img 文件</p><p><a href="https://post.smzdm.com/p/apzkgne7/pic_35/"><img src="https://images.961110.xyz/images/2022/01/25/5ded02c0de68c2683.jpg_e1080.jpg"></a></p><p>将其通过 WinSCP 拷贝到 Windows 电脑上保存。或者直接在树莓派中 dd if=/home/xxx/xxx.img of=/dev/sdb bs=4M ; sync 烧写 img 文件到其他 SD 卡中（镜像目录使用 if= 来指定，外接 U 盘设备的地址使用 of= 来指定，不一定是 sdb，最后的 bs=4M 指定一次写入字节数，sync 同步数据），同样的在树莓派中运行后，要先用 raspi-config 先把分区空间 expand 一下。  </p><p>这种方法虽然步骤比较多，但是照着一步步走下来可以对整个备份的全部技术细节有详细的了解。</p><h3 id="5-sh-脚本一键备份"><a href="#5-sh-脚本一键备份" class="headerlink" title="5. sh 脚本一键备份"></a>5. sh 脚本一键备份</h3><p>上述纯 Linux 命令行进行压缩备份的步骤繁琐，可以把全部步骤写成一个 .sh 脚本文件，这样的话只需要执行该脚本文件就能自动执行完压缩备份命令了。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh  </span></span><br><span class="line">sudo apt-get install dosfstools dump parted kpartx  </span><br><span class="line">sudo dd <span class="keyword">if</span>=/dev/zero of=raspberrypi.img bs=1M count=4500  </span><br><span class="line"><span class="comment"># 通过 count 更改创建的空白镜像大小（按照自己树莓派 TF 卡已用空间更改）  </span></span><br><span class="line">sudo parted raspberrypi.img --script -- mklabel msdos  </span><br><span class="line">sudo parted raspberrypi.img --script -- mkpart primary fat32 8192s 532480s  </span><br><span class="line">sudo parted raspberrypi.img --script -- mkpart primary ext4 540672s -1  </span><br><span class="line"><span class="comment"># 给 img 文件分区  </span></span><br><span class="line">loopdevice=`sudo losetup -f --show raspberrypi.img`  </span><br><span class="line">device=`sudo kpartx -va <span class="variable">$loopdevice</span> | sed -E <span class="string">&#x27;s/.*(loop[0-9])p.*/1/g&#x27;</span> | head -1`  </span><br><span class="line">device=<span class="string">&quot;/dev/mapper/<span class="variable">$&#123;device&#125;</span>&quot;</span>  </span><br><span class="line">partBoot=<span class="string">&quot;<span class="variable">$&#123;device&#125;</span>p1&quot;</span>  </span><br><span class="line">partRoot=<span class="string">&quot;<span class="variable">$&#123;device&#125;</span>p2&quot;</span>  </span><br><span class="line">sudo mkfs.vfat -n boot <span class="variable">$partBoot</span>  </span><br><span class="line">sudo mkfs.ext4 <span class="variable">$partRoot</span>  </span><br><span class="line"><span class="comment"># 空白镜像挂载并格式化，注意修改数值  </span></span><br><span class="line">mkdir tgt_boot tgt_Root  </span><br><span class="line">sudo mount -t vfat -o uid=pi,gid=pi,<span class="built_in">umask</span>=0000 <span class="variable">$partBoot</span> ./tgt_boot/  </span><br><span class="line">sudo mount -t ext4 <span class="variable">$partRoot</span> ./tgt_Root/  </span><br><span class="line"><span class="comment"># 拷贝至镜像  </span></span><br><span class="line">sudo cp -rfp /boot/* ./tgt_boot/  </span><br><span class="line"><span class="comment"># 拷贝 / boot  </span></span><br><span class="line">sudo chmod 777 tgt_Root  </span><br><span class="line">sudo chown pi.pi tgt_Root  </span><br><span class="line">sudo rm -rf ./tgt_Root/*  </span><br><span class="line"><span class="built_in">cd</span> tgt_Root/  </span><br><span class="line">sudo dump -0uaf - / | sudo restore -rf -  </span><br><span class="line"><span class="comment"># 拷贝 / rootfs  </span></span><br><span class="line">sudo umount tgt_boot tgt_Root  </span><br><span class="line">sudo kpartx -d /dev/loop0  </span><br><span class="line">sudo losetup -d /dev/loop0  </span><br><span class="line">rmdir tgt_boot tgt_Root  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 收尾工作</span></span><br><span class="line">使用上述脚本只需要在树莓派中新建一个. sh 文件 sudo vi backup.sh，sudo chmod 777 backup.sh 更改权限，然后 sudo ./backup.sh 就可以在当前脚本目录中生成树莓派的备份镜像文件了，然后还需要手动修改下 PARTUUID。之后既可以在 Windows 中用 Win32DiskImager 将镜像恢复到 SD 卡，也可以在 Linux 用 dd 命令还原到 SD 卡，当用此 SD 卡启动树莓派的时候执行 raspi-config -&gt;Expand Filesystem 即可扩展未使用的空间。</span><br></pre></td></tr></table></figure><p>sh 脚本首先需要能够读懂才能使用，里面有的参数需要修改以适合你自己的环境。sh 脚本如果报错了不容易查找问题原因，建议还是先把 Linux 命令的全部流程走通了再来用这个脚本，这样的可以知道哪一步出错了从而修改。</p><h3 id="6-推荐脚本"><a href="#6-推荐脚本" class="headerlink" title="6. 推荐脚本"></a>6. 推荐脚本</h3><p>这里还有一个<a href="https://blog.csdn.net/qingtian11112/article/details/99825257">脚本</a>是我最推荐使用的，程序内容太长，我就不贴上来了，具体脚本内容我也没有完全读懂，反正简单易用，也是我目前使用的备份方法，可以<a href="https://github.com/BigBubbleGum/RaspberryBackup">去这里下载</a>，使用方法如下：</p><p>step1：下载脚本文件 rpi-backup.sh 到 Linux 系统中</p><p>step2：把需要备份的 SD 卡插入 Linux 系统中，用 df -h 命令查询下 SD 卡对应的设备名。</p><p><a href="https://post.smzdm.com/p/apzkgne7/pic_36/"><img src="https://images.961110.xyz/images/2022/01/25/5ded02c0ed7b03186.jpg_e1080.jpg"></a></p><p>step3：进入脚本文件 rpi-backup.sh 所在目录，只需要下面两行命令即可完成 SD 卡备份，最终 img 文件会生成在~/backupimg / 文件夹下。  </p><p>sudo chmod +x rpi-backup.sh （需要赋可执行权限）</p><p>./rpi-backup.sh /dev/sdb1 /dev/sdb2（脚本执行有两个参数，第一个参数是树莓派 SD 卡 / boot 分区的设备名：/dev/sdb1，第二个参数是 / 分区的设备名：/dev/sdb2，视情况修改）</p><p><a href="https://post.smzdm.com/p/apzkgne7/pic_37/"><img src="https://images.961110.xyz/images/2022/01/25/5ded02c112bae1721.jpg_e1080.jpg"></a></p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><hr><p>全卡备份肯定是不可取的，如果你是新手小白的话，建议先在 Windows 上用 Win32DiskImager 或者树莓派上的 SD Card copier 全卡备份，然后用 PiShrink 进行裁剪，代码量最低，简单不容易出错，就是比较耗时。</p><p>如果你熟悉一点 Linux 的基本操作的话可以在 Linux 虚拟机中用 gparted 图形界面来进行备份。</p><p>如果你是树莓派爱好者或者像我一样想深入学习下树莓派的系统备份技术原理的话，可以用树莓派 / Linux 命令行一步步分区 - 挂载 - 备份操作，大牛们以为想当然的事情小白查好久资料都整不明白，我也是试了好久好久才照着教程操作成功。</p><p>如果你是 Linux 大神的话，可以修改下上述 .sh 脚本文件中的参数，或者直接用我推荐的那个脚本，一键备份。更牛的可以封装成一个有图形界面的软件，造福全体小白。</p><p>以上就是关于树莓派系统备份的全部内容了，后续会继续更新在树莓派 4B 上搭建 WEB <a href="https://www.smzdm.com/fenlei/fuwuqi/">服务器</a>、NAS 云存储、软路由等内容，欢迎关注~</p><blockquote><p>参考</p><p><a href="https://blog.csdn.net/zhshh123/article/details/85063916">树莓派系统备份脚本（原理）</a></p><p><a href="https://blog.csdn.net/Chen_RuiMin/article/details/93903969">树莓派系统最小化备份（gparted）</a></p><p><a href="https://blog.csdn.net/zhufu86/article/details/78821056">手动一步一步来制作备份 Raspberry Pi 树莓派 SD 卡的 img 映像文件 (不用 dd 命令)</a></p><p><a href="https://blog.csdn.net/qingtian11112/article/details/99825257">制作树莓派 img 镜像文件（推荐脚本）</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> 教程 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转载】Ubuntu20.04字符和图形界面切换</title>
      <link href="/posts/61191.html"/>
      <url>/posts/61191.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>【转载】 <a href="https://blog.csdn.net/Jailman/article/details/116301693">Ubuntu20.04 字符和图形界面切换</a></p></blockquote><p>设置默认开机模式</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  默认进入字符界面</span></span><br><span class="line">systemctl set-default multi-user.target</span><br><span class="line"><span class="comment">#  默认进入图形界面</span></span><br><span class="line">systemctl set-default graphical.target   </span><br></pre></td></tr></table></figure><p>命令行界面进入图形界面</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">init 5</span><br></pre></td></tr></table></figure><p>图形界面切换命令行界面</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CTRL+ALT+F1-F6</span><br></pre></td></tr></table></figure><p>关于 init 命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Commands:</span><br><span class="line">  0              Power-off the machine</span><br><span class="line">  6              Reboot the machine</span><br><span class="line">  2, 3, 4, 5     Start runlevelX.target unit</span><br><span class="line">  1, s, S        Enter rescue mode</span><br><span class="line">  q, Q           Reload init daemon configuration</span><br><span class="line">  u, U           Reexecute init daemon</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> Ubuntu 20.04 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 20.04 或 Centos 7.4 安装 Transmission 下载器</title>
      <link href="/posts/50304.html"/>
      <url>/posts/50304.html</url>
      
        <content type="html"><![CDATA[<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><h3 id="2022-05-14"><a href="#2022-05-14" class="headerlink" title="2022-05-14"></a>2022-05-14</h3><p>增加 centos 7.4 下手动编译的安装方法，可以解决 yum 安装导致的权限问题。</p><h3 id="2022-05-13"><a href="#2022-05-13" class="headerlink" title="2022-05-13"></a>2022-05-13</h3><p>增加 centos 7.4 下安装方法</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前在群晖里一直用 Transmission 玩儿 PT，所以想在树莓派上也装一个玩儿玩儿。</p><blockquote><p><a href="https://transmissionbt.com/">Transmission</a>是一种BitTorrent客户端，特点是一个跨平台的后端和其上的简洁的用户界面。Transmission以MIT许可证和GNU通用公共许可证双许可证授权，因此是一款自由软件。挂PT的利器！</p></blockquote><h2 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h2><h3 id="直接用包管理软件安装就可以"><a href="#直接用包管理软件安装就可以" class="headerlink" title="直接用包管理软件安装就可以"></a>直接用包管理软件安装就可以</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu 20.04</span></span><br><span class="line">sudo apt-get install -y transmission-daemon</span><br><span class="line"><span class="comment"># Centos 7.4</span></span><br><span class="line">sudo yum install -y transmission-daemon</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>首先需要停止 transmission 的服务，不然会被修改的配置会被还原</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先启动，会创建默认配置文件</span></span><br><span class="line">sudo systemctl start transmission-daemon.service</span><br><span class="line">sudo systemctl stop transmission-daemon.service</span><br></pre></td></tr></table></figure><p>修改 transmission 的配置文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu 20.04</span></span><br><span class="line">sudo vim /etc/transmission-daemon/settings.json</span><br><span class="line"><span class="comment"># Centos 7.4</span></span><br><span class="line">sudo vim /var/lib/transmission/.config/transmission-daemon/settings.json</span><br></pre></td></tr></table></figure><p>需要修改的地方已经做好了备注</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;alt-speed-down&quot;</span>: <span class="number">50</span>,</span><br><span class="line">    <span class="attr">&quot;alt-speed-enabled&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;alt-speed-time-begin&quot;</span>: <span class="number">540</span>,</span><br><span class="line">    <span class="attr">&quot;alt-speed-time-day&quot;</span>: <span class="number">127</span>,</span><br><span class="line">    <span class="attr">&quot;alt-speed-time-enabled&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;alt-speed-time-end&quot;</span>: <span class="number">1020</span>,</span><br><span class="line">    <span class="attr">&quot;alt-speed-up&quot;</span>: <span class="number">50</span>,</span><br><span class="line">    <span class="attr">&quot;bind-address-ipv4&quot;</span>: <span class="string">&quot;0.0.0.0&quot;</span>,  #开启IPV4地址绑定</span><br><span class="line">    <span class="attr">&quot;bind-address-ipv6&quot;</span>: <span class="string">&quot;::&quot;</span>, #开启IPV6地址绑定</span><br><span class="line">    <span class="attr">&quot;blocklist-enabled&quot;</span>: <span class="literal">false</span>,  #启用黑名单</span><br><span class="line">    <span class="attr">&quot;blocklist-url&quot;</span>: <span class="string">&quot;http://www.example.com/blocklist&quot;</span>, #黑名单地址</span><br><span class="line">    <span class="attr">&quot;cache-size-mb&quot;</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="attr">&quot;dht-enabled&quot;</span>: <span class="literal">false</span>,  #DTH启用，这里我们要关闭</span><br><span class="line">    <span class="attr">&quot;download-dir&quot;</span>: <span class="string">&quot;/home/jason/Downloads/PT&quot;</span>,  #默认下载目录</span><br><span class="line">    <span class="attr">&quot;download-queue-enabled&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;download-queue-size&quot;</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">&quot;encryption&quot;</span>: <span class="number">2</span>,  #修改为2</span><br><span class="line">    <span class="attr">&quot;idle-seeding-limit&quot;</span>: <span class="number">30</span>,</span><br><span class="line">    <span class="attr">&quot;idle-seeding-limit-enabled&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;incomplete-dir&quot;</span>: <span class="string">&quot;/var/lib/transmission/Downloads&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;incomplete-dir-enabled&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;lpd-enabled&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;message-level&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;peer-congestion-algorithm&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;peer-id-ttl-hours&quot;</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="attr">&quot;peer-limit-global&quot;</span>: <span class="number">200</span>,</span><br><span class="line">    <span class="attr">&quot;peer-limit-per-torrent&quot;</span>: <span class="number">50</span>,</span><br><span class="line">    <span class="attr">&quot;peer-port&quot;</span>: <span class="number">51413</span>, #端口</span><br><span class="line">    <span class="attr">&quot;peer-port-random-high&quot;</span>: <span class="number">65535</span>,</span><br><span class="line">    <span class="attr">&quot;peer-port-random-low&quot;</span>: <span class="number">49152</span>,</span><br><span class="line">    <span class="attr">&quot;peer-port-random-on-start&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;peer-socket-tos&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;pex-enabled&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;port-forwarding-enabled&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;preallocation&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;prefetch-enabled&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;queue-stalled-enabled&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;queue-stalled-minutes&quot;</span>: <span class="number">30</span>,</span><br><span class="line">    <span class="attr">&quot;ratio-limit&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;ratio-limit-enabled&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;rename-partial-files&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;rpc-authentication-required&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;rpc-bind-address&quot;</span>: <span class="string">&quot;0.0.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;rpc-enabled&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;rpc-host-whitelist&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;rpc-host-whitelist-enabled&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;rpc-password&quot;</span>:  ,#密码，编辑的时候输入明文密码，保持之后，自动变为加密的</span><br><span class="line">    <span class="attr">&quot;rpc-port&quot;</span>: <span class="number">9091</span>,</span><br><span class="line">    <span class="attr">&quot;rpc-url&quot;</span>: <span class="string">&quot;/transmission/&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;rpc-username&quot;</span>: <span class="string">&quot;jason&quot;</span>,  #用户名</span><br><span class="line">    <span class="attr">&quot;rpc-whitelist&quot;</span>: <span class="string">&quot;*&quot;</span>, #白名单IP,多个IP用‘,&#x27;分隔, <span class="attr">&quot;*&quot;</span>表示允许所有</span><br><span class="line">    <span class="attr">&quot;rpc-whitelist-enabled&quot;</span>: <span class="literal">true</span>,  #是否启用白名单，如果需要可以修改为true</span><br><span class="line">    <span class="attr">&quot;scrape-paused-torrents-enabled&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;script-torrent-done-enabled&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;script-torrent-done-filename&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;seed-queue-enabled&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;seed-queue-size&quot;</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">&quot;speed-limit-down&quot;</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">&quot;speed-limit-down-enabled&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;speed-limit-up&quot;</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">&quot;speed-limit-up-enabled&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;start-added-torrents&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;trash-original-torrent-files&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;umask&quot;</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">&quot;upload-slots-per-torrent&quot;</span>: <span class="number">14</span>,</span><br><span class="line">    <span class="attr">&quot;utp-enabled&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用 yum 安装 transmission 时，下载目录不能指定到 <code>/home/user</code> 目录下，会有权限不足的问题，建议按照上面的默认选项设置。</p></blockquote><h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><p>把 transmission 的下载文件夹修改权限</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo chmod 777 &lt;文件夹&gt;</span><br></pre></td></tr></table></figure><h3 id="开机自启"><a href="#开机自启" class="headerlink" title="开机自启"></a>开机自启</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> transmission-daemon.service</span><br></pre></td></tr></table></figure><h3 id="centos-编译安装"><a href="#centos-编译安装" class="headerlink" title="centos 编译安装"></a>centos 编译安装</h3><h4 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum update</span><br><span class="line">sudo yum groupinstall -y <span class="string">&#x27;development tools&#x27;</span></span><br><span class="line">sudo yum -y install gcc gcc-c++ m4 make automake libtool gettext openssl-devel libcurl-devel libevent-devel intltool gtk3-devel</span><br></pre></td></tr></table></figure><h4 id="下载源码包"><a href="#下载源码包" class="headerlink" title="下载源码包"></a>下载源码包</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/transmission/transmission/releases/download/3.00/transmission-3.00.tar.xz</span><br><span class="line">tar -xf transmission-3.00.tar.xz</span><br><span class="line"><span class="built_in">cd</span> transmission-3.00</span><br></pre></td></tr></table></figure><h4 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h4 id="设定-systemd-Transmission-service"><a href="#设定-systemd-Transmission-service" class="headerlink" title="设定 systemd Transmission-service"></a>设定 systemd Transmission-service</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/systemd/system/transmission.service</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Transmission BitTorrent Daemon</span><br><span class="line">After=network.target</span><br><span class="line"> </span><br><span class="line">[Service]</span><br><span class="line">User=root</span><br><span class="line">LimitNOFILE=100000</span><br><span class="line">ExecStart=/usr/<span class="built_in">local</span>/bin/transmission-daemon -f --log-error -g /usr/<span class="built_in">local</span>/share/transmission</span><br><span class="line"> </span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><h4 id="创建默认配置"><a href="#创建默认配置" class="headerlink" title="创建默认配置"></a>创建默认配置</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> transmission.service</span><br><span class="line">sudo systemctl start transmission.service</span><br><span class="line">sudo systemctl stop transmission.service</span><br></pre></td></tr></table></figure><h4 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /usr/<span class="built_in">local</span>/share/transmission/settings.json</span><br></pre></td></tr></table></figure><p>具体配置参照上面的内容</p><p>重新启动</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl start transmission.service</span><br></pre></td></tr></table></figure><h4 id="防火墙放行"><a href="#防火墙放行" class="headerlink" title="防火墙放行"></a>防火墙放行</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo firewall-cmd --permanent --add-port=9091/tcp</span><br><span class="line">sudo firewall-cmd --permanent --add-port=56789/tcp</span><br><span class="line">sudo firewall-cmd --permanent --add-port=56789/udp</span><br></pre></td></tr></table></figure><p>重启防火墙</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure><h2 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h2><p>原版的界面很丑，美化的方法如下，是大佬自定义的一套 WebUI</p><p><a href="https://github.com/ronggang/transmission-web-control">transmission-web-control</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://gitee.com/styf3501/transmission-web-control/raw/master/install-tr-control-gitee.sh</span><br><span class="line">sudo chmod +x install-tr-control-gitee.sh</span><br><span class="line">sudo bash ./install-tr-control-gitee.sh</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://github.com/ronggang/transmission-web-control">https://github.com/ronggang/transmission-web-control</a></li><li><a href="https://jtxiao.com/main/posts/ubuntu-20.04-%E5%AE%89%E8%A3%85-transmission/">https://jtxiao.com/main/posts/ubuntu-20.04-%E5%AE%89%E8%A3%85-transmission/</a></li><li><a href="https://wp.madjack.info/linux/transmission-2-92-centos-7.html">Transmission 2.92 ~2.94 編譯 for Centos 7</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 20.04 将阿里云盘挂载到本地并设置开机自动挂载</title>
      <link href="/posts/43029.html"/>
      <url>/posts/43029.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>阿里云盘已经开启公测很久了，虽然大部分容量都不是永久的，但是依然有不可抵挡的诱惑——不限速。</p><p>Github 上已经有大神将阿里云盘转为 WebDAV 协议的文件服务器，仓库链接 <a href="https://github.com/zxbu/webdav-aliyundriver">在此</a> </p><p>官方介绍</p><blockquote><p>本项目实现了阿里云盘的 webda v协议，只需要简单的配置一下，就可以让阿里云盘变身为 webdav 协议的文件服务器。 基于此，你可以把阿里云盘挂载为 Windows、Linux、Mac 系统的磁盘，可以通过 NAS 系统做文件管理或文件同步，更多玩法等你挖掘。</p></blockquote><h2 id="作为-Docker-容器部署"><a href="#作为-Docker-容器部署" class="headerlink" title="作为 Docker 容器部署"></a>作为 Docker 容器部署</h2><p>以下内容摘自项目官方教程</p><h3 id="获取必需参数-refreshToken"><a href="#获取必需参数-refreshToken" class="headerlink" title="获取必需参数 refreshToken"></a>获取必需参数 refreshToken</h3><ol><li>先通过浏览器（建议chrome）打开 <a href="https://www.aliyundrive.com/drive/">阿里云盘官网</a> 并登录</li><li>登录成功后，按 F12 打开开发者工具，点击 应用（Application），点击本地存储空间（Local Storage），点击 Local Storage 下的 <a href="https://www.aliyundrive.com/%EF%BC%8C%E7%82%B9%E5%87%BB%E5%8F%B3%E8%BE%B9%E7%9A%84">https://www.aliyundrive.com/，点击右边的</a> token，此时可以看到里面的数据，其中就有 refresh_token，把其值复制出来即可。格式为小写字母和数字，不要复制双引号，例子：ca6bf2175d73as2188efg81f87e55f11</li></ol><img src="https://user-images.githubusercontent.com/32785355/119246278-e6760880-bbb2-11eb-877c-aca16cf75d89.png" style="zoom: 67%;" /><h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>装好 Docker 后，输入一下命令部署</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name=webdav-aliyundriver --restart=always -p 本机端口:8080  -v /etc/localtime:/etc/localtime -v /etc/aliyun-driver/:/etc/aliyun-driver/ -e TZ=<span class="string">&quot;Asia/Shanghai&quot;</span> -e ALIYUNDRIVE_REFRESH_TOKEN=<span class="string">&quot;your refreshToken&quot;</span> -e ALIYUNDRIVE_AUTH_PASSWORD=<span class="string">&quot;admin&quot;</span> -e JAVA_OPTS=<span class="string">&quot;-Xmx1g&quot;</span> zx5253/webdav-aliyundriver</span><br><span class="line"></span><br><span class="line"><span class="comment"># /etc/aliyun-driver/ 挂载卷自动维护了最新的 refreshToken，建议挂载</span></span><br><span class="line"><span class="comment"># ALIYUNDRIVE_AUTH_PASSWORD 是 admin 账户的密码，建议修改</span></span><br><span class="line"><span class="comment"># JAVA_OPTS 可修改最大内存占用，比如 -e JAVA_OPTS=&quot;-Xmx512m&quot; 表示最大内存限制为 512m</span></span><br></pre></td></tr></table></figure><p>参数说明</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--aliyundrive.refresh-token</span><br><span class="line">    阿里云盘的 refreshToken</span><br><span class="line">--server.port</span><br><span class="line">    非必填，服务器端口号，默认为8080</span><br><span class="line">--aliyundrive.auth.enable=<span class="literal">true</span></span><br><span class="line">    是否开启WebDav账户验证，默认开启</span><br><span class="line">--aliyundrive.auth.user-name=admin</span><br><span class="line">    WebDav账户，默认admin</span><br><span class="line">--aliyundrive.auth.password=admin</span><br><span class="line">    WebDav密码，默认admin</span><br><span class="line">--aliyundrive.work-dir=/etc/aliyun-driver/</span><br><span class="line">    token挂载路径（如果多开的话，需修改此配置）</span><br></pre></td></tr></table></figure><h2 id="开机自动挂载"><a href="#开机自动挂载" class="headerlink" title="开机自动挂载"></a>开机自动挂载</h2><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><ol><li><p>安装所需软件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install davfs2 -y</span><br></pre></td></tr></table></figure></li><li><p>创建挂载目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /home/ubuntu/alicloud</span><br></pre></td></tr></table></figure></li><li><p>挂载阿里云盘到本地</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mount -t davfs -o noexec localhost:端口/文件夹名 /home/ubuntu/alicloud</span><br></pre></td></tr></table></figure><p>端口就是刚刚启动容器时设置的本地端口，文件夹名就是要挂载到本地的阿里云盘的文件夹名，不设置文件夹就是默认所有文件夹。</p></li><li><p>按要求输入账户和密码，挂载成功后，即可当正常磁盘一样访问 WebDAV 服务了，速度快慢取决于网速。</p></li><li><p>输入 <code>df -h</code> 即可看到是否挂载成功</p><p><img src="https://images.961110.xyz/images/2022/01/14/alicloud-.png" alt="image-20220114160206764"></p></li><li><p>解除挂载</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo umount /home/ubuntu/alicloud</span><br></pre></td></tr></table></figure></li></ol><h3 id="设置开机自动挂载"><a href="#设置开机自动挂载" class="headerlink" title="设置开机自动挂载"></a>设置开机自动挂载</h3><h4 id="设置-WebDAV-免登陆密码"><a href="#设置-WebDAV-免登陆密码" class="headerlink" title="设置 WebDAV 免登陆密码"></a>设置 WebDAV 免登陆密码</h4><p>修改 /etc/davfs2/secrets，增加下面一行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">localhost:端口/文件夹名 davusername davpassword</span><br></pre></td></tr></table></figure><h3 id="设置开机自动挂载-1"><a href="#设置开机自动挂载-1" class="headerlink" title="设置开机自动挂载"></a>设置开机自动挂载</h3><p>修改 /etc/fstab，增加下面一行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">localhost:端口/文件夹名 /home/ubuntu/alicloud davfs rw,user,uid=username,auto 0 0</span><br></pre></td></tr></table></figure><p>uid 就是当前 Linux 用户名，不是 WebDAV 服务的用户名。</p><p>详细的挂载格式可以参考上一篇博文 <a href="https://blog.961110.xyz/posts/1946.html#%E4%BF%AE%E6%94%B9-fstab">Ubuntu 20.04 开机自动挂载 NTFS 格式存储设备</a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://shipengliang.com/software-exp/%E5%A6%82%E4%BD%95%E5%9C%A8ubuntu%E6%88%96centos%E5%B0%86webdav%E6%8C%82%E8%BD%BD%E4%B8%BA%E6%9C%AC%E5%9C%B0%E7%A3%81%E7%9B%98.html">如何在Ubuntu或CentOS将WebDAV挂载为本地磁盘</a></li><li><a href="https://github.com/zxbu/webdav-aliyundriver">https://github.com/zxbu/webdav-aliyundriver</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 20.04 开机自动挂载 NTFS 格式存储设备</title>
      <link href="/posts/1946.html"/>
      <url>/posts/1946.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>博主有一个无用的 U 盘想将其挂载到基于 Ubuntu Server 20.04 LTS 的树莓派 4B 中拓展存储。为了方便 PC 和树莓派两个平台都可以读写，所以格式化为 NTFS 格式（exFAT 格式也可以），并在树莓派中设置成开机自动挂载，方便使用。</p><h2 id="开机自动挂载方法"><a href="#开机自动挂载方法" class="headerlink" title="开机自动挂载方法"></a>开机自动挂载方法</h2><p>Ubuntu Server 20.04 LTS 默认就可以挂载 NTFS 格式的设备（至少在博主的设备上可以），无需安装其他软件。</p><h3 id="获取分区信息"><a href="#获取分区信息" class="headerlink" title="获取分区信息"></a>获取分区信息</h3><p>输入 <code>lsblk</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">NAME        MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">loop0         7:0    0   62M  1 loop /snap/lxd/21032</span><br><span class="line">loop1         7:1    0 48.9M  1 loop /snap/core18/2127</span><br><span class="line">loop2         7:2    0 28.1M  1 loop /snap/snapd/12707</span><br><span class="line">sda           8:0    1 28.9G  0 disk</span><br><span class="line">└─sda1        8:1    1 28.9G  0 part /home/ubunutu/storage</span><br><span class="line">mmcblk0     179:0    0   30G  0 disk</span><br><span class="line">├─mmcblk0p1 179:1    0  256M  0 part /boot/firmware</span><br><span class="line">└─mmcblk0p2 179:2    0 29.8G  0 part /</span><br></pre></td></tr></table></figure><p>可以看到 sda1 代表的就是这个 U 盘。</p><p>输入 <code>sudo blkid /dev/sda1</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/dev/sda1: LABEL=<span class="string">&quot;storage&quot;</span> UUID=<span class="string">&quot;20466764466739A4&quot;</span> TYPE=<span class="string">&quot;ntfs&quot;</span> PARTLABEL=<span class="string">&quot;Basic data partition&quot;</span> PARTUUID=<span class="string">&quot;76ac87a1-aba5-4398-abbb-f49d1ce2c95c&quot;</span></span><br></pre></td></tr></table></figure><p>可以看到格式为 ntfs，记录下 <code>UUID</code> 的值</p><h3 id="修改-fstab"><a href="#修改-fstab" class="headerlink" title="修改 fstab"></a>修改 fstab</h3><p>输入 <code>sudo vim /etc/fstab</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">LABEL=writable  /        ext4defaults        01</span><br><span class="line">LABEL=system-boot       /boot/firmwarevfat    defaults        0       1</span><br></pre></td></tr></table></figure><p>按照这个格式添加自己的设备即可</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">格式：&lt;fs spec&gt;&lt;fs file&gt;&lt;fs vfstype&gt;&lt;fs mntops&gt;&lt;fs freq&gt;&lt;fs passno&gt;</span><br><span class="line"></span><br><span class="line">&lt;fs spec&gt;：分区定位，可以给UUID或LABEL，例如：UUID=20466764466739A4 或 LABEL=storage</span><br><span class="line">&lt;fs file&gt;：具体挂载点的位置，例如：/home/ubunutu/storage</span><br><span class="line">&lt;fs vfstype&gt;：挂载磁盘类型，根据实际情况填写，linux 分区一般为 ext4，windows 分区一般为 ntfs</span><br><span class="line">&lt;fs mntops&gt;：挂载参数，一般为defaults</span><br><span class="line">&lt;fs freq&gt;：磁盘检查，默认为0，需要开机检查磁盘则为1</span><br><span class="line">&lt;fs passno&gt;：引导选项，0不启动，1启动，2非启动，一般情况下只能为0或2</span><br></pre></td></tr></table></figure><p><strong>每一个选项之间，使用 Tab 而不是空格。</strong></p><p>所以可以增加一条配置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">UUID=20466764466739A4   /home/ubunutu/storage   ntfs    defaults        0       2</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">LABEL=storage/home/ubunutu/storage   ntfs    defaults        0       2</span><br></pre></td></tr></table></figure><p>重启查看一下是否自动挂载到了指定位置。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://lxnchan.cn/ubuntu-mount-disk.html">https://lxnchan.cn/ubuntu-mount-disk.html</a></li><li><a href="https://zhzh.xyz/2019/01/10/Linux/ubuntumountdiskdefault/">https://zhzh.xyz/2019/01/10/Linux/ubuntumountdiskdefault/</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派 4B 安装 Ubuntu Server 20.04 LTS</title>
      <link href="/posts/46533.html"/>
      <url>/posts/46533.html</url>
      
        <content type="html"><![CDATA[<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>博主基于 Windows 10 进行的各项操作，Linux 平台请参阅其他博文。</p><h3 id="系统镜像"><a href="#系统镜像" class="headerlink" title="系统镜像"></a>系统镜像</h3><p>Ubuntu 官方有专门针对树莓派的发行版，树莓派 Ubuntu 镜像的链接 <a href="https://ubuntu.com/download/raspberry-pi">在此</a></p><p>提供了三个版本的镜像，系统镜像依次递减，按需选择。</p><ol><li>Ubuntu Desktop</li><li>Ubuntu Server</li><li>Ubuntu Core</li></ol><p>下载下来是一个压缩包，解压出 .img 文件即可。</p><h3 id="其他软件"><a href="#其他软件" class="headerlink" title="其他软件"></a>其他软件</h3><ol><li><p>SD卡格式化工具：SD Card Formatter <a href="https://www.sdcard.org/downloads/formatter/sd-memory-card-formatter-for-windows-download/">官网下载链接</a></p></li><li><p>写镜像工具</p><ul><li>Win32DiskImager <a href="https://sourceforge.net/projects/win32diskimager/files/latest/download">官方下载链接</a></li><li>Raspberry Pi Imager <a href="https://downloads.raspberrypi.org/imager/imager_latest.exe">官方下载链接</a></li></ul><p>两个都用过，在写镜像的时候官方的工具明显比 Win32DiskImager 慢，具体原因未知。</p></li></ol><h2 id="刷写系统"><a href="#刷写系统" class="headerlink" title="刷写系统"></a>刷写系统</h2><p>步骤和 <a href="https://blog.961110.xyz/posts/59454.html">树莓派4B启动配置</a> 一样，直接拷贝了过来。</p><h3 id="格式化SD卡"><a href="#格式化SD卡" class="headerlink" title="格式化SD卡"></a>格式化SD卡</h3><p>选择好SD卡对应的盘符，选择Quick format，点击右下角Format，稍等片刻即可。<strong>注意不要选择错了盘符，否则后果不堪设想。</strong></p><table>    <tr>        <td ><center><img src="https://images.961110.xyz/images/2021/10/19/SD-Card-Formatter.png" ></center></td>        <td ><center><img src="https://s2.loli.net/2022/01/12/QRiOvFPMKXjmplt.png" alt="image-20211016202211668"  ></center></td>    </tr></table><h3 id="刷写镜像"><a href="#刷写镜像" class="headerlink" title="刷写镜像"></a>刷写镜像</h3><p>选择刚刚解压出来的镜像文件，选择好盘符，然后点击写入即可，完成速度取决于SD卡及读卡器的速度。</p><table>    <tr>        <td ><center><img src="https://s2.loli.net/2022/01/12/OjJoAWr8kX5v2HK.png" > </center></td>        <td ><center><img src="https://images.961110.xyz/images/2021/10/19/1163840ac01b2da689eb0dc2686f4eb3.png"  ></center></td>    </tr></table><p>完成后如果找不到盘符，可以重新插拔读卡器，<strong>如果提示有未识别的分区，切勿格式化</strong>。</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="通过网线共享电脑的网络"><a href="#通过网线共享电脑的网络" class="headerlink" title="通过网线共享电脑的网络"></a>通过网线共享电脑的网络</h4><blockquote><p>设置–&gt;状态–&gt;高级网络设置：更改适配器选项–&gt;选择电脑联网的适配器–&gt;右键选择属性，点击共享–&gt;打开下图中的选项–&gt;选择树莓派要连接的适配器–&gt;确定</p></blockquote><img src="https://images.961110.xyz/images/2021/10/19/2d3ddc0a200c6e2f6386bbfe718cb969.png" alt="image-20211017133126324" style="zoom:50%;" /><p>此种方式的默认的网关 IP 是 192.168.137.1，所以分配给树莓派的 IP 是 192.168.137.XXX ，具体查看方式见下文。</p><h4 id="通过配置WiFi上网"><a href="#通过配置WiFi上网" class="headerlink" title="通过配置WiFi上网"></a>通过配置WiFi上网</h4><p>打开 system-boot 分区名为 network-config 的文件，修改</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">version: 2</span><br><span class="line">ethernets:</span><br><span class="line">  eth0:</span><br><span class="line">    dhcp4: true</span><br><span class="line">    optional: true</span><br><span class="line">wifis:</span><br><span class="line">  wlan0:</span><br><span class="line">    dhcp4: true</span><br><span class="line">    optional: true</span><br><span class="line">    access-points:</span><br><span class="line">      &quot;&lt;network name&gt;&quot;:</span><br><span class="line">        password: &quot;&lt;password&gt;&quot;</span><br></pre></td></tr></table></figure><p>需要注意缩进问题。</p><h3 id="查看树莓派-IP"><a href="#查看树莓派-IP" class="headerlink" title="查看树莓派 IP"></a>查看树莓派 IP</h3><h4 id="通过网线联网，查看树莓派Raspberry-4B的IP"><a href="#通过网线联网，查看树莓派Raspberry-4B的IP" class="headerlink" title="通过网线联网，查看树莓派Raspberry 4B的IP"></a>通过网线联网，查看树莓派Raspberry 4B的IP</h4><p>打开 cmd 或其他 shell 工具，通过<code>arp -a</code>查看本机的 arp 表，找到接口为 192.168.137.1 下的内容</p><p>可以看到树莓派 Raspberry 4B 获得的 IP: 192.168.137.XXX</p><h4 id="通过配置WiFi上网，查看树莓派Raspberry-4B的IP"><a href="#通过配置WiFi上网，查看树莓派Raspberry-4B的IP" class="headerlink" title="通过配置WiFi上网，查看树莓派Raspberry 4B的IP"></a>通过配置WiFi上网，查看树莓派Raspberry 4B的IP</h4><p>进入路由器后台，查看接入网络的设备列表，记录其 IP 即可。</p><p>此处博主通过 Windows 10 开启移动热点，树莓派连接上 WIFI 之后可以直接看到IP地址</p><table>    <tr>        <td ><center><img src="https://images.961110.xyz/images/2021/10/21/Windows10851671f235bebad9.png" alt="image-20211021162217862" ></center></td>        <td ><center><img src="https://images.961110.xyz/images/2021/10/21/Windows104a0509f4c0915e31.png"  ></center></td>    </tr></table><h3 id="系统启动"><a href="#系统启动" class="headerlink" title="系统启动"></a>系统启动</h3><p>开机后需要等10分钟左右，如果没找到 IP ，不要慌，在确保配置无误的情况下，重启树莓派，再等 10 分钟左右去看一下，应该就有了。</p><h3 id="ssh连接"><a href="#ssh连接" class="headerlink" title="ssh连接"></a>ssh连接</h3><p>获取IP后，直接 <code>ssh ubuntu@IP</code> 即可</p><p>密码是 ubuntu，第一次登录会强制更改密码。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="更换软件源"><a href="#更换软件源" class="headerlink" title="更换软件源"></a>更换软件源</h3><p>apt 软件源是 <code>/etc/apt/sources.list</code> 文件，修改 sources.list 前先做个备份，然后填入阿镜像源</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu-ports/ focal main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu-ports/ focal main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu-ports/ focal-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu-ports/ focal-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu-ports/ focal-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu-ports/ focal-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu-ports/ focal-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu-ports/ focal-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu-ports/ focal-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu-ports/ focal-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure><p>清华大学镜像源 <a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu-ports/">在此</a></p><p>更换完毕后，输入</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure><h3 id="将-python-默认设置为-python3"><a href="#将-python-默认设置为-python3" class="headerlink" title="将 python 默认设置为 python3"></a>将 python 默认设置为 python3</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install python-is-python3 python-dev-is-python3</span><br></pre></td></tr></table></figure><h3 id="安装-Cockpit-管理面板"><a href="#安装-Cockpit-管理面板" class="headerlink" title="安装 Cockpit 管理面板"></a>安装 Cockpit 管理面板</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt -y install cockpit</span><br></pre></td></tr></table></figure><p>然后浏览器打开 <strong>服务器IP:9090</strong> 即可访问管理面板</p><p>在这里可以直观的看到 Ubuntu 的运行状态，包括 CPU 使用率、内存使用率、硬盘使用率等。</p><p>详细介绍以及如何设置开机自启可以参考之前的博文 <a href="https://blog.961110.xyz/posts/29824.html">使用 Cockpit 管理你的树莓派</a> </p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://blog.icexmoon.xyz/archives/138.html">https://blog.icexmoon.xyz/archives/138.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/140952829">https://zhuanlan.zhihu.com/p/140952829</a></li><li><a href="https://blog.os7blue.com/article/169">https://blog.os7blue.com/article/169</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> 教程 </tag>
            
            <tag> 配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转载】解除 GitHub 仓库的 Fork 连接</title>
      <link href="/posts/2377.html"/>
      <url>/posts/2377.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址 <a href="https://miroox.github.io/blog/2018/05/2018-5-19-RemoveGitHubFork/">解除 GitHub 仓库的 Fork 连接</a></p></blockquote><p>GitHub 的 Fork 功能实际上主要是服务于 Pull Request，然而我以前并没有正确地认识到这一点，简单地把 Fork 当 clone 使，导致有些时候不太方便。比如生成这个博客的 <a href="https://github.com/miRoox/miRoox.github.io">仓库</a>，以前是直接 Fork <a href="https://github.com/leopardpan/leopardpan.github.io">leopardpan 的博客</a> 得到的。现在我想解除这种 Fork 关系，但同时保留提交的历史。然而在网上却没有找到有关的教程，没办法，只能自己试试。</p><p>实际做起来却意外的简单。</p><p>首先，把删去所有与本地仓库连接的远程仓库</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote remove origin</span><br><span class="line">$ git remote remove upstream</span><br></pre></td></tr></table></figure><p>然后，把 GitHub 上自己的远程仓库给删了。</p><p>最后，在 GitHub 上重新建立同名仓库，然后把本地仓库关联上去。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote add origin &lt;your repo link&gt;</span><br></pre></td></tr></table></figure><p>于是就大功告成了。</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转载】树莓派 SD 卡无损扩容方案——克隆到更大容量的SD卡</title>
      <link href="/posts/11241.html"/>
      <url>/posts/11241.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址 <a href="https://www.jianshu.com/p/a5cfbba49a68">超简单的树莓派SD卡扩容方案，将树莓派16GB的SD卡克隆到64GB的SD卡</a></p></blockquote><p>这段时间，往树莓派装了几个 Docker 镜像之后，16GB 的 SD 卡明显不够用了，于是我打算扩容一下，为了避免从零开始重做系统，我找到了完美克隆 16GB 的 SD 卡 按文件系统结构原样复制到 64GB 卡的方法。以下是具体步骤~</p><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><ul><li>  一台可以同时读写两张 SD 的 Windows 电脑</li><li>  软件 DiskGenius</li></ul><h3 id="在树莓派查看旧-SD-卡容量"><a href="#在树莓派查看旧-SD-卡容量" class="headerlink" title="在树莓派查看旧 SD 卡容量"></a>在树莓派查看旧 SD 卡容量</h3><p>查看旧 SD 卡容量 <code>sudo fdisk -l</code></p><p><img src="https://images.961110.xyz/images/2021/12/17/fdisk--l.png"> </p><h3 id="将树莓派关机"><a href="#将树莓派关机" class="headerlink" title="将树莓派关机"></a>将树莓派关机</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">poweroff</span><br></pre></td></tr></table></figure><p>待 ssh 断开后，等待树莓派灯变红，关闭电源，抽出 SD 卡</p><h3 id="开启-DiskGenius"><a href="#开启-DiskGenius" class="headerlink" title="开启 DiskGenius"></a>开启 DiskGenius</h3><p>绿色版地址:<code>https://frp.v2fy.com/%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D%E8%BD%AF%E4%BB%B6DiskGenius/DiskGenius.zip</code></p><ul><li>  解压后双击运行即可</li></ul><img src="https://images.961110.xyz/images/2021/12/17/3203841-83e0235fd770e26d.png" style="zoom: 67%;" /> <h3 id="将新旧两张-SD-卡插入电脑并读取"><a href="#将新旧两张-SD-卡插入电脑并读取" class="headerlink" title="将新旧两张 SD 卡插入电脑并读取"></a>将新旧两张 SD 卡插入电脑并读取</h3><table>    <tr>        <td ><center><img src="https://images.961110.xyz/images/2021/12/17/16-GB.png" >图1 旧的 16GB 已有数据卡 </center></td>        <td ><center><img src="https://images.961110.xyz/images/2021/12/17/64GB-.png"  >图2 新的 64GB 卡</center></td>    </tr></table>克隆 SD 卡------------<h3 id="打开硬盘工具"><a href="#打开硬盘工具" class="headerlink" title="打开硬盘工具"></a>打开硬盘工具</h3><p>左上角点击工具 ==&gt; 克隆硬盘</p><h3 id="选择源硬盘和目标硬盘"><a href="#选择源硬盘和目标硬盘" class="headerlink" title="选择源硬盘和目标硬盘"></a>选择源硬盘和目标硬盘</h3><table>    <tr>        <td ><center><img src="https://images.961110.xyz/images/2021/12/17/98fa9fe245b7036a4d38fadc16267ad5.png" ></center></td>        <td ><center><img src="https://images.961110.xyz/images/2021/12/17/bac0e91af2c23d1925114f8269b35929.png" style="zoom: 67%"></center></td>    </tr></table><h3 id="开始克隆"><a href="#开始克隆" class="headerlink" title="开始克隆"></a>开始克隆</h3><table>    <tr>        <td ><center><img src="https://images.961110.xyz/images/2021/12/17/41e1eb2fcaec137c4dd69f6c2a423a4f.png" >图1 确认 </center></td>        <td ><center><img src="https://images.961110.xyz/images/2021/12/17/a10afd5d5ed83160c52133550a10eb60.png"  >图2 建立新签名</center></td>    </tr></table><table>    <tr>        <td ><center><img src="https://images.961110.xyz/images/2021/12/17/ede6d149b43a10fc3986a8370e5847d3.png" >图1 等待 </center></td>        <td ><center><img src="https://images.961110.xyz/images/2021/12/17/2aca40e9c6e8122d0b49b1d65df1a39d.png"  >图2 完成</center></td>    </tr></table><img src="https://images.961110.xyz/images/2021/12/17/fd65ba0ed1a774de9126401805566ae0.png" style="zoom: 50%;" /><h2 id="将新卡插入树莓派，开机"><a href="#将新卡插入树莓派，开机" class="headerlink" title="将新卡插入树莓派，开机"></a>将新卡插入树莓派，开机</h2><p>输入 <code>sudo fdisk -l</code></p><img src="https://images.961110.xyz/images/2021/12/17/33846620bd20a90f27e63d227fe83e3b.png" style="zoom:67%;" /><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>树莓派 4B 可以选配 8GB 内存，配上大空间的 SD 空间也显得合理，如果你的树莓派 SD 空间不够用了，欢迎用本文提供的方法扩容，真的是省时省力，如果你想定期为树莓派 SD 卡做备份，本文的方法也是极好的选择。</p><p>如果你有多个同型号的树莓派，用本文的方法克隆旧 SD 卡到其他树莓派的 SD 卡，也能省去大量的树莓派配置时间。</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> 教程 </tag>
            
            <tag> 配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 dlv Debug dockerd(Docker Daemon) 的方法</title>
      <link href="/posts/20654.html"/>
      <url>/posts/20654.html</url>
      
        <content type="html"><![CDATA[<h2 id="使用-dlv-来-Debug-dockerd-Docker-Daemon"><a href="#使用-dlv-来-Debug-dockerd-Docker-Daemon" class="headerlink" title="使用 dlv 来 Debug dockerd(Docker Daemon)"></a>使用 dlv 来 Debug dockerd(Docker Daemon)</h2><h3 id="编译-Docker-Daemon"><a href="#编译-Docker-Daemon" class="headerlink" title="编译 Docker Daemon"></a>编译 Docker Daemon</h3><p>编译 Docker Daemon 的两种方式已经在 <a href="https://blog.961110.xyz/posts/21885.html">前面的博文</a> 中比较详细的说明了。</p><h3 id="安装-dlv"><a href="#安装-dlv" class="headerlink" title="安装 dlv"></a>安装 dlv</h3><p>安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get -u github.com/go-delve/delve/cmd/dlv</span><br></pre></td></tr></table></figure><p>验证是否安装成功，输入 <code>dlv version</code>，安装成功会有如下输出。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Delve Debugger</span><br><span class="line">Version: 1.7.3</span><br><span class="line">Build: <span class="variable">$Id</span>: c532746bc713b05a49680bc8c36b27c72c391a6b $</span><br></pre></td></tr></table></figure><h3 id="编译可-Debug-的-dockerd"><a href="#编译可-Debug-的-dockerd" class="headerlink" title="编译可 Debug 的 dockerd"></a>编译可 Debug 的 dockerd</h3><p>在之前的博文中，没有考虑到编译出的 Docker Daemon 需要调试，所以在用 dlv debug 的时候会报错。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">could not get .debug_frame section: could not find .debug_frame section</span><br></pre></td></tr></table></figure><p>默认情况下在编译 dockerd 的时候会有 <code>-w</code> 参数来关闭 DWARP 调试信息，这样就无法在二进制文件上使用 gdb 的特定功能如设置断点获取堆栈跟踪信息。所以在需要在编译脚本中增加 <code>DOCKER_DEBUG=true</code>，这样在编译时会自动删除 ldflags 中的 <code>-w</code> 参数，具体的修改位置是 <code>/home/jason/GOPATH/src/github.com/docker/docker/hack/make.sh:30</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">set -o pipefail</span><br><span class="line"></span><br><span class="line">export DOCKER_PKG=&#x27;github.com/docker/docker&#x27;</span><br><span class="line">export SCRIPTDIR=&quot;$(cd &quot;$(dirname &quot;$&#123;BASH_SOURCE[0]&#125;&quot;)&quot; &amp;&amp; pwd)&quot;</span><br><span class="line">export MAKEDIR=&quot;$SCRIPTDIR/make&quot;</span><br><span class="line">export PKG_CONFIG=$&#123;PKG_CONFIG:-pkg-config&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 新增的一行</span></span><br><span class="line">export DOCKER_DEBUG=true</span><br><span class="line"></span><br><span class="line">echo</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在 Goland 的远程配置中，根据提示有两种方法来调试 Docker Daemon</p><img src="https://images.961110.xyz/images/2021/12/16/Go-Remote-.png" alt="image-20211216200604227" style="zoom:50%;" /><ol><li>第一种方式是使用 dlv 进而编译，但是需要配置一大堆参数，不太方便。</li><li>第二种方式需要在编译时增加 <code>-gcflags</code> 参数，对应的修改位置是 <code>/home/jason/GOPATH/src/github.com/docker/docker/hack/make/.binary:87</code></li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go build \</span><br><span class="line">-o <span class="string">&quot;<span class="variable">$DEST</span>/<span class="variable">$BINARY_FULLNAME</span>&quot;</span> \</span><br><span class="line"><span class="string">&quot;<span class="variable">$&#123;BUILDFLAGS[@]&#125;</span>&quot;</span> \</span><br><span class="line"><span class="comment"># 增加的一行参数</span></span><br><span class="line">-gcflags <span class="string">&quot;all=-N -l&quot;</span> \</span><br><span class="line">-ldflags <span class="string">&quot;</span></span><br><span class="line"><span class="string"><span class="variable">$LDFLAGS</span></span></span><br><span class="line"><span class="string"><span class="variable">$LDFLAGS_STATIC_DOCKER</span></span></span><br><span class="line"><span class="string"><span class="variable">$DOCKER_LDFLAGS</span></span></span><br><span class="line"><span class="string">&quot;</span> \</span><br><span class="line"><span class="variable">$&#123;GO_PACKAGE&#125;</span></span><br></pre></td></tr></table></figure><p>修改完成后，在 <code>Docker 项目根目录</code> 输入下面命令来手动构建 dockerd 二进制文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">VERSION=test-build DOCKER_GITCOMMIT=1 ./hack/make.sh binary</span><br></pre></td></tr></table></figure><p>构建完成后 cd 到 <code>Docker 项目根目录/bundles/binary-daemon</code> 就可以看到刚刚编译出的文件 dockerd-test-build，并且已经做了软链接。</p><p>理所当然的构建出的 dockerd 会增加一定的体积</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改前</span></span><br><span class="line">总用量 62M</span><br><span class="line">drwxr-xr-x 2 jason root 4.0K 12月 16 19:46 .</span><br><span class="line">drwxr-xr-x 3 jason root 4.0K 12月 16 19:46 ..</span><br><span class="line">lrwxrwxrwx 1 jason root   19 12月 16 19:46 dockerd -&gt; dockerd-jason-build</span><br><span class="line">-rwxr-xr-x 1 jason root  62M 12月 16 19:46 dockerd-jason-build</span><br><span class="line">-rw-r--r-- 1 jason root   54 12月 16 19:46 dockerd-jason-build.md5</span><br><span class="line">-rw-r--r-- 1 jason root   86 12月 16 19:46 dockerd-jason-build.sha256</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改后</span></span><br><span class="line">总用量 79M</span><br><span class="line">drwxr-xr-x 2 jason root 4.0K 12月 16 19:50 .</span><br><span class="line">drwxr-xr-x 3 jason root 4.0K 12月 16 19:50 ..</span><br><span class="line">lrwxrwxrwx 1 jason root   19 12月 16 19:50 dockerd -&gt; dockerd-jason-build</span><br><span class="line">-rwxr-xr-x 1 jason root  79M 12月 16 19:50 dockerd-jason-build</span><br><span class="line">-rw-r--r-- 1 jason root   54 12月 16 19:50 dockerd-jason-build.md5</span><br><span class="line">-rw-r--r-- 1 jason root   86 12月 16 19:50 dockerd-jason-build.sha256</span><br></pre></td></tr></table></figure><h3 id="利用-dlv-开始-debug"><a href="#利用-dlv-开始-debug" class="headerlink" title="利用 dlv 开始 debug"></a>利用 dlv 开始 debug</h3><p>使用下面的命令启动 dockerd，就可以 debug 了</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="variable">$GOPATH</span>/bin/dlv --headless=<span class="literal">true</span> --api-version=2 --<span class="built_in">log</span> --listen=:2345 <span class="built_in">exec</span> ./dockerd -- -D -H unix:// --containerd=/run/containerd/containerd.sock</span><br></pre></td></tr></table></figure><p><strong>–headless=true 表示不要命令界面</strong></p><p>或者使用下面的脚本来 debug 已经在运行的 dockerd</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo &quot;Start to execute dlv_debug script&quot;</span><br><span class="line">echo &quot;===========================================================&quot;</span><br><span class="line">echo</span><br><span class="line"></span><br><span class="line">pid=$(ps -ef | grep &#x27;docker&#x27; | grep &#x27;dockerd&#x27; | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">echo &quot;pid of dockerd is $pid&quot;</span><br><span class="line">echo</span><br><span class="line">echo &#x27;你的密码&#x27; | sudo -S $GOPATH/bin/dlv attach $pid --headless=true --api-version=2 --log --listen=:2345</span><br></pre></td></tr></table></figure><p>dlv 具体的使用方法可以参考其他博主的资料，博文下方有 <a href="http://blog.961110.xyz/posts/20654.html#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a>。</p><h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><p>构建后使用 <code>docker run hello-world</code> 来进行验证，镜像移植拉不下来，错误 log 如下</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">error pulling image configuration: Get https://production.cloudflare.docker.com/registry-</span><br><span class="line">v2/docker/registry/v2/blobs/sha256/d2/d23bdf5b1b1b1afce5f1d0fd33e7ed8afbc084b594b9ccf742a5b27080d8</span><br><span class="line">a4a8/data?verify=1596513158-78B0ocrR%2Bn4iMvUrPrVx12jrGX8%3D: dial tcp 104.18.122.25:443: i/o timeout</span><br></pre></td></tr></table></figure><p>原因是没有配置 docker 源</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 没有的话就新建一个</span></span><br><span class="line">vim /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入以下内容</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;https://hub-mirror.c.163.com&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://registry.aliyuncs.com&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://registry.docker-cn.com&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://liqiang.io/post/remote-debug-go-with-delve-bea7abce">Golang 调试工具 Delve</a></li><li><a href="https://zhuanlan.zhihu.com/p/364346530">Dlv 深入探究</a></li><li><a href="http://www.4k8k.xyz/article/nangonghen/114602755">源码编译docker-ce v18.09.2</a></li><li><a href="https://blog.csdn.net/elvishehai/article/details/107782762">docker run 报错: dial tcp xxxxxxxx:443: i/o timeout报错</a></li><li><a href="https://blog.csdn.net/cyq6239075/article/details/103911098">go build 命令参数详解</a></li><li><a href="https://blog.csdn.net/u010525694/article/details/103111375">dlv远程调试golang程序注意事项</a></li><li><a href="https://github.com/go-delve/delve">delve 官方 Github 链接</a></li><li><a href="https://blog.abnerzhao.com/posts/go-build/">go build 编译优化</a></li><li><a href="https://blog.csdn.net/u013536232/article/details/104123861?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5.highlightwordscore&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5.highlightwordscore">goland远程调试</a></li><li><a href="https://linux.cn/article-12400-1.html">使用 Delve 代替 Println 来调试 Go 程序</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 毕设 </tag>
            
            <tag> Docker </tag>
            
            <tag> 调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转载】Linux 下 golang 多版本管理器</title>
      <link href="/posts/21410.html"/>
      <url>/posts/21410.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址 <a href="https://segmentfault.com/a/1190000019218168">golang 多版本管理器</a></p></blockquote><p><a href="https://link.segmentfault.com/?enc=HGrnxFltecJpZeDIol6ehg==.m1HIrix1OGH/YSkWTzlvyYCMHUI6dAj/Dd5UY7UZjp8=">g</a> 是一个 Linux、macOS、Windows 下的命令行工具，可以提供一个便捷的多版本 <a href="https://link.segmentfault.com/?enc=IiyYZQxxLv1Bxhk2ucPTQg==.DXW2ePczTCYlJBFgRMHx27dSg+tkmQn1stAu5SUZoVw=">go</a> 环境的管理和切换。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>  支持列出可供安装的 go 版本号</li><li>  支持列出已安装的 go 版本号</li><li>  支持在本地安装多个 go 版本</li><li>  支持卸载已安装的 go 版本</li><li>  支持在已安装的 go 版本之间自由切换</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="自动化安装"><a href="#自动化安装" class="headerlink" title="自动化安装"></a>自动化安装</h3><ul><li>Linux/macOS（适用于 bash、zsh）  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 建议安装前清空`GOROOT`、`GOBIN`等环境变量</span></span><br><span class="line">$ wget -qO- https://raw.githubusercontent.com/voidint/g/master/install.sh | bash</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;unalias g&quot;</span> &gt;&gt; ~/.bashrc <span class="comment"># 可选。若其他程序（如&#x27;git&#x27;）使用了&#x27;g&#x27;作为别名。</span></span><br><span class="line">$ <span class="built_in">source</span> ~/.bashrc <span class="comment"># 或者 source ~/.zshrc</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h3><ul><li>  下载对应平台的<a href="https://link.segmentfault.com/?enc=1prd848WenP4l5j4FgFq5w==.mBCUO/9ZDtMAf0MIaGfmljqdRHlA0KMyZoRySI96DBuwp4N7/esQ11/PWJWlkGfD">二进制压缩包</a>。</li><li>  将压缩包解压至<code>PATH</code>环境变量目录下，如<code>/usr/local/bin</code>。</li><li>编辑 shell 环境配置文件（<code>~/.bashrc</code>、<code>~/.zshrc</code>…）  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat&gt;&gt;~/.bashrc&lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">export GOROOT=&quot;$&#123;HOME&#125;/.g/go&quot;</span></span><br><span class="line"><span class="string">export PATH=&quot;$&#123;HOME&#125;/.g/go/bin:$PATH&quot;</span></span><br><span class="line"><span class="string">export G_MIRROR=https://golang.google.cn/dl/</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>查询当前可供安装的<code>stable</code>状态的 go 版本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ g ls-remote stable</span><br><span class="line">1.11.9</span><br><span class="line">1.12.4</span><br></pre></td></tr></table></figure><p>安装目标 go 版本<code>1.12.4</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ g install 1.12.4</span><br><span class="line">Installed successfully</span><br><span class="line">$ go version</span><br><span class="line">go version go1.12.4 darwin/amd64</span><br></pre></td></tr></table></figure><p>查询已安装的 go 版本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ g ls</span><br><span class="line">1.12.4</span><br></pre></td></tr></table></figure><p>查询可供安装的所有 go 版本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ g ls-remote</span><br><span class="line">1.2.2</span><br><span class="line">1.3</span><br><span class="line">1.3.1</span><br><span class="line">...    // 省略若干版本</span><br><span class="line">1.11.7</span><br><span class="line">1.11.8</span><br><span class="line">1.11.9</span><br><span class="line">1.12</span><br><span class="line">1.12.1</span><br><span class="line">1.12.2</span><br><span class="line">1.12.3</span><br><span class="line">1.12.4</span><br></pre></td></tr></table></figure><p>安装目标 go 版本<code>1.11.9</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ g install 1.11.9</span><br><span class="line">Installed successfully</span><br><span class="line">$ go version</span><br><span class="line">go version go1.11.9 darwin/amd64</span><br></pre></td></tr></table></figure><p>切换到另一个已安装的 go 版本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ g ls</span><br><span class="line">1.11.9</span><br><span class="line">1.12.4</span><br><span class="line">$ g use 1.12.4</span><br><span class="line">go version go1.12.4 darwin/amd64</span><br></pre></td></tr></table></figure><p>卸载一个已安装的 go 版本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g uninstall 1.11.9</span><br><span class="line">Uninstall successfully</span><br></pre></td></tr></table></figure><h3 id="将-GOPATH-bin-添加到路径中"><a href="#将-GOPATH-bin-添加到路径中" class="headerlink" title="将 GOPATH/bin 添加到路径中"></a>将 GOPATH/bin 添加到路径中</h3><p>在 ~/.bashrc 或 ~/.zshrc 中增加下面几行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> GO</span></span><br><span class="line">export GOPATH=$HOME/go</span><br><span class="line">export PATH=$PATH:$GOROOT/bin:$GOPATH/bin</span><br></pre></td></tr></table></figure><p>GOPATH 和 GOROOT 都使用 go env 这个命令列出，修改对应路径即可。</p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ul><li>环境变量<code>G_MIRROR</code>有什么作用？  由于中国大陆无法自由访问 Golang 官网，导致查询及下载 go 版本都变得困难，因此可以通过该环境变量指定一个镜像站点（如<code>https://golang.google.cn/dl/</code>），g 将从该站点查询、下载可用的 go 版本。</li><li>支持源代码编译安装吗？  不支持</li></ul><h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><p>感谢 <a href="https://link.segmentfault.com/?enc=N4GmxCVmZsTbV6ul2dbu6A==.ibICcM7AsQynCM9wvSSnd0hyzBSz7cUkXf2H0GnB2Uo=">nvm</a>、<a href="https://link.segmentfault.com/?enc=ozQgme1W/tphsjjlX6NUsQ==.rsDgyfwAd7LfvIObBX2T4Ip7seZDRvdZhVXlgJBXRQU=">n</a>、<a href="https://link.segmentfault.com/?enc=FZndRW4e132UcOeEC1dI4g==.Qf1sRTAYRHRpU1qlvz8KrZMKdR32Uc+Mb/EXu/0sg1M=">rvm</a> 等工具提供的宝贵思路。</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决 Windows 10 电池模式下屏幕亮度低色彩泛白的问题</title>
      <link href="/posts/2083.html"/>
      <url>/posts/2083.html</url>
      
        <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>博主用的电脑是美帝良心想的小新 Pro 14 Intel 1135G7 带 MX450 独显的版本，后期自己安装了 Windows 10 专业版，但是发现在不插电源使用电池的情况下，屏幕的亮度会变低而且会泛白，手动将亮度调低再调到最高可以暂时解决问题，但是前面的问题会复现。</p><h2 id="Intel-版解决办法"><a href="#Intel-版解决办法" class="headerlink" title="Intel 版解决办法"></a>Intel 版解决办法</h2><p>左下角搜索英特尔显卡控制中心。</p><table>    <tr>        <td ><center><img src="https://images.961110.xyz/images/2021/12/07/602d06e942c9ac1b8e93a1b3e37725e3.png" >图1 搜索因特尔 </center></td>        <td ><center><img src="https://images.961110.xyz/images/2021/12/06/1bf9cddb5b2938df966452ff19fee278.png" style="zoom:50%;"  >图2 英特尔显卡控制中心</center></td>    </tr></table><p>打开系统界面，<strong>关闭显示器节能的选项，关闭面板自刷新选项</strong>。</p><img src="https://images.961110.xyz/images/2021/12/07/48bd8d03592568d99fbe608353d0c5c1.png" alt="image-20211207111254144" style="zoom:50%;" /><p>通过上面的方法应该可以解决问题。</p><h2 id="AMD-版解决办法"><a href="#AMD-版解决办法" class="headerlink" title="AMD 版解决办法"></a>AMD 版解决办法</h2><p>AMD 版解决办法来源于 <a href="https://blog.csdn.net/m0_46552496/article/details/119822436">联想笔记本拔掉电源后屏幕发白、泛白，对比度降低</a> ，就不再搬运了。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://blog.csdn.net/m0_46552496/article/details/119822436">联想笔记本拔掉电源后屏幕发白、泛白，对比度降低</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Windows 10 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 日志管理机制</title>
      <link href="/posts/53979.html"/>
      <url>/posts/53979.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>容器技术带来了许多便利，例如应用程序部署和分发。它还为日志处理带来了许多挑战，包括：</p><ol><li>如果将日志保存在容器中，则在删除容器时日志将消失。容器的生命周期比虚拟机短得多，因为容器是经常创建和删除的。因此，您需要找到一种永久保存日志的方法。</li><li>在容器时代，要管理的对象比虚拟机和物理机更多。登录到目标容器并解决问题，这使问题变得复杂并增加了成本。</li><li>使用容器技术，可以更轻松地实现微服务。当它与系统分离时，会带来更多的组件。</li></ol><p>我们需要技术来全面了解系统的运行状态，快速发现问题并准确还原上下文。</p><h2 id="Docker-日志管理机制"><a href="#Docker-日志管理机制" class="headerlink" title="Docker 日志管理机制"></a>Docker 日志管理机制</h2><p>Docker 作为 system service 启动，其本身的日志可以通过 <code>sudo journalctl -u docker</code> 命令来查看。容器的日志管理则是通过 Docker 的 logging driver 实现的，获取的是容器标准输出和标准错误输出的内容。获取到了日志信息，当然需要有输出的目的地，所以就有了下面的 12 种日志驱动。</p><img src="https://images.961110.xyz/images/2021/12/07/Docker-.png" style="zoom:50%;" /><h3 id="logging-driver"><a href="#logging-driver" class="headerlink" title="logging driver"></a>logging driver</h3><p>Docker 目前一共支持 12 种日志驱动。</p><table><thead><tr><th>Driver</th><th>Description</th></tr></thead><tbody><tr><td><code>none</code></td><td>不输出任何容器日志，相当于是禁用容器日志。</td></tr><tr><td><a href="https://docs.docker.com/config/containers/logging/local/"><code>local</code></a></td><td>为了最小化记录日志的代价，以自定义的格式存储 log。</td></tr><tr><td><a href="https://docs.docker.com/config/containers/logging/json-file/"><code>json-file</code></a></td><td>Docker 默认的日志驱动，以 JSON 格式保存日志。</td></tr><tr><td><a href="https://docs.docker.com/config/containers/logging/syslog/"><code>syslog</code></a></td><td>Linux 上的日志管理服务，需要 syslog 守护程序 running。</td></tr><tr><td><a href="https://docs.docker.com/config/containers/logging/journald/"><code>journald</code></a></td><td>Linux 上的日志管理服务，需要 journald 守护程序 running。</td></tr><tr><td><a href="https://docs.docker.com/config/containers/logging/gelf/"><code>gelf</code></a></td><td>开源的日志管理方案，以 Graylog Extended Log Format (GELF) 格式输出到例如 Graylog、Logstash 等终端节点。</td></tr><tr><td><a href="https://docs.docker.com/config/containers/logging/fluentd/"><code>fluentd</code></a></td><td>开源的日志管理方案，将日志写入 fluentd，其守护程序必须在主机上运行。</td></tr><tr><td><a href="https://docs.docker.com/config/containers/logging/awslogs/"><code>awslogs</code></a></td><td>第三方日志托管服务，Amazon CloudWatch Logs</td></tr><tr><td><a href="https://docs.docker.com/config/containers/logging/splunk/"><code>splunk</code></a></td><td>第三方日志托管服务，通过HTTP Event Collector将日志写入splunk。</td></tr><tr><td><a href="https://docs.docker.com/config/containers/logging/etwlogs/"><code>etwlogs</code></a></td><td>将日志作为ETW（Event Tracing for Windows）事件写入，只在Windows平台可用。</td></tr><tr><td><a href="https://docs.docker.com/config/containers/logging/gcplogs/"><code>gcplogs</code></a></td><td>第三方日志托管服务，将日志写入 Google Cloud Platform (GCP) Logging</td></tr><tr><td><a href="https://docs.docker.com/config/containers/logging/logentries/"><code>logentries</code></a></td><td>第三方日志托管服务，将日志写入Rapid7 Logentries。</td></tr></tbody></table><p>在 Docker Engine 19.03 以及之前的版本中，<code>docker log</code>这个命令只支持 local、json-file 和 journald 三个 logging driver，Docker 20.10 通过 <strong>dual logging</strong> 实现了该命令对任意 logging driver 的支持。查看详情：<a href="https://docs.docker.com/config/containers/logging/dual-logging/">Use docker logs with remote logging drivers</a></p><h3 id="json-file"><a href="#json-file" class="headerlink" title="json-file"></a>json-file</h3><p>json-file 是 Docker 默认的日志驱动，除非在启动时指定日志驱动（<code>docker run -d --log-driver=syslog ......</code>），可以通过 <code>docker info | grep &quot;&quot;Logging Driver</code> 来确认。</p><p>Docker Root 目录是 <code>/var/lib/docker</code>，所以容器日志对应的目录是 <code>/var/lib/docker/containers/&lt;container-id&gt;/&lt;container-id&gt;-json.log</code></p><p>也可以通过 <code>docker inspect &lt;container-id&gt; | grep &quot;LogPath&quot;</code>来快速查看。</p><p>json-file 将日志的每一行封装到一个 JSON 串中，因此像 Java 的异常栈日志将会被拆分为多条 JSON ，在处理的时候可能需要做合并。</p><h2 id="Docker-原生健康检查能力"><a href="#Docker-原生健康检查能力" class="headerlink" title="Docker 原生健康检查能力"></a>Docker 原生健康检查能力</h2><p>通过在 Dockerfile 中使用<code>HEALTHCHECK</code>指令对容器的运行状态进行检查，可以指定容器初始化时间、检查状态的时间间隔、服务超时时间、重试次数，例：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">HEALTHCHECK</span><span class="bash"> --interval=5m --timeout=3s \</span></span><br><span class="line"><span class="bash">  CMD curl -f http://localhost/ || <span class="built_in">exit</span> 1</span></span><br></pre></td></tr></table></figure><p>每五分钟左右检查一次 web 服务器是否能在三秒内为站点的主页提供服务。</p><p>容器的健康状态都会存储在容器状态文件中。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://www.codenong.com/db9e4f1d8ec766d4bbc4/">容器日志记录的技术最佳实践：Docker 案例研究</a></li><li><a href="https://segmentfault.com/a/1190000039073943">Docker 容器健康检查</a></li><li><a href="https://www.cnblogs.com/edisonchou/p/docker_logs_study_summary_part1.html">你必须知道的容器日志 (1) Docker logs &amp; logging driver</a></li><li><a href="https://www.codenong.com/db9e4f1d8ec766d4bbc4/">容器日志记录的技术最佳实践：Docker案例研究</a></li><li><a href="https://www.cnblogs.com/operationhome/p/10907591.html">Docker容器日志管理最佳实践</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 毕设 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker源码分析（十一）—— 命令 docker rm 的执行</title>
      <link href="/posts/24743.html"/>
      <url>/posts/24743.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>博文分析的 Docker 源码基于 19.03 版本，阅读工具采用 Goland，追踪的是<code>docker rm</code>命令的执行过程。</p><p>第一次阅读 Docker 源码，如有纰漏还请轻喷，喷完希望能够通过邮件或者留言的方式指出问题。</p><p>限于篇幅以及关注重点的原因，部分个人认为不重要的代码会用省略号代替。</p><p>Tips: 如果图片看不清楚可以点击查看大图。</p></blockquote><h2 id="Docker-Client"><a href="#Docker-Client" class="headerlink" title="Docker Client"></a>Docker Client</h2><p>分析的命令越多，越会发现在 Docker Client 这一端中各个命令的实现都基本一样。</p><p>调用链路是 <code>main() --&gt; runDocker() --&gt; newDockerCommand() --&gt; AddCommands() --&gt; cmd.AddCommand() --&gt; container.NewContainerCommand() --&gt; cmd.AddCommand() --&gt; NewRmCommand() --&gt; runRm() --&gt; Client.ContainerRemove()</code></p><p><code>runRm()</code>并行地处理多个容器的 remove 操作，<code>Client.ContainerRemove()</code>向 Daemon 发送  delete 请求：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">resp, err := cli.<span class="built_in">delete</span>(ctx, <span class="string">&quot;/containers/&quot;</span>+containerID, query, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>这一点跟之前分析过的命令不太一样，之前都是 post 请求，<strong>现在成了 delete 请求</strong>。</p><h2 id="Docker-Daemon"><a href="#Docker-Daemon" class="headerlink" title="Docker Daemon"></a>Docker Daemon</h2><p>和 Docker Client 一样，docker rm 对应的路由表项成了</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">router.NewDeleteRoute(<span class="string">&quot;/containers/&#123;name:.*&#125;&quot;</span>, r.deleteContainers)</span><br></pre></td></tr></table></figure><p>调用 Daemon.ContainerRm() 进一步处理。</p><h3 id="Daemon-ContainerRm"><a href="#Daemon-ContainerRm" class="headerlink" title="Daemon.ContainerRm()"></a>Daemon.ContainerRm()</h3><p>daemon/delete.go: 22</p><img src="https://images.961110.xyz/images/2021/12/03/Daemon.ContainerRmd5e2dae272462ae7.png" style="zoom:50%;" /><p>上面一部分都是一些特殊情况判断，核心函数是 <code>daemon.cleanupContainer()</code></p><h3 id="Daemon-cleanupContainer"><a href="#Daemon-cleanupContainer" class="headerlink" title="Daemon.cleanupContainer()"></a>Daemon.cleanupContainer()</h3><p>daemon/delete.go: 79</p><p><code>Daemon.cleanupContainer()</code>主要是进行容器被 rm 的善后操作。代码比较长，可能先看一下图更好理解一点。</p><img src="https://images.961110.xyz/images/2021/12/03/Daemon.cleanupContainerc4ffc1952d4830a7.png" style="zoom:50%;" /><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(daemon *Daemon)</span> <span class="title">cleanupContainer</span><span class="params">(container *container.Container, forceRemove, removeVolume <span class="keyword">bool</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 首先判断容器是否正在 running</span></span><br><span class="line"><span class="keyword">if</span> container.IsRunning() &#123;</span><br><span class="line">        <span class="comment">// 正在 running，如果不能强行 remove 的话就需要抛出错误</span></span><br><span class="line"><span class="keyword">if</span> !forceRemove &#123;</span><br><span class="line">state := container.StateString()</span><br><span class="line">procedure := <span class="string">&quot;Stop the container before attempting removal or force remove&quot;</span></span><br><span class="line"><span class="keyword">if</span> state == <span class="string">&quot;paused&quot;</span> &#123;</span><br><span class="line">procedure = <span class="string">&quot;Unpause and then &quot;</span> + strings.ToLower(procedure)</span><br><span class="line">&#125;</span><br><span class="line">err := fmt.Errorf(<span class="string">&quot;You cannot remove a %s container %s. %s&quot;</span>, state, container.ID, procedure)</span><br><span class="line"><span class="keyword">return</span> errdefs.Conflict(err)</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 可以强制 remove，就先 kill 容器</span></span><br><span class="line"><span class="keyword">if</span> err := daemon.Kill(container); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;Could not kill running container %s, cannot remove - %v&quot;</span>, container.ID, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断容器的操作系统是否被 host 所支持</span></span><br><span class="line"><span class="keyword">if</span> !system.IsOSSupported(container.OS) &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;cannot remove %s: %s &quot;</span>, container.ID, system.ErrNotSupportedOperatingSystem)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// stop collection of stats for the container regardless</span></span><br><span class="line"><span class="comment">// if stats are currently getting collected.</span></span><br><span class="line"><span class="comment">// 关闭所有订阅了容器状态的订阅者的 channels，删除对应配置</span></span><br><span class="line">daemon.statsCollector.StopCollection(container)</span><br><span class="line"><span class="comment">// 不是 running 状态，也有可能是 pause 等状态，也需要先 stop</span></span><br><span class="line"><span class="keyword">if</span> err = daemon.containerStop(container, <span class="number">3</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 把容器状态保存到磁盘中，这样容器元数据文件删除前发生错误的话重启 docker 也不会让该容器重新启动起来。</span></span><br><span class="line"><span class="keyword">if</span> err := container.CheckpointTo(daemon.containersReplica); err != <span class="literal">nil</span> &amp;&amp; !os.IsNotExist(err) &#123;</span><br><span class="line">logrus.Errorf(<span class="string">&quot;Error saving dying container to disk: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">container.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// When container creation fails and `RWLayer` has not been created yet, we</span></span><br><span class="line"><span class="comment">// do not call `ReleaseRWLayer`</span></span><br><span class="line"><span class="keyword">if</span> container.RWLayer != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 如果容器有读写层，就需要释放</span></span><br><span class="line">err := daemon.imageService.ReleaseLayer(container.RWLayer, container.OS)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">err = errors.Wrapf(err, <span class="string">&quot;container %s&quot;</span>, container.ID)</span><br><span class="line">container.SetRemovalError(err)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">container.RWLayer = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 确保容器的 home 目录下所有内容已移除</span></span><br><span class="line"><span class="keyword">if</span> err := system.EnsureRemoveAll(container.Root); err != <span class="literal">nil</span> &#123;</span><br><span class="line">e := errors.Wrapf(err, <span class="string">&quot;unable to remove filesystem for %s&quot;</span>, container.ID)</span><br><span class="line">container.SetRemovalError(e)</span><br><span class="line"><span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 删除所有和指定容器相关的容器间的链接</span></span><br><span class="line">linkNames := daemon.linkIndex.<span class="built_in">delete</span>(container)</span><br><span class="line"><span class="comment">// 一些清理操作</span></span><br><span class="line">selinuxFreeLxcContexts(container.ProcessLabel)</span><br><span class="line">daemon.idIndex.Delete(container.ID)</span><br><span class="line">daemon.containers.Delete(container.ID)</span><br><span class="line">daemon.containersReplica.Delete(container)</span><br><span class="line"><span class="comment">// 移除容器的所有挂载点</span></span><br><span class="line"><span class="keyword">if</span> e := daemon.removeMountPoints(container, removeVolume); e != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.Error(e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放容器相关的所有别名</span></span><br><span class="line"><span class="keyword">for</span> _, name := <span class="keyword">range</span> linkNames &#123;</span><br><span class="line">daemon.releaseName(name)</span><br><span class="line">&#125;</span><br><span class="line">container.SetRemoved()</span><br><span class="line">stateCtr.del(container.ID)</span><br><span class="line"></span><br><span class="line">daemon.LogContainerEvent(container, <span class="string">&quot;destroy&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>daemon.statsCollector.StopCollection(container)</code>这一句中的 <code>statsCollector</code> 的结构体如下</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Collector <span class="keyword">struct</span> &#123;</span><br><span class="line">m          sync.Mutex</span><br><span class="line">cond       *sync.Cond</span><br><span class="line">supervisor supervisor</span><br><span class="line">interval   time.Duration</span><br><span class="line">publishers <span class="keyword">map</span>[*container.Container]*pubsub.Publisher</span><br><span class="line">bufReader  *bufio.Reader</span><br><span class="line"></span><br><span class="line"><span class="comment">// The following fields are not set on Windows currently.</span></span><br><span class="line">clockTicksPerSecond <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该是负责管理和提供容器状态的类，<code>publishers</code>负责向容器状态订阅者推送状态信息。</p><h3 id="daemon-imageService-ReleaseLayer"><a href="#daemon-imageService-ReleaseLayer" class="headerlink" title="daemon.imageService.ReleaseLayer()"></a>daemon.imageService.ReleaseLayer()</h3><p>daemon/images/service.go: 182</p><p>这个函数会在 rm 容器或者 export 容器的时候调用，主要是调用 <code>layerStore.ReleaseRWLayer()</code> 进一步释放读写层。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *ImageService)</span> <span class="title">ReleaseLayer</span><span class="params">(rwlayer layer.RWLayer, containerOS <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   metadata, err := i.layerStores[containerOS].ReleaseRWLayer(rwlayer)</span><br><span class="line">   layer.LogReleaseMetadata(metadata)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err != layer.ErrMountDoesNotExist &amp;&amp; !os.IsNotExist(errors.Cause(err)) &#123;</span><br><span class="line">      <span class="keyword">return</span> errors.Wrapf(err, <span class="string">&quot;driver %q failed to remove root filesystem&quot;</span>,</span><br><span class="line">         i.layerStores[containerOS].DriverName())</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="layerStore-ReleaseRWLayer"><a href="#layerStore-ReleaseRWLayer" class="headerlink" title="layerStore.ReleaseRWLayer()"></a>layerStore.ReleaseRWLayer()</h3><p>layer/layer_store.go: 587</p><p>这个函数直接看图吧，在看的时候发现还需要多补充下镜像相关的知识。</p><img src="https://images.961110.xyz/images/2021/12/04/layerStore.ReleaseRWLayer.png" style="zoom:50%;" /><h2 id="docker-rm-命令执行过程"><a href="#docker-rm-命令执行过程" class="headerlink" title="docker rm 命令执行过程"></a>docker rm 命令执行过程</h2><p><img src="https://images.961110.xyz/images/2021/12/04/docker-rm-.png"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>无</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 毕设 </tag>
            
            <tag> Docker </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker源码分析（十）—— 命令 docker unpause 的执行</title>
      <link href="/posts/49360.html"/>
      <url>/posts/49360.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>博文分析的 Docker 源码基于 19.03 版本，阅读工具采用 Goland，追踪的是<code>docker unpause</code>命令的执行过程。</p><p>第一次阅读 Docker 源码，如有纰漏还请轻喷，喷完希望能够通过邮件或者留言的方式指出问题。</p><p>限于篇幅以及关注重点的原因，部分个人认为不重要的代码会用省略号代替。</p><p>Tips: 如果图片看不清楚可以点击查看大图。</p></blockquote><h2 id="Docker-Client"><a href="#Docker-Client" class="headerlink" title="Docker Client"></a>Docker Client</h2><p>分析的命令越多，越会发现在 Docker Client 这一端中各个命令的实现都基本一样。</p><p>调用链路是 <code>main() --&gt; runDocker() --&gt; newDockerCommand() --&gt; AddCommands() --&gt; cmd.AddCommand() --&gt; container.NewContainerCommand() --&gt; cmd.AddCommand() --&gt; NewUnpauseCommand() --&gt; runUnpause() --&gt; Client.ContainerUnpause()</code></p><p><code>runUnpause()</code>并行地处理多个容器的 unpause 操作，<code>Client.ContainerUnpause()</code>向 Daemon 发送 unpause 请求：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">resp, err := cli.post(ctx, <span class="string">&quot;/containers/&quot;</span>+containerID+<span class="string">&quot;/unpause&quot;</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><h2 id="Docker-Daemon"><a href="#Docker-Daemon" class="headerlink" title="Docker Daemon"></a>Docker Daemon</h2><p>和前面的几篇一样，直接分析 unpause 路由表项对应的处理函数 <code>containerRouter.postContainersUnpause()</code>，估计和 pause 命令的执行过程正好反过来了。</p><h3 id="containerRouter-postContainersUnpause"><a href="#containerRouter-postContainersUnpause" class="headerlink" title="containerRouter.postContainersUnpause()"></a>containerRouter.postContainersUnpause()</h3><p>api/server/router/container/container_routes.go: 307</p><p>老一套，上图。</p><img src="https://images.961110.xyz/images/2021/12/02/containerRouter.postContainersUnpause.png" style="zoom:50%;" /><p>调用的核心的处理函数 <code>Daemon.containerUnpause()</code></p><h3 id="Daemon-containerUnpause"><a href="#Daemon-containerUnpause" class="headerlink" title="Daemon.containerUnpause()"></a>Daemon.containerUnpause()</h3><p>daemon/unpause.go: 21</p><p>从这个函数的代码来看，比 docker pause 的还要好理解</p><p>直接看图吧</p><img src="https://images.961110.xyz/images/2021/12/02/Daemon.containerUnpause.png" style="zoom:50%;" /><p>其中 <code>daemon.containerd.Resume(context.Background(), container.ID)</code> 这个操作和 <a href="https://blog.961110.xyz/posts/52812.html#client-Pause">Docker源码分析（九）—— 命令 docker pause 的执行</a> 中的流程都是一个意思，等拓展了 containerd 相关的知识后再补充。</p><h2 id="docker-unpause-命令执行过程"><a href="#docker-unpause-命令执行过程" class="headerlink" title="docker unpause 命令执行过程"></a>docker unpause 命令执行过程</h2><img src="https://images.961110.xyz/images/2021/12/02/docker-unpause-.png" style="zoom:50%;" /><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>无</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 毕设 </tag>
            
            <tag> Docker </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker源码分析（九）—— 命令 docker pause 的执行</title>
      <link href="/posts/52812.html"/>
      <url>/posts/52812.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>博文分析的 Docker 源码基于 19.03 版本，阅读工具采用 Goland，追踪的是<code>docker pause</code>命令的执行过程。</p><p>第一次阅读 Docker 源码，如有纰漏还请轻喷，喷完希望能够通过邮件或者留言的方式指出问题。</p><p>限于篇幅以及关注重点的原因，部分个人认为不重要的代码会用省略号代替。</p><p>Tips: 如果图片看不清楚可以点击查看大图。</p></blockquote><h2 id="Docker-Client"><a href="#Docker-Client" class="headerlink" title="Docker Client"></a>Docker Client</h2><p>废话都不说了，上调用链路：</p><p><code>main() --&gt; runDocker() --&gt; newDockerCommand() --&gt; AddCommands() --&gt; cmd.AddCommand() --&gt; container.NewContainerCommand() --&gt; cmd.AddCommand() --&gt; NewPauseCommand() --&gt; runPause() --&gt; Client.ContainerPause()</code></p><p><code>runPause()</code>并行地处理多个容器的 pause 操作，<code>Client.ContainerPause()</code>向 Daemon 发送 pause 请求：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">resp, err := cli.post(ctx, <span class="string">&quot;/containers/&quot;</span>+containerID+<span class="string">&quot;/pause&quot;</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><h2 id="Docker-Daemon"><a href="#Docker-Daemon" class="headerlink" title="Docker Daemon"></a>Docker Daemon</h2><p>和前面的几篇一样，直接分析 pause 路由表项对应的处理函数 <code>containerRouter.postContainersRestart()</code></p><p>这个函数位于 api/server/router/container/container_routes.go: 293，简单到已经不用上图不用上代码的程度了，作用：</p><ol><li>解析请求的表单</li><li>调用 <code>Daemon.ContainerPause()</code> 进一步处理</li></ol><p> <code>Daemon.ContainerPause()</code>也是同样的简单，作用：</p><ol><li>根据传入参数获取指定容器的结构体对象</li><li>调用 <code>Daemon.containerPause()</code> 进一步处理</li></ol><h3 id="Daemon-containerPause"><a href="#Daemon-containerPause" class="headerlink" title="Daemon.containerPause()"></a>Daemon.containerPause()</h3><p>daemon/pause.go: 22</p><p>这个函数整体来说是比较容易理解的，甚至都不需要做解释。先判断容器不能被 pause 的各种可能的状态，然后再通知 containerd 去 pause 容器，接着更新容器的相关状态，最后将容器状态保存到磁盘中。</p><p><strong>code</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(daemon *Daemon)</span> <span class="title">containerPause</span><span class="params">(container *container.Container)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">container.Lock()</span><br><span class="line"><span class="keyword">defer</span> container.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// We cannot Pause the container which is not running</span></span><br><span class="line"><span class="keyword">if</span> !container.Running &#123;</span><br><span class="line"><span class="keyword">return</span> errNotRunning(container.ID)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We cannot Pause the container which is already paused</span></span><br><span class="line"><span class="keyword">if</span> container.Paused &#123;</span><br><span class="line"><span class="keyword">return</span> errNotPaused(container.ID)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We cannot Pause the container which is restarting</span></span><br><span class="line"><span class="keyword">if</span> container.Restarting &#123;</span><br><span class="line"><span class="keyword">return</span> errContainerIsRestarting(container.ID)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := daemon.containerd.Pause(context.Background(), container.ID); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;Cannot pause container %s: %s&quot;</span>, container.ID, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">container.Paused = <span class="literal">true</span></span><br><span class="line">daemon.setStateCounter(container)</span><br><span class="line">daemon.updateHealthMonitor(container)</span><br><span class="line">daemon.LogContainerEvent(container, <span class="string">&quot;pause&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := container.CheckpointTo(daemon.containersReplica); err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.WithError(err).Warn(<span class="string">&quot;could not save container to disk&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>见下图</p><img src="https://images.961110.xyz/images/2021/12/02/Daemon.containerPause.png" style="zoom: 50%;" /><p>如果这个命令分析到这里就结束，那这篇博文看起来挺水的，所以接着 <code>daemon.containerd.Pause()</code> 往下看看 containerd 的执行。</p><h3 id="client-Pause"><a href="#client-Pause" class="headerlink" title="client.Pause()"></a>client.Pause()</h3><p>libcontainerd/remote/client.go: 335</p><p>从调用路径可以看出已经在 libcontainerd 的范围内了，先看看架构图唤醒一下记忆。</p><img src="https://images.961110.xyz/images/2021/11/16/Docker.png" style="zoom: 50%;" /><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *client)</span> <span class="title">Pause</span><span class="params">(ctx context.Context, containerID <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">p, err := c.getProcess(ctx, containerID, libcontainerdtypes.InitProcessName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> wrapError(p.(containerd.Task).Pause(ctx))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的代码比较简短，就两个作用</p><ol><li><p>获取指定容器对应的 init 进程。</p><p><code>p, err := c.getProcess(ctx, containerID, libcontainerdtypes.InitProcessName)</code></p><p>这里的 c 是 remote 包下的一个客户端，实现如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> client <span class="keyword">struct</span> &#123;</span><br><span class="line">   client   *containerd.Client</span><br><span class="line">   stateDir <span class="keyword">string</span></span><br><span class="line">   logger   *logrus.Entry</span><br><span class="line">   ns       <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">   backend libcontainerdtypes.Backend</span><br><span class="line">   eventQ  queue.Queue</span><br><span class="line">   oomMu   sync.Mutex</span><br><span class="line">   oom     <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包含了 containerd 的客户端以及一些配置，<code>libcontainerdtypes.Backend</code>指的是 Docker Daemon。</p><p>process 的结构体实现如下</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> process <span class="keyword">struct</span> &#123;</span><br><span class="line">id   <span class="keyword">string</span></span><br><span class="line">task *task</span><br><span class="line">pid  <span class="keyword">uint32</span></span><br><span class="line">io   cio.IO</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>task 的结构体实现如下</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> task <span class="keyword">struct</span> &#123;</span><br><span class="line">client *Client</span><br><span class="line"></span><br><span class="line">io  cio.IO</span><br><span class="line">id  <span class="keyword">string</span></span><br><span class="line">pid <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 Client 指的是 containerd 与其各种服务交互的客户端</p></li><li><p>开启 Pause 任务 <code>p.(containerd.Task).Pause(ctx)</code></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *task)</span> <span class="title">Pause</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">_, err := t.client.TaskService().Pause(ctx, &amp;tasks.PauseTaskRequest&#123;</span><br><span class="line">ContainerID: t.id,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> errdefs.FromGRPC(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>t.client.TaskService()</code>这里返回的是底层的 TasksClient，然后发送 pause 请求</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *tasksClient)</span> <span class="title">Pause</span><span class="params">(ctx context.Context, in *PauseTaskRequest, opts ...grpc.CallOption)</span> <span class="params">(*types1.Empty, error)</span></span> &#123;</span><br><span class="line">out := <span class="built_in">new</span>(types1.Empty)</span><br><span class="line">err := c.cc.Invoke(ctx, <span class="string">&quot;/containerd.services.tasks.v1.Tasks/Pause&quot;</span>, in, out, opts...)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> out, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>在看 containerd 的代码的时候，因为不太了解其工作原理，所以看的时候比较难理解，深入不下去了，等了解了之后再往下看。</p><h2 id="docker-pause-命令的执行过程"><a href="#docker-pause-命令的执行过程" class="headerlink" title="docker pause 命令的执行过程"></a>docker pause 命令的执行过程</h2><img src="https://images.961110.xyz/images/2021/12/02/docker-pause-2bba1dc72b343bec.png" style="zoom: 40%;" /><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>无</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 毕设 </tag>
            
            <tag> Docker </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker源码分析（八）—— 命令 docker restart 的执行</title>
      <link href="/posts/20332.html"/>
      <url>/posts/20332.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>博文分析的 Docker 源码基于 19.03 版本，阅读工具采用 Goland，追踪的是<code>docker restart</code>命令的执行过程。</p><p>第一次阅读 Docker 源码，如有纰漏还请轻喷，喷完希望能够通过邮件或者留言的方式指出问题。</p><p>限于篇幅以及关注重点的原因，部分个人认为不重要的代码会用省略号代替。</p><p>Tips: 如果图片看不清楚可以点击查看大图。</p></blockquote><h2 id="Docker-Client"><a href="#Docker-Client" class="headerlink" title="Docker Client"></a>Docker Client</h2><p>分析的命令越多，越会发现在 Docker Client 这一端中各个命令的实现都基本一样。</p><p>调用链路是 <code>main() --&gt; runDocker() --&gt; newDockerCommand() --&gt; AddCommands() --&gt; cmd.AddCommand() --&gt; container.NewContainerCommand() --&gt; cmd.AddCommand() --&gt; NewRestartCommand() --&gt; runRestart() --&gt; Client.ContainerRestart()</code></p><p>因为 <a href="https://blog.961110.xyz/posts/40974.html#Docker-Client">前一篇</a> 中已经分析过了 docker stop 命令的执行函数<code>runStop()</code>，<code>runRestart()</code>与其一样都是并行地处理多个容器的 restart 操作。</p><h3 id="Client-ContainerRestart"><a href="#Client-ContainerRestart" class="headerlink" title="Client.ContainerRestart()"></a>Client.ContainerRestart()</h3><p>github.com/docker/docker/client/container_restart.go: 14</p><p><code>Client.ContainerRestart()</code>的实现非常简单，作用也非常简单，就是向 Daemon 发送 restart 请求。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ContainerRestart stops and starts a container again.</span></span><br><span class="line"><span class="comment">// It makes the daemon to wait for the container to be up again for</span></span><br><span class="line"><span class="comment">// a specific amount of time, given the timeout.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *Client)</span> <span class="title">ContainerRestart</span><span class="params">(ctx context.Context, containerID <span class="keyword">string</span>, timeout *time.Duration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">query := url.Values&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> timeout != <span class="literal">nil</span> &#123;</span><br><span class="line">query.Set(<span class="string">&quot;t&quot;</span>, timetypes.DurationToSecondsString(*timeout))</span><br><span class="line">&#125;</span><br><span class="line">resp, err := cli.post(ctx, <span class="string">&quot;/containers/&quot;</span>+containerID+<span class="string">&quot;/restart&quot;</span>, query, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">ensureReaderClosed(resp)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到函数这个函数就是向 Daemon 发送了一个 post 请求。</p><h2 id="Docker-Daemon"><a href="#Docker-Daemon" class="headerlink" title="Docker Daemon"></a>Docker Daemon</h2><p>和前面的几篇一样，直接分析 restart 路由表项对应的处理函数 <code>containerRouter.postContainersRestart()</code></p><h3 id="containerRouter-postContainersRestart"><a href="#containerRouter-postContainersRestart" class="headerlink" title="containerRouter.postContainersRestart()"></a>containerRouter.postContainersRestart()</h3><p>api/server/router/container/container_routes.go: 235</p><p>还是那老一套，直接上图，清晰明了。</p><table>    <tr>        <td>            <center><img                    src="https://images.961110.xyz/images/2021/12/01/containerRouter.postContainersRestart5c00ef290227e48e.png">图1                containerRouter.postContainersRestart() </center>        </td>        <td>            <center><img src="https://images.961110.xyz/images/2021/12/01/Daemon.ContainerRestart.png">图2                Daemon.ContainerRestart()</center>        </td>    </tr></table><p>这两个函数都是比较简单的，做了一点点操作，调用了核心的处理函数 <code>Daemon.containerRestart()</code></p><h3 id="Daemon-containerRestart"><a href="#Daemon-containerRestart" class="headerlink" title="Daemon.containerRestart()"></a>Daemon.containerRestart()</h3><p>daemon/restart.go: 37</p><p>这个函数整体来说是比较容易理解的，就是先 stop 然后再 start，但是<strong>有一点不理解的就是为什么当容器隔离方式不是 HyperV 时，需要再一次挂载容器的 BaseFS，然后在<code>containerRestart()</code>结束后再取消挂载。</strong>这个函数也基本都是调用之前分析过的函数，空降导航</p><ol><li><a href="https://blog.961110.xyz/posts/56133.html#Docker-Daemon-%E5%A4%84%E7%90%86%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8%E7%9A%84%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B">Docker源码分析（三）—— docker start 命令在 Docker Daemon中的执行</a></li><li><a href="https://blog.961110.xyz/posts/40974.html#Docker-Daemon">Docker源码分析（六）—— 命令 docker stop 的执行</a></li></ol><ul><li></li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(daemon *Daemon)</span> <span class="title">containerRestart</span><span class="params">(container *container.Container, seconds <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Determine isolation. If not specified in the hostconfig, use daemon default.</span></span><br><span class="line">   actualIsolation := container.HostConfig.Isolation</span><br><span class="line">   <span class="keyword">if</span> containertypes.Isolation.IsDefault(actualIsolation) &#123;</span><br><span class="line">      actualIsolation = daemon.defaultIsolation</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Avoid unnecessarily unmounting and then directly mounting</span></span><br><span class="line">   <span class="comment">// the container when the container stops and then starts</span></span><br><span class="line">   <span class="comment">// again. We do not do this for Hyper-V isolated containers</span></span><br><span class="line">   <span class="comment">// (implying also on Windows) as the HCS must have exclusive</span></span><br><span class="line">   <span class="comment">// access to mount the containers filesystem inside the utility</span></span><br><span class="line">   <span class="comment">// VM.</span></span><br><span class="line">   <span class="keyword">if</span> !containertypes.Isolation.IsHyperV(actualIsolation) &#123;</span><br><span class="line">      <span class="keyword">if</span> err := daemon.Mount(container); err == <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">defer</span> daemon.Unmount(container)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> container.IsRunning() &#123;</span><br><span class="line">      <span class="comment">// 将容器的 autoremove 设置为 false，防止被自动删除</span></span><br><span class="line">      autoRemove := container.HostConfig.AutoRemove</span><br><span class="line"></span><br><span class="line">      container.HostConfig.AutoRemove = <span class="literal">false</span></span><br><span class="line">      err := daemon.containerStop(container, seconds)</span><br><span class="line">      <span class="comment">// 不管有没有 stop，都需要恢复原来的设置，并且因为容器在 stop 的时候会将 HostConfig 保存到磁盘中，所以恢复了 autoremove 设置之后也需要保存到磁盘中</span></span><br><span class="line">      container.HostConfig.AutoRemove = autoRemove</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> toDiskErr := daemon.checkpointAndSave(container); toDiskErr != <span class="literal">nil</span> &#123;</span><br><span class="line">         logrus.Errorf(<span class="string">&quot;Write container to disk error: %v&quot;</span>, toDiskErr)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 启动</span></span><br><span class="line">   <span class="keyword">if</span> err := daemon.containerStart(container, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="literal">true</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   daemon.LogContainerEvent(container, <span class="string">&quot;restart&quot;</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://images.961110.xyz/images/2021/12/02/Daemon.ContainerRestart.png" style="zoom:33%;" /><h2 id="docker-restart-命令执行过程"><a href="#docker-restart-命令执行过程" class="headerlink" title="docker restart 命令执行过程"></a>docker restart 命令执行过程</h2><img src="https://images.961110.xyz/images/2021/12/02/docker-restart-.png" style="zoom:33%;" /><p>这里放上之前分析过的两个函数</p><table>    <tr>        <td>            <center><img                    src="https://images.961110.xyz/images/2021/12/02/daemon.killWithSignal.png">图1 daemon.killWithSignal()</center>        </td>        <td>            <center><img src="https://images.961110.xyz/images/2021/11/19/containerStart.png">图2 containerStart()</center>        </td>    </tr></table><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>无</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 毕设 </tag>
            
            <tag> Docker </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker源码分析（七）—— 命令 docker kill 的执行</title>
      <link href="/posts/37106.html"/>
      <url>/posts/37106.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>博文分析的 Docker 源码基于 19.03 版本，阅读工具采用 Goland，追踪的是<code>docker kill</code>命令的执行过程。</p><p>第一次阅读 Docker 源码，如有纰漏还请轻喷，喷完希望能够通过邮件或者留言的方式指出问题。</p><p>限于篇幅以及关注重点的原因，部分个人认为不重要的代码会用省略号代替。</p><p>Tips: 如果图片看不清楚可以点击查看大图。</p></blockquote><h2 id="Docker-Client"><a href="#Docker-Client" class="headerlink" title="Docker Client"></a>Docker Client</h2><p>分析的命令越多，越会发现在 Docker Client 这一端中各个命令的实现都基本一样。</p><p>调用链路是 <code>main() --&gt; runDocker() --&gt; newDockerCommand() --&gt; AddCommands() --&gt; cmd.AddCommand() --&gt; container.NewContainerCommand() --&gt; cmd.AddCommand() --&gt; NewKillCommand() --&gt; runKill() --&gt; Client.ContainerKill()</code></p><p>因为 <a href="https://blog.961110.xyz/posts/40974.html#Docker-Client">前一篇</a> 中已经分析过了 docker stop 命令的执行函数<code>runStop()</code>，<code>runKill()</code>与其一样都是并行地处理多个容器的 kill 操作。</p><h3 id="Client-ContainerKill"><a href="#Client-ContainerKill" class="headerlink" title="Client.ContainerKill()"></a>Client.ContainerKill()</h3><p>github.com/docker/docker/client/container_kill.go: 9</p><p><code>Client.ContainerKill()</code>的实现非常简单，作用也非常简单，就是终结指定容器的进程。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ContainerKill terminates the container process but does not remove the container from the docker host.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *Client)</span> <span class="title">ContainerKill</span><span class="params">(ctx context.Context, containerID, signal <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">query := url.Values&#123;&#125;</span><br><span class="line">query.Set(<span class="string">&quot;signal&quot;</span>, signal)</span><br><span class="line"></span><br><span class="line">resp, err := cli.post(ctx, <span class="string">&quot;/containers/&quot;</span>+containerID+<span class="string">&quot;/kill&quot;</span>, query, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">ensureReaderClosed(resp)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到函数这个函数就是向 Daemon 发送了一个 post 请求。</p><h2 id="Docker-Daemon"><a href="#Docker-Daemon" class="headerlink" title="Docker Daemon"></a>Docker Daemon</h2><p>有了之前的经验，同样从 Daemon 的路由入手。处理过程中一些前置的函数已经在前面的博文中分析过，这里直接分析路由处理函数<code>containerRouter.postContainersKill()</code></p><h3 id="containerRouter-postContainersKill"><a href="#containerRouter-postContainersKill" class="headerlink" title="containerRouter.postContainersKill()"></a>containerRouter.postContainersKill()</h3><p>api/server/router/container/container_routes.go: 235</p><p>函数的功能比较简单，看图就一目了然。</p><img src="https://images.961110.xyz/images/2021/12/01/postContainerKill.png" style="zoom:50%;" /><p>对 <code>Daemon.ContainerKill()</code> 进行进一步分析。</p><h3 id="Daemon-ContainerKill"><a href="#Daemon-ContainerKill" class="headerlink" title="Daemon.ContainerKill()"></a>Daemon.ContainerKill()</h3><p>daemon/kill.go: 40</p><p><img src="https://images.961110.xyz/images/2021/12/01/Daemon.ContainerKill4866a473f563b750.png"></p><p>这个函数主要是找到指定的 container 结构体对象，然后检验参数的合法性并根据传入的信号分别进行 kill 操作。</p><p>利用传入的信号进行 kill 操作 <code>daemon.killWithSignal()</code> 这个函数已经在上一篇 <a href="">Docker源码分析（六）—— 命令 docker stop 的执行</a> 分析过了，所以着重看一下 <code>daemon.Kill()</code> 这个函数。</p><h3 id="daemon-Kill"><a href="#daemon-Kill" class="headerlink" title="daemon.Kill()"></a>daemon.Kill()</h3><p>daemon/kill.go: 121</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Kill forcefully terminates a container.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(daemon *Daemon)</span> <span class="title">Kill</span><span class="params">(container *containerpkg.Container)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// 判断容器是否在运行</span></span><br><span class="line"><span class="keyword">if</span> !container.IsRunning() &#123;</span><br><span class="line"><span class="keyword">return</span> errNotRunning(container.ID)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. Send SIGKILL</span></span><br><span class="line"><span class="comment">// 与 stop 不同的是，这发送的系统调用的 SIGKILL 信号</span></span><br><span class="line"><span class="keyword">if</span> err := daemon.killPossiblyDeadProcess(container, <span class="keyword">int</span>(syscall.SIGKILL)); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 如果这里无法 stop 容器，说明其可能已经 stop 了</span></span><br><span class="line">        <span class="comment">// 另外，由于 err 是特定于环境的，无法判断其已经 stop 或者出了其他状况</span></span><br><span class="line">        <span class="comment">// 所以这里等待了两秒再次判断其是否 running，如果其仍在运行，那么就返回遇到的 err</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断是否未找到该进程</span></span><br><span class="line"><span class="keyword">if</span> isErrNoSuchProcess(err) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 延迟两秒，判断是否为 running 状态</span></span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), <span class="number">2</span>*time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"><span class="comment">// 如果还是超时，那就说明可能发生了一些错误，返回给调用者参考</span></span><br><span class="line"><span class="keyword">if</span> status := &lt;-container.Wait(ctx, containerpkg.WaitConditionNotRunning); status.Err() != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Wait for the process to die, in last resort, try to kill the process directly</span></span><br><span class="line"><span class="comment">// 直接 kill 掉</span></span><br><span class="line"><span class="keyword">if</span> err := killProcessDirectly(container); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> isErrNoSuchProcess(err) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait for exit with no timeout.</span></span><br><span class="line"><span class="comment">// Ignore returned status.</span></span><br><span class="line">&lt;-container.Wait(context.Background(), containerpkg.WaitConditionNotRunning)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分的代码还是有一点点复杂的，<code>daemon.killPossiblyDeadProcess()</code>这个函数在 <a href="https://blog.961110.xyz/posts/40974.html#Daemon-killWithSignal">上一篇博文</a> 中已经分析过。<code>killProcessDirectly()</code>是 kill 容器的最后杀手锏。</p><p><img src="https://images.961110.xyz/images/2021/12/01/SIGKILL--kill-48c8237b7a5f83ca.png"></p><h3 id="killProcessDirectly"><a href="#killProcessDirectly" class="headerlink" title="killProcessDirectly()"></a>killProcessDirectly()</h3><p>daemon/container_operations_unix.go: 339</p><p>在这个函数中还在苦苦等待容器退出，超时时间是 10 秒，否则就直接调用系统函数 kill 掉。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">killProcessDirectly</span><span class="params">(cntr *container.Container)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), <span class="number">10</span>*time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一直阻塞等待容器退出或者超时</span></span><br><span class="line">status := &lt;-cntr.Wait(ctx, container.WaitConditionNotRunning)</span><br><span class="line"><span class="keyword">if</span> status.Err() != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Ensure that we don&#x27;t kill ourselves</span></span><br><span class="line"><span class="keyword">if</span> pid := cntr.GetPID(); pid != <span class="number">0</span> &#123;</span><br><span class="line">logrus.Infof(<span class="string">&quot;Container %s failed to exit within 10 seconds of kill - trying direct SIGKILL&quot;</span>, stringid.TruncateID(cntr.ID))</span><br><span class="line"><span class="keyword">if</span> err := unix.Kill(pid, <span class="number">9</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err != unix.ESRCH &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">e := errNoSuchProcess&#123;pid, <span class="number">9</span>&#125;</span><br><span class="line">logrus.Debug(e)</span><br><span class="line"><span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="docker-kill-执行流程分析"><a href="#docker-kill-执行流程分析" class="headerlink" title="docker kill 执行流程分析"></a>docker kill 执行流程分析</h2><img src="https://images.961110.xyz/images/2021/12/01/docker-kill-b3f69031d11d45c8.png" style="zoom: 25%;" /><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>无</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 毕设 </tag>
            
            <tag> Docker </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker源码分析（六）—— 命令 docker stop 的执行</title>
      <link href="/posts/40974.html"/>
      <url>/posts/40974.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>博文分析的 Docker 源码基于 19.03 版本，阅读工具采用 Goland，追踪的是<code>docker stop</code>命令的执行过程。</p><p>第一次阅读 Docker 源码，如有纰漏还请轻喷，喷完希望能够通过邮件或者留言的方式指出问题。</p><p>限于篇幅以及关注重点的原因，部分个人认为不重要的代码会用省略号代替。</p><p>Tips: 如果图片看不清楚可以点击查看大图。</p></blockquote><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前面的博文已经分析了容器的创建和启动过程，秉持着有始有终的信条，所以本篇博文分析 <code>docker stop</code> 命令的执行过程。</p><p>分析的方式同样和前面几篇一样，从 Docker Client 开始，到 Docker Daemon 结束。</p><h2 id="Docker-Client"><a href="#Docker-Client" class="headerlink" title="Docker Client"></a>Docker Client</h2><p>调用链路是 <code>main() --&gt; runDocker() --&gt; newDockerCommand() --&gt; AddCommands() --&gt; cmd.AddCommand() --&gt; container.NewContainerCommand() --&gt; cmd.AddCommand() --&gt; NewStopCommand() --&gt; runStop()</code></p><p>因为 <a href="https://blog.961110.xyz/posts/21441.html">前一篇</a> 中已经分析过了 cobra 新增命令的函数，所以此处略过。从命令要执行的函数<code>runStop()</code>开始进行分析。</p><h3 id="DockerCli-runStop"><a href="#DockerCli-runStop" class="headerlink" title="DockerCli.runStop()"></a>DockerCli.runStop()</h3><p>cli/command/container/stop.go: 42</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runStop</span><span class="params">(dockerCli command.Cli, opts *stopOptions)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">ctx := context.Background()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断超时时间是否有变化，有就更新为用户设置的超时时间</span></span><br><span class="line"><span class="keyword">var</span> timeout *time.Duration</span><br><span class="line"><span class="keyword">if</span> opts.timeChanged &#123;</span><br><span class="line">timeoutValue := time.Duration(opts.time) * time.Second</span><br><span class="line">timeout = &amp;timeoutValue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> errs []<span class="keyword">string</span></span><br><span class="line"><span class="comment">// 通过协程并行地 stop 多个容器（也可能是一个）</span></span><br><span class="line">errChan := parallelOperation(ctx, opts.containers, <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, id <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> dockerCli.Client().ContainerStop(ctx, id, timeout)</span><br><span class="line">&#125;)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 输出 stop 时返回的错误信息   </span></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面的代码，可以看出需要关注的是 <code>dockerCli.Client().ContainerStop(ctx, id, timeout)</code>，接着往下追溯。</p><p>这里的 <code>dockerCli.Client()</code> 指的是 <code>API Client</code>，在前一篇也解释过，其作用是与 docker server 进行交互，保存着服务端的地址、通信方式（unix. fd, tcp）等信息。</p><h3 id="Client-ContainerStop"><a href="#Client-ContainerStop" class="headerlink" title="Client.ContainerStop()"></a>Client.ContainerStop()</h3><p>github.com/docker/docker/client/container_stop.go: 18</p><p>和前一篇分析过的 <code>Client.ContainerInspectWithRaw()</code> 函数一样，这里执行的代码引用自 Docker Daemon 的实现。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ContainerStop stops a container. In case the container fails to stop</span></span><br><span class="line"><span class="comment">// gracefully within a time frame specified by the timeout argument,</span></span><br><span class="line"><span class="comment">// it is forcefully terminated (killed).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If the timeout is nil, the container&#x27;s StopTimeout value is used, if set,</span></span><br><span class="line"><span class="comment">// otherwise the engine default. A negative timeout value can be specified,</span></span><br><span class="line"><span class="comment">// meaning no timeout, i.e. no forceful termination is performed.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *Client)</span> <span class="title">ContainerStop</span><span class="params">(ctx context.Context, containerID <span class="keyword">string</span>, timeout *time.Duration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">query := url.Values&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> timeout != <span class="literal">nil</span> &#123;</span><br><span class="line">query.Set(<span class="string">&quot;t&quot;</span>, timetypes.DurationToSecondsString(*timeout))</span><br><span class="line">&#125;</span><br><span class="line">resp, err := cli.post(ctx, <span class="string">&quot;/containers/&quot;</span>+containerID+<span class="string">&quot;/stop&quot;</span>, query, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">ensureReaderClosed(resp)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据函数注释，可以看出刚刚提到的超时时间并不是命令执行失败的超时时间，而是容器的 <strong>“死期”</strong>（超时会被无情 kill）。</p><p>这里 API Client 向 Docker Daemon 发送了 stop container 的请求，下面转到 Docker Daemon 端。</p><h3 id="docker-stop-命令在-Docker-Client-中的执行过程"><a href="#docker-stop-命令在-Docker-Client-中的执行过程" class="headerlink" title="docker stop 命令在 Docker Client 中的执行过程"></a>docker stop 命令在 Docker Client 中的执行过程</h3><img src="https://images.961110.xyz/images/2021/11/30/docker-stop--Docker-Client-.png" style="zoom: 50%;" /><p>因为略过了一些之前分析过的函数以及一些自认为不重要的代码，所以感觉这个命令在 Docker Client 端的执行还是非常简单的。</p><h2 id="Docker-Daemon"><a href="#Docker-Daemon" class="headerlink" title="Docker Daemon"></a>Docker Daemon</h2><p>从前几篇的分析总结出经验，命令在 Daemon 端的处理会有对应的路由，所以还是从<code>containerRouter.initRoutes()</code>开始分析（Docker Daemon 其他的分析可以在 <a href="https://blog.961110.xyz/posts/19054.html">之前的文章</a> 中查阅）。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *containerRouter)</span> <span class="title">initRoutes</span><span class="params">()</span></span> &#123;</span><br><span class="line">r.routes = []router.Route&#123;</span><br><span class="line">...</span><br><span class="line">router.NewPostRoute(<span class="string">&quot;/containers/&#123;name:.*&#125;/stop&quot;</span>, r.postContainersStop),</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>r.postContainersStop()</code>调用的是<code>containerRouter.backend.ContainerStop()</code>，如果容器不是 running 状态，那就返回错误，否则就调用 <code>daemon.containerStop()</code> 进行进一步处理。</p><h3 id="Daemon-containerStop"><a href="#Daemon-containerStop" class="headerlink" title="Daemon.containerStop()"></a>Daemon.containerStop()</h3><p>daemon/stop.go: 40</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// containerStop sends a stop signal, waits, sends a kill signal.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(daemon *Daemon)</span> <span class="title">containerStop</span><span class="params">(container *containerpkg.Container, seconds <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 获取默认 stop signal 或者容器配置中指定的 stop signal</span></span><br><span class="line">stopSignal := container.StopSignal()</span><br><span class="line"><span class="comment">// 1. Send a stop signal</span></span><br><span class="line"><span class="keyword">if</span> err := daemon.killPossiblyDeadProcess(container, stopSignal); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), <span class="number">2</span>*time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> status := &lt;-container.Wait(ctx, containerpkg.WaitConditionNotRunning); status.Err() != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.Infof(<span class="string">&quot;Container failed to stop after sending signal %d to the process, force killing&quot;</span>, stopSignal)</span><br><span class="line"><span class="keyword">if</span> err := daemon.killPossiblyDeadProcess(container, <span class="number">9</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Wait for the process to exit on its own</span></span><br><span class="line">ctx := context.Background()</span><br><span class="line"><span class="keyword">if</span> seconds &gt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">var</span> cancel context.CancelFunc</span><br><span class="line">ctx, cancel = context.WithTimeout(ctx, time.Duration(seconds)*time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> status := &lt;-container.Wait(ctx, containerpkg.WaitConditionNotRunning); status.Err() != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.Infof(<span class="string">&quot;Container %v failed to exit within %d seconds of signal %d - using the force&quot;</span>, container.ID, seconds, stopSignal)</span><br><span class="line"><span class="comment">// 3. If it doesn&#x27;t, then send SIGKILL</span></span><br><span class="line"><span class="keyword">if</span> err := daemon.Kill(container); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Wait without a timeout, ignore result.</span></span><br><span class="line">&lt;-container.Wait(context.Background(), containerpkg.WaitConditionNotRunning)</span><br><span class="line">logrus.Warn(err) <span class="comment">// Don&#x27;t return error because we only care that container is stopped, not what function stopped it</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">daemon.LogContainerEvent(container, <span class="string">&quot;stop&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>daemon.killPossiblyDeadProcess(container, stopSignal)</code>这个函数实际上是给<code>daemon.killWithSignal(container, sig)</code>传入了<code>stopSignal</code>，所以往下分析一下<code>killWithSignal()</code>。</p><h3 id="Daemon-killWithSignal"><a href="#Daemon-killWithSignal" class="headerlink" title="Daemon.killWithSignal()"></a>Daemon.killWithSignal()</h3><p>daemon/kill.go: 62</p><p>函数的作用就是给指定容器发送指定信号，当然需要判断容器当前可能的各种状态。</p><p>源代码如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(daemon *Daemon)</span> <span class="title">killWithSignal</span><span class="params">(container *containerpkg.Container, sig <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// 再次判断是否为 running 状态</span></span><br><span class="line"><span class="keyword">if</span> !container.Running &#123;</span><br><span class="line"><span class="keyword">return</span> errNotRunning(container.ID)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断容器配置中是否自定义了 stop 信号，并且传入的信号不是系统信号中的 KILL 信号</span></span><br><span class="line"><span class="keyword">var</span> unpause <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">if</span> container.Config.StopSignal != <span class="string">&quot;&quot;</span> &amp;&amp; syscall.Signal(sig) != syscall.SIGKILL &#123;</span><br><span class="line">        <span class="comment">// 解析容器配置中自定义的 stop 信号</span></span><br><span class="line">containerStopSignal, err := signal.ParseSignal(container.Config.StopSignal)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 如果传入的信号就是容器配置中自定义的 stop 信号，就进行相应的操作</span></span><br><span class="line"><span class="keyword">if</span> containerStopSignal == syscall.Signal(sig) &#123;</span><br><span class="line">container.ExitOnNext()</span><br><span class="line">unpause = container.Paused</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 通知 container.RestartManager() 在容器 stop 后不要重启该容器</span></span><br><span class="line">container.ExitOnNext()</span><br><span class="line">unpause = container.Paused</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果 Docker Daemon 不是在 shut down，说明就是手动 stop 的容器</span></span><br><span class="line"><span class="comment">// 于是改变容器的状态，并将状态保存到文件中</span></span><br><span class="line"><span class="keyword">if</span> !daemon.IsShuttingDown() &#123;</span><br><span class="line">container.HasBeenManuallyStopped = <span class="literal">true</span></span><br><span class="line">container.CheckpointTo(daemon.containersReplica)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果容器正在重启，因为上面已经告诉 estartManager 在容器 stop 后不要重启该容器</span></span><br><span class="line"><span class="comment">// 所以不需要做额外的操作</span></span><br><span class="line"><span class="keyword">if</span> container.Restarting &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 发送 stop 信号</span></span><br><span class="line"><span class="keyword">if</span> err := daemon.kill(container, sig); err != <span class="literal">nil</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果容器被阻塞，则先恢复，再发送 stop 信号</span></span><br><span class="line"><span class="keyword">if</span> unpause &#123;</span><br><span class="line"><span class="comment">// above kill signal will be sent once resume is finished</span></span><br><span class="line"><span class="keyword">if</span> err := daemon.containerd.Resume(context.Background(), container.ID); err != <span class="literal">nil</span> &#123;</span><br><span class="line">logrus.Warnf(<span class="string">&quot;Cannot unpause container %s: %s&quot;</span>, container.ID, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分代码的执行流程图如下</p><p><img src="https://images.961110.xyz/images/2021/12/02/daemon.killWithSignal.png"></p><h3 id="Daemon-Kill-container"><a href="#Daemon-Kill-container" class="headerlink" title="Daemon.Kill(container)"></a>Daemon.Kill(container)</h3><p>当到了指定 container 的<strong>“死期”</strong>后，会被无情 Kill 掉，这一部分代码的执行流程会在后续对 <code>docker kill</code> 命令的分析中给出。</p><h3 id="docker-stop-命令在-Docker-Daemon-中的执行过程"><a href="#docker-stop-命令在-Docker-Daemon-中的执行过程" class="headerlink" title="docker stop 命令在 Docker Daemon 中的执行过程"></a>docker stop 命令在 Docker Daemon 中的执行过程</h3><img src="https://images.961110.xyz/images/2021/12/01/docker-stop--Docker-Daemon-.png" style="zoom: 25%;" /><p>刚刚说 docker stop 命令在 Docker Client 端执行的过程比较简单，从上图可以看到这条命令的执行重任基本都交给了 Docker Daemon，不过也合情合理，毕竟 Docker Client 就是一个无情的发送命令的机器。</p><h2 id="docker-stop-的执行过程分析"><a href="#docker-stop-的执行过程分析" class="headerlink" title="docker stop 的执行过程分析"></a>docker stop 的执行过程分析</h2><img src="https://images.961110.xyz/images/2021/12/01/docker-stop-d80c82a9612eb64e.png" style="zoom:25%;" /><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>无</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 毕设 </tag>
            
            <tag> Docker </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 源码梳理文章索引暨容器生命周期相关源码梳理</title>
      <link href="/posts/52319.html"/>
      <url>/posts/52319.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>持续更新中。。。</p></blockquote><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><ol><li><a href="https://blog.961110.xyz/posts/64829.html">Docker源码分析（一）—— docker run 命令在 Docker Client 中的执行</a></li><li><a href="https://blog.961110.xyz/posts/19054.html">Docker源码分析（二）—— docker run 命令在 Docker Daemon中的执行</a></li><li><a href="https://blog.961110.xyz/posts/56133.html">Docker源码分析（三）—— docker start 命令在 Docker Daemon中的执行</a></li><li><a href="https://blog.961110.xyz/posts/2533.html">Docker源码分析（四）—— Docker Daemon 启动流程</a></li><li><a href="https://blog.961110.xyz/posts/21441.html">Docker源码分析（五）—— 命令 docker inspect 的执行</a></li><li><a href="https://blog.961110.xyz/posts/40974.html">Docker源码分析（六）—— 命令 docker stop 的执行</a></li><li><a href="https://blog.961110.xyz/posts/37106.html">Docker源码分析（七）—— 命令 docker kill的执行</a></li><li><a href="https://blog.961110.xyz/posts/20332.html">Docker源码分析（八）—— 命令 docker restart 的执行</a></li><li><a href="https://blog.961110.xyz/posts/52812.html">Docker源码分析（九）—— 命令 docker pause 的执行</a></li><li><a href="https://blog.961110.xyz/posts/49360.html">Docker源码分析（十）—— 命令 docker unpause 的执行</a></li><li><a href="https://blog.961110.xyz/posts/24743.html">Docker源码分析（十一）—— 命令 docker rm 的执行</a></li></ol><h2 id="container-生命周期"><a href="#container-生命周期" class="headerlink" title="container 生命周期"></a>container 生命周期</h2><table>    <tr>        <td ><center><img src="https://images.961110.xyz/images/2021/11/29/225c067867401b13496dcbc407f9747e.png" >图1 container 生命周期简图 </center></td>        <td ><center><img src="https://images.961110.xyz/images/2021/11/29/2fe10549b3c93adcf3e25e7d0cff707e.png"  >图2 container 生命周期图</center></td>    </tr></table><table><thead><tr><th><strong>条件</strong></th><th><strong>对应 container 生命周期</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>docker container create</td><td>created</td><td></td></tr><tr><td>docker container start</td><td>(created | stopped) –&gt; running</td><td></td></tr><tr><td>docker container run</td><td>none –&gt; created –&gt; running</td><td></td></tr><tr><td>docker container stop</td><td>running –&gt; stopped</td><td></td></tr><tr><td>docker container restart</td><td>running –&gt; running</td><td></td></tr><tr><td>docker container pause</td><td>running –&gt; paused</td><td></td></tr><tr><td>docker container unpause</td><td>paused –&gt; running</td><td></td></tr><tr><td>docker container kill</td><td>running –&gt; stopped</td><td></td></tr><tr><td>docker container rm</td><td>(created | stopped) –&gt; deleted</td><td></td></tr><tr><td>docker container inspect</td><td>none</td><td>获取容器的详细信息</td></tr><tr><td>OOM</td><td>running –&gt; (stopped | running)</td><td>当 OOM 时容器会被 kill 掉，<br />然后根据策略退出或重启。</td></tr><tr><td>container process exited</td><td>running –&gt; (stopped | running)</td><td>当容器中的进程退出时，<br />根据策略进行重启或者 stop。</td></tr></tbody></table><p>​                                                                                                                                                                                                                                                                                                </p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 毕设 </tag>
            
            <tag> Docker </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker源码分析（五）—— 命令 docker inspect 的执行</title>
      <link href="/posts/21441.html"/>
      <url>/posts/21441.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>博文分析的 Docker 源码基于 19.03 版本，阅读工具采用 Goland，追踪的是<code>docker inspect</code>命令的执行过程。</p><p>第一次阅读 Docker 源码，如有纰漏还请轻喷，喷完希望能够通过邮件或者留言的方式指出问题。</p><p>限于篇幅以及关注重点的原因，部分个人认为不重要的代码会用省略号代替。</p><p>Tips: 如果图片看不清楚可以点击查看大图。</p></blockquote><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>想要获取 container 的相关信息，看到有 <code>docker inspect containerID</code> 这个命令而且返回了较为完备的 container 底层信息，所以对其进行简单的追踪。这个命令是 Docker Client 的命令，所以从 Docker Client 开始分析。</p><h2 id="Docker-Client"><a href="#Docker-Client" class="headerlink" title="Docker Client"></a>Docker Client</h2><p>调用链路是 <code>main() --&gt; runDocker() --&gt; newDockerCommand() --&gt; AddCommands() --&gt; cmd.AddCommand() --&gt; container.NewContainerCommand() --&gt; cmd.AddCommand() --&gt; newInspectCommand()</code></p><p>从<code>newInspectCommand()</code>开始进行分析，其他的都已经在 <a href="https://blog.961110.xyz/posts/64829.html">Docker源码分析（一）—— docker run 命令在 Docker Client 中的执行</a> 一文中详细分析过。</p><h3 id="newInspectCommand-dockerCli"><a href="#newInspectCommand-dockerCli" class="headerlink" title="newInspectCommand(dockerCli)"></a>newInspectCommand(dockerCli)</h3><p>cli/command/container/inspect.go: 19</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newInspectCommand</span><span class="params">(dockerCli command.Cli)</span> *<span class="title">cobra</span>.<span class="title">Command</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> opts inspectOptions</span><br><span class="line"></span><br><span class="line">cmd := &amp;cobra.Command&#123;</span><br><span class="line">Use:   <span class="string">&quot;inspect [OPTIONS] CONTAINER [CONTAINER...]&quot;</span>,</span><br><span class="line">Short: <span class="string">&quot;Display detailed information on one or more containers&quot;</span>,</span><br><span class="line">Args:  cli.RequiresMinArgs(<span class="number">1</span>),</span><br><span class="line">RunE: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">opts.refs = args</span><br><span class="line"><span class="keyword">return</span> runInspect(dockerCli, opts)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flags := cmd.Flags()</span><br><span class="line">flags.StringVarP(&amp;opts.format, <span class="string">&quot;format&quot;</span>, <span class="string">&quot;f&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Format the output using the given Go template&quot;</span>)</span><br><span class="line">flags.BoolVarP(&amp;opts.size, <span class="string">&quot;size&quot;</span>, <span class="string">&quot;s&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;Display total file sizes&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> cmd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的主要作用是新增 <code>docker inspect</code> 这个命令，相关的可视化效果可以在下图看到。</p><img src="https://images.961110.xyz/images/2021/11/28/docker-inspect--help.png" alt="image-20211128171139806" style="zoom:50%;" /><h3 id="runInspect-dockerCli-opts"><a href="#runInspect-dockerCli-opts" class="headerlink" title="runInspect(dockerCli, opts)"></a>runInspect(dockerCli, opts)</h3><p>cli/command/container/inspect.go: 39</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runInspect</span><span class="params">(dockerCli command.Cli, opts inspectOptions)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">client := dockerCli.Client()</span><br><span class="line">ctx := context.Background()</span><br><span class="line"></span><br><span class="line">getRefFunc := <span class="function"><span class="keyword">func</span><span class="params">(ref <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, []<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> client.ContainerInspectWithRaw(ctx, ref, opts.size)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> inspect.Inspect(dockerCli.Out(), opts.refs, opts.format, getRefFunc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>dockerCli</code>是 Docker 命令行的对象；</li><li><code>dockerCli.Client()</code>是与 docker server(Docker Daemon) 交互的 API Client，对应的结构体中存放着服务端的地址、通信方式（unix. fd, tcp）等信息。</li><li><code>getRefFunc</code>这个函数是这个命令的核心函数，其发送请求 get 请求来获取指定 container 的 JSON 信息，这个下面再分析。</li><li><code>inspect.Inspect()</code>这个函数 的作用是将<code>getRefFunc</code>得到的 JSON 格式的信息输出到 Docker Client 的输出端。</li></ul><h3 id="client-ContainerInspectWithRaw-ctx-ref-opts-size"><a href="#client-ContainerInspectWithRaw-ctx-ref-opts-size" class="headerlink" title="client.ContainerInspectWithRaw(ctx, ref, opts.size)"></a>client.ContainerInspectWithRaw(ctx, ref, opts.size)</h3><p>github.com/docker/docker/client/container_inspect.go: 30</p><p>从调用路径中可以看出，这里引用的是 Docker Daemon 的实现</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *Client)</span> <span class="title">ContainerInspectWithRaw</span><span class="params">(ctx context.Context, containerID <span class="keyword">string</span>, getSize <span class="keyword">bool</span>)</span> <span class="params">(types.ContainerJSON, []<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> containerID == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> types.ContainerJSON&#123;&#125;, <span class="literal">nil</span>, objectNotFoundError&#123;object: <span class="string">&quot;container&quot;</span>, id: containerID&#125;</span><br><span class="line">&#125;</span><br><span class="line">query := url.Values&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> getSize &#123;</span><br><span class="line">query.Set(<span class="string">&quot;size&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">serverResp, err := cli.get(ctx, <span class="string">&quot;/containers/&quot;</span>+containerID+<span class="string">&quot;/json&quot;</span>, query, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">defer</span> ensureReaderClosed(serverResp)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> types.ContainerJSON&#123;&#125;, <span class="literal">nil</span>, wrapResponseError(err, serverResp, <span class="string">&quot;container&quot;</span>, containerID)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">body, err := ioutil.ReadAll(serverResp.body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> types.ContainerJSON&#123;&#125;, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> response types.ContainerJSON</span><br><span class="line">rdr := bytes.NewReader(body)</span><br><span class="line">err = json.NewDecoder(rdr).Decode(&amp;response)</span><br><span class="line"><span class="keyword">return</span> response, body, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最核心的是这行代码</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">serverResp, err := cli.get(ctx, <span class="string">&quot;/containers/&quot;</span>+containerID+<span class="string">&quot;/json&quot;</span>, query, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>向 Docker Daemon 发送 get 请求，并获取响应。</p><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><img src="https://images.961110.xyz/images/2021/11/28/docker-inspect--Docker-Client-.png" style="zoom: 50%;" /><p>接下来看 Docker Daemon 的处理过程。</p><h2 id="Docker-Daemon"><a href="#Docker-Daemon" class="headerlink" title="Docker Daemon"></a>Docker Daemon</h2><p>Docker Daemon 这一端从 <code>containerRouter.initRoutes()</code>开始分析（Docker Daemon 其他的分析可以在 <a href="https://blog.961110.xyz/posts/19054.html">之前的文章</a> 中查阅），这个函数填充了 container 相关的一些 API 的路由了逻辑，其中就包括了 <code>docker inspect</code>这个命令。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *containerRouter)</span> <span class="title">initRoutes</span><span class="params">()</span></span> &#123;</span><br><span class="line">r.routes = []router.Route&#123;</span><br><span class="line">...</span><br><span class="line">router.NewGetRoute(<span class="string">&quot;/containers/&#123;name:.*&#125;/json&quot;</span>, r.getContainersByName),</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>r.getContainersByName</code>调用的是<code>containerRouter.backend.ContainerInspect()</code>，进而根据 API 版本进行不同的函数调用，在 1.20 以上的版本调用的是 <code>daemon.ContainerInspectCurrent()</code>，就执行到了一个需要关注的函数</p><h3 id="Daemon-ContainerInspectCurrent"><a href="#Daemon-ContainerInspectCurrent" class="headerlink" title="Daemon.ContainerInspectCurrent()"></a>Daemon.ContainerInspectCurrent()</h3><p>该函数处理流程图如下</p><img src="https://images.961110.xyz/images/2021/11/29/ContainerInspectCurrent-.png" style="zoom: 50%;" /><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(daemon *Daemon)</span> <span class="title">ContainerInspectCurrent</span><span class="params">(name <span class="keyword">string</span>, size <span class="keyword">bool</span>)</span> <span class="params">(*types.ContainerJSON, error)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 根据输入参数获取对应 container 结构体对象</span></span><br><span class="line">container, err := daemon.GetContainer(name)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 获取指定 container 的基本信息</span></span><br><span class="line">base, err := daemon.getInspectData(container)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定 container 的 Endpoint 配置信息</span></span><br><span class="line">apiNetworks := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*networktypes.EndpointSettings)</span><br><span class="line"><span class="keyword">for</span> name, epConf := <span class="keyword">range</span> container.NetworkSettings.Networks &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 获取指定 container 的 挂载点 配置信息</span></span><br><span class="line">mountPoints := container.GetMountPoints()</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 获取指定 container 的网络配置信息</span></span><br><span class="line">networkSettings := &amp;types.NetworkSettings&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 组装成 JSON 信息返回</span></span><br><span class="line"><span class="keyword">return</span> &amp;types.ContainerJSON&#123;</span><br><span class="line">ContainerJSONBase: base,</span><br><span class="line">Mounts:            mountPoints,</span><br><span class="line">Config:            container.Config,</span><br><span class="line">NetworkSettings:   networkSettings,</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>daemon.GetContainer(name)</code>这个函数的参数名叫做 name，但是 name 实际上可能是容器名、容器完整的 ID、容器 ID 的前缀这三种可能，<code>GetContainer()</code>内部对这三种情况进行了单独处理，最后还是通过容器 ID 来获取对应的容器（容器这个结构体的对象）</p><h3 id="Daemon-GetContainer"><a href="#Daemon-GetContainer" class="headerlink" title="Daemon.GetContainer()"></a>Daemon.GetContainer()</h3><p>daemon/container.go: 38</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(daemon *Daemon)</span> <span class="title">GetContainer</span><span class="params">(prefixOrName <span class="keyword">string</span>)</span> <span class="params">(*container.Container, error)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 省略掉的就是上面提到的分三种情况处理的代码，最后通过 containerID 来获取 container 对象</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> daemon.containers.Get(containerID), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>Get()</code> 方法实现于 container/memory_store.go: 29，其实现思路是根据容器 ID 在 memoryStore 中获取 ID 对应的容器对象，memoryStore 的实现如下</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> memoryStore <span class="keyword">struct</span> &#123;</span><br><span class="line">s <span class="keyword">map</span>[<span class="keyword">string</span>]*Container</span><br><span class="line">sync.RWMutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是一个简单的 map，保存在内存中。</p><h3 id="流程图-1"><a href="#流程图-1" class="headerlink" title="流程图"></a>流程图</h3><img src="https://images.961110.xyz/images/2021/11/29/docker-inspect--Docker-Daemon-.png" style="zoom:50%;" /><h2 id="docker-inspect-命令执行流程图"><a href="#docker-inspect-命令执行流程图" class="headerlink" title="docker inspect 命令执行流程图"></a>docker inspect 命令执行流程图</h2><img src="https://images.961110.xyz/images/2021/11/29/docker-inspect-.png" style="zoom:50%;" /><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>无</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 毕设 </tag>
            
            <tag> Docker </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编码开发规范</title>
      <link href="/posts/41554.html"/>
      <url>/posts/41554.html</url>
      
        <content type="html"><![CDATA[<h2 id="项目命名规范"><a href="#项目命名规范" class="headerlink" title="项目命名规范"></a>项目命名规范</h2><ol><li>项目名称用汉字，而项目 URL 不要用拼音，尽量用英文</li><li>项目 URL 不用大写、下划线</li><li>项目 URL 不用有歧义的缩写，如 src, led</li></ol><h2 id="代码库命名"><a href="#代码库命名" class="headerlink" title="代码库命名"></a>代码库命名</h2><p>英文：首先找官方的翻译</p><p><img src="https://images.961110.xyz/images/2021/11/22/01c9badceb5f05852709a733e7ae9211.png" alt="image-20211122144217905"></p><h2 id="Git-规范"><a href="#Git-规范" class="headerlink" title="Git 规范"></a>Git 规范</h2><h3 id="分支规范"><a href="#分支规范" class="headerlink" title="分支规范"></a>分支规范</h3><p>每个需求一个分支</p><h4 id="Git-Flow"><a href="#Git-Flow" class="headerlink" title="Git Flow"></a>Git Flow</h4><p>都是双分支结构，一个开发分支，一个主分支。</p><h5 id="简易-Git-Flow"><a href="#简易-Git-Flow" class="headerlink" title="简易 Git Flow"></a>简易 Git Flow</h5><p><img src="https://images.961110.xyz/images/2021/11/22/Git-Flow.png" alt="image-20211122144655829"></p><h5 id="严格版简易-Git-Flow"><a href="#严格版简易-Git-Flow" class="headerlink" title="严格版简易 Git Flow"></a>严格版简易 Git Flow<img src="https://images.961110.xyz/images/2021/11/22/Git-Flowca311f5bf49e8ac1.png" alt="image-20211122144757206"></h5><h4 id="分支命名"><a href="#分支命名" class="headerlink" title="分支命名"></a>分支命名</h4><p>命名以分支类型开头+数字+简易描述</p><p><img src="https://images.961110.xyz/images/2021/11/22/49134bf300d2a7631eb132607102bf49.png" alt="image-20211122144848896"></p><h2 id="Git-add-规范"><a href="#Git-add-规范" class="headerlink" title="Git add 规范"></a>Git add 规范</h2><ol><li>依赖包通过网络安装，进行依赖管理，不可以直接提交第三方包</li><li>build 的结果也不要提交上去</li><li>未发布到仓库的依赖包，可以创建一个仓库，放入需要的依赖包</li><li>不用的代码直接删除，需要的时候通过 git 历史找回</li></ol><h2 id="Git-commit-规范"><a href="#Git-commit-规范" class="headerlink" title="Git commit 规范"></a>Git commit 规范</h2><p> 使用 git cz 工具</p><p>原子性提交：每次提交都是可回滚的（一个需求可以提交好几次）</p><h2 id="Git-push-规范"><a href="#Git-push-规范" class="headerlink" title="Git push 规范"></a>Git push 规范</h2><p>主分支</p><ul><li>禁止强制推送（push –force）</li><li>禁止篡改历史（reset），只可以 revert</li></ul><p>开发分支</p><ul><li>允许强制推送</li><li>允许 rebase</li></ul><h2 id="代码合并规范"><a href="#代码合并规范" class="headerlink" title="代码合并规范"></a>代码合并规范</h2><ul><li>直接合并会产生一条垃圾历史</li><li>压缩合并（Squash）适合合并无关痛痒的 commit，以合并时的 commit message 为准</li><li>rebase 不产生垃圾历史</li></ul><h2 id="Git-tag-规范"><a href="#Git-tag-规范" class="headerlink" title="Git tag 规范"></a>Git tag 规范</h2><p>版本格式：主版本号.次版本号.修订号</p><ol><li>主版本号(Major)：不兼容的修改，</li><li>次版本号(Minor)：向下兼容的功能性新增，</li><li>修订号(Patch)：向下兼容的问题修正。</li></ol><p>是否需要前缀 v: 看个人喜好</p><p><img src="https://images.961110.xyz/images/2021/11/22/Git-tag-sample.png" alt="image-20211122155615007"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://www.bilibili.com/video/BV18q4y1n7Bd?p=1&amp;share_medium=iphone&amp;share_plat=ios&amp;share_session_id=43521A93-AADA-4B7D-B501-C2B8DC28DB0A&amp;share_source=COPY&amp;share_tag=s_i&amp;timestamp=1637545301&amp;unique_k=NuF4QQb">https://www.bilibili.com/video/BV18q4y1n7Bd?p=1&amp;share_medium=iphone&amp;share_plat=ios&amp;share_session_id=43521A93-AADA-4B7D-B501-C2B8DC28DB0A&amp;share_source=COPY&amp;share_tag=s_i&amp;timestamp=1637545301&amp;unique_k=NuF4QQb</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转载】中文文案排版指北</title>
      <link href="/posts/39632.html"/>
      <url>/posts/39632.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>【转载】原文地址 <a href="https://www.quchao.net/Chinese-Copywriting-Guidelines.html">www.quchao.net</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>日常生活、写博、工作、学习中，我们每个人都会遇到文案排版问题。<br>借着新的一年，往后都延用本文新规范来写作，有机会我会再写一下整体大纲结构以及配色突出。  </p><p>统一中文文案、排版的相关用法，降低团队成员 / 访客之间的沟通阅读成本，增加网站气质。</p><hr><h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><p>「有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。 毕竟爱情跟书写都需要适时地留白。 与大家共勉之。」 ——<a href="https://github.com/vinta/pangu.js">vinta/paranoid-auto-spacing</a></p><h3 id="中英文之间需要增加空格"><a href="#中英文之间需要增加空格" class="headerlink" title="中英文之间需要增加空格"></a>中英文之间需要增加空格</h3><p>正确：  </p><blockquote><p>在 LeanCloud 上，数据存储是围绕 <code>AVObject</code> 进行的。</p></blockquote><p>错误：  </p><blockquote><p>在 LeanCloud 上，数据存储是围绕<code>AVObject</code>进行的。</p><p>在 LeanCloud 上，数据存储是围绕<code>AVObject</code> 进行的。</p></blockquote><p>完整的正确用法：  </p><blockquote><p>在 LeanCloud 上，数据存储是围绕 <code>AVObject</code> 进行的。每个 <code>AVObject</code> 都包含了与 JSON 兼容的 key-value 对应的数据。数据是 schema-free 的，你不需要在每个 <code>AVObject</code> 上提前指定存在哪些键，只要直接设定对应的 key-value 即可。</p></blockquote><p>例外：「豆瓣FM」等产品名词，按照官方所定义的格式书写。</p><h3 id="中文与数字之间需要增加空格"><a href="#中文与数字之间需要增加空格" class="headerlink" title="中文与数字之间需要增加空格"></a>中文与数字之间需要增加空格</h3><p>正确：  </p><blockquote><p>今天出去买菜花了 5000 元。</p></blockquote><p>错误：  </p><blockquote><p>今天出去买菜花了 5000元。</p><p>今天出去买菜花了5000 元。</p></blockquote><h3 id="数字与单位之间需要增加空格"><a href="#数字与单位之间需要增加空格" class="headerlink" title="数字与单位之间需要增加空格"></a>数字与单位之间需要增加空格</h3><p>正确：  </p><blockquote><p>我家的光纤入屋宽带有 10 Gbps，SSD 一共有 20 TB</p></blockquote><p>错误：  </p><blockquote><p>我家的光纤入屋宽带有 10Gbps，SSD 一共有 20TB</p></blockquote><p>例外：度 / 百分比与数字之间不需要增加空格。</p><p>正确：</p><blockquote><p>今天是 233° 的高温。</p><p>新 MacBook Pro 有 15% 的 CPU 性能提升。</p></blockquote><p>错误：  </p><blockquote><p>今天是 233 ° 的高温。</p><p>新 MacBook Pro 有 15 % 的 CPU 性能提升。</p></blockquote><h3 id="全角标点与其他字符之间不加空格"><a href="#全角标点与其他字符之间不加空格" class="headerlink" title="全角标点与其他字符之间不加空格"></a>全角标点与其他字符之间不加空格</h3><p>正确：  </p><blockquote><p>刚刚买了一部 iPhone，好开心！</p></blockquote><p>错误：  </p><blockquote><p>刚刚买了一部 iPhone ，好开心！</p><p>刚刚买了一部 iPhone， 好开心！</p></blockquote><h4 id="用-text-spacing-来挽救？"><a href="#用-text-spacing-来挽救？" class="headerlink" title="用 text-spacing 来挽救？"></a>用 <code>text-spacing</code> 来挽救？</h4><p>CSS Text Module Level 4 的 <a href="https://www.w3.org/TR/css-text-4/#text-spacing-property"><code>text-spacing</code></a> 和 Microsoft 的 <a href="https://msdn.microsoft.com/library/ms531164(v=vs.85).aspx"><code>-ms-text-autospace</code></a> 可以实现自动为中英文之间增加空白。不过目前并未普及，另外在其他应用场景，例如 macOS、iOS、Windows 等用户介面目前并不存在这个特性，所以请继续保持随手加空格的习惯。</p><hr><h2 id="标点符号"><a href="#标点符号" class="headerlink" title="标点符号"></a>标点符号</h2><h3 id="不重复使用标点符号"><a href="#不重复使用标点符号" class="headerlink" title="不重复使用标点符号"></a>不重复使用标点符号</h3><p>正确：</p><blockquote><p>德国队竟然战胜了巴西队！</p><p>她竟然对你说「喵」？！</p></blockquote><p>错误：</p><blockquote><p>德国队竟然战胜了巴西队！！</p><p>德国队竟然战胜了巴西队！！！！！！！！</p><p>她竟然对你说「喵」？？！！</p><p>她竟然对你说「喵」？！？！？？！！</p></blockquote><hr><h2 id="全角和半角"><a href="#全角和半角" class="headerlink" title="全角和半角"></a>全角和半角</h2><p>不明白什么是全角（全形）与半角（半形）符号？请查看维基百科词条『<a href="https://zh.wikipedia.org/wiki/%E5%85%A8%E5%BD%A2%E5%92%8C%E5%8D%8A%E5%BD%A2">全形和半形</a>』。</p><h3 id="使用全角中文标点"><a href="#使用全角中文标点" class="headerlink" title="使用全角中文标点"></a>使用全角中文标点</h3><p>正确：</p><blockquote><p>嗨！你知道嘛？今天前台的小妹跟我说「喵」了哎！</p><p>核磁共振成像（NMRI）是什么原理都不知道？JFGI！</p></blockquote><p>错误：</p><blockquote><p>嗨! 你知道嘛? 今天前台的小妹跟我说 “喵” 了哎！</p><p>嗨! 你知道嘛?今天前台的小妹跟我说 “喵” 了哎！</p><p>核磁共振成像 (NMRI) 是什么原理都不知道? JFGI!</p><p>核磁共振成像(NMRI)是什么原理都不知道?JFGI!</p></blockquote><h3 id="数字使用半角字符"><a href="#数字使用半角字符" class="headerlink" title="数字使用半角字符"></a>数字使用半角字符</h3><p>正确：</p><blockquote><p>这个蛋糕只卖 1000 元。</p></blockquote><p>错误：</p><blockquote><p>这个蛋糕只卖 １０００ 元。</p></blockquote><p>例外：在设计稿、宣传海报中如出现极少量数字的情形时，为方便文字对齐，是可以使用全形数字的。</p><h3 id="遇到完整的英文整句、特殊名词，其内容使用半角标点"><a href="#遇到完整的英文整句、特殊名词，其内容使用半角标点" class="headerlink" title="遇到完整的英文整句、特殊名词，其内容使用半角标点"></a>遇到完整的英文整句、特殊名词，其内容使用半角标点</h3><p>正确：</p><blockquote><p>贾伯斯那句话是怎么说的？「Stay hungry, stay foolish.」</p><p>推荐你阅读《Hackers &amp; Painters: Big Ideas from the Computer Age》，非常的有趣。</p></blockquote><p>错误：</p><blockquote><p>贾伯斯那句话是怎么说的？「Stay hungry，stay foolish。」</p><p>推荐你阅读《Hackers＆Painters：Big Ideas from the Computer Age》，非常的有趣。</p></blockquote><hr><h2 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h2><h3 id="专有名词使用正确的大小写"><a href="#专有名词使用正确的大小写" class="headerlink" title="专有名词使用正确的大小写"></a>专有名词使用正确的大小写</h3><p>大小写相关用法原属于英文书写范畴，不属于本 wiki 讨论内容，在这里只对部分易错用法进行简述。</p><p>正确：</p><blockquote><p>使用 GitHub 登录</p><p>我们的客户有 GitHub、Foursquare、Microsoft Corporation、Google、Facebook, Inc.。</p></blockquote><p>错误：</p><blockquote><p>使用 github 登录</p><p>使用 GITHUB 登录</p><p>使用 Github 登录</p><p>使用 gitHub 登录</p><p>使用 gｲんĤЦ8 登录</p><p>我们的客户有 github、foursquare、microsoft corporation、google、facebook, inc.。</p><p>我们的客户有 GITHUB、FOURSQUARE、MICROSOFT CORPORATION、GOOGLE、FACEBOOK, INC.。</p><p>我们的客户有 Github、FourSquare、MicroSoft Corporation、Google、FaceBook, Inc.。</p><p>我们的客户有 gitHub、fourSquare、microSoft Corporation、google、faceBook, Inc.。</p><p>我们的客户有 gｲんĤЦ8、ｷouЯƧquﾑгє、๓เςг๏ร๏Ŧt ς๏гק๏гคtเ๏ภn、900913、ƒ4ᄃëв๏๏к, IПᄃ.。</p></blockquote><p>注意：当网页中需要配合整体视觉风格而出现全部大写／小写的情形，HTML 中请使用标淮的大小写规范进行书写；并通过 <code>text-transform: uppercase;</code>／<code>text-transform: lowercase;</code> 对表现形式进行定义。</p><h3 id="不要使用不地道的缩写"><a href="#不要使用不地道的缩写" class="headerlink" title="不要使用不地道的缩写"></a>不要使用不地道的缩写</h3><p>正确：</p><blockquote><p>我们需要一位熟悉 JavaScript、HTML5，至少理解一种框架（如 Backbone.js、AngularJS、React 等）的前端开发者。</p></blockquote><p>错误：</p><blockquote><p>我们需要一位熟悉 Js、h5，至少理解一种框架（如 backbone、angular、RJS 等）的 FED。</p></blockquote><hr><h2 id="争议"><a href="#争议" class="headerlink" title="争议"></a>争议</h2><p>以下用法略带有个人色彩，即：无论是否遵循下述规则，从语法的角度来讲都是<strong>正确</strong>的。</p><h3 id="链接之间增加空格"><a href="#链接之间增加空格" class="headerlink" title="链接之间增加空格"></a>链接之间增加空格</h3><p>用法：</p><blockquote><p>请 <a href="#">提交一个 issue</a> 并分配给相关同事。</p><p>访问我们网站的最新动态，请 <a href="#">点击这里</a> 进行订阅！</p></blockquote><p>对比用法：</p><blockquote><p>请<a href="#">提交一个 issue</a>并分配给相关同事。</p><p>访问我们网站的最新动态，请<a href="#">点击这里</a>进行订阅！</p></blockquote><h3 id="简体中文使用直角引号"><a href="#简体中文使用直角引号" class="headerlink" title="简体中文使用直角引号"></a>简体中文使用直角引号</h3><p>用法：</p><blockquote><p>「老师，『有条不紊』的『紊』是什么意思？」</p></blockquote><p>对比用法：</p><blockquote><p>“老师，‘有条不紊’的‘紊’是什么意思？”</p></blockquote><hr><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><table><thead><tr><th>仓库</th><th>语言</th></tr></thead><tbody><tr><td><a href="https://github.com/vinta/paranoid-auto-spacing" target="_blank">vinta/paranoid-auto-spacing<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></td><td>JavaScript</td></tr><tr><td><a href="https://github.com/huei90/pangu.node" target="_blank">huei90/pangu.node<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></td><td>Node.js</td></tr><tr><td><a href="https://github.com/huacnlee/auto-correct" target="_blank">huacnlee/auto-correct<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></td><td>Ruby</td></tr><tr><td><a href="https://github.com/sparanoid/space-lover" target="_blank">sparanoid/space-lover<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></td><td>PHP (WordPress)</td></tr><tr><td><a href="https://github.com/NauxLiu/auto-correct" target="_blank">nauxliu/auto-correct<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></td><td>PHP</td></tr><tr><td><a href="https://github.com/jxlwqq/chinese-typesetting" target="_blank">jxlwqq/chinese-typesetting<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></td><td>PHP</td></tr><tr><td><a href="https://github.com/hotoo/pangu.vim" target="_blank">hotoo/pangu.vim<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></td><td>Vim</td></tr><tr><td><a href="https://github.com/sparanoid/grunt-auto-spacing" target="_blank">sparanoid/grunt-auto-spacing<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></td><td>Node.js (Grunt)</td></tr><tr><td><a href="https://github.com/hjiang/scripts/blob/master/add-space-between-latin-and-cjk" target="_blank">hjiang/scripts/add-space-between-latin-and-cjk<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></td><td>Python</td></tr><tr><td><a href="https://github.com/hustcc/hint" target="_blank">hustcc/hint<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></td><td>Python</td></tr><tr><td><a href="https://github.com/studygolang/autocorrect" target="_blank">studygolang/autocorrect<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></td><td>Go</td></tr></tbody></table><hr><h2 id="谁在这样做？"><a href="#谁在这样做？" class="headerlink" title="谁在这样做？ "></a>谁在这样做？ </h2><table><thead><tr><th>网站</th><th>文案</th><th>UGC</th></tr></thead><tbody><tr><td><a href="https://www.apple.com/cn/" target="_blank">Apple 中国<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></td><td>是</td><td>N/A</td></tr><tr><td><a href="https://www.apple.com/hk/" target="_blank">Apple 香港<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></td><td>是</td><td>N/A</td></tr><tr><td><a href="https://www.apple.com/tw/" target="_blank">Apple 台湾<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></td><td>是</td><td>N/A</td></tr><tr><td><a href="https://www.microsoft.com/zh-cn/" target="_blank">Microsoft 中国<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></td><td>是</td><td>N/A</td></tr><tr><td><a href="https://www.microsoft.com/zh-hk/" target="_blank">Microsoft 香港<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></td><td>是</td><td>N/A</td></tr><tr><td><a href="https://www.microsoft.com/zh-tw/" target="_blank">Microsoft 台湾<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></td><td>是</td><td>N/A</td></tr><tr><td><a href="https://leancloud.cn/" target="_blank">LeanCloud<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></td><td>是</td><td>N/A</td></tr><tr><td><a href="https://www.v2ex.com/" target="_blank">V2EX<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></td><td>是</td><td>是</td></tr><tr><td><a href="https://apple4us.com/" target="_blank">Apple4us<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></td><td>是</td><td>N/A</td></tr><tr><td><a href="https://ruby-china.org/" target="_blank">Ruby China<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></td><td>是</td><td>标题达成</td></tr><tr><td><a href="https://phphub.org/" target="_blank">PHPHub<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></td><td>是</td><td>标题达成</td></tr><tr><td><a href="https://sspai.com/" target="_blank">少数派<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></td><td>是</td><td>N/A</td></tr></tbody></table><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>  <a href="https://www.thoughtco.com/guidelines-for-using-capital-letters-1691724">Guidelines for Using Capital Letters - ThoughtCo.</a></li><li>  <a href="https://en.wikipedia.org/wiki/Letter_case">Letter case - Wikipedia</a></li><li>  <a href="https://en.oxforddictionaries.com/grammar/punctuation">Punctuation - Oxford Dictionaries</a></li><li>  <a href="https://owl.english.purdue.edu/owl/section/1/6/">Punctuation - The Purdue OWL</a></li><li>  <a href="https://www.wikihow.com/Use-English-Punctuation-Correctly">How to Use English Punctuation Correctly - wikiHow</a></li><li>  <a href="https://zh.opensuse.org/index.php?title=Help:%E6%A0%BC%E5%BC%8F">格式 - openSUSE</a></li><li>  <a href="https://zh.wikipedia.org/wiki/%E5%85%A8%E5%BD%A2%E5%92%8C%E5%8D%8A%E5%BD%A2">全形和半形 - 维基百科</a></li><li>  <a href="https://zh.wikipedia.org/wiki/%E5%BC%95%E8%99%9F">引号 - 维基百科</a></li><li>  <a href="https://zh.wikipedia.org/wiki/%E7%96%91%E5%95%8F%E9%A9%9A%E5%98%86%E8%99%9F">疑问惊叹号 - 维基百科</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker源码分析（四）—— Docker Daemon 启动流程</title>
      <link href="/posts/2533.html"/>
      <url>/posts/2533.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>博文分析的 Docker 源码基于 19.03 版本，阅读工具采用 Goland，追踪的是 Docker Daemon 的启动过程。</p><p>第一次阅读 Docker 源码，如有纰漏还请轻喷，喷完希望能够通过邮件或者留言的方式指出问题。</p><p>限于篇幅以及关注重点的原因，部分个人认为不重要的代码会用省略号代替。</p><p>Tips: 如果图片看不清楚可以点击查看大图。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>照例还是先摆出 Docker 的架构，<strong>架构在心中，源码轻松读</strong>。</p><p>在上两篇博文中跟踪了 Docker Daemon 中创建和运行容器的过程，但是缺失了像 <a href="https://blog.961110.xyz/posts/64829.html">Docker源码分析（一）—— docker run 命令在 Docker Client 中的执行</a> 一文中，Daemon 客户端启动的过程跟踪，所以在本文中将对其启动过程进行简单分析。</p><table>    <tr>        <td ><center><img src="https://images.961110.xyz/images/2021/11/16/docker-architecture.png" >图1  Docker 架构（官网图） </center></td>        <td ><center><img src="https://images.961110.xyz/images/2021/11/16/Docker.png"  >图2 Docker 架构图（分组件）</center></td>    </tr></table><p>在 Client 中调用<code>ContainerStart()</code>，向 Daemon 发送 <code>resp, err := cli.post(ctx, &quot;/containers/&quot;+containerID+&quot;/start&quot;, query, nil, nil)</code>，然后 Daemon 调用 <code>r.postContainersStart()</code>启动容器。</p><h2 id="Docker-Daemon-整体启动过程"><a href="#Docker-Daemon-整体启动过程" class="headerlink" title="Docker Daemon 整体启动过程"></a>Docker Daemon 整体启动过程</h2><h3 id="func-main"><a href="#func-main" class="headerlink" title="func main()"></a>func main()</h3><p>和 Docker Client 一样，Docker Daemon 的入口函数也是 <code>func main()</code>，位于 <code>cmd/dockerd/docker.go: 71</code></p><img src="https://images.961110.xyz/images/2021/11/21/Docker-Daemon-1fc84a77d77879d9.png" style="zoom: 33%;" /><p>在 <a href="https://blog.961110.xyz/posts/64829.html">Docker源码分析（一）—— docker run 命令在 Docker Client 中的执行</a> 一文中提到过，Docker 利用 Cobra 这个命令行库构建了各种 Docker 命令，所以 Daemon 在执行命令的时候同样需要构建一个命令执行对象也就是图中 <code>cmd, err := newDaemonCommand()</code> 这一句，设置好各种参数和命令上述，然后去执行。</p><p>在<code>newDaemonCommand()</code>这个函数创建了一个<code>cobra.Command</code>的对象，在创建的时候绑定了一个匿名函数，函数里调用了<code>runDaemon()</code>函数，这个函数是待会儿要重点分析的函数。</p><p>如果没有猜错的话，绑定的那个匿名函数会在<code>cmd.Execute()</code>的时候被调用，从而接受 Docker Client 的各种请求。</p><p><code>runDaemon()</code>函数的实现只有两行，但是扮演了重要的角色。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runDaemon</span><span class="params">(opts *daemonOptions)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   daemonCli := NewDaemonCli()</span><br><span class="line">   <span class="keyword">return</span> daemonCli.start(opts)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NewDaemonCli"><a href="#NewDaemonCli" class="headerlink" title="NewDaemonCli()"></a>NewDaemonCli()</h3><p>函数实现</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDaemonCli</span><span class="params">()</span> *<span class="title">DaemonCli</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;DaemonCli&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单纯就是创建一个 DaemonCli 对象，其包含的数据有</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> DaemonCli <span class="keyword">struct</span> &#123;</span><br><span class="line">*config.Config<span class="comment">// 配置信息</span></span><br><span class="line">configFile *<span class="keyword">string</span><span class="comment">// 配置文件</span></span><br><span class="line">flags      *pflag.FlagSet<span class="comment">// 参数信息</span></span><br><span class="line"></span><br><span class="line">api             *apiserver.Server<span class="comment">// APIServer</span></span><br><span class="line">d               *daemon.Daemon<span class="comment">// daemon对象</span></span><br><span class="line">authzMiddleware *authorization.Middleware <span class="comment">// authzMiddleware， enables to dynamically reload the authorization plugins，认证插件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中APIServer包含的数据有</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">cfg           *Config<span class="comment">//apiserver的配置信息</span></span><br><span class="line">servers       []*HTTPServer<span class="comment">//httpServer结构体对象，包括http.Server和net.Listener监听器。</span></span><br><span class="line">routers       []router.Router<span class="comment">//路由表对象Route,包括Handler,Method, Path</span></span><br><span class="line">routerSwapper *routerSwapper<span class="comment">//路由交换器对象，使用新的路由交换旧的路由器</span></span><br><span class="line">middlewares   []middleware.Middleware<span class="comment">//中间件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>daemonCli.start()</code>的实现过程中会发挥重要作用。</p><h3 id="daemonCli-start-opts"><a href="#daemonCli-start-opts" class="headerlink" title="daemonCli.start(opts)"></a>daemonCli.start(opts)</h3><p>没错，这个函数贼长，总的来说就是配置 Daemon 客户端、开启服务端的监听以便接受请求、获取 libcontainerd 的地址、初始化接受授请求的路由表、等待请求到来。</p><img src="https://images.961110.xyz/images/2021/11/21/DaemonCli.starte849a93c2dbd7894.png" style="zoom:33%;" /><p><code>preNotifySystem()</code>的实现是空的，不知道为什么会有这么一个调用存在。</p><p>在创建 Daemon 对象的时候（<code>daemon.NewDaemon()</code>），会对网络进行初始化，包括网络控制器和三个内质网络（controller、none、bridge）</p><p>初始化路由表的部分非常关键，已经在 <a href="https://blog.961110.xyz/posts/19054.html#initRouter-opts-routerOptions">Docker源码分析（二）—— docker run 命令在 Docker Daemon中的执行</a> 已经分析过了，可以跳转看一下。</p><p><code>notifySystem()</code>通知系统已经做好准备，可以接受请求了。</p><p><code>errAPI := &lt;-serveAPIWait</code>在等待 apiserver 执行出错，不出错就会阻塞到这里</p><p>下面就是执行出错后守卫的工作。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://www.cnblogs.com/wen123456/p/14187569.html">DOCKER源码分析2 docker daemon启动流程 - luoyuna - 博客园 (cnblogs.com)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 毕设 </tag>
            
            <tag> Docker </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker源码分析（三）—— docker start 命令在 Docker Daemon中的执行</title>
      <link href="/posts/56133.html"/>
      <url>/posts/56133.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>博文分析的 Docker 源码基于 19.03 版本，阅读工具采用 Goland，追踪的是<code>docker start</code>命令在 Docker Daemon 中的执行过程。</p><p>第一次阅读 Docker 源码，如有纰漏还请轻喷，喷完希望能够通过邮件或者留言的方式指出问题。</p><p>限于篇幅以及关注重点的原因，部分个人认为不重要的代码会用省略号代替。</p><p>Tips: 如果图片看不清楚可以点击查看大图。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>照例还是先摆出 Docker 的架构，<strong>架构在心中，源码轻松读</strong>。</p><p>在上一篇博文中跟踪了 Docker Daemon 中创建容器的过程，下一步就是 Client 向 Daemon 发送容器启动命令，所以在这篇博文中跟踪的是 Daemon 启动容器的过程。</p><table>    <tr>        <td ><center><img src="https://images.961110.xyz/images/2021/11/16/docker-architecture.png" >图1  Docker 架构（官网图） </center></td>        <td ><center><img src="https://images.961110.xyz/images/2021/11/16/Docker.png"  >图2 Docker 架构图（分组件）</center></td>    </tr></table><p>在 Client 中调用<code>ContainerStart()</code>，向 Daemon 发送 <code>resp, err := cli.post(ctx, &quot;/containers/&quot;+containerID+&quot;/start&quot;, query, nil, nil)</code>，然后 Daemon 调用 <code>r.postContainersStart()</code>启动容器。</p><h2 id="Docker-Daemon-处理启动容器的请求流程"><a href="#Docker-Daemon-处理启动容器的请求流程" class="headerlink" title="Docker Daemon 处理启动容器的请求流程"></a>Docker Daemon 处理启动容器的请求流程</h2><p>上文提到 Dcoker Client 通过 REST API 与 Docker Daemon 进行交互，启动容器的请求是当然在 Daemon 中也有相应的路由逻辑，</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">router.NewPostRoute(<span class="string">&quot;/containers/&#123;name:.*&#125;/start&quot;</span>, r.postContainersStart)</span><br></pre></td></tr></table></figure><p><code>postContainersStart()</code>就是对应的处理函数。</p><h3 id="postContainersStart"><a href="#postContainersStart" class="headerlink" title="postContainersStart()"></a>postContainersStart()</h3><img src="https://images.961110.xyz/images/2021/11/19/postContainersStart.png" style="zoom:50%;" /><p>可以看出本函数主要是对 Client 传来的数据进行解析和校验，最后调用<code>s.backend.ContainerStart(vars[&quot;name&quot;], hostConfig, checkpoint, checkpointDir)</code>启动镜像，这里的<code>s.backend</code>同样是 Daemon 对象，<code>vars[&quot;name&quot;]</code>是容器名。</p><h3 id="ContainerStart"><a href="#ContainerStart" class="headerlink" title="ContainerStart()"></a>ContainerStart()</h3><img src="https://images.961110.xyz/images/2021/11/19/ContainerStart.png" style="zoom: 50%;" /><p>从上图可以看出，这个函数主要助兴了一些参数以及兼容性配置，最后调用<code>daemon.containerStart(container, checkpoint, checkpointDir, true)</code>准备容器运行所需的所有条件。</p><h3 id="containerStart"><a href="#containerStart" class="headerlink" title="containerStart()"></a>containerStart()</h3><p>daemon/start.go:102</p><img src="https://images.961110.xyz/images/2021/11/19/containerStart.png" alt="image-20211119193411476" style="zoom: 67%;" /><p>在这个函数中，挂载了基本文件系统（可读写层）、初始化了网络配置、创建了符合 OCI 标准的容器 spec、获取了 Libcontainerd 的配置，基于上述的条件 create 了容器，随后启动容器并设置容器的状态为 running。</p><p><code>daemon.containerd.Create()</code>中的<code>daemon.containerd</code>指的是 libcontainerd.client，让我们再回顾一下 Docker 的架构。</p><p><img src="https://images.961110.xyz/images/2021/11/16/Docker.png"></p><p>所以下面创建的过程已经到了 containerd 的层次了</p><p>下面继续跟进 <code>Create()</code> 的过程</p><h3 id="daemon-containerd-Create"><a href="#daemon-containerd-Create" class="headerlink" title="daemon.containerd.Create()"></a>daemon.containerd.Create()</h3><p>libcontainerd/remote/client.go: 127</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *client)</span> <span class="title">Create</span><span class="params">(ctx context.Context, id <span class="keyword">string</span>, ociSpec *specs.Spec, runtimeOptions <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   bdir := c.bundleDir(id)</span><br><span class="line">   c.logger.WithField(<span class="string">&quot;bundle&quot;</span>, bdir).WithField(<span class="string">&quot;root&quot;</span>, ociSpec.Root.Path).Debug(<span class="string">&quot;bundle dir created&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用传入的 spec 和 containerd 创建容器    </span></span><br><span class="line">   _, err := c.client.NewContainer(ctx, id,</span><br><span class="line">      containerd.WithSpec(ociSpec),</span><br><span class="line">      containerd.WithRuntime(runtimeName, runtimeOptions),</span><br><span class="line">      WithBundle(bdir, ociSpec),</span><br><span class="line">   )</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>c.client</code>指的是 containerd client。</p><p>目前为止，Docker Daemon 创建容器的部分已经结束，现在回过头去看怎么启动容器。</p><h3 id="Start"><a href="#Start" class="headerlink" title="Start()"></a>Start()</h3><p>libcontainerd/remote/client.go: 146</p><p>daemon/start.go:102 的 <code>containerStart()</code>函数创建完容器后，紧接着调用下面的代码启动容器。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pid, err := daemon.containerd.Start(context.Background(), container.ID, checkpointDir,</span><br><span class="line">   container.StreamConfig.Stdin() != <span class="literal">nil</span> || container.Config.Tty,</span><br><span class="line">   container.InitializeStdio)</span><br></pre></td></tr></table></figure><p><img src="https://images.961110.xyz/images/2021/11/19/Start.png" alt="image-20211119213607191"></p><p>在这个函数中，利用刚刚创建好的容器，根据其 ID 获取对应的容器，然后创建一个启动任务去启动容器。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Start create and start a task for the specified containerd id</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *client)</span> <span class="title">Start</span><span class="params">(ctx context.Context, id, checkpointDir <span class="keyword">string</span>, withStdin <span class="keyword">bool</span>, attachStdio libcontainerdtypes.StdioCallback)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 根据 ID 获取容器</span></span><br><span class="line">ctr, err := c.getContainer(ctx, id)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">cp             *types.Descriptor</span><br><span class="line">t              containerd.Task</span><br><span class="line">rio            cio.IO</span><br><span class="line">stdinCloseSync = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">spec, err := ctr.Spec(ctx)</span><br><span class="line">labels, err := ctr.Labels(ctx)</span><br><span class="line"></span><br><span class="line">bundle := labels[DockerContainerBundlePath]</span><br><span class="line">uid, gid := getSpecUser(spec)</span><br><span class="line">t, err = ctr.NewTask(ctx,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">string</span>)</span> <span class="params">(cio.IO, error)</span></span> &#123;</span><br><span class="line">fifos := newFIFOSet(bundle, libcontainerdtypes.InitProcessName, withStdin, spec.Process.Terminal)</span><br><span class="line"></span><br><span class="line">rio, err = c.createIO(fifos, id, libcontainerdtypes.InitProcessName, stdinCloseSync, attachStdio)</span><br><span class="line"><span class="keyword">return</span> rio, err</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(_ context.Context, _ *containerd.Client, info *containerd.TaskInfo)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">info.Checkpoint = cp</span><br><span class="line"><span class="keyword">if</span> runtime.GOOS != <span class="string">&quot;windows&quot;</span> &#123;</span><br><span class="line">info.Options = &amp;runctypes.CreateOptions&#123;</span><br><span class="line">IoUid:       <span class="keyword">uint32</span>(uid),</span><br><span class="line">IoGid:       <span class="keyword">uint32</span>(gid),</span><br><span class="line">NoPivotRoot: os.Getenv(<span class="string">&quot;DOCKER_RAMDISK&quot;</span>) != <span class="string">&quot;&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Make sure we set the runhcs options to debug if we are at debug level.</span></span><br><span class="line"><span class="keyword">if</span> c.logger.Level == logrus.DebugLevel &#123;</span><br><span class="line">info.Options = &amp;options.Options&#123;Debug: <span class="literal">true</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line">...</span><br><span class="line"><span class="comment">// Signal c.createIO that it can call CloseIO</span></span><br><span class="line"><span class="built_in">close</span>(stdinCloseSync)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := t.Start(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> _, err := t.Delete(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.logger.WithError(err).WithField(<span class="string">&quot;container&quot;</span>, id).</span><br><span class="line">Error(<span class="string">&quot;failed to delete task after fail start&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>, wrapError(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">int</span>(t.Pid()), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再往下追踪任务的创建和启动，也是通过发送 RPC 请求的方式与下层组件沟通</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *tasksClient)</span> <span class="title">Create</span><span class="params">(ctx context.Context, in *CreateTaskRequest, opts ...grpc.CallOption)</span> <span class="params">(*CreateTaskResponse, error)</span></span> &#123;</span><br><span class="line">out := <span class="built_in">new</span>(CreateTaskResponse)</span><br><span class="line">err := c.cc.Invoke(ctx, <span class="string">&quot;/containerd.services.tasks.v1.Tasks/Create&quot;</span>, in, out, opts...)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> out, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *tasksClient)</span> <span class="title">Start</span><span class="params">(ctx context.Context, in *StartRequest, opts ...grpc.CallOption)</span> <span class="params">(*StartResponse, error)</span></span> &#123;</span><br><span class="line">out := <span class="built_in">new</span>(StartResponse)</span><br><span class="line">err := c.cc.Invoke(ctx, <span class="string">&quot;/containerd.services.tasks.v1.Tasks/Start&quot;</span>, in, out, opts...)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> out, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>越看感觉越迷糊，也没有对应的文章可以学习，姑且分析到这里吧。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://www.cnblogs.com/wen123456/p/14187666.html">DOCKER源码分析5 daemon端对container start的处理 - luoyuna - 博客园 (cnblogs.com)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 毕设 </tag>
            
            <tag> Docker </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker源码分析（二）—— docker run 命令在 Docker Daemon中的执行</title>
      <link href="/posts/19054.html"/>
      <url>/posts/19054.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>博文分析的 Docker 源码基于 19.03 版本，阅读工具采用 Goland，追踪的是<code>docker run</code>命令在 Docker Daemon 中的执行过程。</p><p>第一次阅读 Docker 源码，如有纰漏还请轻喷，喷完希望能够通过邮件或者留言的方式指出问题。</p><p>限于篇幅以及关注重点的原因，部分个人认为不重要的代码会用省略号代替。</p><p>Tips: 如果图片看不清楚可以点击查看大图。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>照例还是先摆出 Docker 的架构，<strong>架构在心中，源码轻松读</strong>。</p><p>在上一篇博文中跟踪了<code>docker run</code>命令在 Docker Client 的执行过程，于是就有了本篇博文———分析 <code>docker run</code>在 Docker Daemon 中的执行过程。</p><table>    <tr>        <td ><center><img src="https://images.961110.xyz/images/2021/11/16/docker-architecture.png" >图1  Docker 架构（官网图） </center></td>        <td ><center><img src="https://images.961110.xyz/images/2021/11/16/Docker.png"  >图2 Docker 架构图（分组件）</center></td>    </tr></table>上篇博文提到，在 Docker Client 中调用：`serverResp, err := cli.post(ctx, "/containers/create", query, body, nil)``resp, err := cli.post(ctx, "/containers/"+containerID+"/start", query, nil, nil)`两条语句向 Docker Daemon 发送创建容器和启动容器的请求，所以在本篇博文中将从如何处理`"/containers/create"`这个请求开始分析执行流程。<h2 id="Docker-Daemon-处理-Docker-Client-请求的过程"><a href="#Docker-Daemon-处理-Docker-Client-请求的过程" class="headerlink" title="Docker Daemon 处理 Docker Client 请求的过程"></a>Docker Daemon 处理 Docker Client 请求的过程</h2><p>从 Docker Client 发送的请求可以看出其使用 REST API 与 Docker Daemon 进行交互，那 Docker Daemon 中一定会有相应的路由逻辑，所以从初始化路由开始跟踪。</p><h3 id="initRouter-opts-routerOptions"><a href="#initRouter-opts-routerOptions" class="headerlink" title="initRouter(opts routerOptions)"></a>initRouter(opts routerOptions)</h3><p>这个函数的作用就是初始化路由逻辑。</p><p>向上追溯其调用链路：<code>initRouter(routerOptions)</code> &lt;– <code>daemonCli.start(opts)</code> &lt;– <code>runDaemon(opts)</code> &lt;– <code>newDaemonCommand()</code> &lt;– <code>main()</code>可以清楚得看出 Docker Daemon 创建 DaemonCommand 对象的过程中进行了路由的初始化，这个后面再分析，先追踪初始化路由的过程。</p><img src="https://images.961110.xyz/images/2021/11/18/initRouter.png" alt="image-20211118204241671" style="zoom: 67%;" /><p>源代码如下</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initRouter</span><span class="params">(opts routerOptions)</span></span> &#123;</span><br><span class="line"><span class="comment">// 获取容器解码器</span></span><br><span class="line">decoder := runconfig.ContainerDecoder&#123;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 创建各个组件的路由表</span></span><br><span class="line">routers := []router.Router&#123;</span><br><span class="line"><span class="comment">// we need to add the checkpoint router before the container router or the DELETE gets masked</span></span><br><span class="line">checkpointrouter.NewRouter(opts.daemon, decoder),</span><br><span class="line">container.NewRouter(opts.daemon, decoder),</span><br><span class="line">image.NewRouter(opts.daemon.ImageService()),</span><br><span class="line">systemrouter.NewRouter(opts.daemon, opts.cluster, opts.buildCache, opts.buildkit, opts.features),</span><br><span class="line">volume.NewRouter(opts.daemon.VolumesService()),</span><br><span class="line">build.NewRouter(opts.buildBackend, opts.daemon, opts.features),</span><br><span class="line">sessionrouter.NewRouter(opts.sessionManager),</span><br><span class="line">swarmrouter.NewRouter(opts.cluster),</span><br><span class="line">pluginrouter.NewRouter(opts.daemon.PluginManager()),</span><br><span class="line">distributionrouter.NewRouter(opts.daemon.ImageService()),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 根据设置好的路由表初始化apiServer的路由器</span></span><br><span class="line">opts.api.InitRouter(routers...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个函数中创建了一个路由表，包含 image, volume, container 等路由项，向下追踪 container 的路由项，看看 <code>container.NewRouter(opts.daemon, decoder)</code>是怎样执行的。</p><h3 id="NewRouter-b-Backend-decoder-httputils-ContainerDecoder"><a href="#NewRouter-b-Backend-decoder-httputils-ContainerDecoder" class="headerlink" title="NewRouter(b Backend, decoder httputils.ContainerDecoder)"></a>NewRouter(b Backend, decoder httputils.ContainerDecoder)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NewRouter initializes a new container router</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRouter</span><span class="params">(b Backend, decoder httputils.ContainerDecoder)</span> <span class="title">router</span>.<span class="title">Router</span></span> &#123;</span><br><span class="line">r := &amp;containerRouter&#123;</span><br><span class="line">backend: b,</span><br><span class="line">decoder: decoder,</span><br><span class="line">&#125;</span><br><span class="line">r.initRoutes()</span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个函数中创建了一个<code>containerRouter</code>的对象，其中<code>backend</code>就是<code>initRouter()</code>在调用时传入的<code>daemon.Daemon</code>对象。</p><p>继续看<code>initRoutes()</code>函数</p><h3 id="func-r-containerRouter-initRoutes"><a href="#func-r-containerRouter-initRoutes" class="headerlink" title="func (r *containerRouter) initRoutes()"></a>func (r *containerRouter) initRoutes()</h3><p>下面是这个函数完整的代码，可以看到 REST API 经典的 get, psot, put, delete 方法，后面跟着资源路径。 </p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// initRoutes initializes the routes in container router</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *containerRouter)</span> <span class="title">initRoutes</span><span class="params">()</span></span> &#123;</span><br><span class="line">r.routes = []router.Route&#123;</span><br><span class="line"><span class="comment">// HEAD</span></span><br><span class="line">router.NewHeadRoute(<span class="string">&quot;/containers/&#123;name:.*&#125;/archive&quot;</span>, r.headContainersArchive),</span><br><span class="line"><span class="comment">// GET</span></span><br><span class="line">router.NewGetRoute(<span class="string">&quot;/containers/json&quot;</span>, r.getContainersJSON),</span><br><span class="line">router.NewGetRoute(<span class="string">&quot;/containers/&#123;name:.*&#125;/export&quot;</span>, r.getContainersExport),</span><br><span class="line">...</span><br><span class="line">router.NewGetRoute(<span class="string">&quot;/exec/&#123;id:.*&#125;/json&quot;</span>, r.getExecByID),</span><br><span class="line">router.NewGetRoute(<span class="string">&quot;/containers/&#123;name:.*&#125;/archive&quot;</span>, r.getContainersArchive),</span><br><span class="line"><span class="comment">// POST</span></span><br><span class="line">router.NewPostRoute(<span class="string">&quot;/containers/create&quot;</span>, r.postContainersCreate),</span><br><span class="line">router.NewPostRoute(<span class="string">&quot;/containers/&#123;name:.*&#125;/kill&quot;</span>, r.postContainersKill),</span><br><span class="line">router.NewPostRoute(<span class="string">&quot;/containers/&#123;name:.*&#125;/pause&quot;</span>, r.postContainersPause),</span><br><span class="line">...</span><br><span class="line">router.NewPostRoute(<span class="string">&quot;/containers/&#123;name:.*&#125;/update&quot;</span>, r.postContainerUpdate),</span><br><span class="line">router.NewPostRoute(<span class="string">&quot;/containers/prune&quot;</span>, r.postContainersPrune),</span><br><span class="line">router.NewPostRoute(<span class="string">&quot;/commit&quot;</span>, r.postCommit),</span><br><span class="line"><span class="comment">// PUT</span></span><br><span class="line">router.NewPutRoute(<span class="string">&quot;/containers/&#123;name:.*&#125;/archive&quot;</span>, r.putContainersArchive),</span><br><span class="line"><span class="comment">// DELETE</span></span><br><span class="line">router.NewDeleteRoute(<span class="string">&quot;/containers/&#123;name:.*&#125;&quot;</span>, r.deleteContainers),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点关注一下这两行代码</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">router.NewPostRoute(<span class="string">&quot;/containers/create&quot;</span>, r.postContainersCreate)</span><br><span class="line">router.NewPostRoute(<span class="string">&quot;/containers/&#123;name:.*&#125;/start&quot;</span>, r.postContainersStart)</span><br></pre></td></tr></table></figure><p>第二个参数就是对应的处理函数，在这两个函数中分别做容器创建和启动的工作。</p><h2 id="Docker-Daemon-处理创建容器的请求流程"><a href="#Docker-Daemon-处理创建容器的请求流程" class="headerlink" title="Docker Daemon 处理创建容器的请求流程"></a>Docker Daemon 处理创建容器的请求流程</h2><h3 id="postContainersCreate"><a href="#postContainersCreate" class="headerlink" title="postContainersCreate"></a>postContainersCreate</h3><p>api/server/router/container/container_routes.go: 453</p><p>代码不是很复杂，只需要关注重点内容即可，主要是解析 client 传来的数据并根据版本进行相应的配置，然后创建容器，最后给 client 返回结果。</p><img src="https://images.961110.xyz/images/2021/11/18/postContainerCreate.png" alt="image-20211118204056283" style="zoom: 50%;" /><p>实现代码如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *containerRouter)</span> <span class="title">postContainersCreate</span><span class="params">(ctx context.Context, w http.ResponseWriter, r *http.Request, vars <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// 解析表单是否合法</span></span><br><span class="line"><span class="keyword">if</span> err := httputils.ParseForm(r); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查表达内容是否为JSON格式</span></span><br><span class="line"><span class="keyword">if</span> err := httputils.CheckForJSON(r); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从表单中获取名字（&quot;/container/create&quot;）</span></span><br><span class="line">name := r.Form.Get(<span class="string">&quot;name&quot;</span>)</span><br><span class="line"><span class="comment">// 获取 client 传过来的config, hostConfig, networkingConfig数据</span></span><br><span class="line">config, hostConfig, networkingConfig, err := s.decoder.DecodeConfig(r.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">version := httputils.VersionFromContext(ctx)</span><br><span class="line">adjustCPUShares := versions.LessThan(version, <span class="string">&quot;1.19&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据API版本号进行针对性配置</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据配置创建容器</span></span><br><span class="line">ccr, err := s.backend.ContainerCreate(types.ContainerCreateConfig&#123;</span><br><span class="line">Name:             name,</span><br><span class="line">Config:           config,</span><br><span class="line">HostConfig:       hostConfig,</span><br><span class="line">NetworkingConfig: networkingConfig,</span><br><span class="line">AdjustCPUShares:  adjustCPUShares,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给 client 返回创建的结果</span></span><br><span class="line"><span class="keyword">return</span> httputils.WriteJSON(w, http.StatusCreated, ccr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中出现的各个config主要是为了容器的可移植性，config 中包含了容器的基本信息：name、输入输出流等；host相关不可移植的保存在 HostConfig 中。</p><p>这个函数中需要关注的重点是这一段。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ccr, err := s.backend.ContainerCreate(types.ContainerCreateConfig&#123;</span><br><span class="line">Name:             name,</span><br><span class="line">Config:           config,</span><br><span class="line">HostConfig:       hostConfig,</span><br><span class="line">NetworkingConfig: networkingConfig,</span><br><span class="line">AdjustCPUShares:  adjustCPUShares,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>代码中的<code>s.backend</code>其实就是<code>daemon.Daemon</code>对象，参数就是用 client 传来的数据解析出的各个配置信息创建的<code>ContainerCreateConfig</code>对象</p><p>往下追踪调用的是这个函数</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(daemon *Daemon)</span> <span class="title">ContainerCreate</span><span class="params">(params types.ContainerCreateConfig)</span> <span class="params">(containertypes.ContainerCreateCreatedBody, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> daemon.containerCreate(createOpts&#123;</span><br><span class="line">params:                  params,</span><br><span class="line">managed:                 <span class="literal">false</span>,</span><br><span class="line">ignoreImagesArgsEscaped: <span class="literal">false</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>managed</code>和<code>ignoreImagesArgsEscaped</code>这两个参数的意思不详。</p><h3 id="containerCreate-opts-createOpts"><a href="#containerCreate-opts-createOpts" class="headerlink" title="containerCreate(opts createOpts)"></a>containerCreate(opts createOpts)</h3><p>daemon/create.go: 55</p><p><img src="https://images.961110.xyz/images/2021/11/18/containerCreate.png" alt="image-20211118204547389"></p><p>这个函数中主要是检验 config, hostconfig, networkingconfig 的合理性，进而正确地创建镜像。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(daemon *Daemon)</span> <span class="title">containerCreate</span><span class="params">(opts createOpts)</span> <span class="params">(containertypes.ContainerCreateCreatedBody, error)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">...</span><br><span class="line"><span class="comment">// // 验证HostConfig和Container Config之间的合法性</span></span><br><span class="line">warnings, err := daemon.verifyContainerSettings(os, opts.params.HostConfig, opts.params.Config, <span class="literal">false</span>)</span><br><span class="line">    </span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 验证NetworkingConfig的正确性，如client的配置中是否为一个容器创建时配置了超过1个network，查看IPAMConfig是否有效</span></span><br><span class="line">err = verifyNetworkingConfig(opts.params.NetworkingConfig)</span><br><span class="line">    </span><br><span class="line">...</span><br><span class="line"><span class="comment">// 调整HostConfig不正常的值，如CPUShares、Memory</span></span><br><span class="line">err = daemon.adaptContainerSettings(opts.params.HostConfig, opts.params.AdjustCPUShares)</span><br><span class="line">    </span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">container, err := daemon.create(opts)</span><br><span class="line">    </span><br><span class="line">....</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 返回运行结果</span></span><br><span class="line"><span class="keyword">return</span> containertypes.ContainerCreateCreatedBody&#123;ID: container.ID, Warnings: warnings&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步关注<code>container, err := daemon.create(opts)</code>这行代码，其返回了创建成功的容器。</p><h3 id="func-daemon-Daemon-create-opts-createOpts"><a href="#func-daemon-Daemon-create-opts-createOpts" class="headerlink" title="func (daemon *Daemon) create(opts createOpts)"></a>func (daemon *Daemon) create(opts createOpts)</h3><img src="https://images.961110.xyz/images/2021/11/18/docker-create.png" alt="docker  create" style="zoom: 33%;" /><p>在这个函数中创建容器进一步调用了<code>daemon.newContainer(opts.params.Name, os, opts.params.Config, opts.params.HostConfig, imgID, opts.managed)</code>创建容器，</p><p>其他的部分主要是为容器的运行做准备：</p><ul><li>找到容器所依赖的镜像ID，并根据镜像配置容器的运行 OS；</li><li>将用户传过来的容器 config 与所依赖镜像 JSON 文件描述的 config 进行合并并验证合法性</li><li>设置安全性选项</li><li>在挂载了 labels 后，创建可读写层</li><li>以 root uid gid的属性创建目录，并修改权限，在<code>/var/lib/docker/containers</code>目录下创建容器文件，并在容器文件下创建 checkpoints 目录</li><li>注册所有挂载到容器的数据卷</li><li>没有设置网络就设置 default 网络</li><li>在 /var/lib/docker/aufs/mnt目录下创建文件以及设置工作目录</li><li>更新网络设置</li><li>将 container 对象 json 化后写入到本地磁盘进行持久化</li><li>向 Docker Daemon 注册新 container</li></ul><h3 id="daemon-newContainer"><a href="#daemon-newContainer" class="headerlink" title="daemon.newContainer()"></a>daemon.newContainer()</h3><p>daemon/container.go: 130</p><p><img src="https://images.961110.xyz/images/2021/11/18/newContainer.png"></p><p>在这个函数中主要是为容器生成了 ID 和 name，创建了一个 basecontainer 对象，其本身也就是 container 结构体的对象，随后对 basecontainer 对象的一些属性进行初始化，最后返回 basecontainer。</p><p><strong>至此已经完成了对 container 对象的创建和初始化</strong>，目前整个的流程图如下。</p><p><img src="https://images.961110.xyz/images/2021/11/18/r.postContainersCreatede976bc83f5b619b.png" alt="r.postContainersCreate()"></p><p>最后在<code>postContainersCreate()</code>中的<code>return httputils.WriteJSON(w, http.StatusCreated, ccr)</code>，将结果返回给 Docker Client。在 Client 中一下步就是调用 ContainerStart()，向 Docker Daemon 发送 <code>resp, err := cli.post(ctx, &quot;/containers/&quot;+containerID+&quot;/start&quot;, query, nil, nil)</code>，然后 Docker Daemon 调用 <code>r.postContainersStart()</code>启动容器。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://www.cnblogs.com/wen123456/p/14187663.html">DOCKER源码分析4 daemon端对container create的处理 - luoyuna - 博客园 (cnblogs.com)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 毕设 </tag>
            
            <tag> Docker </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker源码分析（一）—— docker run 命令在 Docker Client 中的执行</title>
      <link href="/posts/64829.html"/>
      <url>/posts/64829.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>博文分析的 Docker 源码基于 19.03 版本，阅读工具采用 Goland，追踪的是<code>docker run</code>命令在 Docker Client 中的执行过程。</p><p>第一次阅读 Docker 源码，如有纰漏还请轻喷，喷完希望能够通过邮件或者留言的方式指出问题。</p><p>限于篇幅以及关注重点的原因，部分个人认为不重要的代码会用省略号代替。</p><p>Tips: 如果图片看不清楚可以点击查看大图。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><table>    <tr>        <td ><center><img src="https://images.961110.xyz/images/2021/11/16/docker-architecture.png" >图1  Docker 架构（官网图） </center></td>        <td ><center><img src="https://images.961110.xyz/images/2021/11/16/Docker.png"  >图2 Docker 架构图（分组件）</center></td>    </tr></table><p>Docker是一个典型的 C/S 架构，Docker Client作为直接与用户交互的一端，其作用是将用户的命令解析然后通过REST API传递给 Docker Daemon 执行（虽然真正执行的也不是 Docker Daemon）。</p><h2 id="docker-run-命令在-Docker-Client-中的执行"><a href="#docker-run-命令在-Docker-Client-中的执行" class="headerlink" title="docker run 命令在 Docker Client 中的执行"></a>docker run 命令在 Docker Client 中的执行</h2><p>Dcoker Client 作为 Docker 整个架构中的最前端，其主要作用就是和用户交互。当用户输入命令时，最终的执行是靠更下层的 Docker Daemon，所以分析的流程终结点就是找到如何解析用户命令并发给 Docker Daemon 以及获取响应。</p><h3 id="func-main"><a href="#func-main" class="headerlink" title="func main()"></a>func main()</h3><p>Docker Client 的入口函数是<code>func main()</code>， 在这个函数中主要做了以下几个工作：</p><ol><li>创建 Dcoker客户端 DockerCli 对象</li><li>根据 DockerCli 对象解析命令行参数，生成带有命令行参数以及客户端配置信息的 DcokerCommand 对象</li><li>根据输入参数 args 执行命令</li></ol><img src="https://images.961110.xyz/images/2021/11/16/Docker-Client-main.png" alt="image-20211117105757983" style="zoom: 67%;" /><p>核心的代码就两条</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cli\cmd\docker\docker.<span class="keyword">go</span>: <span class="number">285</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Dcoker客户端 DockerCli 对象</span></span><br><span class="line">dockerCli, err := command.NewDockerCli()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 DockerCli 对象解析命令行参数，生成带有命令行参数以及客户端配置信息的 DcokerCommand 命令行对象，执行命令</span></span><br><span class="line">err := runDocker(dockerCli)</span><br></pre></td></tr></table></figure><h3 id="command-NewDockerCli"><a href="#command-NewDockerCli" class="headerlink" title="command.NewDockerCli()"></a>command.NewDockerCli()</h3><p>主要作用是使用各种默认选项初始化一个 DockerCli，包括</p><p>cli/command/cli.go: 490</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDockerCli</span><span class="params">(ops ...DockerCliOption)</span> <span class="params">(*DockerCli, error)</span></span> &#123;</span><br><span class="line">cli := &amp;DockerCli&#123;&#125;</span><br><span class="line">defaultOps := []DockerCliOption&#123;</span><br><span class="line">WithContentTrustFromEnv(),</span><br><span class="line">WithContainerizedClient(containerizedengine.NewClient),</span><br><span class="line">&#125;</span><br><span class="line">cli.contextStoreConfig = DefaultContextStoreConfig()</span><br><span class="line">ops = <span class="built_in">append</span>(defaultOps, ops...)</span><br><span class="line"><span class="keyword">if</span> err := cli.Apply(ops...); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> cli.out == <span class="literal">nil</span> || cli.in == <span class="literal">nil</span> || cli.err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 设置标准输入、输出、错误输出</span></span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cli, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="runDocker-dockerCli"><a href="#runDocker-dockerCli" class="headerlink" title="runDocker(dockerCli)"></a>runDocker(dockerCli)</h3><p>cli\cmd\docker\docker.go: 249</p><p>创建 DockerCommand 对象、解析参数、执行命令都是在这个函数中完成的。</p><img src="https://images.961110.xyz/images/2021/11/17/Docker-Client-runDocker.png" alt="image-20211117113448273" style="zoom:50%;" /><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runDocker</span><span class="params">(dockerCli *command.DockerCli)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// 根据 DockerCli 对象解析命令行参数，生成带有命令行参数以及客户端配置信息的 DcokerCommand 命令行对象</span></span><br><span class="line">tcmd := newDockerCommand(dockerCli)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析全局 flags</span></span><br><span class="line">cmd, args, err := tcmd.HandleGlobalFlags()</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 完成全局选项解析并初始化docker客户端（tcmd结构体中带有 DockerCli 对象）</span></span><br><span class="line"><span class="keyword">if</span> err := tcmd.Initialize(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析参数别名</span></span><br><span class="line">args, os.Args, err = processAliases(dockerCli, cmd, args, os.Args)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 参数是否合法</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(args) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> _, _, err := cmd.Find(args); err != <span class="literal">nil</span> &#123;</span><br><span class="line">err := tryPluginRun(dockerCli, cmd, args[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">if</span> !pluginmanager.IsNotFound(err) &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cmd.SetArgs(args)</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 执行</span></span><br><span class="line"><span class="keyword">return</span> cmd.Execute()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中需要对两行重点代码进行分析：</p><ol><li><code>tcmd := newDockerCommand(dockerCli)</code></li><li><code>return cmd.Execute()</code></li></ol><h3 id="newDockerCommand-dockerCli"><a href="#newDockerCommand-dockerCli" class="headerlink" title="newDockerCommand(dockerCli)"></a>newDockerCommand(dockerCli)</h3><h4 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h4><p>Docker Client中使用 Cobra 这个命令行库构建 Docker 命令，其基本用法大概是四步：</p><ol><li>定义一个主命令（包含命令执行函数等）</li><li>定义若干子命令（包含命令执行函数等，根据需要可以为子命令定义子命令），并添加到主命令</li><li>为命令添加选项</li><li>执行命令</li></ol><p>其结构由三部分组成：命令 (commands)、参数 (arguments)、标志 (flags)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> URL --bare</span><br></pre></td></tr></table></figure><ul><li>git：主命令</li><li>clone：子命令</li><li>URL：参数，即 clone 作用的对象</li><li>–bare：标志</li></ul><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>直接在命令行输入<code>docker</code>看到的效果，就可以在下面的代码中找到对应的实现，不过这里看到的是 Docker Client 中实现的效果，想要看 Docker Daemon 中实现的效果可以输入 <code>sudo /usr/bin/dockerd -h</code></p><img src="https://images.961110.xyz/images/2021/11/17/docker-cobra.png" alt="image-20211117112841317" style="zoom: 50%;" /><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newDockerCommand</span><span class="params">(dockerCli *command.DockerCli)</span> *<span class="title">cli</span>.<span class="title">TopLevelCommand</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">cmd := &amp;cobra.Command&#123;</span><br><span class="line">Use:              <span class="string">&quot;docker [OPTIONS] COMMAND [ARG...]&quot;</span>,</span><br><span class="line">Short:            <span class="string">&quot;A self-sufficient runtime for containers&quot;</span>,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">opts, flags, helpCmd = cli.SetupRootCommand(cmd)</span><br><span class="line">...</span><br><span class="line">cmd.SetOutput(dockerCli.Out())</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 将 run、build 等一些命令的执行函数添加到 commands 中</span></span><br><span class="line">commands.AddCommands(cmd, dockerCli)</span><br><span class="line">...</span><br><span class="line"><span class="comment">// flags must be the top-level command flags, not cmd.Flags()</span></span><br><span class="line"><span class="keyword">return</span> cli.NewTopLevelCommand(cmd, dockerCli, opts, flags)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中需要关注的是<code>commands.AddCommands(cmd, dockerCli)</code>，在这个函数中会添加所有子命令以及子命令的选项，比如 run, build, image 等</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddCommands</span><span class="params">(cmd *cobra.Command, dockerCli command.Cli)</span></span> &#123;</span><br><span class="line">cmd.AddCommand(</span><br><span class="line">...</span><br><span class="line"><span class="comment">// container</span></span><br><span class="line">container.NewContainerCommand(dockerCli),</span><br><span class="line">container.NewRunCommand(dockerCli),</span><br><span class="line"></span><br><span class="line"><span class="comment">// image</span></span><br><span class="line">image.NewImageCommand(dockerCli),</span><br><span class="line">image.NewBuildCommand(dockerCli),</span><br><span class="line"></span><br><span class="line"><span class="comment">// builder</span></span><br><span class="line">builder.NewBuilderCommand(dockerCli),</span><br><span class="line">...</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> runtime.GOOS == <span class="string">&quot;linux&quot;</span> &#123;</span><br><span class="line"><span class="comment">// engine</span></span><br><span class="line">cmd.AddCommand(engine.NewEngineCommand(dockerCli))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中创建 <code>docker run</code> 命令的部分就是在<code>container.NewRunCommand()</code>函数中。</p><p>在使用 <code>docker run</code>命令时，就可以看到该函数实现的效果。</p><img src="https://images.961110.xyz/images/2021/11/17/image-20211117161046326.png" alt="image-20211117161046326" style="zoom:50%;" /><p>在<code>NewRunCommand()</code>中调用<code>runRun(dockerCli, cmd.Flags(), &amp;opts, copts)</code>，在这个函数中会解析参数并生成容器的配置，调用<code>runContainer(dockerCli, ropts, copts, containerConfig)</code>函数。</p><p>调用流程图如下</p><img src="https://images.961110.xyz/images/2021/11/17/runContainer.png" alt="image-20211117160902172" style="zoom: 67%;" /><h3 id="runContainer"><a href="#runContainer" class="headerlink" title="runContainer()"></a>runContainer()</h3><p>cli/command/container/run.go: 93</p><p>从这个函数中可以看出，<code>docker run</code>其实执行了两个核心的步骤：</p><ol><li>创建容器：<code>createResponse, err := createContainer(ctx, dockerCli, containerConfig, &amp;opts.createOptions)</code></li><li>启动容器：<code>err := client.ContainerStart(ctx, createResponse.ID, types.ContainerStartOptions&#123;&#125;)</code></li></ol><img src="https://images.961110.xyz/images/2021/11/17/runContainerb3382fc06811dffe.png" alt="image-20211117210548863" style="zoom:67%;" /><p>下面跟踪一下这两个函数。</p><h3 id="createContainer"><a href="#createContainer" class="headerlink" title="createContainer"></a>createContainer</h3><p>cli/command/container/create.go: 178</p><img src="https://images.961110.xyz/images/2021/11/17/createContainer.png" alt="image-20211117211323919" style="zoom:50%;" /><p>这个函数中需要重点关注的是红色字体的这个函数调用，它向 Docker Daemon 发送 post 请求：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">serverResp, err := cli.post(ctx, <span class="string">&quot;/containers/create&quot;</span>, query, body, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>请求创建容器并获取 Server 的响应。</p><h3 id="ContainerStart"><a href="#ContainerStart" class="headerlink" title="ContainerStart"></a>ContainerStart</h3><p>github.com/docker/docker/client/container_start.go: 11</p><p>这个函数比较简短，直接上代码。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *Client)</span> <span class="title">ContainerStart</span><span class="params">(ctx context.Context, containerID <span class="keyword">string</span>, options types.ContainerStartOptions)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">query := url.Values&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(options.CheckpointID) != <span class="number">0</span> &#123;</span><br><span class="line">query.Set(<span class="string">&quot;checkpoint&quot;</span>, options.CheckpointID)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(options.CheckpointDir) != <span class="number">0</span> &#123;</span><br><span class="line">query.Set(<span class="string">&quot;checkpoint-dir&quot;</span>, options.CheckpointDir)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resp, err := cli.post(ctx, <span class="string">&quot;/containers/&quot;</span>+containerID+<span class="string">&quot;/start&quot;</span>, query, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">ensureReaderClosed(resp)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样是向 Docker Daemon 发送 post 请求，这次请求的是启动容器。</p><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>Docker Client 向 Docker Daemon 发送了创建容器、启动容器的请求，Docker Client 这一端的需要关注的执行流基本结束，下面就是跟踪 Docker Daemon 中的执行流。</p><p>在cmd/docker/docker.go文件的<code>runDocker()</code>函数末尾有<code>return cmd.Execute()</code>这一行代码，所处的位置如图示</p><img src="https://images.961110.xyz/images/2021/11/17/cmd.Execute.png" alt="image-20211117213550937" style="zoom:50%;" /><p>追踪其调用流，跟踪到了<code>github.com/spf13/cobra/command.go</code>文件的<code>execute()</code>函数，已经到了第三方库中，函数执行的过程大致是三个阶段：</p><ol><li>c.preRun()</li><li>c.Run(c, argWoFlags)</li><li>c.PostRun(c, argWoFlags)</li></ol><p>具体执行没有继续深入，结合 cobra 的命令结果，猜测可能是因为其命令结构是树形的，所以有先后执行关系，进而有了以上三个阶段</p><h2 id="docker-run-在-Docker-Client-中的执行过程"><a href="#docker-run-在-Docker-Client-中的执行过程" class="headerlink" title="docker run 在 Docker Client 中的执行过程"></a>docker run 在 Docker Client 中的执行过程</h2><img src="https://images.961110.xyz/images/2021/12/06/docker-run--Docker-Client-.png" style="zoom:50%;" /><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://www.cnblogs.com/wen123456/p/14187555.html">DOCKER源码分析1 docker client命令行执行流程 - luoyuna - 博客园 (cnblogs.com)</a></li><li><a href="https://www.jianshu.com/p/63dd2075eb22">Golang | 使用 Cobra 构建命令行工具 - 简书 (jianshu.com)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 毕设 </tag>
            
            <tag> Docker </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker架构</title>
      <link href="/posts/4242.html"/>
      <url>/posts/4242.html</url>
      
        <content type="html"><![CDATA[<h2 id="Docker-架构及组件作用"><a href="#Docker-架构及组件作用" class="headerlink" title="Docker 架构及组件作用"></a>Docker 架构及组件作用<img src="https://images.961110.xyz/images/2021/11/11/Docker.png" alt="Docker组件"></h2><p>之所以要分成这么多个组件共同作用，原因可能看下图就能略知一二。</p><p><img src="D:/Downloads/container-ecosystem.png"></p><p>整个容器生态是非常庞大的，有不同的平台，不同的架构，不同的客户端。如果想要形成一个标准，势必要对功能进行拆分来暴露出统一的 API，这样组件可以相互结合来应对不同的场景。</p><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p>OCI现在有两个标准：</p><ul><li>the Runtime Specification (runtime-spec) ，指出如何运行已经解压到disk上的filesystem bundle</li><li>the Image Specification (image-spec)</li></ul><p>都是为了兼容性和可移植的特性。其中runc就是一种runtime spec的实现。</p><h3 id="bundle"><a href="#bundle" class="headerlink" title="bundle"></a>bundle</h3><p><code>filesystem bundle</code> 就是一个目录，提供 config.json 文件和 rootfs 文件系统</p><h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><p>config 描述了当前容器的配置: OCI 版本，启动程序路径与参数，挂载哪些文件系统，平台相关的比如 cgroup, namespaces, cpu quota 等等</p><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>runc 启动的容器，都会把状态文件 state.json 存到一个地方，默认路径是 <code>/run/runc/$&#123;container_id&#125;</code>，通过 <code>runc state</code> 获取的状态来自于这个文件</p><h3 id="Config-结构体"><a href="#Config-结构体" class="headerlink" title="Config 结构体"></a>Config 结构体</h3><p>描述 Docker Container 独立的配置信息。独立的含义是：Config 这部分信息描述的是容器本身，而不会与容器所在 host 宿主机相关；</p><h3 id="HostConfig-结构体"><a href="#HostConfig-结构体" class="headerlink" title="HostConfig 结构体"></a>HostConfig 结构体</h3><p>描述 Docker Container 与宿主机相关的配置信息。</p><p><code>runc run</code> 根据提供的 filesystem bundle 生成创建容器所需要各种配置，然后创建子进程 <code>runc init</code>，同时父进程 <code>runc run</code> 设置子进程 <code>runc init</code> 的 cgroup, namespaces 等等。子进程 <code>runc init</code> 也要做一部份容器内的初始化，比如创建网络接口路由等等，最后 <code>runc init</code> 系统调用 <code>exec</code> 执行真正的 cmd，而 <code>runc run</code> 退出后，cmd 进程要么由操作系统 1 号进程接管，要么在 docker 环境中被 <code>containerd-shim</code> 接管。</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p><code>$GOPATH\src\github.com\docker\docker\</code>项目的结构组成</p><ul><li>api：定义 API，使用了 Swagger2.0 这个工具来生成 API，配置文件在api/swagger.yaml</li><li>builder：用来 build docker 镜像的包，看来历史比较悠久了</li><li>cli：使用 cobra 工具生成的 docker 客户端命令行解析器。</li><li>client：接收cli的请求，调用 RESTful API 中的接口，向 server 端发送 http 请求。</li><li>cmd：其中包括docker和dockerd两个包，他们分别包含了客户端和服务端的 main 函数入口。</li><li>container：容器的配置管理，对不同的 platform 适配。</li><li>contrib：这个目录包括一些有用的脚本、镜像和其他非 docker core 中的部分。</li><li>daemon：这个包中将 docker deamon 运行时状态 expose 出来。</li><li>distribution：负责 docker 镜像的 pull、push 和镜像仓库的维护。</li><li>dockerversion：编译的时候自动生成的。</li><li>docs：文档。这个目录已经不再维护，文档在另一个仓库里。</li><li>errdefs: 一些常见的错误</li><li>hack：创建 docker 开发环境和编译打包时用到的脚本和配置文件。</li><li>image：用于构建 docker 镜像的。</li><li>integration: 集成测试</li><li>integration-cli：集成测试</li><li>internal: </li><li>layer：管理 union file system driver 上的 read-only 和 read-write mounts。</li><li>libcontainerd：访问内核中的容器系统调用。</li><li>oci：Open Container Interface 库</li><li>opts：命令行的选项库。</li><li>man：生成 man pages。</li><li>migrate：将老版本的 graph 目录转换成新的 metadata。</li><li>patches: </li><li>pkg：</li><li>plugin：docker 插件后端实现包。</li><li>profiles：里面有 apparmor 和 seccomp 两个目录。用于内核访问控制。</li><li>project：项目管理的一些说明文档。</li><li>reference：处理 docker store 中镜像的 reference。</li><li>registry：docker registry 的实现。</li><li>reports: </li><li>restartmanager：处理重启后的动作。</li><li>rootless: </li><li>runconfig：配置格式解码和校验。</li><li>vendor：各种依赖包。</li><li>volume：docker volume 的实现。</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://jimmysong.io/blog/docker-source-code-analysis-code-structure/">Docker源码分析第一篇——代码结构</a></li><li><a href="https://www.jianshu.com/p/b448b4db9c5c">docker 学习笔记1：什么是 runc</a></li><li><a href="https://www.jianshu.com/p/5ca02db248ee">Containerd到底是干啥的？</a></li><li><a href="https://blog.csdn.net/qq_34556414/article/details/112247223">组件组成：剖析 Docker 组件作用及其底层工作原理</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 毕设 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 10 通过以太网共享WiFi网络</title>
      <link href="/posts/14412.html"/>
      <url>/posts/14412.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>宿舍上传速度太慢，想要把硬盘数据备份到云端网盘，只能把NAS搬到实验室。但是实验室没有网线接口，只能通过带网口的拓展坞共享网络给NAS。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="开启共享"><a href="#开启共享" class="headerlink" title="开启共享"></a>开启共享</h3><p>如图示进入适配器配置页面</p><img src="https://images.961110.xyz/images/2021/11/09/a4ab00b80f7175e00c8ec195afac8297.png" alt="image-20211109164126283" style="zoom: 50%;" /><p>开启WLAN的共享，以太网3就是拓展坞里的网卡。开启之后，WLAN后会多“共享的”这几个字</p><img src="https://images.961110.xyz/images/2021/11/09/WLAN.png" alt="image-20211109164252170" style="zoom:50%;" /><h3 id="配置中转网卡"><a href="#配置中转网卡" class="headerlink" title="配置中转网卡"></a>配置中转网卡</h3><p>如图示进入以太网3的IP配置页面</p><p>IP和子网掩码都是自动填好的，DNS服务器要设置成和WLAN一样的。</p><img src="https://images.961110.xyz/images/2021/11/09/e4da94844f916fd700d4583067137e18.png" alt="image-20211109164526100" style="zoom:50%;" /><img src="https://images.961110.xyz/images/2021/11/09/WLAN-DNSe4c505deeee6901a.png" alt="image-20211109165034807" style="zoom:50%;" /><h3 id="配置需要网络的机器"><a href="#配置需要网络的机器" class="headerlink" title="配置需要网络的机器"></a>配置需要网络的机器</h3><p>以Ubuntu为例，界面右上角打开有线设置（我这里用的是中文版，英文版相比读者应该也看得懂）</p><img src="https://images.961110.xyz/images/2021/11/09/Ubuntu-wired-setting.png" alt="image-20211109165156462" style="zoom:50%;" /><p>地址就写192.168.137.2-192.168.137.254之间随便一个，子网掩码写255.255.255.0，网关写192.168.137.1，DNS写Windows 10 WLAN的DNS服务器地址</p><img src="https://images.961110.xyz/images/2021/11/09/Ubuntu-IP.png" alt="image-20211109165412737" style="zoom:50%;" /><p>不出意外应该可以上网了。</p><blockquote><p>DNS服务器地址一定要配置，不然没有网！</p></blockquote><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="http://www.cqnu0001.com/article/89038.html">win10将WLAN网络共享给以太网 (cqnu0001.com)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Windows 10 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 10下为Powershell设置全局代理</title>
      <link href="/posts/38820.html"/>
      <url>/posts/38820.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>使用 GoLand 阅读 Docker 源码的时候，缺少一些必要的依赖包，需要自己下载，所以要自己安装，但是不出意外的超时了。</p><h2 id="设置方法"><a href="#设置方法" class="headerlink" title="设置方法"></a>设置方法</h2><p>打开Powershell终端，输入</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">env:HTTP_PROXY=<span class="string">&quot;http://127.0.0.1:端口&quot;</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash">env:HTTPS_PROXY=<span class="string">&quot;http://127.0.0.1:端口</span></span></span><br></pre></td></tr></table></figure><p>其中端口是本地代理软件设置的端口，Clash是7890。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://blog.csdn.net/weixin_44120025/article/details/110950434">WIN10给powershell设置全局代理</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 代理 </tag>
            
            <tag> Powershell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 免密提交</title>
      <link href="/posts/40815.html"/>
      <url>/posts/40815.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>毕设需要修改Docker代码，在fork后克隆到本地，修改后推送到github发现需要输入密码，所以有了这篇博文。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>将仓库克隆到本地时，使用的是http的方法，也就是</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/xxx/xxx.git</span><br></pre></td></tr></table></figure><p>所以应该改为ssh的方式，即</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:xxx/xxx.git</span><br></pre></td></tr></table></figure><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h4 id="免密push"><a href="#免密push" class="headerlink" title="免密push"></a>免密push</h4><ol><li><p>查看当前方式</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br><span class="line"></span><br><span class="line">origin  https://github.com/xxx/xxx.git (fetch)</span><br><span class="line">origin  https://github.com/xxx/xxx.git (push)</span><br></pre></td></tr></table></figure></li><li><p>移除当前远程仓库</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote rm origin</span></span><br></pre></td></tr></table></figure></li><li><p>添加新的远程仓库链接并查看是否改变</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote add origin git@github.com:xxx/xxx.git</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br><span class="line"></span><br><span class="line">origin  git@github.com:xxx/xxx.git (fetch)</span><br><span class="line">origin  git@github.com:xxx/xxx.git (push)</span><br></pre></td></tr></table></figure></li><li><p>在改动之后需要设置上游要跟踪的分支，与此同时会自动执行一次 git push 命令，</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push --set-upstream origin master</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="Permission-denied"><a href="#Permission-denied" class="headerlink" title="Permission denied"></a>Permission denied</h4><p>在上面一通操作完成后，如果在push的时候提示Permission </p><img src="https://images.961110.xyz/images/2021/11/02/git-push-permission-denied1df07a46f1a7bca9.png" alt="image-20211102150353591" style="zoom:67%;" /><p>需要重新生成秘钥</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa -C <span class="string">&quot;你的GitHub注册邮箱&quot;</span></span></span><br></pre></td></tr></table></figure><img src="https://images.961110.xyz/images/2021/11/02/3bbe8926552e1625fa534430761177dc.png" alt="image-20211102150112039" style="zoom: 50%;" /><p>复制公钥（文件的内容）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim /home/jason/.ssh/id_rsa.pub</span></span><br></pre></td></tr></table></figure><p>在Github个人设置页面，增加新的SSH key</p><img src="https://images.961110.xyz/images/2021/11/02/SSH-keys.png" alt="image-20211102150559897" style="zoom:50%;" /><p>title起一个名字，key填入刚刚复制的公钥。</p><img src="https://images.961110.xyz/images/2021/11/02/create-new-keydd12a7fe91d06071.png" alt="image-20211102150900313" style="zoom:50%;" /><p>不出意外应该可以免密推送了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://blog.csdn.net/yychuyu/article/details/80186783?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2.no_search_link">解决git push代码到github上一直提示输入用户名及密码的问题_码到成功-CSDN博客_git push 密码</a></li><li><a href="https://www.cnblogs.com/ckxlovejava/p/9707192.html">git@github.com: Permission denied (publickey). fatal: Could not read from remote repository. - ckx0709 - 博客园 (cnblogs.com)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Linux </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译Docker Engine源码的两种方法以及遇到的问题</title>
      <link href="/posts/21885.html"/>
      <url>/posts/21885.html</url>
      
        <content type="html"><![CDATA[<h2 id="前情梗概"><a href="#前情梗概" class="headerlink" title="前情梗概"></a>前情梗概</h2><p>Docker是前后端分离的架构，社区版本的Docker-CE前端部分由<a href="https://github.com/docker/cli">docker/cli: The Docker CLI</a>维护，后端部分由<a href="https://github.com/moby/moby">moby/moby: Moby Project</a>维护。从Docker 20.10 release版本开始，Docker Engine 和 Docker CLI单独从各自的项目编译。</p><p><img src="https://images.961110.xyz/images/2021/10/30/docker-ce-overview.jpg" alt="docker-ce-overview"></p><p>这次Docker Engine源码编译选择的是19.03的版本，通过两种方式进行了尝试：</p><ol><li>通过官方指定方式，使用docker-dev镜像在容器中编译；</li><li>本地构建编译环境，在本机中编译。</li></ol><h2 id="使用docker-dev镜像在容器中编译"><a href="#使用docker-dev镜像在容器中编译" class="headerlink" title="使用docker-dev镜像在容器中编译"></a>使用docker-dev镜像在容器中编译</h2><h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><p>因为是要在容器中编译，所以肯定先要安装好Docker，安装步骤可以参考<a href="https://docs.docker.com/engine/install/ubuntu/">官方文档</a>或者其他教程贴。</p><h3 id="克隆moby仓库并切换到相应分支"><a href="#克隆moby仓库并切换到相应分支" class="headerlink" title="克隆moby仓库并切换到相应分支"></a>克隆moby仓库并切换到相应分支</h3><p>克隆仓库</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/moby/moby.git</span></span><br></pre></td></tr></table></figure><p>查看所有分支</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -a</span></span><br><span class="line"></span><br><span class="line">* (HEAD detached at origin/19.03)</span><br><span class="line">  19.03</span><br><span class="line">  master</span><br><span class="line">  remotes/origin/1.12.x</span><br><span class="line">  remotes/origin/1.13.x</span><br><span class="line">  remotes/origin/17.03.x</span><br><span class="line">  remotes/origin/17.04.x</span><br><span class="line">  remotes/origin/17.05.x</span><br><span class="line">  remotes/origin/19.03</span><br><span class="line">  remotes/origin/20.10</span><br><span class="line">  remotes/origin/HEAD -&gt; origin/master</span><br><span class="line">  remotes/origin/docs</span><br><span class="line">  remotes/origin/master</span><br></pre></td></tr></table></figure><p>切换到对应分支</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout remotes/origin/19.03</span></span><br></pre></td></tr></table></figure><p>如果想要从当前分支另起一个分支</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b dry-run-test</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -a</span></span><br><span class="line"></span><br><span class="line">* dry-run-test</span><br><span class="line">  master</span><br><span class="line">  remotes/origin/1.12.x</span><br><span class="line">  remotes/origin/1.13.x</span><br><span class="line">  remotes/origin/17.03.x</span><br><span class="line">  remotes/origin/17.04.x</span><br><span class="line">  remotes/origin/17.05.x</span><br><span class="line">  remotes/origin/19.03</span><br><span class="line">  remotes/origin/20.10</span><br><span class="line">  remotes/origin/HEAD -&gt; origin/master</span><br><span class="line">  remotes/origin/docs</span><br><span class="line">  remotes/origin/dry-run-test</span><br><span class="line">  remotes/origin/master</span><br></pre></td></tr></table></figure><h3 id="清空所有现有镜像和容器"><a href="#清空所有现有镜像和容器" class="headerlink" title="清空所有现有镜像和容器"></a>清空所有现有镜像和容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker ps -a</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker system prune -a</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker images</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker rmi -f $(docker images -q -a -f dangling=<span class="literal">true</span>)</span></span><br></pre></td></tr></table></figure><h3 id="利用Dockerfile构建docker-dev镜像"><a href="#利用Dockerfile构建docker-dev镜像" class="headerlink" title="利用Dockerfile构建docker-dev镜像"></a>利用Dockerfile构建docker-dev镜像</h3><p>安装make工具</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install make</span><br></pre></td></tr></table></figure><p>在项目根目录直接输入</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make BIND_DIR=. shell</span></span><br></pre></td></tr></table></figure><p>在Makefile文件中对应执行的是</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">build: bundles</span></span><br><span class="line"><span class="variable">$(<span class="built_in">warning</span> The docker client CLI has moved to github.com/docker/cli. For a dev-test cycle involving the CLI, run:$&#123;\n&#125; DOCKER_CLI_PATH=/host/path/to/cli/binary make <span class="built_in">shell</span> $&#123;\n&#125; then change the cli <span class="built_in">and</span> compile into a binary at the same location.$&#123;\n&#125;)</span></span><br><span class="line">DOCKER_BUILDKIT=<span class="string">&quot;$&#123;DOCKER_BUILDKIT&#125;&quot;</span> docker build --build-arg=GO_VERSION $&#123;BUILD_APT_MIRROR&#125; $&#123;DOCKER_BUILD_ARGS&#125; $&#123;DOCKER_BUILD_OPTS&#125; -t <span class="string">&quot;<span class="variable">$(DOCKER_IMAGE)</span>&quot;</span> -f <span class="string">&quot;<span class="variable">$(DOCKERFILE)</span>&quot;</span> .</span><br></pre></td></tr></table></figure><p>大体意思是调用<code>docker build</code>依据设置的环境变量和的传入的参数遵从Dockerfile构建<code>docker-dev</code>镜像。</p><p>如果构成过程没有错误的话，终端输出的末尾应该会有如下的提示</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> =&gt; [dev  8/25] RUN update-alternatives --set iptables  /usr/sbin/iptables-legacy  || true  &amp;&amp; update-alternative  0.4s</span><br><span class="line"> =&gt; [dev  9/25] RUN pip3 install yamllint==1.16.0                                                                  5.7s</span><br><span class="line"> =&gt; [dev 10/25] COPY --from=dockercli     /build/ /usr/local/cli                                                   0.2s</span><br><span class="line"> =&gt; [dev 11/25] COPY --from=frozen-images /build/ /docker-frozen-images                                            0.7s</span><br><span class="line"> =&gt; [dev 12/25] COPY --from=swagger       /build/ /usr/local/bin/                                                  0.1s</span><br><span class="line">...</span><br><span class="line"> =&gt; [dev 22/25] COPY --from=rootlesskit   /build/ /usr/local/bin/                                                  0.1s</span><br><span class="line"> =&gt; [dev 23/25] COPY --from=vpnkit        /vpnkit /usr/local/bin/vpnkit.x86_64                                     0.2s</span><br><span class="line"> =&gt; [dev 24/25] COPY --from=proxy         /build/ /usr/local/bin/                                                  0.1s</span><br><span class="line"> =&gt; [dev 25/25] WORKDIR /go/src/github.com/docker/docker                                                           0.0s</span><br><span class="line"> =&gt; exporting to image                                                                                             7.1s</span><br><span class="line"> =&gt; =&gt; exporting layers                                                                                            7.1s</span><br><span class="line"> =&gt; =&gt; writing image sha256:1bc0901b7d2b1f958a24445ca93c73401a60e2f9e301255ea092002bb8c1c7b9                       0.0s</span><br><span class="line"> =&gt; =&gt; naming to docker.io/library/docker-dev:dry-run-test                                                         0.0s</span><br></pre></td></tr></table></figure><p>构建完成后可以先查看一下刚刚构建出的镜像</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~ docker image ls -a</span><br><span class="line">REPOSITORY   TAG            IMAGE ID       CREATED      SIZE</span><br><span class="line">docker-dev   dry-run-test   1bc0901b7d2b   2 days ago   2.07GB</span><br></pre></td></tr></table></figure><p>构建完成后也会有启动<code>docker-dev</code>的命令提示</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --rm -i --privileged  -e DOCKER_CROSSPLATFORMS -e BUILD_APT_MIRROR -e BUILDFLAGS -e KEEPBUNDLE -e DOCKER_BUILD_ARGS -e DOCKER_BUILD_GOGC -e DOCKER_BUILD_OPTS -e DOCKER_BUILD_PKGS -e DOCKER_BUILDKIT -e DOCKER_BASH_COMPLETION_PATH -e DOCKER_CLI_PATH -e DOCKER_DEBUG -e DOCKER_EXPERIMENTAL -e DOCKER_GITCOMMIT -e DOCKER_GRAPHDRIVER -e DOCKER_LDFLAGS -e DOCKER_PORT -e DOCKER_REMAP_ROOT -e DOCKER_STORAGE_OPTS -e DOCKER_TEST_HOST -e DOCKER_USERLANDPROXY -e DOCKERD_ARGS -e TEST_INTEGRATION_DIR -e TEST_SKIP_INTEGRATION -e TEST_SKIP_INTEGRATION_CLI -e TESTDEBUG -e TESTDIRS -e TESTFLAGS -e TESTFLAGS_INTEGRATION -e TESTFLAGS_INTEGRATION_CLI -e TEST_FILTER -e TIMEOUT -e VALIDATE_REPO -e VALIDATE_BRANCH -e VALIDATE_ORIGIN_BRANCH -e HTTP_PROXY -e HTTPS_PROXY -e NO_PROXY -e http_proxy -e https_proxy -e no_proxy -e VERSION -e PLATFORM -e DEFAULT_PRODUCT_LICENSE -e PRODUCT -v &quot;/home/jason/repos/moby-fork/.:/go/src/github.com/docker/docker/.&quot; -v &quot;/home/jason/repos/moby-fork/.git:/go/src/github.com/docker/docker/.git&quot; -v docker-dev-cache:/root/.cache    -t &quot;docker-dev:dry-run-test&quot; bash</span><br></pre></td></tr></table></figure><p>进入之后，可以看一下当前目录有哪些文件</p><img src="https://images.961110.xyz/images/2021/11/01/344dda91545cbed1cc59cf2daa90a848.png" alt="image-20211101111913141" style="zoom: 67%;" /><p>从镜像启动命令可以看出，实际是将主机的moby目录挂载到了当前路径。也就是说，如果在主机或者<code>docker-dev</code>中修改了代码，会同步修改。</p><h3 id="docker-dev环境"><a href="#docker-dev环境" class="headerlink" title="docker-dev环境"></a>docker-dev环境</h3><h4 id="docker-version"><a href="#docker-version" class="headerlink" title="docker version"></a>docker version</h4><p>初始环境中是没有docker engine的，需要自行编译</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@c17a2f34853b:/go/src/github.com/docker/docker# docker version</span><br><span class="line">Client:</span><br><span class="line"> Version:      17.06.2-ce</span><br><span class="line"> API version:  1.30</span><br><span class="line"> Go version:   go1.8.3</span><br><span class="line"> Git commit:   cec0b72</span><br><span class="line"> Built:        Tue Sep  5 19:57:21 2017</span><br><span class="line"> OS/Arch:      linux/amd64</span><br><span class="line"> Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</span><br></pre></td></tr></table></figure><h4 id="go-env"><a href="#go-env" class="headerlink" title="go env"></a>go env</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@9e6c8aab5a7f:/go/src/github.com/docker/docker# go env</span><br><span class="line">GO111MODULE=&quot;off&quot;</span><br><span class="line">GOARCH=&quot;amd64&quot;</span><br><span class="line">GOBIN=&quot;&quot;</span><br><span class="line">GOCACHE=&quot;/root/.cache/go-build&quot;</span><br><span class="line">GOENV=&quot;/root/.config/go/env&quot;</span><br><span class="line">GOEXE=&quot;&quot;</span><br><span class="line">GOFLAGS=&quot;&quot;</span><br><span class="line">GOHOSTARCH=&quot;amd64&quot;</span><br><span class="line">GOHOSTOS=&quot;linux&quot;</span><br><span class="line">GONOPROXY=&quot;&quot;</span><br><span class="line">GONOSUMDB=&quot;&quot;</span><br><span class="line">GOOS=&quot;linux&quot;</span><br><span class="line">GOPATH=&quot;/go&quot;</span><br><span class="line">GOPRIVATE=&quot;&quot;</span><br><span class="line">GOPROXY=&quot;https://goproxy.cn,direct&quot;</span><br><span class="line">GOROOT=&quot;/usr/local/go&quot;</span><br><span class="line">GOSUMDB=&quot;sum.golang.org&quot;</span><br><span class="line">GOTMPDIR=&quot;&quot;</span><br><span class="line">GOTOOLDIR=&quot;/usr/local/go/pkg/tool/linux_amd64&quot;</span><br><span class="line">GCCGO=&quot;gccgo&quot;</span><br><span class="line">AR=&quot;ar&quot;</span><br><span class="line">CC=&quot;gcc&quot;</span><br><span class="line">CXX=&quot;g++&quot;</span><br><span class="line">CGO_ENABLED=&quot;1&quot;</span><br><span class="line">GOMOD=&quot;&quot;</span><br><span class="line">CGO_CFLAGS=&quot;-g -O2&quot;</span><br><span class="line">CGO_CPPFLAGS=&quot;&quot;</span><br><span class="line">CGO_CXXFLAGS=&quot;-g -O2&quot;</span><br><span class="line">CGO_FFLAGS=&quot;-g -O2&quot;</span><br><span class="line">CGO_LDFLAGS=&quot;-g -O2&quot;</span><br><span class="line">PKG_CONFIG=&quot;pkg-config&quot;</span><br><span class="line">GOGCCFLAGS=&quot;-fPIC -m64 -pthread -fmessage-length=0 -fdebug-prefix-map=/tmp/go-build033151478=/tmp/go-build -gno-record-gcc-switches&quot;</span><br></pre></td></tr></table></figure><h3 id="编译docker-binary"><a href="#编译docker-binary" class="headerlink" title="编译docker binary"></a>编译docker binary</h3><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@c17a2f34853b:/go/src/github.com/docker/docker# hack/make.sh binary</span><br><span class="line"></span><br><span class="line">Removing bundles/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">---&gt;</span><span class="bash"> Making bundle: binary (<span class="keyword">in</span> bundles/binary)</span></span><br><span class="line">Building: bundles/binary-daemon/dockerd-dev</span><br><span class="line">GOOS=&quot;&quot; GOARCH=&quot;&quot; GOARM=&quot;&quot;</span><br><span class="line">Created binary: bundles/binary-daemon/dockerd-dev</span><br><span class="line">Copying nested executables into bundles/binary-daemon</span><br><span class="line"></span><br><span class="line">root@c17a2f34853b:/go/src/github.com/docker/docker#</span><br></pre></td></tr></table></figure><p>内容如下</p><img src="https://images.961110.xyz/images/2021/11/01/binary.png" alt="image-20211101115527967" style="zoom:67%;" /><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>在项目目录输入<code>make install</code>，会把刚刚编译生成的各个执行文件拷贝到<code>/usr/local/bin/</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@c17a2f34853b:/go/src/github.com/docker/docker# make install</span><br><span class="line">Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</span><br><span class="line">Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</span><br><span class="line">Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</span><br><span class="line">Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</span><br><span class="line">KEEPBUNDLE=1 hack/make.sh install-binary</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">---&gt;</span><span class="bash"> Making bundle: install-binary (<span class="keyword">in</span> bundles/install-binary)</span></span><br><span class="line">Installing dockerd to /usr/local/bin/</span><br><span class="line">Installing runc to /usr/local/bin/</span><br><span class="line">Installing containerd to /usr/local/bin/</span><br><span class="line">Installing ctr to /usr/local/bin/</span><br><span class="line">Installing containerd-shim to /usr/local/bin/</span><br><span class="line">Installing docker-proxy to /usr/local/bin/</span><br><span class="line">Installing docker-init to /usr/local/bin/</span><br><span class="line">Installing rootlesskit to /usr/local/bin/</span><br><span class="line">Installing rootlesskit-docker-proxy to /usr/local/bin/</span><br><span class="line">Installing dockerd-rootless.sh to /usr/local/bin/</span><br><span class="line">Installing vpnkit to /usr/local/bin/</span><br><span class="line"></span><br><span class="line">root@c17a2f34853b:/go/src/github.com/docker/docker#</span><br></pre></td></tr></table></figure><p>输入<code>dockerd &amp;</code>在后台启动dockerd（如果想要开启debug模式的话，加一个<code>-D</code>参数），然后输入<code>docker version</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@c17a2f34853b:/go/src/github.com/docker/docker# docker version</span><br><span class="line">DEBU[2021-11-01T04:00:11.890237855Z] Calling GET /_ping</span><br><span class="line">DEBU[2021-11-01T04:00:11.891512505Z] Calling GET /v1.30/version</span><br><span class="line">Client:</span><br><span class="line"> Version:      17.06.2-ce</span><br><span class="line"> API version:  1.30</span><br><span class="line"> Go version:   go1.8.3</span><br><span class="line"> Git commit:   cec0b72</span><br><span class="line"> Built:        Tue Sep  5 19:57:21 2017</span><br><span class="line"> OS/Arch:      linux/amd64</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Version:      dev</span><br><span class="line"> API version:  1.40 (minimum version 1.12)</span><br><span class="line"> Go version:   go1.13.15</span><br><span class="line"> Git commit:   e2b63fbe46</span><br><span class="line"> Built:        Mon Nov  1 03:53:11 2021</span><br><span class="line"> OS/Arch:      linux/amd64</span><br><span class="line"> Experimental: false</span><br><span class="line">root@c17a2f34853b:/go/src/github.com/docker/docker#</span><br></pre></td></tr></table></figure><p>可以看到刚刚编译好的dockerd已经运行起来了，版本也是我们的dev版。</p><p>可以用hello world这个检查镜像试试运行是否正常：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker run hello-world</span></span><br><span class="line"></span><br><span class="line">Unable to find image &#x27;hello-world:latest&#x27; locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">2db29710123e: Pull complete</span><br><span class="line">Digest: sha256:37a0b92b08d4919615c3ee023f7ddb068d12b8387475d64c622ac30f45c29c51</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line">INFO[2021-11-01T06:36:18.265460389Z] shim containerd-shim started                  address=&quot;unix:///run/containerd/s/92a66bf121c2fc3d2061a0e56a70ac73c148421caab878528d96b31a6cf23b24&quot; debug=false pid=912</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">INFO[2021-11-01T06:36:18.494924873Z] shim reaped                                   id=7f500aadff4b87ef747825e95a182bc00fe033dcacb4f976aa3b4fd8db98cea4</span><br><span class="line">INFO[2021-11-01T06:36:18.505731593Z] ignoring event                                module=libcontainerd namespace=moby topic=/tasks/delete type=&quot;*events.TaskDelete&quot;</span><br><span class="line">root@c17a2f34853b:/go/src/github.com/docker/docker#</span><br></pre></td></tr></table></figure><h3 id="使用docker-dev镜像编译遇到的问题"><a href="#使用docker-dev镜像编译遇到的问题" class="headerlink" title="使用docker-dev镜像编译遇到的问题"></a>使用docker-dev镜像编译遇到的问题</h3><p>在国内最主要的就是网络问题，其他的都好解决。</p><h4 id="从github克隆项目超时"><a href="#从github克隆项目超时" class="headerlink" title="从github克隆项目超时"></a>从github克隆项目超时</h4><p>终端输出没有记录到，不过这个问题和下面一个问题相同，都是因为被墙的原因。</p><h4 id="go-install超时"><a href="#go-install超时" class="headerlink" title="go install超时"></a>go install超时</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  moby git:(master) ✗ make build</span><br><span class="line">docker build  --build-arg=GO_VERSION  -f &quot;Dockerfile&quot; --target=final   -t &quot;docker-dev&quot; .</span><br><span class="line">[+] Building 873.7s (41/75)</span><br><span class="line">...</span><br><span class="line"> =&gt; CANCELED [dockercli 2/2] RUN --mount=type=cache,target=/root/.cache/go-build     --mount=type=cache,target=/  24.6s</span><br><span class="line">------</span><br><span class="line"><span class="meta"> &gt;</span><span class="bash"> [vndr 1/1] RUN --mount=<span class="built_in">type</span>=cache,target=/root/.cache/go-build     --mount=<span class="built_in">type</span>=cache,target=/go/pkg/mod         GOBIN=/build/ GO111MODULE=on go install <span class="string">&quot;github.com/LK4D4/vndr@v0.1.2&quot;</span>      &amp;&amp; /build/vndr --<span class="built_in">help</span>:</span></span><br><span class="line"><span class="meta"> &gt;</span><span class="bash"> <span class="comment">#49 24.73 go install: github.com/LK4D4/vndr@v0.1.2: github.com/LK4D4/vndr@v0.1.2: Get &quot;https://proxy.golang.org/github.com/%21l%21k4%21d4/vndr/@v/v0.1.2.info&quot;: dial tcp 172.217.160.81:443: connect: connection refused</span></span></span><br><span class="line">------</span><br><span class="line">------</span><br><span class="line"><span class="meta"> &gt;</span><span class="bash"> [shfmt 1/1] RUN --mount=<span class="built_in">type</span>=cache,target=/root/.cache/go-build     --mount=<span class="built_in">type</span>=cache,target=/go/pkg/mod         GOBIN=/build/ GO111MODULE=on go install <span class="string">&quot;mvdan.cc/sh/v3/cmd/shfmt@v3.0.2&quot;</span>      &amp;&amp; /build/shfmt --version:</span></span><br><span class="line"><span class="meta"> &gt;</span><span class="bash"> <span class="comment">#55 24.68 go install: mvdan.cc/sh/v3/cmd/shfmt@v3.0.2: mvdan.cc/sh/v3/cmd/shfmt@v3.0.2: Get &quot;https://proxy.golang.org/mvdan.cc/sh/v3/cmd/shfmt/@v/v3.0.2.info&quot;: dial tcp 172.217.160.81:443: connect: connection refused</span></span></span><br><span class="line">------</span><br><span class="line">executor failed running [/bin/sh -c GOBIN=/build/ GO111MODULE=on go install &quot;mvdan.cc/sh/v3/cmd/shfmt@$&#123;SHFMT_VERSION&#125;&quot;      &amp;&amp; /build/shfmt --version]: exit code: 1</span><br><span class="line">make: *** [Makefile:214: build] Error 1</span><br><span class="line">➜  moby git:(master) ✗</span><br></pre></td></tr></table></figure><h4 id="go无法找到mian模块"><a href="#go无法找到mian模块" class="headerlink" title="go无法找到mian模块"></a>go无法找到mian模块</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  moby git:(69f9c8c906) ✗ make BIND_DIR=. shell</span><br><span class="line"></span><br><span class="line">Makefile:157: The docker client CLI has moved to github.com/docker/cli. For a dev-test cycle involving the CLI, run:</span><br><span class="line"> DOCKER_CLI_PATH=/host/path/to/cli/binary make shell</span><br><span class="line"> then change the cli and compile into a binary at the same location.</span><br><span class="line"></span><br><span class="line">DOCKER_BUILDKIT=&quot;1&quot; docker build --build-arg=GO_VERSION  --build-arg=CROSS=false --target=dev -t &quot;docker-dev:HEAD&quot; -f &quot;Dockerfile&quot; .</span><br><span class="line">[+] Building 8.9s (30/68)</span><br><span class="line">...</span><br><span class="line">------</span><br><span class="line"><span class="meta"> &gt;</span><span class="bash"> [vndr 3/3] RUN PREFIX=/build ./install.sh vndr:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">42 3.016 + RM_GOPATH=0</span></span><br><span class="line"><span class="meta">#</span><span class="bash">42 3.016 + TMP_GOPATH=</span></span><br><span class="line"><span class="meta">#</span><span class="bash">42 3.016 + : /build</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#</span><span class="bash">42 6.332 + go build -buildmode=pie -v -o /build/vndr .</span></span><br><span class="line"><span class="meta">#</span><span class="bash">42 6.361 go: cannot find main module, but found .git/config <span class="keyword">in</span> /tmp/tmp.ZFV3RuyK4q/src/github.com/LK4D4/vndr</span></span><br><span class="line"><span class="meta">#</span><span class="bash">42 6.361       to create a module there, run:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">42 6.361       go mod init</span></span><br><span class="line">------</span><br><span class="line">executor failed running [/bin/sh -c PREFIX=/build ./install.sh $INSTALL_BINARY_NAME]: exit code: 1</span><br><span class="line">make: *** [Makefile:158: build] Error 1</span><br></pre></td></tr></table></figure><p>仿佛是因为<strong>GO111MODULE</strong>这个环境变量的问题，在Dockerfile将其配置为<code>off</code>之后就编译成功了。需要了解原理的话看最后的参考链接。</p><h4 id="文件不完整"><a href="#文件不完整" class="headerlink" title="文件不完整"></a>文件不完整</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">20 2.670 + url=https://download.docker.com/linux/static</span></span><br><span class="line"><span class="meta">#</span><span class="bash">20 2.670 + curl -Ls https://download.docker.com/linux/static/stable/x86_64/docker-17.06.2-ce.tgz</span></span><br><span class="line"><span class="meta">#</span><span class="bash">20 2.674 + tar -xz docker/docker</span></span><br><span class="line"><span class="meta">#</span><span class="bash">20 276.2</span></span><br><span class="line"><span class="meta">#</span><span class="bash">20 276.2 gzip: stdin: unexpected end of file</span></span><br><span class="line"><span class="meta">#</span><span class="bash">20 276.2 tar: Unexpected EOF <span class="keyword">in</span> archive</span></span><br><span class="line"><span class="meta">#</span><span class="bash">20 276.2 tar: Error is not recoverable: exiting now</span></span><br><span class="line">------</span><br><span class="line">executor failed running [/bin/sh -c PREFIX=/build ./install.sh $INSTALL_BINARY_NAME]: exit code: 2</span><br><span class="line">make: *** [Makefile:158: build] Error 1</span><br></pre></td></tr></table></figure><p>目测是下载docker-17.06.2-ce.tgz这个文件的时候没有下载完整，<code>make clean</code>后重新build一次。</p><h4 id="提示docker-client-CLI项目已经搬迁"><a href="#提示docker-client-CLI项目已经搬迁" class="headerlink" title="提示docker client CLI项目已经搬迁"></a>提示docker client CLI项目已经搬迁</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Makefile:157: The docker client CLI has moved to github.com/docker/cli. For a dev-test cycle involving the CLI, run:</span><br><span class="line"> DOCKER_CLI_PATH=/host/path/to/cli/binary make shell</span><br><span class="line"> then change the cli and compile into a binary at the same location.</span><br><span class="line"></span><br><span class="line">DOCKER_BUILDKIT=&quot;1&quot; docker build --build-arg=GO_VERSION  --build-arg=CROSS=false --target=dev -t &quot;docker-dev:dry-run-test&quot; -f &quot;Dockerfile&quot; .</span><br></pre></td></tr></table></figure><p>这个影响不大，是因为前后端分开维护的原因。可以自行编译CLI，<a href="https://github.com/moby/moby/blob/master/docs/contributing/set-up-dev-env.md">参考链接</a>，不编译也不影响。</p><h2 id="在本地配置环境进行编译"><a href="#在本地配置环境进行编译" class="headerlink" title="在本地配置环境进行编译"></a>在本地配置环境进行编译</h2><h3 id="安装依赖的库"><a href="#安装依赖的库" class="headerlink" title="安装依赖的库"></a>安装依赖的库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install -y libbtrfs-dev libbtrfs0 gcc pkg-config libdevmapper-dev</span><br></pre></td></tr></table></figure><h3 id="安装并配置GO开发环境"><a href="#安装并配置GO开发环境" class="headerlink" title="安装并配置GO开发环境"></a>安装并配置GO开发环境</h3><p>教程请移步其他博客。</p><h3 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h3><p>将<a href="https://github.com/moby/moby">moby的项目</a>克隆到<code>$GOPATH/src/github.com/docker/</code>目录下，并将moby更名为docker，也就是说docker源码的路径是<code>$GOPATH/src/github.com/docker/docker</code></p><img src="https://images.961110.xyz/images/2021/11/01/docker.png" alt="image-20211101170629004" style="zoom:67%;" /><h3 id="编译-1"><a href="#编译-1" class="headerlink" title="编译"></a>编译</h3><p>在docker源码目录下输入</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">VERSION=testbuild DOCKER_GITCOMMIT=1 ./hack/make.sh binary</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ul><li><code>VERSION=xxx</code>是指定构建后的docker版本，比如直接安装，会显示<code>18.09.3</code>，此处我们将版本命名为<code>testbuild</code>。</li><li>在编译指令中，你还可以选择储存引擎，只需要再命令前加上<code>DOCKER_GRAPHDRIVER=overlay2</code>就可以了</li><li>构建完成后，生成的二进制文件储存在<code>$GOPATH/src/github.com/docker/docker/bundles/binary-daemon</code>目录下，名字是<code>dockerd</code>。使用<code>ls -l</code>命令可以看到这里已经创建了软连接<code>dockerd -&gt; dockerd-testbuild</code></li></ul><h3 id="替换docker启动文件"><a href="#替换docker启动文件" class="headerlink" title="替换docker启动文件"></a>替换docker启动文件</h3><p>用生成的<code>dockerd</code>替换掉当前系统的docker启动文件。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 停止系统中正在运行的dockerd</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl stop docker</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">找到docker服务文件的位置</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl cat docker.service</span></span><br><span class="line"><span class="meta">#</span><span class="bash">输出的第一行就是docker.service的路径，修改ExecStart</span></span><br><span class="line">/lib/systemd/system/docker.service</span><br></pre></td></tr></table></figure><p>修改docker.service，找到<code>ExecStart=/usr/bin/dockerd xxx</code>，将其中的<code>/usr/bin.dockerd</code>替换成刚刚生成的二进制文件，也就是<code>$GOPATH/src/github.com/docker/docker/bundles/binary-daemon/dockerd</code></p><p><strong>注意</strong>：这里的<code>$GOPATH</code>要用绝对路径，每个人设置的路径是不同的。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $GOPATH</span><br></pre></td></tr></table></figure><h3 id="重载及启动docker服务"><a href="#重载及启动docker服务" class="headerlink" title="重载及启动docker服务"></a>重载及启动docker服务</h3><p>替换完成后，终端输入</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> systemctl daemon-reload</span></span><br></pre></td></tr></table></figure><p>重载完成后，就可以启动引擎了</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> systemctl start docker</span></span><br></pre></td></tr></table></figure><p>验证是否替换成功，执行<code>sudo docker version</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  binary-daemon docker version</span><br><span class="line">Client: Docker Engine - Community</span><br><span class="line"> Version:           20.10.10</span><br><span class="line"> API version:       1.40</span><br><span class="line"> Go version:        go1.16.9</span><br><span class="line"> Git commit:        b485636</span><br><span class="line"> Built:             Mon Oct 25 07:42:59 2021</span><br><span class="line"> OS/Arch:           linux/amd64</span><br><span class="line"> Context:           default</span><br><span class="line"> Experimental:      true</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Engine:</span><br><span class="line">  Version:          testbuild</span><br><span class="line">  API version:      1.40 (minimum version 1.12)</span><br><span class="line">  Go version:       go1.13.15</span><br><span class="line">  Git commit:       1</span><br><span class="line">  Built:            Fri Oct 29 11:14:50 2021</span><br><span class="line">  OS/Arch:          linux/amd64</span><br><span class="line">  Experimental:     false</span><br><span class="line"> containerd:</span><br><span class="line">  Version:          1.4.11</span><br><span class="line">  GitCommit:        5b46e404f6b9f661a205e28d59c982d3634148f8</span><br><span class="line"> runc:</span><br><span class="line">  Version:          1.0.2</span><br><span class="line">  GitCommit:        v1.0.2-0-g52b36a2</span><br><span class="line"> docker-init:</span><br><span class="line">  Version:          0.19.0</span><br><span class="line">  GitCommit:        de40ad0</span><br><span class="line">➜  binary-daemon</span><br></pre></td></tr></table></figure><p>可以看到Docker Engine已经替换成了刚刚编译的版本。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://ops.tips/blog/compiling-your-own-forked-docker-release/">Compiling and running your own forked Docker release | OpsTips</a></li><li><a href="https://github.com/moby/moby/blob/master/docs/contributing/set-up-dev-env.md">moby/set-up-dev-env.md at master · moby/moby (github.com)</a></li><li><a href="https://swayye.xyz/2019/09/03/%E5%88%A9%E7%94%A8go%E7%BC%96%E8%AF%91%E5%99%A8%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91docker/">利用go编译器源码编译docker | 一葉扁舟 (swayye.xyz)</a></li><li><a href="https://github.com/docker/docker-ce">docker/docker-ce: This repository is deprecated and will be archived (Docker CE itself is NOT deprecated) see the https://github.com/docker/docker-ce/blob/master/README.md</a></li><li><a href="https://github.com/docker/cli">docker/cli: The Docker CLI (github.com)</a></li><li><a href="https://github.com/moby/moby">moby/moby: Moby Project - a collaborative project for the container ecosystem to assemble container-based systems (github.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/374372749">GO111MODULE 是个啥？ - 知乎 (zhihu.com)</a></li><li><a href="https://www.a-programmer.top/2019/04/24/%E7%BC%96%E8%AF%91docker%E6%BA%90%E7%A0%81%E5%B9%B6%E7%94%B1%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%90%AF%E5%8A%A8docker/">编译docker源码并由二进制启动docker | 成长录-知行合一 (a-programmer.top)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 毕设 </tag>
            
            <tag> Docker </tag>
            
            <tag> Docker源码编译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMware虚拟机使用主机代理</title>
      <link href="/posts/60538.html"/>
      <url>/posts/60538.html</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>虚拟机网页使用主机代理，<a href="https://blog.961110.xyz/posts/60538.html#%E7%A1%AE%E5%AE%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5">点击链接跳转</a></li><li>虚拟机终端使用主机代理，<a href="https://blog.961110.xyz/posts/60538.html#%E7%BB%88%E7%AB%AF%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE">点击链接跳转</a></li></ul></blockquote><h2 id="确定虚拟机网络连接"><a href="#确定虚拟机网络连接" class="headerlink" title="确定虚拟机网络连接"></a>确定虚拟机网络连接</h2><p>在虚拟机设置页面里面可以找到网络适配器的选项，常用的就是桥接和NAT模式。</p><p><img src="https://images.961110.xyz/images/2021/10/27/cfee8f430d38afc804c18db63639499e.png" alt="image-20211027133942723" style="zoom:50%;" /><img src="https://images.961110.xyz/images/2021/10/27/NAT.png" alt="image-20211027133902778" style="zoom: 67%;" /></p><p>我这里之前<a href="https://blog.961110.xyz/posts/5768.html">设置过静态IP</a>，所以沿用NAT模式。</p><p>当然也可以选择桥接模式，设置代理的方法都是一样的。</p><h2 id="确定网卡"><a href="#确定网卡" class="headerlink" title="确定网卡"></a>确定网卡</h2><p>打开虚拟网络编辑器，查看桥接或者NAT模式对应的网卡。</p><img src="https://images.961110.xyz/images/2021/10/24/gatewayIP.png" alt="image-20211024115756744" style="zoom:50%;" /><p>我这里用的是NAT模式，如下图可以看到使用的网卡是VMnet8</p><img src="https://images.961110.xyz/images/2021/10/27/4f92fbe9575fe10143b1e168a2e97967.png" alt="image-20211027140608855" style="zoom: 67%;" /><p>我这里用的是Clash for Windows</p><p>需要打开允许局域网（Allow LAN）的选项，端口的话默认7890就可以，有需要可以自行更改。</p><img src="https://images.961110.xyz/images/2021/10/27/clashforWindows.png" alt="image-20211027140244748" style="zoom:50%;" /><p>把光标移动到Clash for Windows页面允许局域网选项，页面下方会自动显示不同适配器对应的IP，VMnet8对应的192.168.74.1。</p><img src="https://images.961110.xyz/images/2021/10/27/IP.png" alt="image-20211027140822152" style="zoom:50%;" /><h2 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h2><h3 id="系统代理设置"><a href="#系统代理设置" class="headerlink" title="系统代理设置"></a>系统代理设置</h3><p>在虚拟机图形化界面的右上角进行网络设置。</p><img src="https://images.961110.xyz/images/2021/10/27/Ubuntu20.04.png" alt="image-20211027134307360" style="zoom:67%;" /><p>点击设置Network Proxy设置代理</p><img src="https://images.961110.xyz/images/2021/10/27/proxy-setting.png" alt="image-20211027141049935" style="zoom:50%;" /><p>代理服务器地址设置成VMnet8的IP，端口设置成Clash for Windows的端口</p><img src="https://images.961110.xyz/images/2021/10/27/Proxy.png" alt="image-20211027141222842" style="zoom:67%;" /><h3 id="终端代理设置"><a href="#终端代理设置" class="headerlink" title="终端代理设置"></a>终端代理设置</h3><p>我用的shell是zsh，编辑配置文件。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim ~/.zshrc</span><br></pre></td></tr></table></figure><p>增加的内容如下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> proxy</span></span><br><span class="line">proxy () &#123;</span><br><span class="line">  export http_proxy=&quot;http://192.168.74.1:7890&quot;</span><br><span class="line">  export https_proxy=$http_proxy</span><br><span class="line">  export socks5_proxy=&quot;http://192.168.74.1:7890&quot;</span><br><span class="line">  echo &quot;HTTP Proxy on&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> noproxy</span></span><br><span class="line">noproxy () &#123;</span><br><span class="line">  unset http_proxy</span><br><span class="line">  unset https_proxy</span><br><span class="line">  echo &quot;HTTP Proxy off&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>开启或者关闭代理</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  proxy</span><br><span class="line">HTTP Proxy on</span><br><span class="line">➜  noproxy</span><br><span class="line">HTTP Proxy off</span><br><span class="line">➜  Downloads</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl www.google.com -I</span><br></pre></td></tr></table></figure><p>返回状态为 200 说明设置成功。</p><p>如果用 bash，可以直接上面命令的 <code>~/.zshrc</code> 换成 <code>./.bash_profile</code></p><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>桥接模式直接将代理服务器设置成主机的IP即可。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://www.cnblogs.com/mysticbinary/p/14522644.html">zsh设置代理 - Mysticbinary - 博客园 (cnblogs.com)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Linux </tag>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux（树莓派）安装Frpc</title>
      <link href="/posts/29306.html"/>
      <url>/posts/29306.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>树莓派是用校园网联网的，如果长时间不联网就需要重新验证登录，届时IP也会跟着变化，所以是个比较麻烦的事情。</p><p>同样用笔记本开热点给树莓派用，每次连接分配给树莓派的IP也是不固定的。</p><p>如果是通过网线共享笔记本的网络，又比较繁琐，毕竟多拖了一根线。</p><p>之前看到了有大佬写了自动登录校园网的Python脚本，所以有了这边博文。总体的想法是利用大佬的脚本自动登录校园网，通过Frp实现内网穿透，如果发现树莓派IP变化后，可以通过穿透出来的VNC端口开启远程桌面，进而获得树莓派的新IP。</p><p>如果没有Frp服务器的同学，可以写一个脚本，在每次IP变化后通过发送邮件或其他方式获取IP，参考链接<a href="https://zhangshenjia.com/it/raspberry_pi/raspbian-ipmailer/">树莓派Raspbian开机自动发ip邮件的解决方案</a>。</p><h2 id="二进制包"><a href="#二进制包" class="headerlink" title="二进制包"></a>二进制包</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p><a href="https://github.com/fatedier/frp/releases/tag/v0.38.0">Release v0.38.0 · fatedier/frp (github.com)</a></p><p>直接到Github项目的发布页下载好对应的版本即可。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>解压压缩包，将可执行文件和配置文件复制到相应目录</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">这里需要<span class="built_in">cd</span>到加压缩frp压缩包的文件位置，解压后会看到文件里有frpc的启动程序</span></span><br><span class="line">cd /home/pi/frp/</span><br><span class="line"></span><br><span class="line">sudo mkdir /usr/local/bin/frpc</span><br><span class="line">sudo cp frpc /usr/local/bin/frpc</span><br><span class="line"></span><br><span class="line">sudo mkdir /etc/frpc</span><br><span class="line">sudo cp frpc.ini /etc/frpc/frpc.ini</span><br></pre></td></tr></table></figure><p>修改systemd文件夹中<code>frpc.service</code>文件，</p><p>内容如下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Frp Client Service</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">User=nobody</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5s</span><br><span class="line">ExecStart=/usr/local/bin/frpc/frpc -c /etc/frpc/frpc.ini</span><br><span class="line">ExecReload=/usr/local/bin/frpc/frpc reload -c /etc/frpc/frpc.ini</span><br><span class="line">LimitNOFILE=1048576</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>将该文件复制到如下文件夹<code>/usr/lib/systemd/system/</code></p><h3 id="修改Fprc配置"><a href="#修改Fprc配置" class="headerlink" title="修改Fprc配置"></a>修改Fprc配置</h3><p>如果服务端还没有配置好的，可以直接百度Fprs配置教程。</p><p>修改<code>/etc/frpc/frpc.ini</code>文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = xxx.xxx.xxx.xxx</span><br><span class="line">server_port = 7000</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> [SSH]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">type</span> = tcp</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> local_ip = 127.0.0.1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> local_port = 22</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> remote_port = 7002</span></span><br><span class="line"></span><br><span class="line">[raspberry-vnc]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 5900</span><br><span class="line">remote_port = 7005</span><br></pre></td></tr></table></figure><p>不建议穿透SSH端口，降低风险。</p><p>vnc服务的默认端口是5900，如果还没有开启VNC服务，可以到<a href="https://blog.961110.xyz/posts/59454.html#%E5%BC%80%E5%90%AFVNC">树莓派4B启动配置 | Jason’s Blog (961110.xyz)</a>开启VNC服务</p><h3 id="设置Frpc服务自启动"><a href="#设置Frpc服务自启动" class="headerlink" title="设置Frpc服务自启动"></a>设置Frpc服务自启动</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable frpc</span><br><span class="line">systemctl start frpc</span><br></pre></td></tr></table></figure><p>查看服务状态</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl status frpc</span><br></pre></td></tr></table></figure><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>配置文件与上文的一样</p><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --restart=always --network host -d -v /etc/frpc/frpc.ini:/etc/frp/frpc.ini --name frpc snowdreamtech/frpc</span><br></pre></td></tr></table></figure><p>Docker yyds，真的方便。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://www.jianshu.com/p/41560282c302">frpc开机自启动 - 简书 (jianshu.com)</a></li><li><a href="https://blog.csdn.net/haostart_/article/details/110249574">自动登录武汉理工大学鉴湖宿舍校园网的方式-python及exe程序_haostart_的博客-CSDN博客</a></li><li><a href="https://hub.docker.com/r/snowdreamtech/frpc">snowdreamtech/frpc - Docker Image | Docker Hub</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> 教程 </tag>
            
            <tag> 配置 </tag>
            
            <tag> frp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转载】Ubuntu 20.04 提示找不到 python</title>
      <link href="/posts/1027.html"/>
      <url>/posts/1027.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址 <a href="https://blog.csdn.net/GerZhouGengCheng/article/details/118468389">blog.csdn.net</a></p></blockquote><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>Ubuntu 20.04 Focal 默认自带 python3.8，但是根据指引，所有引用 python 的包必须显示指定 python3 或其他 python 版本。</p><p>Ubuntu 从 20.04 开始不再将 python 加入<code>PATH</code>环境变量，在编译安装一些软件会提示无法运行并提示找不到 python，然而 python3 已安装，需要额外重定向。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install python-is-python3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>或者手动创建 symlink</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ln -s /usr/bin/python3 /usr/bin/python</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>检查是否配置成功：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">whereis python</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Linux </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMware授权服务启动失败、ens33网卡没有IP地址解决方案</title>
      <link href="/posts/3687.html"/>
      <url>/posts/3687.html</url>
      
        <content type="html"><![CDATA[<h3 id="VMware授权服务启动失败"><a href="#VMware授权服务启动失败" class="headerlink" title="VMware授权服务启动失败"></a>VMware授权服务启动失败</h3><p>启动虚拟机报错，根据提示是因为授权服务未能成功启动。</p><img src="https://images.961110.xyz/images/2021/10/25/VMware.png" alt="image-20211025164644686" style="zoom: 67%;" /><p>右下角Windows搜索栏直接搜索服务，然后找到VMware Authorization Service，双击设置其启动类型为自动，应用，然后点击启动。</p><img src="https://images.961110.xyz/images/2021/10/25/VMware-Authorization-Service.png" alt="image-20211025165252791" style="zoom:50%;" /><p>这个时候应该可以启动虚拟机了。</p><h3 id="ens33网卡没有IP地址"><a href="#ens33网卡没有IP地址" class="headerlink" title="ens33网卡没有IP地址"></a>ens33网卡没有IP地址</h3><img src="https://images.961110.xyz/images/2021/10/25/ens33IP.png" alt="image-20211025165646238" style="zoom:50%;" /><p>跟上述原因相同，也有可能是因为VMware DHCP Service没有启动解决办法类似。</p><img src="https://images.961110.xyz/images/2021/10/25/IP.png" alt="image-20211025165851601" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Linux </tag>
            
            <tag> VMware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统更换软件源</title>
      <link href="/posts/32224.html"/>
      <url>/posts/32224.html</url>
      
        <content type="html"><![CDATA[<h3 id="明确自己的发行版本"><a href="#明确自己的发行版本" class="headerlink" title="明确自己的发行版本"></a>明确自己的发行版本</h3><p><strong>确保与自己的Linux分发版本一致</strong>，不然会出现下载的编译器版本<strong>不匹配问题</strong>。</p><p>有以下三种方法：</p><ol><li><p><code>lsb_release -a</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jason@ubuntu:/etc/apt$ lsb_release -a</span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID: Ubuntu</span><br><span class="line">Description:    Ubuntu 20.04.3 LTS</span><br><span class="line">Release:        20.04</span><br><span class="line">Codename:       focal</span><br></pre></td></tr></table></figure></li><li><p>查看配置文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jason@ubuntu:/etc/apt$ ls /etc/ | grep &quot;release&quot;</span><br><span class="line">lsb-release</span><br><span class="line">os-release</span><br><span class="line"></span><br><span class="line">jason@ubuntu:/etc/apt$ cat /etc/os-release</span><br><span class="line">NAME=&quot;Ubuntu&quot;</span><br><span class="line">VERSION=&quot;20.04.3 LTS (Focal Fossa)&quot;</span><br><span class="line">ID=ubuntu</span><br><span class="line">ID_LIKE=debian</span><br><span class="line">PRETTY_NAME=&quot;Ubuntu 20.04.3 LTS&quot;</span><br><span class="line">VERSION_ID=&quot;20.04&quot;</span><br><span class="line">HOME_URL=&quot;https://www.ubuntu.com/&quot;</span><br><span class="line">SUPPORT_URL=&quot;https://help.ubuntu.com/&quot;</span><br><span class="line">BUG_REPORT_URL=&quot;https://bugs.launchpad.net/ubuntu/&quot;</span><br><span class="line">PRIVACY_POLICY_URL=&quot;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy&quot;</span><br><span class="line">VERSION_CODENAME=focal</span><br><span class="line">UBUNTU_CODENAME=focal</span><br><span class="line"></span><br><span class="line">jason@ubuntu:/etc/apt$ cat /etc/lsb-release</span><br><span class="line">DISTRIB_ID=Ubuntu</span><br><span class="line">DISTRIB_RELEASE=20.04</span><br><span class="line">DISTRIB_CODENAME=focal</span><br><span class="line">DISTRIB_DESCRIPTION=&quot;Ubuntu 20.04.3 LTS&quot;</span><br></pre></td></tr></table></figure></li><li><p><code>cat /etc/issue</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jason@ubuntu:/etc/apt$ cat /etc/issue</span><br><span class="line">Ubuntu 20.04.3 LTS \n \l</span><br></pre></td></tr></table></figure></li></ol><h3 id="查找对应的软件源"><a href="#查找对应的软件源" class="headerlink" title="查找对应的软件源"></a>查找对应的软件源</h3><p>清华大学镜像源链接：<a href="https://mirrors.tuna.tsinghua.edu.cn/">清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a></p><p>直接搜索对应的发行版</p><img src="https://images.961110.xyz/images/2021/10/24/Ubuntu.png" alt="image-20211024164923972" style="zoom:50%;" /><p>进去之后就可以看到使用帮助，<strong>记得选择自己的Ubuntu版本</strong></p><img src="https://images.961110.xyz/images/2021/10/24/Ubuntu7357b30fc9ba54cb.png" alt="image-20211024164949010" style="zoom:50%;" /><blockquote><p><strong>在 ARM(arm64, armhf)、PowerPC(ppc64el)、RISC-V(riscv64) 和 S390x 等架构的设备上（对应官方源为ports.ubuntu.com）请使用 <a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu-ports/">ubuntu-ports 镜像</a></strong></p></blockquote><h3 id="替换软件源配置文件内容"><a href="#替换软件源配置文件内容" class="headerlink" title="替换软件源配置文件内容"></a>替换软件源配置文件内容</h3><p><strong>备份！！！</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure><p>然后清空或者直接删除</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jason@ubuntu:/etc/apt$ sudo -i</span><br><span class="line">root@ubuntu:~# sudo cat /dev/null &gt; sources.list</span><br><span class="line">root@ubuntu:~# file sources.list</span><br><span class="line">sources.list: empty</span><br><span class="line">root@ubuntu:~# vim sources.list</span><br><span class="line">root@ubuntu:~# exit</span><br><span class="line">logout</span><br><span class="line">jason@ubuntu:/etc/apt$</span><br></pre></td></tr></table></figure><p>更新软件源镜像</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ol><li><a href="https://www.cnblogs.com/wojiatingting/p/6879084.html">Linux查看系统发行版本 - 星星&amp;之火 - 博客园 (cnblogs.com)</a></li><li><a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">ubuntu | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a></li><li><a href="https://www.jb51.net/article/100462.htm">Linux 中清空或删除大文件内容的五种方法_Linux_脚本之家 (jb51.net)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vmware虚拟机Ubuntu20.04.3 LTS设置静态IP并使用ssh连接</title>
      <link href="/posts/5768.html"/>
      <url>/posts/5768.html</url>
      
        <content type="html"><![CDATA[<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><ol><li><p>安装net-tools，解决<code>ifconfig</code>命令找不到的问题</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install net-tools</span><br></pre></td></tr></table></figure></li><li><p>安装openssh-server，开启ssh服务</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">   sudo apt-get install openssh-server</span><br><span class="line">   sudo service ssh start</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 设置静态IP</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 查看网关IP</span></span></span><br><span class="line"></span><br><span class="line">点击虚拟网络编辑器</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://images.961110.xyz/images/2021/10/24/gatewayIP.png&quot; alt=&quot;image-20211024115756744&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 查看网关IP以及DHCP范围</span></span></span><br><span class="line"></span><br><span class="line">查看网关IP</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://images.961110.xyz/images/2021/10/24/get-gateway-IP.png&quot; alt=&quot;image-20211024120112875&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">查看DHCP范围</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://images.961110.xyz/images/2021/10/24/DHCP-range.png&quot; alt=&quot;image-20211024120215689&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">将静态IP设置成范围之内的就可以，我选择192.168.74.222</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 设置静态IP</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">### 查看网卡信息</span></span></span><br><span class="line"></span><br><span class="line">输入`ifconfig`查看网卡的名称，可以看到是`ens33`</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://images.961110.xyz/images/2021/10/24/7ea2a1247790a95580b6056738221623.png&quot; alt=&quot;image-20211024120653533&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">与Ubuntu 16不同，在Ubuntu 18之后默认使用netplan来管理网络，配置文件是`yaml`文件</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">### 设置静态IP</span></span></span><br><span class="line"></span><br><span class="line">配置文件如下，**最好做一个备份**。</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">sudo vim /etc/netplan/01-network-manager-all.yaml</span><br></pre></td></tr></table></figure></li></ol><p>内容如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">network:</span></span><br><span class="line">  <span class="attr">version:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">renderer:</span> <span class="string">NetworkManager</span></span><br><span class="line">  <span class="attr">ethernets:</span></span><br><span class="line">    <span class="attr">ens33:</span></span><br><span class="line">      <span class="attr">dhcp4:</span> <span class="literal">no</span></span><br><span class="line">      <span class="attr">addresses:</span> [<span class="number">192.168</span><span class="number">.74</span><span class="number">.222</span><span class="string">/24</span>]</span><br><span class="line">      <span class="attr">gateway4:</span>  <span class="number">192.168</span><span class="number">.74</span><span class="number">.2</span></span><br><span class="line">      <span class="attr">nameservers:</span></span><br><span class="line">        <span class="attr">addresses:</span> [<span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>, <span class="number">114.114</span><span class="number">.114</span><span class="number">.114</span>]</span><br></pre></td></tr></table></figure><p><strong>缩进一定要对齐，且冒号之后要有一个空格。</strong></p><p>保存后，提交修改，使用<code>ifconfig</code>查看是否修改成功。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo netplan apply</span><br></pre></td></tr></table></figure><h2 id="使用ssh连接"><a href="#使用ssh连接" class="headerlink" title="使用ssh连接"></a>使用ssh连接</h2><h3 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h3><p>在首选项里可以设置虚拟机在VMware关闭后继续运行。</p><img src="https://images.961110.xyz/images/2021/10/24/gatewayIP.png" alt="image-20211024115756744" style="zoom:50%;" /><p>勾选Workstation关闭后保持虚拟机运行，就可以关掉VMware了。</p><img src="https://images.961110.xyz/images/2021/10/24/58a0ca43677d6443b173b79c33547567.png" alt="image-20211024122045615" style="zoom:50%;" /><h3 id="ssh连接"><a href="#ssh连接" class="headerlink" title="ssh连接"></a>ssh连接</h3><p>如果想要免密登录，可以在git-bash下输入，然后输入密码验证就好了。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-copy-id -i C:\\Users\\用户名\\.ssh\\id_rsa.pub jason@虚拟机IP</span><br></pre></td></tr></table></figure><p>否则，直接ssh连接就好了。</p><h2 id="设置虚拟机开机自启"><a href="#设置虚拟机开机自启" class="headerlink" title="设置虚拟机开机自启"></a>设置虚拟机开机自启</h2><p>可以参考下面两个博文</p><ol><li><a href="https://blog.csdn.net/weixin_42808782/article/details/116485359">win10设置vmware 虚拟机开机自启动_丛娟的博客-CSDN博客_vmware虚拟机开机自启动</a></li><li><a href="https://blog.csdn.net/qq_16149777/article/details/73162480?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5.no_search_link">Windows设置VMware开机自动启动，虚拟机也启动_张懿的博客-CSDN博客_vmware开机自动启动虚拟机</a></li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://blog.csdn.net/u014454538/article/details/88646689">ubuntu18.04配置静态ip和动态ip_lucyLee的博客-CSDN博客_ubuntu配置静态ip</a></li><li><a href="https://blog.csdn.net/chaofanjun/article/details/106663662">Ubuntu20.04配置静态ip_chaofanjun-CSDN博客</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Linux </tag>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转载】在 linux 后台运行脚本命令和程序的方法大全</title>
      <link href="/posts/36766.html"/>
      <url>/posts/36766.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址 <a href="https://blog.csdn.net/davidhzq/article/details/102766881">https://blog.csdn.net/davidhzq/article/details/102766881</a></p></blockquote><p>需要在 linux 后台执行任务的情况还是经常会遇到的，比如一些费时的操作，或者一些需要长时间存在的程序。当然你也可以把这些任务做成守护进程或者后台服务，但这需要额外的工作量。linux 提供了很多方法可以直接将普通的命令、脚本、应用程序以后台的形式运行起来，这样就不会阻塞终端窗口的继续使用。常用的涉及后台执行的命令有十几多个，包括：&amp;、ctrl+z、bg、fg、nohup、disown、setsid、(cmd)、jobs、ps、kill 等。</p><p>下面先对每个命令的功能作用做一个简单的介绍，然后分别给出使用案例进行详细解释。</p><h2 id="1、后台执行脚本命令功能介绍"><a href="#1、后台执行脚本命令功能介绍" class="headerlink" title="1、后台执行脚本命令功能介绍"></a>1、后台执行脚本命令功能介绍</h2><p><code>&amp;</code>：将当前命令以后台的形式运行；<br><code>ctrl+z</code>：将前台任务转后台并冻结；<br><code>bg</code>：将后台冻结的任务再次运行起来；<br><code>fg</code>：将后台任务重新转前台执行；<br><code>nohup</code>：隔离终端挂断信号，是命令的前缀；<br><code>disown</code>：隔离终端挂断信号，事后使用；<br><code>setsid</code>：重新创建一个会话进程来执行任务；<br><code>(cmd)</code>：创建一个独立 shell 来执行命令；<br><code>jobs</code>：查看在后台运行的任务列表；<br><code>ps</code>：查看正在运行的进程信息；<br><code>kill</code>：杀掉某个进程；</p><p> 下面就分别对上面的命令举例来说说如何让脚本命令在后台执行，先看一下测试用例。</p><h2 id="2、后台脚本任务测试用例"><a href="#2、后台脚本任务测试用例" class="headerlink" title="2、后台脚本任务测试用例"></a>2、后台脚本任务测试用例</h2><p> 下面所有的例子中的脚本统一使用这个脚本，它的功能是每 2 秒打印一次当前时间。hzqtest8.sh 是测试脚本的名字，.sh 文件最好放在当前用户默认目录中（如果你放在其他目录了，请注意权限问题！）。</p><p><strong>1）创建脚本：</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">创建脚本文件</span></span><br><span class="line">hzq@ubuntu:~$ sudo gedit hzqtest8.sh</span><br><span class="line">[sudo] hzq 的密码：</span><br><span class="line"><span class="meta">#</span><span class="bash">输入脚本内容</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">for ((i = 0; i &lt; 10; i++)); do</span><br><span class="line">    sleep 2</span><br><span class="line">    echo $(date)</span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span><span class="bash">保存退出。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2）赋予执行权限：</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hzq@ubuntu:~$ sudo chmod 755 hzqtest8.s</span><br></pre></td></tr></table></figure><h2 id="3、linux-后台运行命令和脚本任务的例子"><a href="#3、linux-后台运行命令和脚本任务的例子" class="headerlink" title="3、linux 后台运行命令和脚本任务的例子"></a>3、linux 后台运行命令和脚本任务的例子</h2><p> 下面通过 6 个典型的使用案例来解释各个命令的功能和使用方法。</p><h4 id="●-例1：用-amp"><a href="#●-例1：用-amp" class="headerlink" title="● 例1：用 &amp;"></a>● 例1：用 &amp;</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hzq@ubuntu:~$ ./hzqtest8.sh &amp;</span><br></pre></td></tr></table></figure><p> 功能：&amp; 加在一个命令的最后，可以把当前行的命令放在后台执行。注意 &amp; 前面有空格。</p><p> 这种方法中，当非正常退出当前 shell 终端时（包括直接叉掉、杀死、直接注销关机等），后台运行的 hzqtest8.sh 也会结束。这是因为脚本在后台运行时，运行脚本的父进程是当前 shell 终端进程，关闭当前 shell 终端时，会发送 hangup 挂断信号给子进程，子进程收到 hangup 信号后也就退出了。</p><p> 但是，如果用 exit 退出，ctrl+d 退出，命令可以继续在后台运行。</p><h4 id="●-例2：用-nohup-和-amp"><a href="#●-例2：用-nohup-和-amp" class="headerlink" title="● 例2：用 nohup 和 &amp;"></a>● 例2：用 nohup 和 &amp;</h4><p>为了解决上面的问题可以用下面的例子，</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hzq@ubuntu:~$ nohup ./hzqtest8.sh &amp;</span><br><span class="line">[1] 3640</span><br><span class="line">hzq@ubuntu:~$ nohup: 忽略输入并把输出追加到&#x27;nohup.out&#x27;</span><br><span class="line">hzq@ubuntu:~$</span><br></pre></td></tr></table></figure><p> 功能：命令前加上 nohup 可以让你退出 shell 之后继续运行相应的进程。nohup 就是忽略当前任务挂断信号的意思。这样就解决上面的问题了。</p><p> 输入 nohup 命令之后会给出提示：nohup: ignoring input and appending output to ‘nohup.out’（中文版参见上文），这是正常提示，直接打回车就可以。</p><ul><li>  nohup 默认会把标准输出重定向到默认文件 nohup.out 中，你可以自定义该输出文件，如下例子。</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hzq@ubuntu:~$ nohup ./hzqtest8.sh &gt;hzqout.txt &amp;</span><br><span class="line">[1] 3668</span><br><span class="line">hzq@ubuntu:~$ nohup: 忽略输入重定向错误到标准输出端</span><br><span class="line"></span><br><span class="line">[1]+  已完成               nohup ./hzqtest8.sh &gt; hzqout.txt</span><br><span class="line">hzq@ubuntu:~$</span><br><span class="line"><span class="meta">#</span><span class="bash">看一下输出文件里的内容。</span></span><br><span class="line">hzq@ubuntu:~$ cat hzqout.txt</span><br><span class="line">2019年 10月 25日 星期五 23:37:48 CST</span><br><span class="line">2019年 10月 25日 星期五 23:37:49 CST</span><br><span class="line">2019年 10月 25日 星期五 23:37:50 CST</span><br><span class="line">2019年 10月 25日 星期五 23:37:51 CST</span><br></pre></td></tr></table></figure><ul><li>  如果输入 nohup 后不想打回车，可以用下面的例子，</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hzq@ubuntu:~$ nohup ./hzqtest8.sh &gt;hzqout.txt 2&gt;&amp;1 &amp;</span><br><span class="line">[1] 3690</span><br><span class="line">hzq@ubuntu:~$ cat hzqout.txt</span><br><span class="line">nohup: 忽略输入</span><br><span class="line">2019年 10月 25日 星期五 23:38:53 CST</span><br><span class="line">2019年 10月 25日 星期五 23:38:54 CST</span><br><span class="line">2019年 10月 25日 星期五 23:38:55 CST</span><br><span class="line">2019年 10月 25日 星期五 23:38:56 CST</span><br><span class="line">2019年 10月 25日 星期五 23:39:02 CST</span><br><span class="line">[1]+  已完成               nohup ./hzqtest8.sh &gt; hzqout.txt 2&gt;&amp;1</span><br><span class="line">hzq@ubuntu:~$</span><br></pre></td></tr></table></figure><p> 功能解释：2&gt;&amp;1 是将错误提示信息的输出 重定向到 标准输出，而这里的标准输出已经重定向到 hzqout.txt 文件，也就是说标准的错误提示也直接输出到 out.file 文件中，所以就没有提示了，也就不用再打回车了。</p><ul><li>  另外，如果你的后台任务没有输出，你可以直接重定向到 / dev/null</li></ul><h4 id="●-例3：用-ctrl-z、jobs-和-bg"><a href="#●-例3：用-ctrl-z、jobs-和-bg" class="headerlink" title="● 例3：用 ctrl+z、jobs 和 bg"></a>● 例3：用 ctrl+z、jobs 和 bg</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hzq@ubuntu:~$ ./hzqtest8.sh</span><br><span class="line">2019年 10月 25日 星期五 23:56:15 CST</span><br><span class="line">2019年 10月 25日 星期五 23:56:16 CST</span><br><span class="line">2019年 10月 25日 星期五 23:56:17 CST</span><br><span class="line">2019年 10月 25日 星期五 23:56:18 CST</span><br><span class="line">^Z[3]   已完成               nohup ./hzqtest8.sh &gt; /dev/null 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line">[4]+  已停止               ./hzqtest8.sh</span><br><span class="line">hzq@ubuntu:~$ jobs</span><br><span class="line">[4]+  已停止               ./hzqtest8.sh</span><br><span class="line">hzq@ubuntu:~$ bg 4</span><br><span class="line">[4]+ ./hzqtest8.sh &amp;</span><br><span class="line">hzq@ubuntu:~$ 2019年 10月 25日 星期五 23:57:04 CST</span><br><span class="line">2019年 10月 25日 星期五 23:57:05 CST</span><br><span class="line">2019年 10月 25日 星期五 23:57:06 CST</span><br><span class="line">2019年 10月 25日 星期五 23:57:07 CST</span><br><span class="line">2019年 10月 25日 星期五 23:57:08 CST</span><br><span class="line">2019年 10月 25日 星期五 23:57:09 CST</span><br><span class="line"></span><br><span class="line">[4]+  已完成               ./hzqtest8.sh</span><br><span class="line">hzq@ubuntu:~$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 功能：上面的例子中脚本命令事先已经正常执行，然后你可能发现这个任务执行时间比较长，一直独占着终端窗口的使用，很不方便。</p><p> ctrl+z 命令可以将当前的前台任务转后台，也就是放到后台任务池中了，这个时候前台窗口就变成非阻塞状态了，但是要注意转过去的任务在后台默认是冻结状态。从上面例子中可以看出任务输出了 4 行之后中断了。</p><p> 这个时候需要用到 bg 命令，bg 命令的功能就是将后台冻结的任务再次运行起来，但是它需要一个任务 ID 号，而 jobs 命令就是查看所有任务状态的，包括 ID 号。</p><p> 例子中的 bg 4 就是当前任务号码。</p><p> 该例子中没有使用 nohup，有需要的同学可以自行加上，包括重定向都是可以加上的。</p><h4 id="●-例4：用-disown、jobs-和-amp"><a href="#●-例4：用-disown、jobs-和-amp" class="headerlink" title="● 例4：用 disown、jobs 和 &amp;"></a>● 例4：用 disown、jobs 和 &amp;</h4><p> 上面的例子中没有使用 nohup 命令，所以当终端环境强行退出时，后台正在执行的任务 (作业 / 命令 / 程序 / 脚本) 也会退出，由于各种原因你可能想事后加上 nohup 的功能（忽略终端关闭信号），看下面的例子。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hzq@ubuntu:~$ ./hzqtest8.sh &gt;hzqout.txt 2&gt;&amp;1 &amp;</span><br><span class="line">[1] 7168</span><br><span class="line">hzq@ubuntu:~$ jobs</span><br><span class="line">[1]+  运行中               ./hzqtest8.sh &gt; hzqout.txt 2&gt;&amp;1 &amp;</span><br><span class="line">hzq@ubuntu:~$ disown -h %1</span><br><span class="line">hzq@ubuntu:~$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 功能：disown 也是隔离终端挂断信号，但主要用于事后使用。上面执行完 disown 之后，你可以强行关闭终端窗口，然后等待 1 分钟后去查看重定向文件 hzqout.txt 看看有没有执行成功，如果成功里面有完整的 10 条信息，并且是连续的。下面的结果可以看到已经成功执行了。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hzq@ubuntu:~$ ps -ef |grep hzqtest</span><br><span class="line">hzq        7166   7152  0 01:11 pts/1    00:00:00 grep --color=auto hzqtest</span><br><span class="line"><span class="meta">#</span><span class="bash">确认后台进程已经执行完毕退出，后面会解释用法。</span></span><br><span class="line">hzq@ubuntu:~$ cat hzqout.txt</span><br><span class="line">2019年 10月 26日 星期六 01:11:16 CST</span><br><span class="line">2019年 10月 26日 星期六 01:11:20 CST</span><br><span class="line">2019年 10月 26日 星期六 01:11:24 CST</span><br><span class="line">2019年 10月 26日 星期六 01:11:28 CST</span><br><span class="line">hzq@ubuntu:~$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="●-例5：用-setsid-和-amp"><a href="#●-例5：用-setsid-和-amp" class="headerlink" title="● 例5：用 setsid 和 &amp;"></a>● 例5：用 setsid 和 &amp;</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hzq@ubuntu:~$ setsid ./hzqtest8.sh &amp;</span><br><span class="line">[1] 3001</span><br><span class="line">hzq@ubuntu:~$ 2019年 10月 26日 星期六 16:27:09 CST</span><br><span class="line">2019年 10月 26日 星期六 16:27:11 CST</span><br><span class="line">2019年 10月 26日 星期六 16:27:13 CST</span><br><span class="line">2019年 10月 26日 星期六 16:27:15 CST</span><br><span class="line">2019年 10月 26日 星期六 16:27:17 CST</span><br><span class="line"></span><br><span class="line">[1]+  已完成               setsid ./hzqtest8.sh</span><br><span class="line">hzq@ubuntu:~$</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 功能：setsid 是重新创建一个会话进程来执行任务。setsid 可以起到和 nohup 类似的效果，但是 setsid 更彻底，所以严格上说 setsid 不是忽略终端关闭信号，而是这个后台任务创建之后就与当前终端没有关系了，所以当前终端的关闭自然不会影响到它。</p><p> 同然的原理，大家估计已经想到了，jobs 命令在这个时候是不起作用的。</p><p> 另外，和 nohup 还有一个区别就是，不用多打一个回车，因为它没有提示信息。</p><h4 id="●-例6：用-小括号-圆括号-和-amp"><a href="#●-例6：用-小括号-圆括号-和-amp" class="headerlink" title="● 例6：用 小括号 / 圆括号 和 &amp;"></a>● 例6：用 小括号 / 圆括号 和 &amp;</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hzq@ubuntu:~$ (./hzqtest8.sh &amp;)</span><br><span class="line">hzq@ubuntu:~$ 2019年 10月 26日 星期六 23:58:26 CST</span><br><span class="line">2019年 10月 26日 星期六 23:58:28 CST</span><br><span class="line">2019年 10月 26日 星期六 23:58:30 CST</span><br><span class="line">2019年 10月 26日 星期六 23:58:32 CST</span><br><span class="line">2019年 10月 26日 星期六 23:58:34 CST</span><br><span class="line">hzq@ubuntu:~$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 功能：小括号可以起到和 setsid 类似的效果，小括号是创建一个独立 shell 来执行命令，当前的后台任务创建之后就与当前终端没有关系了，所以终端的关闭也不会影响到它。</p><p> 同然的原理，jobs 命令在这个时候是不起作用的。</p><p> 另外，和 setsid 一样，圆括号执行命令不用多打一个回车，因为它没有提示信息。</p><h2 id="4、查看后台任务的命令"><a href="#4、查看后台任务的命令" class="headerlink" title="4、查看后台任务的命令"></a>4、查看后台任务的命令</h2><p> 常用的有 jobs 和 ps 命令，区别是 jobs 用于查看当前终端后台运行的任务，换了终端就看不到了（包括关闭终端再重新打开也看不到的）。而 ps 命令用于查看全局所有后台进程的信息，当然可以看到别的终端运行的后台任务。</p><p><strong>1）jobs 命令</strong><br>功能：查看当前终端任务信息</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hzq@ubuntu:~$ jobs -l</span><br><span class="line">[1]-  3427 运行中               nohup ./hzqtest8.sh &amp;</span><br><span class="line">[2]+  3445 运行中               nohup firefox &amp;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>jobs -l 选项可以多显示一个 PID 信息。<br>第一列：任务序号，注意并不是 PID。<br>第二列：+ 号表示当前顶部任务，- 号其次任务，没符号是其他任务。<br>第三列：PID（上面例子中，默认情况下没有 PID）。例<br>第四列：状态，四种（运行中，已停止，已完成，已杀死）。例<br>第五列：任务名称（即刚才运行的命令）。</p><p><strong>2）ps 命令</strong><br>功能：全局查看进程信息</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hzq@ubuntu:~$ ps -ef |grep gedit</span><br><span class="line">root       3791   2566  0 00:29 pts/0    00:00:00 sudo gedit</span><br><span class="line">root       3792   3791  0 00:29 pts/0    00:00:00 gedit</span><br><span class="line">root       3802   2566  0 00:30 pts/0    00:00:00 sudo gedit</span><br><span class="line">root       3803   3802  0 00:30 pts/0    00:00:00 gedit</span><br><span class="line">hzq        3820   2566  0 00:44 pts/0    00:00:00 grep --color=auto gedit</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> ps 命令是 Process Status 的缩写，功能比较强大，参数非常多，尤其与其他命令组合时可以完成很复杂的操作。<br> ps -ef |grep hzqtest 是常见用法之一，<br> e：表示列出所有进程，f：表示输出完整格式，<br> grep hzqtest：表示过滤筛选 “hzqtest” 关键字。<br> 上面例子中，第一列：用户名，第二列：PID，第三列：父级 PID，最后一列：命令名称或路径</p><h2 id="5、关闭后台任务的命令"><a href="#5、关闭后台任务的命令" class="headerlink" title="5、关闭后台任务的命令"></a>5、关闭后台任务的命令</h2><p> 处于 linux 后台的任务有几种关闭方式：任务运行完毕自行退出；通过交互方式退出（包括传入参数对话，界面操作，终端 ctrl+c 等）；通过进程管理工具杀掉；关闭系统退出等。</p><p> <strong>kill 命令：属于进程管理工具，功能：杀掉进程。</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hzq@ubuntu:~$ jobs</span><br><span class="line">[2]   已停止               nohup firefox</span><br><span class="line">[3]-  已停止               nohup sudo gedit</span><br><span class="line">[4]+  已停止               nohup sudo gedit</span><br><span class="line">hzq@ubuntu:~$ kill -9 %2</span><br><span class="line"></span><br><span class="line">[2]   已停止               nohup firefox</span><br><span class="line">hzq@ubuntu:~$ jobs</span><br><span class="line">[2]   已杀死               nohup firefox</span><br><span class="line">[3]-  已停止               nohup sudo gedit</span><br><span class="line">[4]+  已停止               nohup sudo gedit</span><br><span class="line">hzq@ubuntu:~$ jobs</span><br><span class="line">[3]-  已停止               nohup sudo gedit</span><br><span class="line">[4]+  已停止               nohup sudo gedit</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>  1）上面的例子中先通过 jobs 命令查看任务号，然后通过任务号 %N 杀死进程！最后再次查询发现 jobs 中的任务已经减少了。</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hzq@ubuntu:~$ ps -ef |grep gedit</span><br><span class="line">root       3791   2566  0 00:29 pts/0    00:00:00 sudo gedit</span><br><span class="line">root       3792   3791  0 00:29 pts/0    00:00:00 gedit</span><br><span class="line">root       3802   2566  0 00:30 pts/0    00:00:00 sudo gedit</span><br><span class="line">root       3803   3802  0 00:30 pts/0    00:00:00 gedit</span><br><span class="line">hzq        3829   2566  0 00:59 pts/0    00:00:00 grep --color=auto gedit</span><br><span class="line">hzq@ubuntu:~$ sudo kill -9 3791</span><br><span class="line">[sudo] hzq 的密码： </span><br><span class="line">[3]-  已杀死               nohup sudo gedit</span><br><span class="line">hzq@ubuntu:~$ ps -ef |grep gedit</span><br><span class="line">root       3792    912  0 00:29 pts/0    00:00:00 gedit</span><br><span class="line">root       3802   2566  0 00:30 pts/0    00:00:00 sudo gedit</span><br><span class="line">root       3803   3802  0 00:30 pts/0    00:00:00 gedit</span><br><span class="line">hzq        3835   2566  0 01:01 pts/0    00:00:00 grep --color=auto gedit</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>  2）上面的例子中先通过 ps 命令查看任务 PID，然后通过 PID 杀掉进程，注意上面例子中使用了管理员权限。</li><li>  3）如果你的任务还没有转到后台运行，那么直接 Ctrl+c 就可以终止了。或者你也可以将后台任务转到前台然后执行 ctrl+c 来终止。该方法可参考下面举例。</li></ul><h2 id="6、前后台任务的转换"><a href="#6、前后台任务的转换" class="headerlink" title="6、前后台任务的转换"></a>6、前后台任务的转换</h2><p><strong>1）fg 命令</strong><br>功能：将后台中的任务调至前台并继续运行。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hzq@ubuntu:~$ jobs</span><br><span class="line">[1]-  运行中               nohup gedit &amp;</span><br><span class="line">[2]+  运行中               nohup ./hzqtest8.sh &amp;</span><br><span class="line">hzq@ubuntu:~$ fg 1</span><br><span class="line">nohup gedit</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先通过上面介绍的 jobs 命令查看任务信息，然后用 fg N 将选中的任务调到前台，跳到前台之后终端界面被阻塞，此时终端不能做别的事情了。</p><p><strong>2）Ctrl + z 命令</strong><br>功能：将正在前台执行的命令作业放到后台，并冻结运行状态。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hzq@ubuntu:~$ ./hzqtest8.sh</span><br><span class="line">2019年 10月 27日 星期日 01:53:31 CST</span><br><span class="line">2019年 10月 27日 星期日 01:53:33 CST</span><br><span class="line">^Z</span><br><span class="line">[3]+  已停止               ./hzqtest8.sh</span><br><span class="line">hzq@ubuntu:~$ jobs</span><br><span class="line">[3]+  已停止               ./hzqtest8.sh</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>例子中先正常运行任务脚本，可以看到刚开始是正常输出的，执行 ctrl+z 之后，提示任务已停止，用 jobs 查看任务已在后台并处于停止状态。</p><p><strong>3）bg 命令</strong><br>功能：将后台冻结的任务再次运行起来，运行后任务还在后台。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hzq@ubuntu:~$ jobs</span><br><span class="line">[1]+  已停止               ./hzqtest8.sh</span><br><span class="line">hzq@ubuntu:~$ bg 1</span><br><span class="line">[1]+ ./hzqtest8.sh &amp;</span><br><span class="line">hzq@ubuntu:~$ 2019年 10月 27日 星期日 01:58:17 CST</span><br><span class="line">2019年 10月 27日 星期日 01:58:19 CST</span><br><span class="line">2019年 10月 27日 星期日 01:58:21 CST</span><br><span class="line"></span><br><span class="line">[1]+  已完成               ./hzqtest8.sh</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面例子中先用 jobs 查看有一个任务处于后台停止状态，执行 bg 1 之后任务继续在后台运行，并继续输出剩余信息。</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转载】Docker更新日志（截止到2020年9月10日）</title>
      <link href="/posts/32194.html"/>
      <url>/posts/32194.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址 <a href="https://blog.csdn.net/wuzheng8023/article/details/108514370">Docker更新日志（截止到2020年9月10日）</a></p><p>本文记录 docker-ce 从 17.03 到 19.03 更新日志情况，主要内容为更新版本所修复的问题和新增功能等。所有内容来自官方文档的更新日志，很多地方有翻译不准确情况，仅供简单参考。</p></blockquote><p><strong>官方版本记录日志：<a href="https://docs.docker.com/engine/release-notes/">https://docs.docker.com/engine/release-notes/</a></strong></p><h3 id="版本号：19-03"><a href="#版本号：19-03" class="headerlink" title="版本号：19.03"></a>版本号：19.03</h3><p>首次发布时间： 2019-07-22</p><h4 id="构造相关"><a href="#构造相关" class="headerlink" title="构造相关"></a>构造相关</h4><ul><li>  buildkit：修复并行构建多个映像时并发映射写入异常的问题。<a href="https://github.com/moby/moby/pull/40780">moby/moby＃40780</a></li><li>  buildkit：修复了防止与用户级之间的非超级用户拥有文件的问题。<a href="https://github.com/moby/moby/pull/40955">moby/moby＃40955</a></li><li>  避免在 Windows 上创建无关的临时文件。<a href="https://github.com/moby/moby/pull/40877">moby/moby＃40877</a></li><li>  builder-next：修复极端情况下的死锁问题。<a href="https://github.com/moby/moby/pull/40557">moby/moby＃40557</a></li><li>  builder-next：允许使用现代符号哈希进行 ssh 转发。<a href="https://github.com/docker/engine/pull/453">docker/engine＃453</a></li><li>  builder-next：触发后清除 onbuild 规则。<a href="https://github.com/docker/engine/pull/453">docker/engine＃453</a></li><li>  builder-next：修复了启用用户名空间时目录权限的问题。<a href="https://github.com/moby/moby/pull/40440">moby/moby＃40440</a></li><li>  来修复 Windows 1903 上的 docker 构建失败。<a href="https://github.com/docker/engine/pull/429">docker / engine＃429</a></li><li>  builder-next：<code>entitlements</code>在构建器配置中添加。<a href="https://github.com/docker/engine/pull/412">docker/engine＃412</a></li><li>  修复 builder-next：在使用 build secret 或通过 userns-remap 进行 ssh 转发时出现权限错误。<a href="https://github.com/docker/engine/pull/420">docker/engine＃420</a></li><li>  修复 builder-next：在已经复制的目录中复制符号链接。<a href="https://github.com/docker/engine/pull/420">docker/engine＃420</a></li><li>  修复 builder-next：解决第三方注册表的摘要。<a href="https://github.com/docker/engine/pull/339">docker/engine＃339</a></li><li>  修复 builder-next：当守护程序通过套接字激活启动时，将建立用户名称空间。<a href="https://github.com/docker/engine/pull/373">docker/engine＃373</a></li><li>  修复 builder-next; 会话：释放每个连接转发的 ssh 套接字连接。<a href="https://github.com/docker/engine/pull/373">docker/engine＃373</a></li><li>  修复 build-next：llbsolver：多个缓存导入器上的错误。<a href="https://github.com/docker/engine/pull/373">docker/engine＃373</a></li><li>  修复<code>COPY --from</code>Windows 上不存在的目录。<a href="https://github.com/moby/moby/pull/39695">moby/moby＃39695</a></li><li>  修复 builder-next：元数据命令在历史记录中未创建时间。<a href="https://github.com/moby/moby/issues/39456">moby/moby＃39456</a></li><li>  修复 builder-next：关闭图层导出错误的进度。<a href="https://github.com/moby/moby/pull/39782">moby/moby＃39782</a></li><li>  将 buildkit 更新到 588c73e1e4。<a href="https://github.com/moby/moby/pull/39781">moby/moby＃39781</a></li><li>  固定<code>COPY --from</code>以保留所有权。<a href="https://github.com/moby/moby/pull/38599">moby/moby＃38599</a></li><li>生成器下一个：<ul><li>  添加了内联缓存支持<code>--cache-from</code>。<a href="https://github.com/docker/engine/pull/215">docker/engine＃215</a></li><li>  允许输出配置。<a href="https://github.com/moby/moby/pull/38898">moby/moby＃38898</a></li><li>  修复了 gcr 解决方法令牌缓存。<a href="https://github.com/docker/engine/pull/212">docker/engine＃212</a></li><li>  <code>stopprogress</code>调用下载错误。<a href="https://github.com/docker/engine/pull/215">docker/engine＃215</a></li><li>  Buildkit 现在使用 systemd 的<code>resolv.conf</code>。<a href="https://github.com/docker/engine/pull/260">docker / engine＃260</a>。</li><li>  现在可以设置 buildkit 输出。<a href="https://github.com/docker/cli/pull/1766">docker/ cli＃1766</a></li><li>  查找特定于 Dockerfile 的 dockerignore 文件（例如 Dockerfile.dockerignore）以查找忽略的路径。<a href="https://github.com/docker/engine/pull/215">docker/engine＃215</a></li><li>  自动检测 x86，arm 和 arm64 二进制文件是否可以执行进程。 <a href="https://github.com/docker/engine/pull/215">docker/engine＃215</a></li><li>  将 buildkit 更新为 1f89ec1。<a href="https://github.com/docker/engine/pull/260">docker/engine＃260</a></li><li>  <code>docker/dockerfile:1.1</code>默认情况下使用 Dockerfile 前端版本。 <a href="https://github.com/docker/engine/pull/215">docker/engine＃215</a></li><li>  不再依赖外部镜像进行 COPY / ADD 操作。 <a href="https://github.com/docker/engine/pull/215">docker/engine＃215</a></li></ul></li></ul><h4 id="客户端相关"><a href="#客户端相关" class="headerlink" title="客户端相关"></a>客户端相关</h4><ul><li>  修复了使用多个配置文件（例如，使用 Docker Desktop 时使用 Windows vs WSL2）时无法从注册表注销的错误 <a href="https://github.com/docker/cli/pull/2592">docker / cli＃2592</a></li><li>  修复回归问题，防止上下文元数据被读取 <a href="https://github.com/docker/cli/pull/2586">docker / cli＃2586</a></li><li>  升级 Golang 1.13.12 <a href="https://github.com/docker/cli/pull/2575">docker / cli＃2575</a></li><li>  修复与旧 engine 的版本协商。<a href="https://github.com/docker/cli/pull/2538">docker/ cli＃2538</a></li><li>  避免通过主机名设置 SSH 标志。<a href="https://github.com/docker/cli/pull/2560">docker/ cli＃2560</a></li><li>  当 DOCKER_CLI_EXPERIMENTAL 无效时，解决异常问题。<a href="https://github.com/docker/cli/pull/2558">docker/ cli＃2558</a></li><li>  通过升级到 1.13.11，避免对 s390x 造成潜在的异常。<a href="https://github.com/docker/cli/pull/2532">docker/ cli＃2532</a></li><li>  解决单字符卷的紧急情况。<a href="https://github.com/docker/cli/pull/2471">docker/ cli＃2471</a></li><li>  惰性守护程序功能检测可避免简单命令长时间超时。<a href="https://github.com/docker/cli/pull/2442">docker/ cli＃2442</a></li><li>  Windows 上的 Docker 上下文检查现在更快。<a href="https://github.com/docker/cli/pull/2516">docker/ cli＃2516</a></li><li>  升级 Golang 1.13.10。<a href="https://github.com/docker/cli/pull/2431">docker/ cli＃2431</a></li><li>  将 gopkg.in/yaml.v2 碰撞到 v2.2.8。<a href="https://github.com/docker/cli/pull/2470">docker/ cli＃2470</a></li><li>  升级 Golang 1.12.17。<a href="https://github.com/docker/cli/pull/2342">docker/ cli＃2342</a></li><li>  将 google.golang.org/grpc 连接到 v1.23.1。<a href="https://github.com/docker/cli/pull/1884">docker/ cli＃1884</a> <a href="https://github.com/docker/cli/pull/2373">docker/ cli＃2373</a></li><li>  添加了对 Docker Template 0.1.6 的支持。</li><li>  缓解别名过多的 YAML 文件。<a href="https://github.com/docker/cli/pull/2119">docker/ cli＃2119</a></li><li>  修复非 Windows <a href="https://github.com/docker/cli/pull/1990">docker / cli＃1990</a> 上的 Windows 绝对路径检测</li><li>  修复了的 zsh 完成脚本<code>docker login --username</code>。</li><li>  修复上下文：在上产生一致的输出<code>context create</code>。<a href="https://github.com/docker/cli/pull/1874">docker/ cli＃1985</a></li><li>  修复了对 HTTP 代理环境变量的支持。<a href="https://github.com/docker/cli/pull/2059">docker/ cli＃2059</a></li><li>  已将<code>--pids-limit</code>标志添加到<code>docker update</code>。<a href="https://github.com/docker/cli/pull/1765">docker/ cli＃1765</a></li><li>  添加了对服务的 systctl 支持。<a href="https://github.com/docker/cli/pull/1754">docker/ cli＃1754</a></li><li>  添加了<code>template_driver</code>对撰写文件的支持。<a href="https://github.com/docker/cli/pull/1746">docker/ cli＃1746</a></li><li>  添加了<code>--device</code>对 Windows 的支持。<a href="https://github.com/docker/cli/pull/1606">docker/ cli＃1606</a></li><li>  添加了对数据路径端口配置的支持。<a href="https://github.com/docker/cli/pull/1509">docker/ cli＃1509</a></li><li>  添加了快速上下文切换：命令。<a href="https://github.com/docker/cli/pull/1501">docker/ cli＃1501</a></li><li>  增加了对<code>--mount type=bind,bind-nonrecursive,...</code> <a href="https://github.com/docker/cli/pull/1430">docker / cli＃1430 的支持</a></li><li>  增加了每个节点的最大副本数。<a href="https://github.com/docker/cli/pull/1612">docker/ cli＃1612</a></li><li>  添加了静音拉动镜像的选项。<a href="https://github.com/docker/cli/pull/882">docker/ cli＃882</a></li><li>  添加了一个单独的<code>--domainname</code>标志。<a href="https://github.com/docker/cli/pull/1130">docker/ cli＃1130</a></li><li>  在中增加了对秘密驱动程序的支持<code>docker stack deploy</code>。<a href="https://github.com/docker/cli/pull/1783">docker/ cli＃1783</a></li><li>  增加了将 swarm <code>Configs</code>用作<code>CredentialSpecs</code>服务的功能。 <a href="https://github.com/docker/cli/pull/1781">docker/ cli＃1781</a></li><li>  增加了<code>--security-opt systempaths=unconfined</code>支持。<a href="https://github.com/docker/cli/pull/1808">docker/ cli＃1808</a></li><li>  添加了用于编写和运行 CLI 插件的基本框架。<a href="https://github.com/docker/cli/pull/1564">docker/ cli＃1564</a> <a href="https://github.com/docker/cli/pull/1898">docker/ cli＃1898</a></li><li>  将 Docker App 升级到 v0.8.0。<a href="https://github.com/docker/docker-ce-packaging/pull/341">docker / docker-ce-packaging＃341</a></li><li>  添加了对 Docker buildx 的支持。<a href="https://github.com/docker/docker-ce-packaging/pull/336">docker/ docker-ce-packaging＃336</a></li><li>  添加了对 Docker Assemble v0.36.0 的支持。</li><li>  添加了对 Docker Cluster v1.0.0-rc2 的支持。</li><li>  添加了对 Docker 模板 v0.1.4 的支持。</li><li>  添加了对 Docker Registry v0.1.0-rc1 的支持。</li><li>  将 google.golang.org/grpc 连接到 v1.20.1。<a href="https://github.com/docker/cli/pull/1884">docker/ cli＃1884</a></li><li>  CLI 更改为将驱动程序特定选项传递给<code>docker run</code>。<a href="https://github.com/docker/cli/pull/1767">docker/ cli＃1767</a></li><li>  重击 Golang 1.12.5。<a href="https://github.com/docker/cli/pull/1875">docker/ cli＃1875</a></li><li>  <code>docker system info</code>现在，输出将隔离与客户机和守护程序有关的信息。 <a href="https://github.com/docker/cli/pull/1638">docker/ cli＃1638</a></li><li>  （实验性）以 Kubernetes 为目标时，增加了<code>x-pull-secret: some-pull-secret</code>对 compose-files 服务配置的支持。<a href="https://github.com/docker/cli/pull/1617">docker/ cli＃1617</a></li><li>  （实验性）以 Kubernetes 为目标时，增加了<code>x-pull-policy:</code> 对 compose-files 服务配置的支持。<a href="https://github.com/docker/cli/pull/1617">docker/ cli＃1617</a></li><li>  cp，保存，导出：现在可以防止覆盖不规则文件。<a href="https://github.com/docker/cli/pull/1515">docker/ cli＃1515</a></li><li>  现在允许堆栈文件上的 npipe 卷类型。<a href="https://github.com/docker/cli/pull/1195">docker/ cli＃1195</a></li><li>  修复了 tty 初始大小错误。<a href="https://github.com/docker/cli/pull/1529">docker/ cli＃1529</a></li><li>  解决了标签从环境变量复制值的问题。 <a href="https://github.com/docker/cli/pull/1671">docker/ cli＃1671</a></li></ul><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><ul><li>  将 API 版本更新为 v1.40。<a href="https://github.com/moby/moby/pull/38089">moby/moby＃38089</a></li><li>  向<code>/info</code>端点添加了警告，并将检测移至守护程序。 <a href="https://github.com/moby/moby/pull/37502">moby/moby＃37502</a></li><li>  添加了对<code>/_ping</code>端点的 HEAD 支持。<a href="https://github.com/moby/moby/pull/38570">moby/moby＃38570</a></li><li>  添加了<code>Cache-Control</code>标头以禁用缓存<code>/_ping</code>端点。 <a href="https://github.com/moby/moby/pull/38569">moby/moby＃38569</a></li><li>  添加<code>containerd</code>，<code>runc</code>和<code>docker-init</code>版本<code>/version</code>。 <a href="https://github.com/moby/moby/pull/37974">moby/moby＃37974</a></li><li>  添加了未记录的<code>/grpc</code>端点并注册了 BuildKit 的控制器。 <a href="https://github.com/moby/moby/pull/38990">moby/moby＃38990</a></li></ul><h4 id="实验性功能"><a href="#实验性功能" class="headerlink" title="实验性功能"></a>实验性功能</h4><ul><li>  使用 TTY 启用容器的检查点 / 还原。<a href="https://github.com/moby/moby/pull/38405">moby/moby＃38405</a></li><li>  LCOW：添加了对内存和 CPU 限制的支持。<a href="https://github.com/moby/moby/pull/37296">moby/moby＃37296</a></li><li>  Windows：添加了 ContainerD 运行时。<a href="https://github.com/moby/moby/pull/38541">moby/moby＃38541</a></li><li>  Windows：LCOW 现在需要 Windows RS5 +。<a href="https://github.com/moby/moby/pull/39108">moby/moby＃39108</a></li></ul><h4 id="安全相关"><a href="#安全相关" class="headerlink" title="安全相关"></a>安全相关</h4><ul><li>apparmor：为用户添加缺少的规则。<a href="https://github.com/moby/moby/pull/40564">moby/moby＃40564</a></li><li>SElinux：修复了重新标记时未检测到的 ENOTSUP 错误。<a href="https://github.com/moby/moby/pull/40946">moby/moby＃40946</a></li><li>装<code>runc</code>在容器中。[CVE-2019-14271](<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?&gt;CVE-2017-18367">https://cve.mitre.org/cgi-bin/cvename.cgi?&gt;CVE-2017-18367</a></a></p> </li><li> <p>固定在 Glibc 下的 chroot 中加载基于 nsswitch 的配置。&lt;a href=)</li><li>安装：添加 BindOptions.NonRecursive（API v1.40）。<a href="https://github.com/moby/moby/pull/38003">moby/moby＃38003</a></li><li>seccomp：列入白名单<code>io_pgetevents()</code>。<a href="https://github.com/moby/moby/pull/38895">moby/moby＃38895</a></li><li>seccomp：<code>ptrace(2)</code>现在允许 4.8 + 内核。<a href="https://github.com/moby/moby/pull/38137">moby/moby＃38137</a></li></ul><h4 id="运行相关"><a href="#运行相关" class="headerlink" title="运行相关"></a>运行相关</h4><ul><li>升级 Golang 1.13.12 Moby <a href="https://github.com/moby/moby/pull/41082">/ Moby＃41082</a></li><li>通过升级到 1.13.11，避免对 s390x 造成潜在的异常。<a href="https://github.com/moby/moby/pull/40978">moby/moby＃40978</a></li><li>修复在 / etc / subuid 和 / etc / subgid 中使用 UID 创建名称空间时 docker 崩溃的问题。<a href="https://github.com/moby/moby/pull/40562">moby/moby＃40562</a></li><li>改进 ARM 平台匹配。<a href="https://github.com/moby/moby/pull/40758">moby/moby＃40758</a></li><li>overlay2：显示支持文件系统。<a href="https://github.com/moby/moby/pull/40652">moby/moby＃40652</a></li><li>将 CRIU 更新到 v3.13“Silicon Willet”。<a href="https://github.com/moby/moby/pull/40850">moby/moby＃40850</a></li><li>成功回退后，仅显示注册表 v2 schema1 弃用警告，而不是出现任何注册表错误。<a href="https://github.com/moby/moby/pull/40681">moby/moby＃40681</a></li><li>在 Windows 上将 FILE_SHARE_DELETE 用于日志文件。<a href="https://github.com/moby/moby/pull/40563">moby/moby＃40563</a></li><li>升级 Golang 1.13.10。<a href="https://github.com/moby/moby/pull/40803">moby/moby＃40803</a></li><li>改善某些 nscd 配置的 <a href="https://nvd.nist.gov/vuln/detail/CVE-2019-14271">CVE-2019-14271</a> 缓解措施。</li><li>overlay：删除 modprobe 执行程序。<a href="https://github.com/moby/moby/pull/40462">moby/moby＃40462</a></li><li>selinux：设置文件标签时显示更好的错误消息。<a href="https://github.com/moby/moby/pull/40547">moby/moby＃40547</a></li><li>加快初始统计信息收集。<a href="https://github.com/moby/moby/pull/40549">moby/moby＃40549</a></li><li>使用 XDG_CONFIG_HOME 中的 certs.d。<a href="https://github.com/moby/moby/pull/40461">moby/moby＃40461</a></li><li>升级 Golang 1.12.17。<a href="https://github.com/moby/moby/pull/40533">moby/moby＃40533</a></li><li>将 google.golang.org/grpc 连接到 v1.23.1。<a href="https://github.com/moby/moby/pull/40566">moby/moby＃40566</a></li><li>将容器化的二进制文件更新为 v1.2.13。<a href="https://github.com/moby/moby/pull/40540">moby/moby＃40540</a></li><li>防止将停止的容器显示为在边缘情况下运行。<a href="https://github.com/moby/moby/pull/40555">moby/moby＃40555</a></li><li>防止潜在的锁定。<a href="https://github.com/moby/moby/pull/40604">moby/moby＃40604</a></li><li>升级 Golang 1.12.16。<a href="https://github.com/moby/moby/pull/40433">moby/moby＃40433</a></li><li>将容器化的二进制文件更新为 v1.2.12。<a href="https://github.com/moby/moby/pull/40453">moby/moby＃40433</a></li><li>更新到 runc v1.0.0-rc10。<a href="https://github.com/moby/moby/pull/40453">moby/moby＃40433</a></li><li>修复 Lgetxattr 中可能出现的运行时紧急情况。<a href="https://github.com/docker/engine/pull/454">docker/engine＃454</a></li><li>无根：修复代理 UDP 数据包。<a href="https://github.com/docker/engine/pull/434">docker/engine＃434</a></li><li>将 Golang 升至 1.12.12。<a href="https://github.com/docker/engine/pull/418">docker/engine＃418</a></li><li>更新到 RootlessKit 到 v0.7.0，以使用装载名称空间和 seccomp 加固 slirp4netns。<a href="https://github.com/docker/engine/pull/397">docker/engine＃397</a></li><li>修复了从事件处理器传播 GetContainer 错误的问题。<a href="https://github.com/docker/engine/pull/407">docker/engine＃407</a></li><li>修复 OCI 图片推送。<a href="https://github.com/docker/engine/pull/405">docker/engine＃405</a></li><li>将 Golang 升至 1.12.10。<a href="https://github.com/docker/engine/pull/387">docker/engine＃387</a></li><li>装箱至 1.2.10。<a href="https://github.com/docker/engine/pull/385">docker/engine＃385</a></li><li>分发：拉出 v2 schema1 清单时修改警告逻辑。<a href="https://github.com/docker/engine/pull/368">docker/engine＃368</a></li><li><code>POST /images/create</code>提供错误的平台选项时，修复返回 500 状态代码的问题。<a href="https://github.com/docker/engine/pull/365">docker /engine＃365</a></li><li><code>POST /build</code>提供错误的平台选项时，修复返回 500 状态代码的问题。<a href="https://github.com/docker/engine/pull/365">docker /engine＃365</a></li><li>修复由于结构成员未对齐而导致的 32 位 ARMv7 异常。<a href="https://github.com/docker/engine/pull/363">docker/engine＃363</a></li><li>修复了链接到不存在的容器时返回 “无效参数” 的问题。<a href="https://github.com/docker/engine/pull/352">docker/engine＃352</a></li><li>修复 overlay2：使用内核 &gt; = 5.2 时，安装时出现繁忙错误。<a href="https://github.com/docker/engine/pull/332">docker/engine＃332</a></li><li>修复<code>docker rmi</code>卡在某些配置错误的系统中，例如死掉的 NFS 共享。<a href="https://github.com/docker/engine/pull/335">docker/engine＃335</a></li><li>修复对执行过程的阻塞 I / O 的处理。<a href="https://github.com/docker/engine/pull/296">docker/engine＃296</a></li><li>修复 jsonfile 记录器：跟踪<code>max-size</code>设置为和时卡住的日志<code>max-file=1</code>。<a href="https://github.com/docker/engine/pull/378">docker/engine＃378</a></li><li>将 Golang 升至 1.12.8。</li><li>当对容器使用 XFS 磁盘配额时，修复潜在的 engine 异常。<a href="https://github.com/moby/moby/pull/39644">moby/moby＃39644</a></li><li><code>dockerd</code>现在允许以非 root 用户身份运行（无根模式）。 <a href="https://github.com/moby/moby/pull/38050">moby/moby＃380050</a></li><li>无根：为<code>lxc-user-nic</code>SUID 二进制文件提供了可选支持。 <a href="https://github.com/docker/engine/pull/208">docker/engine＃208</a></li><li>向 HostConfig 添加了 DeviceRequests 以支持 NVIDIA GPU。<a href="https://github.com/moby/moby/pull/38828">moby/moby＃38828</a></li><li>添加了<code>--device</code>对 Windows 的支持。<a href="https://github.com/moby/moby/pull/37638">moby/moby＃37638</a></li><li>添加了<code>memory.kernelTCP</code>对 linux 的支持。<a href="https://github.com/moby/moby/pull/37043">moby/moby＃37043</a></li><li>Windows 凭据规范现在可以直接传递到 engine。 <a href="https://github.com/moby/moby/pull/38777">moby/moby＃38777</a></li><li>在 docker update 中添加了 pids-limit 支持。<a href="https://github.com/moby/moby/pull/32519">moby/moby＃32519</a></li><li>添加了对功能列表的支持。<a href="https://github.com/moby/moby/pull/38380">moby/moby＃38380</a></li><li>守护程序：现在默认使用 “专用” ipc 模式。<a href="https://github.com/moby/moby/pull/35621">moby/moby＃35621</a></li><li>守护程序：切换到信号量门控的 WaitGroup 来执行启动任务。<a href="https://github.com/moby/moby/pull/38301">moby/moby＃38301</a></li><li>现在使用 docker.sock 所有权<code>idtools.LookupGroup</code>而不是解析<code>/etc/group</code>文件来修复：<code>api.go doesn&#39;t respect nsswitch.conf</code>。<a href="https://github.com/moby/moby/pull/38126">moby/moby＃38126</a></li><li>cli：使用多参考滤镜时固定镜像滤镜。<a href="https://github.com/moby/moby/pull/38171">moby/moby＃38171</a></li><li>将 Golang 提升至 1.12.5。<a href="https://github.com/docker/engine/pull/209">docker/engine＃209</a></li><li>被撞<code>containerd</code>至 1.2.6。<a href="https://github.com/moby/moby/pull/39016">moby/moby＃39016</a></li><li>已连接<code>runc</code>到 1.0.0-rc8，opencontainers / selinux v1.2.2。<a href="https://github.com/docker/engine/pull/210">docker/engine＃210</a></li><li>被撞<code>google.golang.org/grpc</code>到 v1.20.1。<a href="https://github.com/docker/engine/pull/215">docker/engine＃215</a></li><li>在 aufs 和图层存储中优化的性能可用于大规模并行容器的创建 / 删除。 <a href="https://github.com/moby/moby/pull/39209">moby/moby</a><a href="https://github.com/moby/moby/pull/39135">＃39135</a> <a href="https://github.com/moby/moby/pull/39209">moby/moby＃39209</a></li><li>根现在传递给 chroot 以获取 chroot Tar / Untar（CVE-2018-15664）Moby <a href="https://github.com/moby/moby/pull/39292">/ Moby＃39292</a></li><li><code>docker --init</code>用 / dev 绑定安装修复。<a href="https://github.com/moby/moby/pull/37665">moby/moby＃37665</a></li><li>大于 255 并使用该<code>--device-read-bps</code>选项时，现在将获取正确的设备号。 <a href="https://github.com/moby/moby/pull/39212">moby/moby＃39212</a></li><li>修复了<code>Path does not exist</code>路径绝对存在时的错误。<a href="https://github.com/moby/moby/pull/39251">moby/moby＃39251</a></li></ul><h4 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h4><ul><li>  修复回归问题，防止守护程序在 systemd-nspawn 环境中启动 <a href="https://github.com/moby/moby/pull/41124">moby / moby＃41124</a> <a href="https://github.com/moby/libnetwork/pull/2567">moby / libnetwork＃2567</a></li><li>  修复了在 swarm 中创建覆盖网络的重试逻辑 <a href="https://github.com/moby/moby/pull/41124">moby/moby#41124</a> <a href="https://github.com/moby/libnetwork/pull/2565">moby/libnetwork#2565</a></li><li>  禁用 IPv6 路由器广告以防止地址欺骗。[moby/moby＃41009](<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?&gt;CVE-2020-13401">https://cve.mitre.org/cgi-bin/cvename.cgi?&gt;CVE-2020-13401</a></a></li><li> 修复 DNS 后备回归。&lt;a href=)</li><li>  重新启动时解决潜在的紧急情况。<a href="https://github.com/moby/moby/pull/40809">moby/moby＃40809</a></li><li>  将正确的网络值分配给默认网桥 “子网” 字段。<a href="https://github.com/moby/moby/pull/40565">moby/moby＃40565</a></li><li>  回滚 libnetwork 更改以修复<code>DOCKER-USER</code>iptables 链问题。<a href="https://github.com/docker/engine/pull/404">docker/engine＃404</a></li><li>  通过禁用网络，防止连接到容器的网络出现混乱。<a href="https://github.com/moby/moby/pull/39589">moby/moby＃39589</a></li><li>  将 IPVLAN 驱动程序移出了实验阶段。 <a href="https://github.com/moby/moby/pull/38983">moby/moby＃38983</a></li><li>  添加了对 “悬挂” 过滤器的支持。<a href="https://github.com/moby/moby/pull/31551">moby / moby＃31551 docker</a> <a href="https://github.com/docker/libnetwork/pull/2230">/ libnetwork＃2230</a></li><li>  现在，当使用来更新服务时，负载均衡器沙箱将被删除<code>--network-rm</code>。 <a href="https://github.com/docker/engine/pull/213">docker/engine＃213</a></li><li>  Windows：现在强制将指定的零 IP 强制<code>PortBindings</code>为 IPv4zero（0.0.0.0）。 <a href="https://github.com/docker/libnetwork/pull/2376">docker/ libnetwork＃2376</a></li></ul><h4 id="集群相关"><a href="#集群相关" class="headerlink" title="集群相关"></a>集群相关</h4><ul><li>  增加记录器的重新装填率，以避免挂在服务日志上。<a href="https://github.com/moby/moby/pull/40628">moby/moby＃40628</a></li><li>  修复了重启后单个 swarm 管理器停留在 Down 状态的问题。<a href="https://github.com/moby/moby/pull/40831">moby/moby＃40831</a></li><li>  task.db 不再无限期增长。[moby / moby＃40830]</li><li>  解决了无法删除具有多个任务的节点的问题。<a href="https://github.com/docker/swarmkit/pull/2867">docker/ swarmkit＃2867</a></li><li>  添加了对每个节点最大副本数的支持。<a href="https://github.com/moby/moby/pull/37940">moby/moby＃37940</a></li><li>  从 Swarmkit 配置中添加了对 GMSA CredentialSpecs 的支持。<a href="https://github.com/moby/moby/pull/38632">moby/moby＃38632</a></li><li>  添加了对服务中 sysctl 选项的支持。<a href="https://github.com/moby/moby/pull/37701">moby/moby＃37701</a></li><li>  添加了对节点标签过滤的支持。<a href="https://github.com/moby/moby/pull/37650">moby/moby＃37650</a></li><li>  Windows：在 docker service create + stack yml 中增加了对命名管道安装的支持。 <a href="https://github.com/moby/moby/pull/37400">moby/moby＃37400</a></li><li>  现在支持 VXLAN UDP 端口配置。<a href="https://github.com/moby/moby/pull/38102">moby/moby＃38102</a></li><li>  现在在 Enforcer 中使用服务放置约束。<a href="https://github.com/docker/swarmkit/pull/2857">docker/ swarmkit＃2857</a></li><li>  增加了节点和机密的最大 recv gRPC 消息大小。 <a href="https://github.com/docker/engine/pull/256">docker/engine＃256</a></li></ul><h4 id="日志相关"><a href="#日志相关" class="headerlink" title="日志相关"></a>日志相关</h4><ul><li>避免由于关闭已关闭的日志文件而导致容器日志无法旋转的情况。<a href="https://github.com/moby/moby/pull/40921">moby/moby＃40921</a></li><li>修复了读取日志日志的问题 <a href="https://github.com/moby/moby/pull/37819">moby/moby#37819</a> <a href="http://github.com/moby/moby/pull/38859">moby/moby#38859</a></li><li>在 Windows 上启用了 gcplogs 驱动程序。<a href="https://github.com/moby/moby/pull/37717">moby/moby＃37717</a></li><li>为 RFC5424 syslog 格式添加了零填充。<a href="https://github.com/moby/moby/pull/38335">moby/moby＃38335</a></li><li>添加<code>IMAGE_NAME</code>属性以<code>journald</code>记录事件。<a href="https://github.com/moby/moby/pull/38032">moby/moby＃38032</a></li></ul><h4 id="弃用"><a href="#弃用" class="headerlink" title="弃用"></a>弃用</h4><ul><li>  不推荐使用映像清单 v2 schema1，而推荐使用 v2 schema2。将来的 Docker 版本将完全不再支持 v2 schema1。<a href="https://github.com/moby/moby/pull/39365">moby/moby＃39365</a></li><li>  删除了 v1.10 迁移器。<a href="https://github.com/moby/moby/pull/38265">moby/moby＃38265</a></li><li>  现在跳过自动选择中已弃用的存储驱动程序。<a href="https://github.com/moby/moby/pull/38019">moby/moby＃38019</a></li><li>  不建议使用的<code>aufs</code>存储驱动程序，并添加了警告。<a href="https://github.com/moby/moby/pull/38090">moby/moby＃38090</a></li><li>  删除了对 17.09 的支持。</li></ul><h4 id="已知问题"><a href="#已知问题" class="headerlink" title="已知问题"></a>已知问题</h4><ul><li>在大型集群的某些情况下，作为 Swarm 部分的一部分，Docker 信息可能包含 error <code>code = ResourceExhausted desc = grpc: received message larger than max (5351376 vs. 4194304)</code>。这并不表示用户有任何故障或配置错误，并且不需要响应。</li><li>将所有服务重新部署为新服务时，可能会发生 Orchestrator 端口冲突。由于短时间内有许多 Swarm 管理器请求，因此某些服务无法接收流量，并且<code>404</code>在部署后会导致错误。<ul><li>  ** 解决方法：** 通过重新启动所有任务<code>docker service update --force</code>。</li></ul></li><li>具有目录遍历的 <a href="https://nvd.nist.gov/vuln/detail/CVE-2018-15664">CVE-2018-15664</a> symlink-exchange 攻击。解决方法，直到在即将进行的修补程序发行版中提供正确的修复程序：<code>docker pause</code>容器之前执行文件操作。<a href="https://github.com/moby/moby/pull/39252">moby/moby＃39252</a></li><li><code>docker cp</code>CVE 缓解导致的回归。当的来源<code>docker cp</code>设为时，会产生错误<code>/</code>。</li><li><h4 id="新问题"><a href="#新问题" class="headerlink" title="新问题"></a>新问题</h4><ul><li>```<br>  DOCKER-USER  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line">    iptables 链丢失：docker / for-linux＃810。用户无法在此 iptables 链的顶部执行其他容器网络流量过滤。如果您不自定义 iptable 链，则不会受到此问题的影响 DOCKER-USER</span><br><span class="line">    </span><br><span class="line">    *   解决办法：</span><br><span class="line">        </span><br><span class="line">        在 docker 守护程序启动后插入 iptables 链。例如：</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">iptables -N DOCKER-USER  </span><br><span class="line">iptables -I FORWARD -j DOCKER-USER  </span><br><span class="line">iptables -A DOCKER-USER -j RETURN  </span><br></pre></td></tr></table></figure></li></ul><h4 id="现有"><a href="#现有" class="headerlink" title="现有"></a>现有</h4><ul><li>在某些集群较大的情况下，作为 Swarm 部分的一部分，docker 信息可能包含 error <code>code = ResourceExhausted desc = grpc: received message larger than max (5351376 vs. 4194304)</code>。这并不表示用户有任何故障或配置错误，并且不需要响应。</li><li>将所有服务重新部署为新服务时，可能会发生 Orchestrator 端口冲突。由于在短时间内有许多群集管理器请求，因此某些服务无法接收流量，并且 404 在部署后会导致错误。<ul><li>  ** 解决方法：** 通过重新启动所有任务<code>docker service update --force</code>。</li></ul></li><li>具有目录遍历的 <a href="https://nvd.nist.gov/vuln/detail/CVE-2018-15664">CVE-2018-15664</a> symlink-exchange 攻击。解决方法，直到在即将进行的修补程序发行版中提供正确的修复程序：<code>docker pause</code>容器之前执行文件操作。<a href="https://github.com/moby/moby/pull/39252">moby/moby＃39252</a></li><li><code>docker cp</code>CVE 缓解导致的回归。当的来源<code>docker cp</code>设为时，会产生错误<code>/</code>。</li></ul></li><li>在某些集群较大的情况下，作为 Swarm 部分的一部分，docker 信息可能包含 error <code>code = ResourceExhausted desc = grpc: received message larger than max (5351376 vs. 4194304)</code>。这并不表示用户有任何故障或配置错误，并且不需要响应。</li><li>将所有服务重新部署为新服务时，可能会发生 Orchestrator 端口冲突。由于在短时间内有许多群集管理器请求，因此某些服务无法接收流量，并且<code>404</code>在部署后会导致错误。<ul><li>  解决方法：通过重新启动所有任务<code>docker service update --force</code>。</li></ul></li><li>由于缺少 FORWARD 链中的 Iptables 规则，流量无法流出主机。缺少的规则是：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/sbin/iptables --wait -C FORWARD -o docker_gwbridge -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">/sbin/iptables --wait -C FORWARD -o docker0 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">    </span><br></pre></td></tr></table></figure><ul><li>  解决方法：使用脚本和 cron 定义重新添加这些规则。该脚本必须包含 “-C” 命令以检查规则的存在，以及 “ -A” 命令以添加规则。定期在 cron 上运行脚本，例如，每个 分钟。</li><li>  受影响的版本：18.09.1、19.03.0</li></ul></li><li>具有目录遍历的 <a href="https://nvd.nist.gov/vuln/detail/CVE-2018-15664">CVE-2018-15664</a> symlink-exchange 攻击。解决方法，直到在即将进行的修补程序发行版中提供正确的修复程序：<code>docker pause</code>容器之前执行文件操作。<a href="https://github.com/moby/moby/pull/39252">moby/moby＃39252</a></li><li><code>docker cp</code>CVE 缓解导致的回归。当的来源<code>docker cp</code>设为时，会产生错误<code>/</code>。</li><li>在某些情况下，在大型集群中，泊坞窗信息可能会在 Swarm 部分中包含 error <code>code = ResourceExhausted desc = grpc: received message larger than max (5351376 vs. 4194304)</code>。这并不表示用户有任何故障或配置错误，并且不需要响应。</li><li>将所有服务重新部署为新服务时，可能会发生 Orchestrator 端口冲突。由于在短时间内有许多群集管理器请求，因此某些服务无法接收流量，并且 404 在部署后会导致错误。<ul><li>  解决方法：通过重新启动所有任务<code>docker service update --force</code>。</li></ul></li><li>由于缺少 FORWARD 链中的 Iptables 规则，流量无法流出主机。缺少的规则是：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/sbin/iptables --wait -C FORWARD -o docker_gwbridge -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">/sbin/iptables --wait -C FORWARD -o docker0 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">    </span><br></pre></td></tr></table></figure><ul><li>  解决方法：使用脚本和 cron 定义重新添加这些规则。该脚本必须包含 “-C” 命令以检查规则的存在，以及 “ -A” 命令以添加规则。定期在 cron 上运行脚本，例如，每个 分钟。</li><li>  受影响的版本：18.09.1、19.03.0</li></ul></li><li>具有目录遍历的 <a href="https://nvd.nist.gov/vuln/detail/CVE-2018-15664">CVE-2018-15664</a> symlink-exchange 攻击。解决方法，直到在即将进行的修补程序发行版中提供正确的修复程序：<code>docker pause</code>容器之前执行文件操作。<a href="https://github.com/moby/moby/pull/39252">moby/moby＃39252</a></li><li><code>docker cp</code>CVE 缓解导致的回归。当的来源<code>docker cp</code>设为时，会产生错误<code>/</code>。</li><li>在某些集群较大的情况下，作为 Swarm 部分的一部分，docker 信息可能包含 error <code>code = ResourceExhausted desc = grpc: received message larger than max (5351376 vs. 4194304)</code>。这并不表示用户有任何故障或配置错误，并且不需要响应。</li><li>将所有服务重新部署为新服务时，可能会发生 Orchestrator 端口冲突。由于在短时间内有许多群集管理器请求，因此某些服务无法接收流量，并且 404 在部署后会导致错误。<ul><li>  解决方法：通过重新启动所有任务<code>docker service update --force</code>。</li></ul></li><li>由于缺少 FORWARD 链中的 Iptables 规则，流量无法流出主机。缺少的规则是：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/sbin/iptables --wait -C FORWARD -o docker_gwbridge -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">/sbin/iptables --wait -C FORWARD -o docker0 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">    </span><br></pre></td></tr></table></figure><ul><li>  解决方法：使用脚本和 cron 定义重新添加这些规则。该脚本必须包含 “-C” 命令以检查规则的存在，以及 “ -A” 命令以添加规则。定期在 cron 上运行脚本，例如，每个 分钟。</li><li>  受影响的版本：18.09.1、19.03.0</li></ul></li><li>具有目录遍历的 <a href="https://nvd.nist.gov/vuln/detail/CVE-2018-15664">CVE-2018-15664</a> symlink-exchange 攻击。解决方法，直到在即将进行的修补程序发行版中提供正确的修复程序：<code>docker pause</code>容器之前执行文件操作。<a href="https://github.com/moby/moby/pull/39252">moby/moby＃39252</a></li><li><code>docker cp</code>CVE 缓解导致的回归。当的来源<code>docker cp</code>设为时，会产生错误。</li></ul><h4 id="打包相关"><a href="#打包相关" class="headerlink" title="打包相关"></a>打包相关</h4><ul><li>修复 ARM 基于 ARM64 构建。<a href="https://github.com/moby/moby/pull/41027">moby/moby＃41027</a></li><li>支持 RHEL 8 软件包</li></ul><h3 id="版本号：18-09"><a href="#版本号：18-09" class="headerlink" title="版本号：18.09"></a>版本号：18.09</h3><p>首次发布时间： 2018-11-08</p><h4 id="客户端相关-1"><a href="#客户端相关-1" class="headerlink" title="客户端相关"></a>客户端相关</h4><ul><li>  在非 Windows 上修复 Windows 绝对路径检测。<a href="https://github.com/docker/cli/pull/1990">docker/ cli＃1990</a></li><li>  修复 Docker 拒绝从 Windows 上的委托文件加载密钥的问题。<a href="https://github.com/docker/cli/pull/1968">docker/ cli＃1968</a></li><li>  bash 和 zsh 的完成脚本更新。</li><li>  修复了<code>parallelism</code>和<code>max_failure_ratio</code>字段的回滚配置类型插值。</li><li>  修复了 tty 初始大小错误。<a href="https://github.com/docker/cli/pull/1775">docker/ cli＃1775</a></li><li>  修复了 Dial-stdio goroutine 泄漏。<a href="https://github.com/docker/cli/pull/1795">docker/ cli＃1795</a></li><li>  修复了用于跟踪部署的堆栈通知程序的选择器。<a href="https://github.com/docker/cli/pull/1794">docker/ cli＃1794</a></li></ul><h4 id="日志相关-1"><a href="#日志相关-1" class="headerlink" title="日志相关"></a>日志相关</h4><ul><li>  修复了读取日志日志的问题。 <a href="https://github.com/moby/moby/pull/37819">moby/moby#37819</a> <a href="https://github.com/moby/moby/pull/38859">moby/moby#38859</a></li><li>  添加了一个修复程序，该修复程序现在允许记录器插件的日志行较大。<a href="https://github.com/moby/moby/pull/39038">moby/moby＃39038</a></li></ul><h4 id="网络相关-1"><a href="#网络相关-1" class="headerlink" title="网络相关"></a>网络相关</h4><ul><li>  通过禁用网络，防止连接到容器的网络出现混乱。<a href="https://github.com/moby/moby/pull/39589">moby/moby＃39589</a></li><li>  应用程序的修订服务端口随机变为不可用。<a href="https://github.com/docker/libnetwork/pull/2069">docker/ libnetwork＃2069</a></li><li>  修复清理<code>--config-only</code>网络<code>--config-from</code>网络剃毛的问题。<a href="https://github.com/docker/libnetwork/pull/2373">docker/ libnetwork＃2373</a></li><li>  修复了<code>--network-rm</code>无法删除网络的错误。<a href="https://github.com/moby/moby/pull/39174">moby/moby＃39174</a></li><li>  关闭代理后，请清理集群提供程序。<a href="https://github.com/docker/libnetwork/pull/2354">docker/ libnetwork＃2354</a></li><li>  Windows：现在，如果用户未指定主机端口，则选择一个随机主机端口。<a href="https://github.com/docker/libnetwork/pull/2369">docker/ libnetwork＃2369</a></li><li>  修复<code>network=host</code>了<code>resolv.conf</code>与错误的使用<code>systemd-resolved</code>。<a href="https://github.com/docker/engine/pull/180">docker/engine＃180</a></li><li>  修复了 Windows ARP 条目在负载下随机损坏的问题。<a href="https://github.com/docker/engine/pull/192">docker/engine＃192</a></li><li>  缩短 exec-root 中的控制器 ID，使其不命中 UNIX_PATH_MAX。<a href="https://github.com/docker/engine/pull/424">docker/engine＃424</a></li><li>  修复 drivers / overlay / encryption.go 中的紧急情况。<a href="https://github.com/docker/engine/pull/424">docker/engine＃424</a></li><li>  修复 hwaddr 设置我们和 udev 之间的比赛。<a href="https://github.com/docker/engine/pull/439">docker/engine＃439</a></li></ul><h4 id="运行相关-1"><a href="#运行相关-1" class="headerlink" title="运行相关"></a>运行相关</h4><ul><li>  更新至 Go 1.11.13。</li><li>  当对容器使用 XFS 磁盘配额时，修复潜在的 engine 异常。<a href="https://github.com/moby/moby/pull/39644">moby/moby＃39644</a></li><li>  在调试模式下运行 Docker Engine 时，屏蔽了更新到日志文件的机密。[docker stack deploy用于重新部署包含非外部机密的堆栈，则日志将包含该机密。](<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?&gt;CVE-2019-13509">https://cve.mitre.org/cgi-bin/cvename.cgi?&gt;CVE-2019-13509</a></a>：如果 Dockerengine 以调试模式运行，并&lt;code onclick=)</li><li>  [在 aufs 和图层存储中添加了性能优化，有助于大规模并行创建和删除容器。](<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?&gt;CVE-2019-13509">https://cve.mitre.org/cgi-bin/cvename.cgi?&gt;CVE-2019-13509</a></a>：如果 Dockerengine 以调试模式运行，并&lt;code onclick=)<a href="https://github.com/moby/moby/pull/39107">Moby / moby＃39107</a>，<a href="https://github.com/moby/moby/pull/39107">Moby</a> <a href="https://github.com/moby/moby/pull/39135">/ moby＃39135</a></li><li>  已将容器更新为版本 1.2.6。<a href="https://github.com/moby/moby/pull/39016">moby/moby＃39016</a></li><li>  修复了具有目录遍历的 <a href="https://nvd.nist.gov/vuln/detail/CVE-2018-15664">CVE-2018-15664</a> symlink-exchange 攻击。<a href="https://github.com/moby/moby/pull/39357">moby/moby＃39357</a></li><li>  Windows：修复了对的支持<code>docker service create --limit-cpu</code>。<a href="https://github.com/moby/moby/pull/39190">moby/moby＃39190</a></li><li>  守护程序：修复了镜像验证问题。 <a href="https://github.com/moby/moby/pull/38991">moby/moby＃38991</a></li><li>  Docker 不再支持在 ID 映射中对 UID 和 GID 范围进行排序。<a href="https://github.com/moby/moby/pull/39288">moby/moby＃39288</a></li><li>  现在显示已停止的容器，其重启策略为<code>Restarting</code>。<a href="https://github.com/docker/engine/pull/181">docker/engine＃181</a></li><li>  现在对执行人员使用原始流程规范。<a href="https://github.com/docker/engine/pull/178">docker/engine＃178</a></li><li>  修复<code>docker cp</code>了文件名大于 100 个字符的错误。<a href="https://github.com/moby/moby/pull/38634">moby/moby＃38634</a></li><li>  已修复，<code>layer/layer_store</code>以确保<code>NewInputTarStream</code>释放资源。<a href="https://github.com/moby/moby/pull/38413">moby/moby＃38413</a></li><li>  增加了 GRPC 的限制<code>GetConfigs</code>。<a href="https://github.com/moby/moby/pull/38800">moby/moby＃38800</a></li><li>  更新了<code>containerd</code>1.2.5。<a href="https://github.com/docker/engine/pull/173">docker/engine＃173</a></li></ul><h4 id="集群相关-1"><a href="#集群相关-1" class="headerlink" title="集群相关"></a>集群相关</h4><ul><li>  修复 “grpc：收到的邮件大于最大数量” 错误。<a href="https://github.com/moby/moby/pull/39306">moby/moby＃39306</a></li><li>  修复了无法删除多个任务的节点的问题。<a href="https://github.com/docker/swarmkit/pull/2867">docker/ swarmkit＃2867</a></li><li>  修复了删除节点时泄漏的任务资源。<a href="https://github.com/docker/engine/pull/185">docker/engine＃185</a></li><li>  修复了将节点加入集群时 nil 指针异常的问题。<a href="https://github.com/moby/moby/issues/38618">moby/moby＃38618</a></li><li>  修复了如果设置了 http 代理的群集节点无法加入为主节点的问题。[moby / moby＃36951]</li></ul><h4 id="构造相关-1"><a href="#构造相关-1" class="headerlink" title="构造相关"></a>构造相关</h4><ul><li>  修复了构建仅包含注释的 dockerfile 时的紧急错误。<a href="https://github.com/moby/moby/pull/38487">moby/moby＃38487</a></li><li>  添加了 GCR 身份验证问题的解决方法。<a href="https://github.com/moby/moby/pull/38246">moby/moby＃38246</a></li><li>  下一步生成器：修复了 GCR 令牌缓存实施解决方法中的错误。<a href="https://github.com/moby/moby/pull/39183">moby/moby＃39183</a></li><li>  修复<code>DOCKER_BUILDKIT=1 docker build --squash ..</code> <a href="https://github.com/docker/engine/pull/176">docker / engine＃176</a></li><li>  修复了 <a href="https://nvd.nist.gov/vuln/detail/CVE-2019-13139">CVE-2019-13139</a>，添加了验证，<code>git ref</code>以避免将其误解为标志。<a href="https://github.com/moby/moby/pull/38944">moby/moby＃38944</a></li></ul><h4 id="已知问题-1"><a href="#已知问题-1" class="headerlink" title="已知问题"></a>已知问题</h4><ul><li>升级过程中有一些<a href="https://docs.docker.com/ee/upgrade">重要更改</a>，如果未正确遵循，则会对升级期间在 Swarm 上运行的应用程序的可用性产生影响。这些限制影响从 18.09 之前的任何版本到 18.09 或更高版本的任何升级。</li><li>升级过程中有一些<a href="https://docs.docker.com/ee/upgrade">重要更改</a>，如果未正确遵循，则会对升级期间在 Swarm 上运行的应用程序的可用性产生影响。这些限制影响从 18.09 之前的任何版本到 18.09 或更高版本的任何升级。</li><li>已修复，<code>COPY</code>并且<code>ADD</code>具有多个 ``，不会使缓存无效<code>DOCKER_BUILDKIT=1</code>。<a href="https://github.com/moby/moby/issues/38964">moby/moby＃38964</a></li><li>升级过程中有一些<a href="https://docs.docker.com/ee/upgrade">重要更改</a>，如果未正确遵循，则会对升级期间在 Swarm 上运行的应用程序的可用性产生影响。这些限制影响从 18.09 之前的任何版本到 18.09 或更高版本的任何升级。</li><li>升级过程中有一些<a href="https://docs.docker.com/ee/upgrade">重要更改</a>，如果未正确遵循，则会对升级期间在 Swarm 上运行的应用程序的可用性产生影响。这些限制影响从 18.09 之前的任何版本到 18.09 或更高版本的任何升级。</li><li><a href="https://docs.docker.com/ee/upgrade">升级过程</a>中有一些<a href="https://docs.docker.com/ee/upgrade">重要更改</a>，如果未正确遵循，则会对升级期间在 Swarm 上运行的应用程序的可用性产生影响。这些限制影响从 18.09 之前的任何版本到 18.09 或更高版本的任何升级。</li><li><a href="https://docs.docker.com/ee/upgrade">升级过程</a>中有一些<a href="https://docs.docker.com/ee/upgrade">重要更改</a>，如果未正确遵循，则会对升级期间在 Swarm 上运行的应用程序的可用性产生影响。这些限制影响从 18.09 之前的任何版本到 18.09 或更高版本的任何升级。</li><li><a href="https://docs.docker.com/ee/upgrade">升级过程</a>中有一些<a href="https://docs.docker.com/ee/upgrade">重要更改</a>，如果未正确遵循，则会对升级期间在 Swarm 上运行的应用程序的可用性产生影响。这些限制影响从 18.09 之前的任何版本到 18.09 或更高版本的任何升级。</li><li>从 18.09.0 升级到 18.09.1 时，<code>containerd</code>在 Ubuntu 上没有升级到正确的版本。</li><li><a href="https://docs.docker.com/ee/upgrade">升级过程</a>中有一些<a href="https://docs.docker.com/ee/upgrade">重要更改</a>，如果未正确遵循，则会对升级期间在 Swarm 上运行的应用程序的可用性产生影响。这些限制影响从 18.09 之前的任何版本到 18.09 或更高版本的任何升级。</li><li><a href="https://docs.docker.com/ee/upgrade">升级过程</a>中有一些<a href="https://docs.docker.com/ee/upgrade">重要更改</a>，如果未正确遵循，则会对升级期间在 Swarm 上运行的应用程序的可用性产生影响。这些限制影响从 18.09 之前的任何版本到 18.09 或更高版本的任何升级。</li><li>使用 <a href="https://github.com/boot2docker/boot2docker/releases/download/v18.09.0/boot2docker.iso%EF%BC%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8A%E7%9A%84%E8%8A%82%E7%82%B9%E8%A2%AB%E6%8B%92%E7%BB%9D%E8%BF%9E%E6%8E%A5%E3%80%82%E5%9C%A8">https://github.com/boot2docker/boot2docker/releases/download/v18.09.0/boot2docker.iso，虚拟机上的节点被拒绝连接。在</a> virtualbox 创建的 docker-machine VM 中对群集端口的任何发布都不会响应。这是在 docker-machine 版本 0.15 和 0.16 的 macOS 和 Windows 10 上发生的。  以下<code>docker run</code>命令有效，允许从主机浏览器进行访问：  <code>docker run -d -p 4000:80 nginx</code>  但是，以下<code>docker service</code>命令失败，导致 curl / chrome 无法连接（连接被拒绝）：  <code>docker service create -p 5000:80 nginx</code>  使用 docker-machine 配置 18.09.0 云虚拟机时，此问题不明显。  解决方法：<ul><li>  使用不依赖 boot2docker 的云 VM。</li><li>  <code>docker run</code> 不受影响。</li><li>  对于 Swarm，设置 VIRTUALBOX_BOOT2DOCKER_URL = https：//github.com/boot2docker/boot2docker/releases/download/v18.06.1-ce/boot2docker.iso。</li></ul>  此问题已在 18.09.1。中解决。</li></ul><h4 id="打包相关-1"><a href="#打包相关-1" class="headerlink" title="打包相关"></a>打包相关</h4><ul><li>  为 docker.service 添加 docker.socket 要求。<a href="https://github.com/docker/docker-ce-packaging/pull/276">docker / docker-ce-packaging＃276</a></li><li>  为基于 RHEL 的发行版添加套接字激活。<a href="https://github.com/docker/docker-ce-packaging/pull/274">docker / docker-ce-packaging＃274</a></li><li>  为 RPM 软件包添加 libseccomp 要求。<a href="https://github.com/docker/docker-ce-packaging/pull/266">docker/ docker-ce-packaging＃266</a></li></ul><h4 id="运行修复和更新部分"><a href="#运行修复和更新部分" class="headerlink" title="运行修复和更新部分"></a>运行修复和更新部分</h4><ul><li>  更新到 Go 版本 1.10.8。</li><li>  容器名称生成器中的已修改名称。<a href="https://github.com/docker/engine/pull/159">docker/engine＃159</a></li><li>  复制现有文件夹时，现在将忽略目标文件系统不支持 xattr 时的 xattr 设置错误。<a href="https://github.com/docker/engine/pull/135">docker/engine＃135</a></li><li>  Graphdriver：固定的 “设备” 模式，如果设置了 “字符设备” 位。<a href="https://github.com/docker/engine/pull/160">docker/engine＃160</a></li><li>  修复了在无法连接到容器时 nil 指针取消引用的问题。<a href="https://github.com/docker/engine/pull/162">docker/engine＃162</a></li><li>  启动失败时删除了过时的容器对象。<a href="https://github.com/docker/engine/pull/154">docker/engine＃154</a></li></ul><h4 id="网络修复部分"><a href="#网络修复部分" class="headerlink" title="网络修复部分"></a>网络修复部分</h4><ul><li>  Windows：现在避免重新生成网络 ID，以防止损坏对网络的引用。<a href="https://github.com/docker/engine/pull/149">docker/engine＃149</a></li><li>  Windows：修复了<code>- restart always</code>在指定网络时无法解决独立容器上的标志的问题。（docker / 升级＃1037）</li><li>  修复了如果管理器未连接到覆盖网络时从 networkdb 解决 IPAM 状态的问题。（docker / 升级＃1049）</li><li>  将 Go 语言升级到 1.10.6 以解决 <a href="https://nvd.nist.gov/vuln/detail/CVE-2018-16873">CVE-2018-16873</a>，<a href="https://nvd.nist.gov/vuln/detail/CVE-2018-16874">CVE-2018-16874</a> 和 <a href="https://nvd.nist.gov/vuln/detail/CVE-2018-16875">CVE-2018-16875</a>。</li><li>  修复了用于长度为 0 的内容和路径验证的 authz 插件。</li><li>  添加<code>/proc/asound</code>到屏蔽路径 <a href="https://github.com/docker/engine/pull/126">docker / engine＃126</a></li></ul><h4 id="修复部分"><a href="#修复部分" class="headerlink" title="修复部分"></a>修复部分</h4><ul><li>  在 RHEL/CentOS 上禁用运行 c 中的 kmem 会计 (docker/escalation#614, docker/escalation#692) <a href="https://github.com/docker/engine/pull/121">docker/engine#121</a></li><li>  修复了效率低下的网络配置 <a href="https://github.com/docker/engine/pull/123">docker / engine＃123</a></li><li>  修复了 docker 系统修剪，直到过滤器才接受 <a href="https://github.com/docker/engine/pull/122">docker / engine＃122</a></li><li>  避免在<code>containerd</code>取消设置凭据 <a href="https://github.com/docker/engine/pull/122">docker / engine＃122 中</a></li><li>  修复了 Debian 上的 iptables 兼容性 <a href="https://github.com/docker/engine/pull/107">docker / engine＃107</a></li><li>  修复了将 Docker 主机默认架构设置为 tcp 的问题 <a href="https://github.com/docker/cli/pull/1454">docker / cli＃1454</a></li><li>  修复了 bash 完成<code>service update --force</code><a href="https://github.com/docker/cli/pull/1526">docker / cli＃1526</a></li><li>  Windows：清理 DetachVhd 尝试</li><li>  API：正确处理无效的 JSON 以返回 400 状态的 <a href="https://github.com/docker/engine/pull/110">docker / engine＃110</a></li><li>  API：忽略 API &lt;1.39 上的默认地址池 <a href="https://github.com/docker/engine/pull/118">docker / engine＃118</a></li><li>  API：将缺少的默认地址池字段添加到 <a href="https://github.com/docker/engine/pull/119">docker / engine＃119</a></li><li>  awslogs：在限制考虑 UTF-8 规范化 <a href="https://github.com/docker/engine/pull/112">docker / engine＃112</a></li><li>  禁止在 HTTP 错误响应读取超过 1MB 的内容 <a href="https://github.com/docker/engine/pull/114">docker / engine＃114</a></li><li>  apparmor：允许接收来自的信号<code>docker kill</code><a href="https://github.com/docker/engine/pull/116">docker / engine＃116</a></li><li>  overlay2：如果可能，使用 index = off（在挂载上修复 EBUSY）<a href="https://github.com/docker/engine/pull/84">docker / engine＃84</a></li><li>  BuildKit：不要取消 buildkit 状态请求。<a href="https://github.com/moby/moby/pull/37597">moby/moby＃37597</a></li><li>  修复如果在 docker 构建过程中缺少构建参数，则不会显示错误 <a href="https://github.com/moby/moby/pull/37396">moby/moby#37396</a></li><li>  修复了添加 8GB 文件时的错误 “意外 EOF”<a href="https://github.com/moby/moby/pull/37771">Moby / Moby＃37771</a></li><li>  LCOW：确保在<code>COPY</code>/ 上填充平台<code>ADD</code>。<a href="https://github.com/moby/moby/pull/37563">moby/moby＃37563</a></li><li>  修复了将一系列主机端口映射到单个容器端口的问题 <a href="https://github.com/docker/cli/pull/1102">docker / cli＃1102</a></li><li>  修正<code>trust inspect</code>拼写错误：“ <code>AdminstrativeKeys</code>” <a href="https://github.com/docker/cli/pull/1300">docker / cli＃1300</a></li><li>  修复了环境文件解析，以导入缺少的变量和没有名称的变量。<a href="https://github.com/docker/cli/pull/1019">docker/ cli＃1019</a></li><li>  修复了当运行<code>docker image prune</code>大量悬空镜像时可能出现的 “内存不足异常”<a href="https://github.com/docker/cli/pull/1432">docker / cli＃1432</a> / <a href="https://github.com/docker/cli/pull/1423">docker / cli＃1423</a></li><li>  修复 Windows 上 ConEmu 和 ConsoleZ 中的管道处理 <a href="https://github.com/moby/moby/pull/37600">moby / moby＃37600</a></li><li>  修复 Windows 上长时间启动的问题，并使用非 hns 控制的 Hyper-V 网络 <a href="https://github.com/docker/engine/pull/67">docker / engine＃67</a> / <a href="https://github.com/moby/moby/pull/37774">moby / moby＃37774</a></li><li>  修复了在配置文件和 cli 都定义了 “运行时” 选项时守护程序无法启动的问题 <a href="https://github.com/docker/engine/pull/57">docker / engine＃57</a> / <a href="https://github.com/moby/moby/pull/37871">moby / moby＃37871</a></li><li>  放宽对<code>/etc/docker</code>目录的权限，以防止在使用<code>docker manifest inspect</code>时出现 “permission denied” 错误 <a href="https://github.com/docker/engine/pull/56">docker/engine#56</a> / <a href="https://github.com/moby/moby/pull/37847">moby/moby#37847</a></li><li>  服务拒绝修复与大量<code>cpuset-cpus</code>和<code>cpuset-mems</code> <a href="https://github.com/docker/engine/pull/70">docker/enginer＃70</a> / <a href="https://github.com/moby/moby/pull/37967">MOBY / MOBY＃37967</a></li><li>  LCOW：添加<code>--platform</code>到 docker <code>docker import</code> <a href="https://github.com/docker/cli/pull/1375">/ cli＃1375</a> / <a href="https://github.com/docker/cli/pull/1371">docker / cli＃1371</a></li><li>  LCOW：默认在 Windows 上添加 LinuxMetadata 支持 <a href="https://github.com/moby/moby/pull/37514">Moby / moby＃37514</a></li><li>  LCOW：安装到较短的容器路径，以避免命令行长度限制 <a href="https://github.com/moby/moby/pull/37659">moby / moby＃37659</a></li><li>  LCOW：使用错误的缓存层修复了构建器 <a href="https://github.com/moby/moby/pull/37356">Moby / moby＃37356</a></li><li>  修复了 json-log 文件描述符在使用<code>--follow</code>时泄漏的问题 <a href="https://github.com/docker/engine/pull/48">docker/engine#48</a> <a href="https://github.com/moby/moby/pull/37576">moby/moby#37576</a> <a href="https://github.com/moby/moby/pull/37734">moby/moby#37734</a></li><li>  修复了在关闭 kqueue 上的监视器时可能出现的死锁 <a href="https://github.com/moby/moby/pull/37392">moby/moby#37392</a></li><li>  使用基于轮询的观察器来解决 Windows 的文件缓存问题 <a href="https://github.com/moby/moby/pull/37412">Moby / moby＃37412</a></li><li>  通过为网络层提供适当的 resolv.conf 来处理 systemd 解决的情况 <a href="https://github.com/moby/moby/pull/37485">moby / moby</a></li><li>  删除对 TLS &lt;1.2 的支持 <a href="https://github.com/moby/moby/pull/37660">moby / moby＃37660</a></li><li>  Seccomp：将<code>CAP_SYS_NICE</code>默认 seccomp 配置文件链接的白名单系统调用 <a href="https://github.com/moby/moby/pull/37242">moby / moby＃37242</a></li><li>  Seccomp：将 syslog 系统调用移至<code>CAP_SYS_ADMIN</code>或<code>CAP_SYSLOG</code>进行把控 <a href="https://github.com/docker/engine/pull/64">docker / engine＃64</a> / <a href="https://github.com/moby/moby/pull/37929">moby / moby＃37929</a></li><li>  SELinux：修复了在启用 selinux 的系统上通过 Mounts API 指定的本地卷的重新标记的方法 <a href="https://github.com/moby/moby/pull/37739">moby / moby＃37739</a></li><li>  如果可以通过不安全的连接访问 REST API，则添加警告 <a href="https://github.com/moby/moby/pull/37684">moby / moby＃37684</a></li><li>  当在系统信息显示时，从 URL 屏蔽代理凭据 <a href="https://github.com/docker/engine/pull/72">docker / engine＃72</a> / <a href="https://github.com/moby/moby/pull/37934">moby / moby＃37934</a></li><li>  修复了 btrfs 的挂载传播 <a href="https://github.com/docker/engine/pull/86">docker / engine＃86</a> / <a href="https://github.com/moby/moby/pull/38026">moby / moby＃38026</a></li><li>  修正零指针引用在节点分配 <a href="https://github.com/docker/engine/pull/94">docker/engine#94</a> / <a href="https://github.com/docker/swarmkit/pull/2764">docker/swarmkit#2764</a></li></ul><h4 id="改进部分"><a href="#改进部分" class="headerlink" title="改进部分"></a>改进部分</h4><ul><li>  更新至 BuildKit 0.3.3 docker <a href="https://github.com/docker/engine/pull/122">/ engine＃122</a></li><li>  更新为容器化的 1.2.2 <a href="https://github.com/docker/engine/pull/144">docker / engine＃144</a></li><li>  提供了有关使用不建议使用的旧版覆盖和 devicemapper 存储驱动程序其他警告 <a href="https://github.com/docker/engine/pull/85">docker / engine＃85</a></li><li>  修剪：在构建缓存修剪之前执行镜像修剪 <a href="https://github.com/docker/cli/pull/1532">docker / cli＃1532</a></li><li>  为实验性 CLI 命令添加了 bash <a href="https://github.com/docker/cli/pull/1542">补全</a>（清单）<a href="https://github.com/docker/cli/pull/1542">docker / cli＃1542</a></li><li>  Windows：允许 Windows 10 上的进程隔离 <a href="https://github.com/docker/engine/pull/81">docker / engine＃81</a></li><li>  `` 在 / info 响应不返回 “ ”<a href="https://github.com/moby/moby/pull/37472">moby / moby＃37472</a></li><li>  BuildKit：更改<code>--console=[auto,false,true]</code>至<code>--progress=[auto,plain,tty]</code> <a href="https://github.com/docker/cli/pull/1276">docker/ CLI＃1276</a></li><li>  BuildKit：设置 BuildKit 的 ExportedProduct 变量以在将来显示有用的错误。<a href="https://github.com/moby/moby/pull/37439">moby/moby＃37439</a></li><li>  <code>--data-path-addr</code>连接到不支持此选项的守护程序时隐藏标记 <a href="https://github.com/docker/cli/pull/1240">docker / docker / cli＃1240</a></li><li>  如果启用了 BuildKit，则仅显示特定于 buildkit 的标志 docker <a href="https://github.com/docker/cli/pull/1438">/ cli＃1438</a> / docker <a href="https://github.com/docker/cli/pull/1427">/ cli＃1427</a></li><li>  改进了版本输出对齐方式 <a href="https://github.com/docker/cli/pull/1204">docker / cli＃1204</a></li><li>  按自然顺序对插件名称和网络进行排序 <a href="https://github.com/docker/cli/pull/1166">docker / cli＃1166</a>，<a href="https://github.com/docker/cli/pull/1266">docker / cli＃1266</a></li><li>  更新 bash 和 zsh <a href="https://github.com/docker/cli/issues?q=label:area/completion+milestone:18.09.0+is:closed">完成脚本</a></li><li>  将日志级别传递到容器。<a href="https://github.com/moby/moby/pull/37419">moby/moby＃37419</a></li><li>  在东西覆盖负载使用直接服务器返回（DSR）平衡 <a href="https://github.com/docker/engine/pull/93">docker / 发动机＃93</a> / <a href="https://github.com/docker/libnetwork/pull/2270">docker/ libnetwork＃2270</a></li><li>  Builder：使用 buildkit 时暂时禁用桥接网络。<a href="https://github.com/moby/moby/pull/37691">moby/moby＃37691</a></li><li>  阻止任务开始直到节点附件准备就绪 <a href="https://github.com/moby/moby/pull/37604">Moby / Moby＃37604</a></li><li>  将提供的外部 CA 证书传播到 swarm 中的外部 CA 对象。<a href="https://github.com/docker/cli/pull/1178">docker/ cli＃1178</a></li><li>  移除 Ubuntu 14.04“Trusty Tahr” 作为受支持的平台 <a href="https://github.com/docker/docker-ce-packaging/pull/255">docker-ce-packaging＃255</a> / <a href="https://github.com/docker/docker-ce-packaging/pull/254">docker-ce-packaging＃254</a></li><li>  删除 Debian 8“Jessie” 作为受支持的平台 <a href="https://github.com/docker/docker-ce-packaging/pull/255">docker-ce-packaging＃255</a> / <a href="https://github.com/docker/docker-ce-packaging/pull/254">docker-ce-packaging＃254</a></li><li>  删除容器和 Runc 二进制文件 docker <a href="https://github.com/docker/engine/pull/61">/ engine＃61</a> / <a href="https://github.com/moby/moby/pull/37907">moby / moby＃37907</a>，<a href="https://github.com/moby/moby/pull/37907">docker</a> <a href="https://github.com/docker/docker-ce-packaging/pull/241">-ce-packaging＃241 的</a> ‘docker-‘前缀</li><li>  将 “engine”，“ cli” 和“ containerd”拆分为单独的程序包，并作为单独的系统服务容器运行 <a href="https://github.com/docker/docker-ce-packaging/pull/131">docker-ce-packaging＃131</a>，<a href="https://github.com/docker/docker-ce-packaging/pull/158">docker-ce-packaging＃158</a></li><li>  升级 Go 到 1.10.4 <a href="https://github.com/docker/docker-ce-packaging/pull/181">docker-ce-packaging#181</a></li><li>  <code>-ce</code>从版本字符串删除后缀 <a href="https://github.com/docker/docker-ce-packaging/pull/206">docker-ce-packaging＃206</a></li></ul><h4 id="安全修复部分"><a href="#安全修复部分" class="headerlink" title="安全修复部分"></a>安全修复部分</h4><ul><li>更新<code>runc</code>以解决一个严重漏洞，该漏洞使特制容器可以在主机上获得管理特权。[](<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?&gt;CVE-2019-5736">https://cve.mitre.org/cgi-bin/cvename.cgi?&gt;CVE-2019-5736</a></a></li><li> 使用 3.13 内核的 Ubuntu 14.04 客户将需要升级到受支持的 Ubuntu 4.x 内核</li></ul><p></p>&lt;h4 id=)新功能<ul><li>  API 版本更新为 1.39 <a href="https://github.com/moby/moby/pull/37640">Moby / moby＃37640</a></li><li>  添加了对使用 SSH 远程连接的支持 <a href="https://github.com/docker/cli/pull/1014">docker / cli＃1014</a></li><li>  Builder：向 API 添加了修剪选项 <a href="https://github.com/moby/moby/pull/37651">Moby / moby＃37651</a></li><li>  向<code>/info</code>端点添加了 “警告” ，并将检测移动到守护程序 <a href="https://github.com/moby/moby/pull/37502">moby / moby＃37502</a></li><li>  允许 BuildKit 构建在未启用实验模式的情况下运行。现在可以使用 daemon.json 中的选项配置 Buildkit.json <a href="https://github.com/moby/moby/pull/37593">moby / moby＃37593</a> <a href="https://github.com/moby/moby/pull/37686">moby / moby＃37686</a> <a href="https://github.com/moby/moby/pull/37692">moby / moby＃37692</a> <a href="https://github.com/moby/moby/pull/37686">docker</a> <a href="https://github.com/docker/cli/pull/1303">/ cli＃1303</a> <a href="https://github.com/docker/cli/pull/1275">docker / cli＃1275</a></li><li>  添加了对<code>--secret</code>使用 BuildKit 时使用标志的构建时机密的支持 <a href="https://github.com/docker/cli/pull/1288">docker/ cli＃1288</a></li><li>  <code>docker build --ssh $SSHMOUNTID=$SSH_AUTH_SOCK</code>使用 BuildKit [ 时添加了 SSH 代理套接字转发器（） <a href="https://github.com/docker/cli/pull/1438">docker/cli#1438</a> / <a href="https://github.com/docker/cli/pull/1419">docker/cli#1419</a></li><li>  在 Windows 上添加了对<code>--chown</code>标志<code>ADD</code>和<code>COPY</code>命令的标志支持<a href="https://github.com/moby/moby/pull/35521">＃35521</a></li><li>  <code>builder prune</code>向修剪 BuildKit 构建缓存添加了子命令 <a href="https://github.com/docker/cli/pull/1295">docker/cli#1295</a> <a href="https://github.com/docker/cli/pull/1334">docker/cli#1334</a></li><li>  BuildKit：为 BuildKit 构建缓存添加可配置的垃圾收集策略 <a href="https://github.com/docker/engine/pull/59">docker/engine#59</a> / <a href="https://github.com/moby/moby/pull/37846">moby/moby#37846</a></li><li>  BuildKit：添加了对<code>docker build --pull ...</code>使用 BuildKit 的支持 <a href="https://github.com/moby/moby/pull/37613">moby / moby＃37613</a></li><li>  BuildKit：使用 BuildKit 时添加支持或 “注册表镜像” 和“不安全注册表” <a href="https://github.com/docker/engine/pull/59">docker/engine#59</a> / <a href="https://github.com/moby/moby/pull/37852">moby/moby#37852</a></li><li>  BuildKit：启用网络模式和桥接。<a href="https://github.com/moby/moby/pull/37620">moby/moby＃37620</a></li><li>  添加了<code>docker engine</code>子命令来管理作为特权容器在容器之上运行的 Docker Engine 的生命周期，并允许升级到 Docker Engine Enterprise <a href="https://github.com/docker/cli/pull/1260">docker / cli＃1260</a></li><li>  <code>docker info</code>输出已公开产品许可证 <a href="https://github.com/docker/cli/pull/1313">docker / cli＃1313</a></li><li>  显示守护程序在<code>docker info</code>输出产生的警告 <a href="https://github.com/docker/cli/pull/1225">docker / cli＃1225</a></li><li>  添加了 “本地” 日志驱动程序 <a href="https://github.com/moby/moby/pull/37092">moby / moby＃37092</a></li><li>  Amazon CloudWatch：添加<code>awslogs-endpoint</code>日志记录选项 <a href="https://github.com/moby/moby/pull/37374">moby / moby＃37374</a></li><li>  添加了对全局默认地址池的支持 <a href="https://github.com/moby/moby/pull/37558">moby / moby＃37558 docker</a> <a href="https://github.com/docker/cli/pull/1233">/ cli＃1233</a></li><li>  配置的容器化日志级别与 dockerd 相同 <a href="https://github.com/moby/moby/pull/37419">moby / moby＃37419</a></li><li>  为 cri-containerd <a href="https://github.com/moby/moby/pull/37519">moby / moby</a> 添加了配置选项<a href="https://github.com/moby/moby/pull/37519">＃37519</a></li><li>  将容器化的客户端更新为 v1.2.0-rc.1 <a href="https://github.com/moby/moby/pull/37664">moby / moby＃37664</a>，<a href="https://github.com/moby/moby/pull/37664">docker</a> <a href="https://github.com/docker/engine/pull/75">/ engine＃75</a> / <a href="https://github.com/moby/moby/pull/37710">moby / moby＃37710</a></li><li>  添加了对全局默认地址池的支持 <a href="https://github.com/moby/moby/pull/37558">moby / moby＃37558 docker</a> <a href="https://github.com/docker/cli/pull/1233">/ cli＃1233</a></li><li>  将<code>POST /session</code>端点移出实验。<a href="https://github.com/moby/moby/pull/40028">moby/moby＃40028</a></li></ul><h4 id="弃用-1"><a href="#弃用-1" class="headerlink" title="弃用"></a>弃用</h4>  Docker 已弃用对 Device Mapper 作为存储驱动程序的支持。目前将继续支持它，但是在将来的版本中将删除该支持。<h4 id="终止服务"><a href="#终止服务" class="headerlink" title="终止服务"></a>终止服务</h4>  在此版本中，Docker 还删除了对 TLS &lt;1.2 <a href="https://github.com/moby/moby/pull/37660">moby / moby＃37660</a>，Ubuntu 14.04“ Trusty <a href="https://github.com/moby/moby/pull/37660">Tahr</a> ” <a href="https://github.com/moby/moby/pull/37660">docker</a> <a href="https://github.com/docker/docker-ce-packaging/pull/255">-ce-packaging＃255</a> / <a href="https://github.com/docker/docker-ce-packaging/pull/254">docker-ce-packaging＃254</a> 和 Debian 8“Jessie” <a href="https://github.com/docker/docker-ce-packaging/pull/255">docker-ce 的支持。 -packaging＃255</a> / <a href="https://github.com/docker/docker-ce-packaging/pull/255">docker</a> <a href="https://github.com/docker/docker-ce-packaging/pull/254">-ce-packaging＃254</a>。<h3 id="版本号：18-06"><a href="#版本号：18-06" class="headerlink" title="版本号：18.06"></a>版本号：18.06</h3>  首次发布时间： 2018-07-18<h4 id="Docker-Engine-的安全修复程序"><a href="#Docker-Engine-的安全修复程序" class="headerlink" title="Docker Engine 的安全修复程序"></a>Docker Engine 的安全修复程序</h4><ul><li>更改<code>runc</code>关键漏洞补丁的应用方式，以将修补程序包括在 RPM 软件包中。 <a href="https://github.com/docker/engine/pull/156">docker/engine#156</a></li><li>更新<code>runc</code>以解决一个严重漏洞，该漏洞使特制容器可以在主机上获得管理特权。[](<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?&gt;CVE-2019-5736">https://cve.mitre.org/cgi-bin/cvename.cgi?&gt;CVE-2019-5736</a></a></p> </li><li> <p>使用 3.13 内核的 Ubuntu 14.04 客户将需要升级到受支持的 Ubuntu 4.x 内核</p> </li></ul><p></p>&lt;h4 id=)构造相关<ul><li>  如果在 docker build 期间缺少 build args，则不会修复任何错误。<a href="https://github.com/docker/engine/pull/25">docker/engine＃25</a></li><li>  设置 BuildKit 的 ExportedProduct 变量以显示有用的错误。<a href="https://github.com/docker/engine/pull/21">docker/engine＃21</a></li><li>  Builder：修复多级通配符副本上的图层泄漏。<a href="https://github.com/moby/moby/pull/37178">moby/moby＃37178</a></li><li>  修复了无效环境变量替换的解析。<a href="https://github.com/moby/moby/pull/37134">moby/moby＃37134</a></li><li>  生成器：使用基础镜像中的拱门信息。<a href="https://github.com/moby/moby/pull/37197">moby/moby</a><a href="https://github.com/moby/moby/pull/36816">＃36816</a> <a href="https://github.com/moby/moby/pull/37197">moby/moby＃37197</a></li><li>  基于 <a href="https://github.com/moby/buildkit">BuildKit 的</a>新的实验生成器后端。要启用，请在实验模式下运行守护程序，然后<code>DOCKER_BUILDKIT=1</code>在 Docker CLI 上设置环境变量。<a href="https://github.com/moby/moby/pull/37151">moby / moby＃37151</a> <a href="https://github.com/docker/cli/pull/1111">docker / cli＃1111</a></li><li>  修复了在多阶段构建中处理大写目标名称的问题。<a href="https://github.com/moby/moby/pull/36960">moby/moby＃36960</a></li></ul><h4 id="客户端相关-2"><a href="#客户端相关-2" class="headerlink" title="客户端相关"></a>客户端相关</h4><ul><li>  各种 Shell 完成脚本更新：<a href="https://github.com/docker/cli/pull/1229">docker / cli＃1229</a>， <a href="https://github.com/docker/cli/pull/1268">docker / cli＃1268</a> 和 <a href="https://github.com/docker/cli/pull/1272">docker / cli＃1272</a></li><li>  修复<code>DOCKER_CONFIG</code>警告消息和后备搜索。<a href="https://github.com/docker/cli/pull/1241">docker/ cli＃1241</a></li><li>  修复<code>docker stack</code>命令和子命令上的帮助消息标志。<a href="https://github.com/docker/cli/pull/1267">docker/ cli＃1267</a></li></ul><h4 id="运行相关-2"><a href="#运行相关-2" class="headerlink" title="运行相关"></a>运行相关</h4><ul><li>默认情况下，禁用在端口 10010 上侦听的 CRI 插件。<a href="https://github.com/docker/engine/pull/29">docker/engine＃29</a></li><li>将容器更新到 v1.1.2。<a href="https://github.com/docker/engine/pull/33">docker/engine＃33</a></li><li>Windows：如果终止调用，则不要调用 HCS 关闭。<a href="https://github.com/docker/engine/pull/31">docker/engine＃31</a></li><li>Windows：为 Windows 日志监视程序选择基于轮询的监视程序。<a href="https://github.com/docker/engine/pull/34">docker/engine＃34</a></li><li>将 spf13 / cobra 碰撞到 v0.0.3，将 pflag 碰撞到 v1.0.1。<a href="https://github.com/moby/moby/pull/37106">moby/moby＃37106</a></li><li>添加对新的 Kubernetes v1beta2 堆栈 API 的支持。<a href="https://github.com/docker/cli/pull/899">docker/ cli＃899</a></li><li>K8s：部署时更强大的堆栈错误检测。<a href="https://github.com/docker/cli/pull/948">docker/ cli＃948</a></li><li>在 compose 3.7 中支持回滚配置。<a href="https://github.com/docker/cli/pull/409">docker/ cli＃409</a></li><li>更新 Cobra 和 pflag，并使用内置的–version 功能。<a href="https://github.com/docker/cli/pull/1069">docker/ cli＃1069</a></li><li><code>docker stack deploy --prune</code>使用空名称修复，删除所有服务。<a href="https://github.com/docker/cli/pull/1088">docker/ cli＃1088</a></li><li>[Kubernetes] 堆栈服务过滤器。<a href="https://github.com/docker/cli/pull/1023">docker/ cli＃1023</a></li><li>仅在帮助中的 root，stack 和 version 命令中显示 orchestrator 标志。<a href="https://github.com/docker/cli/pull/1106">docker/ cli＃1106</a></li><li><code>Extras</code>在撰写配置类型上添加一个字段。<a href="https://github.com/docker/cli/pull/1126">docker/ cli＃1126</a></li><li>将选项添加到 compose loader。<a href="https://github.com/docker/cli/pull/1128">docker/ cli＃1128</a></li><li>修复始终在 Kubernetes 上的 docker stack ps 命令中列出节点的问题。<a href="https://github.com/docker/cli/pull/1093">docker/ cli＃1093</a></li><li>修复在堆栈 rm 错误消息中两次显示输出的问题。<a href="https://github.com/docker/cli/pull/1093">docker/ cli＃1093</a></li><li>使用自定义 HTTP 请求扩展客户端 API。<a href="https://github.com/moby/moby/pull/37071">moby/moby＃37071</a></li><li>更改了针对不可读文件的错误消息，以阐明. Dockerignore 条目的可能性。<a href="https://github.com/docker/cli/pull/1053">docker/ cli＃1053</a></li><li>在配置文件中将 kubernetes.allNamespaces 值限制为 “enabled” 或“ disabled”。<a href="https://github.com/docker/cli/pull/1087">docker/ cli＃1087</a></li><li>在 help 命令中初始化 Docker 客户端时检查错误。<a href="https://github.com/docker/cli/pull/1119">docker/ cli＃1119</a></li><li>Kubernetes 更好的命名空间体验。使用〜/ .kube / config 中定义的名称空间来解决堆栈命令。为 docker stack ls 命令添加一个 NAMESPACE 列。为 docker stack ls 命令添加–all-namespaces 标志。<a href="https://github.com/docker/cli/pull/991">docker/ cli＃991</a></li><li>导出推送并保存。<a href="https://github.com/docker/cli/pull/1123">docker/ cli＃1123</a></li><li>导出拉为公共功能。<a href="https://github.com/docker/cli/pull/1026">docker/ cli＃1026</a></li><li>从实验性删除 Kubernetes 命令。<a href="https://github.com/docker/cli/pull/1068">docker/ cli＃1068</a></li><li>添加配置 / 秘密服务检查漂亮。<a href="https://github.com/docker/cli/pull/1006">docker/ cli＃1006</a></li><li>在 Kubernetes 上按名称修复服务过滤。<a href="https://github.com/docker/cli/pull/1101">docker/ cli＃1101</a></li><li>修复中的组件信息对齐<code>docker version</code>。<a href="https://github.com/docker/cli/pull/1065">docker/ cli＃1065</a></li><li>修复 cpu / 内存限制和保留在服务更新时重置。<a href="https://github.com/docker/cli/pull/1079">docker/ cli＃1079</a></li><li>清单清单：请求特定的权限。<a href="https://github.com/docker/cli/pull/1024">docker/ cli＃1024</a></li><li>设置–orchestrator = all 还会设置–all-namespaces，除非设置了特定的–namespace。<a href="https://github.com/docker/cli/pull/1059">docker/ cli＃1059</a></li><li>一起使用–compress 和–stream 时，可以解决紧急情况。<a href="https://github.com/docker/cli/pull/1105">docker/ cli＃1105</a></li><li>从 x / net / context 切换到上下文。<a href="https://github.com/docker/cli/pull/1038">docker/ cli＃1038</a></li><li>将–init 选项添加到中<code>docker service create</code>。<a href="https://github.com/docker/cli/pull/479">docker/ cli＃479</a></li><li>修复了合并–stream 和–quiet 标志时显示生成构建命令的垃圾输出的错误。<a href="https://github.com/docker/cli/pull/1090">docker/ cli＃1090</a></li><li><code>init</code>在 3.7 模式中添加支持。<a href="https://github.com/docker/cli/pull/1129">docker/ cli＃1129</a></li><li>修复 Docker 信任签名者删除。<a href="https://github.com/docker/cli/pull/1112">docker/ cli＃1112</a></li><li>修复来自 docker inspect 的错误消息 <a href="https://github.com/docker/cli/pull/1071">docker/ cli＃1071</a></li><li>允许<code>x-*</code>在第 3 级对象上扩展。<a href="https://github.com/docker/cli/pull/1097">docker/ cli＃1097</a></li><li>无效的协调器现在会生成错误，而不是被静默忽略。<a href="https://github.com/docker/cli/pull/1055">docker/ cli＃1055</a></li><li>在 docker stack ls 命令中添加了 ORCHESTRATOR 列。<a href="https://github.com/docker/cli/pull/973">docker/ cli＃973</a></li><li>在将 host-ip 用于已发布的服务端口时发出警告。<a href="https://github.com/docker/cli/pull/1017">docker/ cli＃1017</a></li><li>添加了通过<code>DOCKER_CLI_EXPERIMENTAL</code>环境变量启用实验性 cli 功能的选项。<a href="https://github.com/docker/cli/pull/1138">docker/ cli＃1138</a></li><li>将 exec_die 添加到已知容器事件的列表中。<a href="https://github.com/docker/cli/pull/1028">docker/ cli＃1028</a></li><li>[K8s] 对未解释的 Config 文件进行环境变量扩展。<a href="https://github.com/docker/cli/pull/974">docker/ cli＃974</a></li><li>在解析组成文件以在 Kubernetes 上部署时，在 stderr 上为每个不支持的功能打印警告。<a href="https://github.com/docker/cli/pull/903">docker/ cli＃903</a></li><li>添加了有关 pids 计数的描述。<a href="https://github.com/docker/cli/pull/1045">docker/ cli＃1045</a></li><li>修剪时警告用户使用过滤器。<a href="https://github.com/docker/cli/pull/1043">docker/ cli＃1043</a></li><li>修复<code>--rollback-*</code>选项覆盖<code>--update-*</code>选项。<a href="https://github.com/docker/cli/pull/1052">docker/ cli＃1052</a></li><li>更新附加，生成，提交，Cp，创建子命令鱼补全。<a href="https://github.com/docker/cli/pull/1005">docker/ cli＃1005</a></li><li>为添加 bash 完成<code>dockerd --default-address-pool</code>。<a href="https://github.com/docker/cli/pull/1173">docker/ cli＃1173</a></li><li>为<code>exec_die</code>事件添加 bash 完成。<a href="https://github.com/docker/cli/pull/1173">docker/ cli＃1173</a></li><li>更新 docker-credential-helper，因此<code>pass</code>不会在每个 docker 命令上都调用它。<a href="https://github.com/docker/cli/pull/1184">docker/ cli＃1184</a></li><li>修复了旋转群集外部 CA 的问题。<a href="https://github.com/docker/cli/pull/1199">docker/ cli＃1199</a></li><li>改进版本输出对齐方式。<a href="https://github.com/docker/cli/pull/1207">docker/ cli＃1207</a></li><li>为添加 bash 完成<code>service create|update --init</code>。<a href="https://github.com/docker/cli/pull/1210">docker/ cli＃1210</a></li><li>Aufs：记录为什么不支持 aufs。<a href="https://github.com/moby/moby/pull/36995">moby/moby＃36995</a></li><li>在 Windows 上隐藏实验性检查点功能。<a href="https://github.com/docker/cli/pull/1094">docker/ cli＃1094</a></li><li>Lcow：允许客户端为 LCOW 容器自定义功能和设备 cgroup 规则。<a href="https://github.com/moby/moby/pull/37294">moby/moby＃37294</a></li><li>将 Windows 中可执行输出的给定路径更改为可执行输出的实际位置。<a href="https://github.com/moby/moby/pull/37295">moby/moby＃37295</a></li><li>添加 Windows 回收站测试并将 hcsshim 更新到 v0.6.11。<a href="https://github.com/moby/moby/pull/36994">moby/moby＃36994</a></li><li>进行运行时允许添加任何参数。<a href="https://github.com/moby/moby/pull/37190">moby/moby＃37190</a></li><li>优化 ContainerTop（）又名 docker top。<a href="https://github.com/moby/moby/pull/37131">moby/moby＃37131</a></li><li>在 32 位计算机上修复编译。<a href="https://github.com/moby/moby/pull/37292">moby/moby＃37292</a></li><li>将 API 版本更新为 <a href="https://github.com/moby/moby/pull/37141">v138。moby / moby＃37141</a></li><li>修复<code>docker service update --host-add</code>不会更新现有的主机条目。<a href="https://github.com/docker/cli/pull/1054">docker/ cli＃1054</a></li><li>修复 ExecIds 的大头贴文件类型。<a href="https://github.com/moby/moby/pull/36962">moby/moby＃36962</a></li><li>修正了摇摇卷类型的生成。<a href="https://github.com/moby/moby/pull/37060">moby/moby＃37060</a></li><li>修复卷 / 服务包中的错误声明。<a href="https://github.com/moby/moby/pull/37211">moby/moby＃37211</a></li><li>当插件运行时，重新启动时修复守护进程紧急情况。<a href="https://github.com/moby/moby/pull/37234">moby/moby＃37234</a></li><li>从 “标签” 选项构建 “ LABEL” 命令并将其添加到最后阶段。<a href="https://github.com/moby/moby/pull/37011">moby/moby＃37011</a></li><li>修复执行启动和调整大小之间的竞争条件<a href="https://github.com/moby/moby/pull/37172">。.moby / moby＃37172</a></li><li>替代故障缓解<code>TestExecInteractiveStdinClose</code>。<a href="https://github.com/moby/moby/pull/37143">moby/moby＃37143</a></li><li>RawAccess 允许将一组路径设置为未屏蔽或只读。<a href="https://github.com/moby/moby/pull/36644">moby/moby＃36644</a></li><li>明确说明 github.com 前缀是一项旧功能。<a href="https://github.com/moby/moby/pull/37174">moby/moby＃37174</a></li><li>将 Golang 升至 1.10.3。<a href="https://github.com/docker/cli/pull/1122">docker/ cli＃1122</a></li><li>关闭 ReadClosers 以防止 xz 僵尸。<a href="https://github.com/moby/moby/pull/34218">moby/moby＃34218</a></li><li>Daemon.ContainerStop（）：修复了超时错误。<a href="https://github.com/moby/moby/pull/36874">moby/moby＃36874</a></li><li>Daemon.setMounts（）：复制切片。<a href="https://github.com/moby/moby/pull/36991">moby/moby＃36991</a></li><li>描述大方端口定义的 IP 字段。<a href="https://github.com/moby/moby/pull/36971">moby/moby＃36971</a></li><li>将卷交互提取到卷服务。<a href="https://github.com/moby/moby/pull/36688">moby/moby＃36688</a></li><li>修复了 docker image v1，v1.1 和 v1.2 规范中的 markdown 格式。<a href="https://github.com/moby/moby/pull/37051">moby/moby＃37051</a></li><li>改进 GetTimestamp 解析。<a href="https://github.com/moby/moby/pull/35402">moby/moby＃35402</a></li><li>Jsonmessage：将消息传递给 aux 回调。<a href="https://github.com/moby/moby/pull/37064">moby/moby＃37064</a></li><li>覆盖 2：删除未使用的 cdMountFrom（）帮助函数。<a href="https://github.com/moby/moby/pull/37041">moby/moby＃37041</a></li><li>覆盖：修复覆盖存储驱动程序，而忽略了未知的存储驱动程序选项。<a href="https://github.com/moby/moby/pull/37040">moby/moby＃37040</a></li><li>删除一些未使用的贡献项目。<a href="https://github.com/moby/moby/pull/36977">moby/moby＃36977</a></li><li>Restartmanager：不要对创建的容器应用重启策略。<a href="https://github.com/moby/moby/pull/36924">moby/moby＃36924</a></li><li>设置 ExecID 的项目类型。<a href="https://github.com/moby/moby/pull/37121">moby/moby＃37121</a></li><li>在 Linux 版本的 dockerd 中使用 go-systemd const 代替魔术字符串。<a href="https://github.com/moby/moby/pull/37136">moby/moby＃37136</a></li><li>使用 stdlib TLS 拨号程序。<a href="https://github.com/moby/moby/pull/36687">moby/moby＃36687</a></li><li>根据 <a href="https://docs.docker.com/config/labels-custom">https://docs.docker.com/config/labels-custom</a> - 配置使用保留名称空间（com.docker。*，io.docker。_或 org.dockerproject。_）的 engine 标签时发出警告。元数据 /。<a href="https://github.com/moby/moby/pull/36921">moby/moby＃36921</a></li><li>修复消息中缺少的插件名称。<a href="https://github.com/moby/moby/pull/37052">moby/moby＃37052</a></li><li>修复 CONTRIBUTING.md 中的链接锚点。<a href="https://github.com/moby/moby/pull/37276">moby/moby＃37276</a></li><li>修复到 Docker Toolbox 的链接。<a href="https://github.com/moby/moby/pull/37240">moby/moby＃37240</a></li><li>修复误用的跳过条件。<a href="https://github.com/moby/moby/pull/37179">moby/moby＃37179</a></li><li>修复绑定挂载在某些情况下不起作用。<a href="https://github.com/moby/moby/pull/37031">moby/moby＃37031</a></li><li>修复 fd 泄漏。<a href="https://github.com/moby/moby/pull/37184">moby/moby＃37184</a></li><li>修复流利的局部检测。<a href="https://github.com/moby/moby/pull/37029">moby/moby＃37029</a></li><li>修复 version-history.md 中的错误链接。<a href="https://github.com/moby/moby/pull/37049">moby/moby＃37049</a></li><li>允许 vim 对 dockerfile 中的 D 不区分大小写。<a href="https://github.com/moby/moby/pull/37235">moby/moby＃37235</a></li><li>添加<code>t.Name()</code>到测试中，以便服务名称是唯一的。<a href="https://github.com/moby/moby/pull/37166">moby/moby＃37166</a></li><li>如果 backendfs 是没有 d_type 支持的 extfs，则添加其他消息。<a href="https://github.com/moby/moby/pull/37022">moby/moby＃37022</a></li><li>添加 api 版本检查以检查新功能中的测试。<a href="https://github.com/moby/moby/pull/37169">moby/moby＃37169</a></li><li>添加用于推拉的镜像指标。<a href="https://github.com/moby/moby/pull/37233">moby/moby＃37233</a></li><li>添加<code>init</code>对服务的支持。<a href="https://github.com/moby/moby/pull/37183">moby/moby＃37183</a></li><li>在 pkg / term / proxy.go 中添加转义键数组长度的验证。<a href="https://github.com/moby/moby/pull/36918">moby/moby＃36918</a></li><li>当 overlay2 的链接 ID 为空时，请勿删除此链接<a href="https://github.com/moby/moby/pull/36161">。.moby / moby＃36161</a></li><li>通过定义 Self（）修复在 OpenBSD 上的构建。<a href="https://github.com/moby/moby/pull/37301">moby/moby＃37301</a></li><li>Windows：修复了对 Hyper-v 隔离容器的命名管道支持。<a href="https://github.com/docker/engine/pull/2">docker/engine＃2</a> <a href="https://github.com/docker/cli/pull/1165">docker/ cli＃1165</a></li><li>修正清单清单，以始终使用正确的大小。<a href="https://github.com/docker/cli/pull/1183">docker/ cli＃1183</a></li><li>注册 OCI 媒体类型。<a href="https://github.com/docker/engine/pull/4">docker/engine＃4</a></li><li>将容器更新到 v1.1.1 <a href="https://github.com/docker/engine/pull/17">docker / engine＃17</a></li><li>LCOW：在清单列表中，Windows 优先于 Linux。<a href="https://github.com/docker/engine/pull/3">docker/engine＃3</a></li><li><code>MaskPaths</code>直接使用容器添加添加代码路径中使用的更新以解决 [docker/engine＃15](<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?&gt;CVE-2018-10892">https://cve.mitre.org/cgi-bin/cvename.cgi?&gt;CVE-2018-10892</a></a>。&lt;a href=)</li><li>添加<code>/proc/acpi</code>到掩码路径以解决 [docker/engine＃14](<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?&gt;CVE-2018-10892">https://cve.mitre.org/cgi-bin/cvename.cgi?&gt;CVE-2018-10892</a></a>。&lt;a href=)</li><li>  修复 bindmount 自动创建种族。<a href="https://github.com/docker/engine/pull/11">docker/engine＃11</a></li></ul><h4 id="日志相关-2"><a href="#日志相关-2" class="headerlink" title="日志相关"></a>日志相关</h4><ul><li>  允许 awslogs 使用非阻塞模式。<a href="https://github.com/moby/moby/pull/36522">moby / moby＃36522</a></li><li>  改善流利的日志驱动程序上长日志行的记录。.moby <a href="https://github.com/moby/moby/pull/36159">/ moby＃36159</a></li><li>  重新排序 CHANGELOG.md 以通过<code>make validate</code>测试。<a href="https://github.com/moby/moby/pull/37047">moby/moby＃37047</a></li><li>  更新事件，执行，导出，历史记录，镜像，导入，检查，加载和登录子命令鱼的完成。<a href="https://github.com/docker/cli/pull/1061">docker/ cli＃1061</a></li><li>  更新 RingLogger 环形缓冲区的文档。<a href="https://github.com/moby/moby/pull/37084">moby/moby＃37084</a></li><li>  添加日志失败 / 部分的指标。<a href="https://github.com/moby/moby/pull/37034">moby/moby＃37034</a></li><li>  修复日志记录插件崩溃无法恢复的问题。<a href="https://github.com/moby/moby/pull/37028">moby/moby＃37028</a></li><li>  修复日志记录测试类型。<a href="https://github.com/moby/moby/pull/37070">moby/moby＃37070</a></li><li>  修复日志 API 中的竞争条件。<a href="https://github.com/moby/moby/pull/37062">moby/moby＃37062</a></li><li>  修复了日志文件阅读器和轮换中的一些问题。<a href="https://github.com/moby/moby/pull/37063">moby/moby＃37063</a></li></ul><h4 id="弃用-2"><a href="#弃用-2" class="headerlink" title="弃用"></a>弃用</h4><ul><li>  文档保留的名称空间已弃用。<a href="https://github.com/docker/cli/pull/1040">docker/ cli＃1040</a></li></ul><h4 id="网络相关-2"><a href="#网络相关-2" class="headerlink" title="网络相关"></a>网络相关</h4><ul><li>  允许用户为 Docker 网络指定默认地址池。<a href="https://github.com/moby/moby/pull/36396">moby / moby＃36396 docker</a> <a href="https://github.com/docker/cli/pull/818">/ cli＃818</a></li><li>  为 ipam state <a href="https://github.com/docker/libnetwork/pull/2147">doccker / libnetwork＃2417</a> 添加日志</li><li>  修复覆盖网络驱动程序 <a href="https://github.com/docker/libnetwork/pull/2143">doccker / libnetwork＃2143</a> 中的竞争条件</li><li>  将等待时间添加到 <a href="https://github.com/docker/libnetwork/pull/2142">xtables</a> 锁定警告 <a href="https://github.com/docker/libnetwork/pull/2142">doccker / libnetwork＃2142</a></li><li>  当 firewalld 处于活动状态时过滤 <a href="https://github.com/docker/libnetwork/pull/2135">xtables</a> 锁定警告 <a href="https://github.com/docker/libnetwork/pull/2135">doccker / libnetwork＃2135</a></li><li>  从 x / net / context 切换到 context <a href="https://github.com/docker/libnetwork/pull/2140">doccker / libnetwork＃2140</a></li><li>  为拆分的八卦群集 <a href="https://github.com/docker/libnetwork/pull/2134">doccker / libnetwork＃2134</a> 添加恢复机制</li><li>  现在，对网络附件任务运行 docker inspect 会返回完整的任务对象。<a href="https://github.com/moby/moby/pull/35246">moby/moby＃35246</a></li><li>  一些容器 / 网络清理。<a href="https://github.com/moby/moby/pull/37033">moby/moby＃37033</a></li><li>  修复网络检查覆盖网络。<a href="https://github.com/moby/moby/pull/37045">moby/moby＃37045</a></li><li>  提高 Linux 负载平衡的可伸缩性。<a href="https://github.com/docker/engine/pull/16">docker/engine＃16</a></li><li>  将日志级别从错误更改为警告。<a href="https://github.com/docker/engine/pull/19">docker/engine＃19</a></li></ul><h4 id="集群相关-2"><a href="#集群相关-2" class="headerlink" title="集群相关"></a>集群相关</h4><ul><li>  修复用于跳过正在运行的任务的条件。<a href="https://github.com/docker/swarmkit/pull/2677">docker/ swarmkit＃2677</a></li><li>  修复任务排序。<a href="https://github.com/docker/swarmkit/pull/2712">docker/ swarmkit＃2712</a></li><li>  在 docker stack ls 中使用–orchestrator = all 列出 Swarm 和 Kubernetes 的堆栈。使用 docker stack ls 允许 Kubernetes 多次出现–namespace。<a href="https://github.com/docker/cli/pull/1031">docker/ cli＃1031</a></li><li>  Bump SwarmKit 删除不推荐使用的 grpc 元数据包装器。<a href="https://github.com/moby/moby/pull/36905">moby/moby＃36905</a></li><li>  在不匹配的 Swarm 和 Kubernetes 主机上工作时，为–orchestrator = all 发出错误。<a href="https://github.com/docker/cli/pull/1035">docker/ cli＃1035</a></li><li>  使用定义为 Orchestrator 的 Kubernetes 修复损坏的 swarm 命令。“–orchestrator” 标志不再是全局的，而是位于堆栈命令和子命令的本地 docker <a href="https://github.com/docker/cli/pull/1137">/ cli＃1137</a> <a href="https://github.com/docker/cli/pull/1139">docker / cli＃1139</a></li><li>  Bump swarmkit 包含任务收割者修复程序和更多指标。<a href="https://github.com/docker/engine/pull/13">docker/engine＃13</a></li><li>  删除具有未分配任务的服务时，避免泄漏。<a href="https://github.com/docker/engine/pull/27">docker/engine＃27</a></li><li>  在分派器上修复批量批处理。<a href="https://github.com/docker/engine/pull/27">docker/engine＃27</a></li></ul><h3 id="版本号：18-05"><a href="#版本号：18-05" class="headerlink" title="版本号：18.05"></a>版本号：18.05</h3>  首次发布时间： 2018-05-09<h4 id="构造相关-2"><a href="#构造相关-2" class="headerlink" title="构造相关"></a>构造相关</h4><ul><li>  添加<code>netbsd</code>兼容性的包<code>pkg/term</code>。<a href="https://github.com/moby/moby/pull/36887">moby/moby＃36887</a></li><li>  标准化中间版本到的内部工件的输出路径<code>/build/</code>。<a href="https://github.com/moby/moby/pull/36858">moby/moby＃36858</a></li></ul><h4 id="客户端相关-3"><a href="#客户端相关-3" class="headerlink" title="客户端相关"></a>客户端相关</h4><ul><li>  修复<code>docker stack deploy</code>参考标记。<a href="https://github.com/docker/cli/pull/981">docker/ cli＃981</a></li><li>  修复 docker stack 在服务更新为后部署重新部署服务<code>--force</code>。<a href="https://github.com/docker/cli/pull/963">docker/ cli＃963</a></li><li>  为添加 bash 完成<code>secret|config create --template-driver</code>。<a href="https://github.com/docker/cli/pull/1004">docker/ cli＃1004</a></li><li>  为 docker trust 子命令添加与补全。<a href="https://github.com/docker/cli/pull/984">docker/ cli＃984</a></li><li>  修复 docker 历史记录的–format 示例。<a href="https://github.com/docker/cli/pull/980">docker/ cli＃980</a></li><li>  使用网络合并 composefile 修复错误。<a href="https://github.com/docker/cli/pull/983">docker/ cli＃983</a></li></ul><h4 id="日志相关-3"><a href="#日志相关-3" class="headerlink" title="日志相关"></a>日志相关</h4><ul><li>  标准化了存储驱动程序日志消息的属性。<a href="https://github.com/moby/moby/pull/36492">moby/moby＃36492</a></li><li>  改进记录器中的部分消息支持。<a href="https://github.com/moby/moby/pull/35831">moby/moby＃35831</a></li></ul><h4 id="网络相关-3"><a href="#网络相关-3" class="headerlink" title="网络相关"></a>网络相关</h4><ul><li>  允许使用更大的预设属性值，请勿覆盖。<a href="https://github.com/docker/libnetwork/pull/2124">docker/ libnetwork＃2124</a></li><li>  networkdb：handleNodeEvent 中的用户写锁定。 <a href="https://github.com/docker/libnetwork/pull/2136">docker/ libnetwork＃2136</a></li><li>  导入 libnetwork 修复程序以滚动更新。<a href="https://github.com/moby/moby/pull/36638">moby/moby＃36638</a></li><li>  更新 libnetwork 以改善桥网络隔离规则的可扩展性。<a href="https://github.com/moby/moby/pull/36774">moby/moby＃36774</a></li><li>  修复滥用的网络对象名称。<a href="https://github.com/moby/moby/pull/36745">moby/moby＃36745</a></li></ul><h4 id="运行相关-3"><a href="#运行相关-3" class="headerlink" title="运行相关"></a>运行相关</h4><ul><li>  LCOW：实施<code>docker save</code>。<a href="https://github.com/moby/moby/pull/36599">moby / moby＃36599</a></li><li>  Pkg：devmapper：动态加载 dm_task_deferred_remove。<a href="https://github.com/moby/moby/pull/35518">moby/moby＃35518</a></li><li>  Windows：在 graphdriver 中添加 GetLayerPath 实现。<a href="https://github.com/moby/moby/pull/36738">moby/moby＃36738</a></li><li>  修复写入失败时 Windows 层泄漏的问题。<a href="https://github.com/moby/moby/pull/36728">moby/moby＃36728</a></li><li>  在用户 NS 中运行时，修复 FIFO，套接字和设备文件。<a href="https://github.com/moby/moby/pull/36756">moby/moby＃36756</a></li><li>  修复 docker 版本输出对齐方式。<a href="https://github.com/docker/cli/pull/965">docker/ cli＃965</a></li><li>  始终使 sysfs 具有特权读写。<a href="https://github.com/moby/moby/pull/36808">moby/moby＃36808</a></li><li>  将 Golang 升至 1.10.1。<a href="https://github.com/moby/moby/pull/35739">moby/moby＃35739</a></li><li>  升级容器客户端。<a href="https://github.com/moby/moby/pull/36684">moby/moby＃36684</a></li><li>  将 golang.org/x/net 推送到 go1.10 版本提交。<a href="https://github.com/moby/moby/pull/36894">moby/moby＃36894</a></li><li>  Context.WithTimeout：调用取消函数。<a href="https://github.com/moby/moby/pull/36920">moby/moby＃36920</a></li><li>  复制：避免将所有系统内存与 authz 插件一起使用。<a href="https://github.com/moby/moby/pull/36595">moby / moby＃36595</a></li><li>  守护程序 / 集群：在配置期间处理部分附件条目。<a href="https://github.com/moby/moby/pull/36769">moby/moby＃36769</a></li><li>  使容器安装可绑定。<a href="https://github.com/moby/moby/pull/36768">moby/moby＃36768</a></li><li>  关机前进行额外检查。<a href="https://github.com/moby/moby/pull/36879">moby/moby＃36879</a></li><li>  将安装解析移动到单独的程序包。<a href="https://github.com/moby/moby/pull/36896">moby/moby＃36896</a></li><li>  没有全局卷驱动程序存储。<a href="https://github.com/moby/moby/pull/36637">moby/moby＃36637</a></li><li>  Pkg / 安装改进。<a href="https://github.com/moby/moby/pull/36091">moby/moby＃36091</a></li><li>  放松一些 libcontainerd 客户端锁定。<a href="https://github.com/moby/moby/pull/36848">moby/moby＃36848</a></li><li>  删除对 api 包的守护程序依赖性。<a href="https://github.com/moby/moby/pull/36912">moby/moby＃36912</a></li><li>  删除重试以进行服务更新。<a href="https://github.com/moby/moby/pull/36827">moby/moby＃36827</a></li><li>  还原未加密的存储警告提示。<a href="https://github.com/docker/cli/pull/1008">docker/ cli＃1008</a></li><li>  支持取消<code>directory.Size()</code>。<a href="https://github.com/moby/moby/pull/36734">moby/moby＃36734</a></li><li>  从 x / net / context-&gt; 上下文切换。<a href="https://github.com/moby/moby/pull/36904">moby/moby＃36904</a></li><li>  修复了检查内容类型是否正确的功能<code>application/json</code>。<a href="https://github.com/moby/moby/pull/36778">moby/moby＃36778</a></li><li>  添加默认的 pollSettings 配置功能。<a href="https://github.com/moby/moby/pull/36706">moby/moby＃36706</a></li><li>  在对 daemonWaitCh 进行操作之前判断是否添加。<a href="https://github.com/moby/moby/pull/36651">moby/moby＃36651</a></li><li>  解决以非 root 用户身份运行音量测试的问题<a href="https://github.com/moby/moby/pull/36935">。.moby / moby＃36935</a></li></ul><h4 id="集群相关-3"><a href="#集群相关-3" class="headerlink" title="集群相关"></a>集群相关</h4><ul><li>  RoleManager 将从集群成员删除检测到的节点 <a href="https://github.com/docker/swarmkit/pull/2548">docker / swarmkit＃2548</a></li><li>  Scheduler / TaskReaper：处理标记为关闭的未分配任务 <a href="https://github.com/docker/swarmkit/pull/2574">docker / swarmkit＃2574</a></li><li>  避免预定义的错误日志。<a href="https://github.com/docker/swarmkit/pull/2561">docker/ swarmkit＃2561</a></li><li>  任务收割者应删除尚未分配插槽的任务。<a href="https://github.com/docker/swarmkit/pull/2557">docker/ swarmkit＃2557</a></li><li>  代理报告 FIPS 状态。<a href="https://github.com/docker/swarmkit/pull/2587">docker/ swarmkit＃2587</a></li><li>  修复：timeMutex 关键部分之外的关键操作。<a href="https://github.com/docker/swarmkit/pull/2603">docker/ swarmkit＃2603</a></li><li>  在 engine 配置中公开 swarmkit 的 Raft 调整参数。<a href="https://github.com/moby/moby/pull/36726">moby/moby＃36726</a></li><li>  使内部 / 测试 / 守护进程。守护进程集群。<a href="https://github.com/moby/moby/pull/36826">moby/moby＃36826</a></li></ul><h3 id="版本号：18-04"><a href="#版本号：18-04" class="headerlink" title="版本号：18.04"></a>版本号：18.04</h3>  首次发布时间：2018-04-10<h4 id="构造相关-3"><a href="#构造相关-3" class="headerlink" title="构造相关"></a>构造相关</h4><ul><li>  修复构建器和客户端中的拼写错误。 <a href="https://github.com/moby/moby/pull/36424">moby/moby#36424</a></li></ul><h4 id="客户端相关-4"><a href="#客户端相关-4" class="headerlink" title="客户端相关"></a>客户端相关</h4><ul><li>  在版本命令中打印 Stack API 和 Kubernetes 版本。<a href="https://github.com/docker/cli/pull/898">docker/ cli＃898</a></li><li>  修复版本命令中的 Kubernetes 重复项。<a href="https://github.com/docker/cli/pull/953">docker cli＃953</a></li><li>  在帮助中使用 HasAvailableFlags 代替 HasFlags for Options。<a href="https://github.com/docker/cli/pull/959">docker/ cli＃959</a></li><li>  添加对强制变量的支持以进行堆栈部署。<a href="https://github.com/docker/cli/pull/893">docker/ cli＃893</a></li><li>  修复 docker stack services 命令的端口输出。<a href="https://github.com/docker/cli/pull/943">docker/ cli＃943</a></li><li>  弃用未加密的存储。<a href="https://github.com/docker/cli/pull/561">docker/ cli＃561</a></li><li>  不要为 ConfigFile 设置默认文件名。<a href="https://github.com/docker/cli/pull/917">docker/ cli＃917</a></li><li>  修复撰写网络名称。<a href="https://github.com/docker/cli/pull/941">docker cli＃941</a></li></ul><h4 id="日志相关-4"><a href="#日志相关-4" class="headerlink" title="日志相关"></a>日志相关</h4><ul><li>  静默登录：使用 cred 存储中的凭据登录。<a href="https://github.com/docker/cli/pull/139">docker/ cli＃139</a></li><li>  添加对日志文件可压缩性的支持。<a href="https://github.com/moby/moby/pull/29932">docker＃29932</a></li><li>  使用非阻塞日志记录模式修复空的 LogPath。<a href="https://github.com/moby/moby/pull/36272">docker36272</a></li></ul><h4 id="网络相关-4"><a href="#网络相关-4" class="headerlink" title="网络相关"></a>网络相关</h4><ul><li>  防止显式删除入口网络。<a href="https://github.com/moby/moby/pull/36538">docker＃36538</a></li></ul><h4 id="运行相关-4"><a href="#运行相关-4" class="headerlink" title="运行相关"></a>运行相关</h4><ul><li>  Devmapper 清理改进。<a href="https://github.com/moby/moby/pull/36307">docker＃36307</a></li><li>  Devmapper.Mounted：删除。<a href="https://github.com/moby/moby/pull/36437">docker＃36437</a></li><li>  Devmapper / Remove（）：使用 Rmdir，忽略错误。<a href="https://github.com/moby/moby/pull/36438">docker＃36438</a></li><li>  LCOW - 将平台解析器指令更改为 FROM 语句标志。<a href="https://github.com/moby/moby/pull/35089">moby/moby＃35089</a></li><li>  将守护程序服务代码拆分为 Windows 文件。<a href="https://github.com/moby/moby/pull/36653">moby/moby＃36653</a></li><li>  Windows：阻止拉高级别镜像。<a href="https://github.com/moby/moby/pull/36327">moby/moby＃36327</a></li><li>  Windows：合并 36586 后，Hyper-V 容器损坏。<a href="https://github.com/moby/moby/pull/36610">moby/moby＃36610</a></li><li>  Windows：移动 kernel_windows 以使用 golang 注册表功能。<a href="https://github.com/moby/moby/pull/36617">moby/moby＃36617</a></li><li>  Windows：在容器退出时传回系统错误。<a href="https://github.com/moby/moby/pull/35967">moby/moby＃35967</a></li><li>  Windows：删除服务模式。<a href="https://github.com/moby/moby/pull/36267">moby/moby＃36267</a></li><li>  Windows：报告版本和 UBR。<a href="https://github.com/moby/moby/pull/36451">moby/moby＃36451</a></li><li>  将 Runc 碰撞到 1.0.0-rc5。<a href="https://github.com/moby/moby/pull/36449">moby/moby＃36449</a></li><li>  装载失败表示失败的路径。<a href="https://github.com/moby/moby/pull/36407">moby/moby＃36407</a></li><li>  更改 errdefs.getImplementer（）的返回值。<a href="https://github.com/moby/moby/pull/36489">moby/moby＃36489</a></li><li>  客户端：修复 hijackedconn 从缓冲区读取的问题。<a href="https://github.com/moby/moby/pull/36663">moby/moby＃36663</a></li><li>  内容编码协商已添加到存档请求。<a href="https://github.com/moby/moby/pull/36164">moby/moby＃36164</a></li><li>  后台程序 / 统计信息：更灵活的 CPU 采样。<a href="https://github.com/moby/moby/pull/36519">moby / moby＃36519</a></li><li>  守护程序 / 统计信息：删除令人讨厌的类型文件。<a href="https://github.com/moby/moby/pull/36494">moby/moby＃36494</a></li><li>  守护程序：使用上下文错误而不是发明新的错误。<a href="https://github.com/moby/moby/pull/36670">moby/moby＃36670</a></li><li>  在非 amd64 架构（v2）上启用 CRIU。<a href="https://github.com/moby/moby/pull/36676">moby/moby＃36676</a></li><li>  在关闭 stdin 到连接的容器后修复间歇性客户端挂起 <a href="https://github.com/moby/moby/pull/36517">Moby / moby＃36517</a></li><li>  重新启动后修复容器导出上的守护程序紧急情况<a href="https://github.com/moby/moby/pull/36586">＃36586</a></li><li>  多阶段 Moby 的 Dockerfile 的后续修复。<a href="https://github.com/moby/moby/pull/36425">moby/moby＃36425</a></li><li>  在 Docker 映像中冻结 busybox 和最新的 glibc。<a href="https://github.com/moby/moby/pull/36375">moby/moby＃36375</a></li><li>  如果容器将以非 root 用户身份运行，请允许早期删除有效上限。<a href="https://github.com/moby/moby/pull/36587">moby/moby＃36587</a></li><li>  层：删除元数据存储界面。<a href="https://github.com/moby/moby/pull/36504">moby/moby＃36504</a></li><li>  对 dockerd 的次要优化。<a href="https://github.com/moby/moby/pull/36577">moby / moby＃36577</a></li><li>  将 statx syscall 列入白名单。<a href="https://github.com/moby/moby/pull/36417">moby/moby＃36417</a></li><li>  添加缺少的错误返回信息以创建插件。<a href="https://github.com/moby/moby/pull/36646">moby/moby＃36646</a></li><li>  修复 AppArmor 不应用于 Exec 进程的问题。<a href="https://github.com/moby/moby/pull/36466">moby/moby＃36466</a></li><li>  Daemon / logger / ring.go：日志错误不是实例。<a href="https://github.com/moby/moby/pull/36475">moby/moby＃36475</a></li><li>  如果未收集任何统计信息，请修复统计信息收集器旋转的 CPU。<a href="https://github.com/moby/moby/pull/36609">moby/moby＃36609</a></li><li>  修复（分发）：摘要缓存如果是身份验证，则不应移动。<a href="https://github.com/moby/moby/pull/36509">moby / moby＃36509</a></li><li>  确保在失败时删除插件容器。<a href="https://github.com/moby/moby/pull/36715">moby/moby＃36715</a></li><li>  碰撞到容器 1.0.3。<a href="https://github.com/moby/moby/pull/36749">moby/moby＃36749</a></li><li>  不要对插件安装片排序。<a href="https://github.com/moby/moby/pull/36711">moby/moby＃36711</a></li></ul><h4 id="集群相关-4"><a href="#集群相关-4" class="headerlink" title="集群相关"></a>集群相关</h4><ul><li>  修复了使调度程序关闭与正在进行的 rpcs 同步的问题。<a href="https://github.com/moby/moby/pull/36371">moby/moby＃36371</a></li><li>  将筏 ElectionTick 增加到 10xHeartbeatTick。<a href="https://github.com/moby/moby/pull/36672">moby/moby＃36672</a></li><li>  在守护程序配置中使 Swarm Manager Raft 仲裁参数可配置。<a href="https://github.com/moby/moby/pull/36726">moby/moby＃36726</a></li><li>  入口网络不应是可连接的。<a href="https://github.com/docker/swarmkit/pull/2523">docker/ swarmkit＃2523</a></li><li>  [经理 / 州] 将 Fernet 添加为筏加密的选项。<a href="https://github.com/docker/swarmkit/pull/2535">docker/ swarmkit＃2535</a></li><li>  记录 GRPC 服务器错误。 <a href="https://github.com/docker/swarmkit/pull/2541">docker/ swarmkit＃2541</a></li><li>  在经理级别记录领导层的变化。<a href="https://github.com/docker/swarmkit/pull/2542">docker/ swarmkit＃2542</a></li><li>  删除容器的执行程序。<a href="https://github.com/docker/swarmkit/pull/2568">docker/ swarmkit＃2568</a></li><li>  代理：没有遥控器可用时的退避会话。<a href="https://github.com/docker/swarmkit/pull/2570">docker/ swarmkit＃2570</a></li><li>  [ca / manager] 完全删除根 CA 密钥加密支持。<a href="https://github.com/docker/swarmkit/pull/2573">docker/ swarmkit＃2573</a></li><li>  修复代理日志记录竞赛。<a href="https://github.com/docker/swarmkit/pull/2578">docker/ swarmkit＃2578</a></li><li>  添加逻辑以按顺序还原网络。<a href="https://github.com/docker/swarmkit/pull/2571">docker/ swarmkit＃2571</a></li></ul><h3 id="版本号：18-03"><a href="#版本号：18-03" class="headerlink" title="版本号：18.03"></a>版本号：18.03</h3>  首次发布时间：2018-03-21<h4 id="构造相关-4"><a href="#构造相关-4" class="headerlink" title="构造相关"></a>构造相关</h4><ul><li>  切换到 - buildmode = pie <a href="https://github.com/moby/moby/pull/34369">moby / moby＃34369</a></li><li>  允许 Dockerfile 在构建上下文 docker <a href="https://github.com/docker/cli/pull/886">/ cli＃886 之外</a></li><li>  构建器: 修正错误的缓存命中塔 <a href="https://github.com/moby/moby/pull/36329">moby/moby#36329</a></li><li>  修复多阶段构建中泄漏到其他映像的文件 <a href="https://github.com/moby/moby/pull/36338">moby/moby#36338</a></li></ul><h4 id="客户端相关-5"><a href="#客户端相关-5" class="headerlink" title="客户端相关"></a>客户端相关</h4><ul><li>  使用网络合并合并文件修复错误 <a href="https://github.com/docker/cli/pull/983">docker / cli＃983</a></li><li>  在使用<code>--force</code>后更新服务后修复 docker stack 部署重新部署服务 <a href="https://github.com/docker/cli/pull/963">docker / cli＃963</a></li><li>  修复 docker 版本输出对齐方式 <a href="https://github.com/docker/cli/pull/965">docker / cli＃965</a></li><li>  简化组合类型的封送处理。配置 docker <a href="https://github.com/docker/cli/pull/895">/ cli＃895</a></li><li>  部署 docke 时添加对多个 composefile 的支持 r <a href="https://github.com/docker/cli/pull/569">/ cli＃569</a></li><li>  修复损坏的 Kubernetes 堆栈标志 docker <a href="https://github.com/docker/cli/pull/831">/ cli＃831</a></li><li>  修复 Kubernetes docker 的堆栈封送处理 <a href="https://github.com/docker/cli/pull/890">/ cli＃890</a></li><li>  修复并简化服务环境的 bash 完成，挂载和标记 <a href="https://github.com/docker/cli/pull/682">docker / cli＃682</a></li><li>  修复<code>before</code>并<code>since</code>过滤<code>docker ps</code> <a href="https://github.com/moby/moby/pull/35938">Moby / Moby＃35938</a></li><li>  修复<code>--label-file</code>奇怪的行为 <a href="https://github.com/docker/cli/pull/838">docker / cli＃838</a></li><li>  修复在不受支持的平台对 defaultCredentialStore（）的编译 <a href="https://github.com/docker/cli/pull/872">docker / cli＃872</a></li><li>  改善和修复镜像的 bash 完成 <a href="https://github.com/docker/cli/pull/717">docker / cli＃717</a></li><li>  在绑定安装的添加了对空源的检查 <a href="https://github.com/docker/cli/pull/824">docker / cli＃824</a></li><li>  从客户端中的环境变量修复 TLS<a href="https://github.com/moby/moby/pull/36270">Moby / Moby＃36270</a></li><li>  泊坞窗现在构建的运行速度更快，当特定注册表凭证助手（S）配置 <a href="https://github.com/docker/cli/pull/840">docker/cli#840</a></li><li>  更新事件过滤器的 zsh 完成用<code>disable</code>，<code>enable</code>，<code>install</code>和<code>remove</code> <a href="https://github.com/docker/cli/pull/372">docker/cli#372</a></li><li>  将空 ID 传递到检查调用时产生错误 <a href="https://github.com/moby/moby/pull/36144">Moby / Moby＃36144</a></li><li>  用于 k8s 控制器的 Marshall 版本 <a href="https://github.com/docker/cli/pull/891">docker/cli#891</a></li><li>  为 HTTP 客户端与插件后端通信设置一个非零超时 <a href="https://github.com/docker/cli/pull/883">docker/cli#883</a></li><li>  为–tls 选项添加 DOCKER_TLS 环境变量 <a href="https://github.com/docker/cli/pull/863">docker/cli#863</a></li><li>  为加密 / 配置添加–模板驱动程序选项 <a href="https://github.com/docker/cli/pull/896">docker/cli#896</a></li><li>  将 docker trust` 命令移除实验范围 docker/cli#934](<a href="https://github.com/docker/cli/pull/934">https://github.com/docker/cli/pull/934</a>) <a href="https://github.com/docker/cli/pull/935">docker/cli#935</a> <a href="https://github.com/docker/cli/pull/944">docker/cli#944</a></li></ul><h4 id="日志相关-5"><a href="#日志相关-5" class="headerlink" title="日志相关"></a>日志相关</h4><ul><li>  AWS 日志 - 不要在最大大小的事件中添加新行 <a href="https://github.com/moby/moby/pull/36078">moby / moby＃36078</a></li><li>  加载插件后移动日志验证器逻辑 <a href="https://github.com/moby/moby/pull/36306">Moby / Moby＃36306</a></li><li>  在 Splunk 日志驱动程序支持代理 <a href="https://github.com/moby/moby/pull/36220">Moby / Moby＃36220</a></li><li>  修正带有空日志的日志尾部 <a href="https://github.com/moby/moby/pull/36305">moby/moby#36305</a></li></ul><h4 id="网络相关-5"><a href="#网络相关-5" class="headerlink" title="网络相关"></a>网络相关</h4><ul><li>  修正了 Memberlist revendor 退出时的死锁问题 <a href="https://github.com/docker/libnetwork/pull/2040">docker/libnetwork#2040</a></li><li>  修复用户指定的 ndots 选项 <a href="https://github.com/docker/libnetwork/pull/2065">docker / libnetwork＃2065</a></li><li>  修复为 Windows 使用 ContainerID 而不是 SandboxID docker <a href="https://github.com/docker/libnetwork/pull/2010">/ libnetwork＃2010</a></li><li>  验证 NetworkingConfig 以确保 EndpointSettings 不是 nil <a href="https://github.com/moby/moby/pull/36077">moby / moby＃36077</a></li><li>  修复<code>DockerNetworkInternalMode</code>问题 <a href="https://github.com/moby/moby/pull/36298">Moby / Moby＃36298</a></li><li>  在可附加网络附件的修复种族<a href="https://github.com/moby/moby/pull/36191">＃36191</a></li><li>  修复<code>InspectNetwork</code>AArch64 超时问题 <a href="https://github.com/moby/moby/pull/36257">Moby / Moby＃36257</a></li><li>  部分覆盖 ID 的缺少详细信息 <a href="https://github.com/moby/moby/pull/35989">Moby / moby＃35989</a></li><li>  更新<code>FindNetwork</code>以解决网络名称重复的问题 <a href="https://github.com/moby/moby/pull/30897">moby / moby＃30897</a></li><li>  禁止附加入口网络 <a href="https://github.com/docker/swarmkit/pull/2523">docker / swarmkit＃2523</a></li><li>  防止隐式删除入口网络 <a href="https://github.com/moby/moby/pull/36538">moby / moby＃36538</a></li><li>  修复 Windows 上旧的 HNS 端点<a href="https://github.com/moby/moby/pull/36603">＃36603</a></li><li>  IPAM 修复了重复的 IP 地址 <a href="https://github.com/docker/libnetwork/pull/2104">docker / libnetwork＃2104</a> <a href="https://github.com/docker/libnetwork/pull/2105">docker / libnetwork＃2105</a></li></ul><h4 id="运行相关-5"><a href="#运行相关-5" class="headerlink" title="运行相关"></a>运行相关</h4><ul><li>  修复 AppArmor 配置文件未应用于<code>docker exec</code>进程 <a href="https://github.com/moby/moby/pull/36466">Moby / Moby＃36466</a></li><li>  不要对插件装载片进行排序 <a href="https://github.com/moby/moby/pull/36711">moby/moby#36711</a></li><li>  守护程序 / 集群：在配置期间处理部分附件条目 <a href="https://github.com/moby/moby/pull/36769">moby / moby＃36769</a></li><li>  将 Golang 撞到 1.9.5 <a href="https://github.com/moby/moby/pull/36779">Moby</a> <a href="https://github.com/docker/cli/pull/986">/</a> <a href="https://github.com/moby/moby/pull/36779">Moby＃36779 docker</a> <a href="https://github.com/docker/cli/pull/986">/ cli＃986</a></li><li>  守护进程 / 统计: 更有弹性的 cpu 采样 <a href="https://github.com/moby/moby/pull/36519">moby/moby#36519</a></li><li>  容器化：更新至 1.0.3 版本 <a href="https://github.com/moby/moby/pull/36749">Moby / Moby＃36749</a></li><li>  修正了写操作失败时的 Windows 层泄漏 <a href="https://github.com/moby/moby/pull/36728">moby/moby#36728</a></li><li>  不要使容器安装不可绑定 <a href="https://github.com/moby/moby/pull/36768">moby/moby#36768</a></li><li>  修复守护进程重启后在容器导出上的守护进程异常 <a href="https://github.com/moby/moby/pull/36586">moby/moby/36586</a></li><li>  修复摘要缓存已在删除的问题 <a href="https://github.com/moby/moby/pull/36509">authErrors Moby / Moby＃36509 上</a></li><li>  确保在失败时删除了插件容器 <a href="https://github.com/moby/moby/pull/36715">Moby / Moby＃36715</a></li><li>  复制：避免将所有系统内存与 authz 插件一起使用 <a href="https://github.com/moby/moby/pull/36595">moby / moby＃36595</a></li><li>  放松一些 libcontainerd 客户端锁定 <a href="https://github.com/moby/moby/pull/36848">moby/moby#36848</a></li><li>  更新<code>hcsshim</code>到 v0.6.10 以解决 <a href="https://portal.msrc.microsoft.com/en-us/security-guidance/advisory/CVE-2018-8115">CVE-2018-8115</a></li><li>  为 Windows 启用 HotAdd <a href="https://github.com/moby/moby/pull/35414">moby/moby#35414</a></li><li>  Graphdriver 修复 hotRemoveVHDs 中的死锁 <a href="https://github.com/moby/moby/pull/36114">moby/moby#36114</a></li><li>  普通挂载，如果只有一层 <a href="https://github.com/moby/moby/pull/36052">moby/moby#36052</a></li><li>  删除临时环境变量 LCOW_API_PLATFORM_IF_OMITTED <a href="https://github.com/moby/moby/pull/36269">moby / moby＃36269</a></li><li>  Revendor Microsoft / opengcs @ v0.3.6 <a href="https://github.com/moby/moby/pull/36108">moby / moby＃36108</a></li><li>  修复 ExitCode 和 PID 问题未显示在 Task.Status.ContainerStatus <a href="https://github.com/moby/moby/pull/36150">moby / moby＃36150</a></li><li>  修复了插件扫描程序过深的问题 <a href="https://github.com/moby/moby/pull/36119">moby / moby＃36119</a></li><li>  不要使 graphdriver homes 私人挂载 <a href="https://github.com/moby/moby/pull/36047">moby / moby＃36047</a></li><li>  不要在清理 zfs / btrfs 递归卸载<a href="https://github.com/moby/moby/pull/36237">＃36237</a></li><li>  如果镜像不存在，请不要还原镜像 <a href="https://github.com/moby/moby/pull/36304">Moby / moby＃36304</a></li><li>  调整模板化配置 / 加密最低 API 版本<a href="https://github.com/moby/moby/pull/36366">＃36366</a></li><li>  容器升级到 1.0.2（cfd04396dc68220d1cecbe686a6cc3aa5ce3667c） <a href="https://github.com/moby/moby/pull/36308">＃36308</a></li><li>  将 Golang 撞到 1.9.4 Moby <a href="https://github.com/moby/moby/pull/36243">/ Moby＃36243</a></li><li>  确保在关机上卸载了守护程序根目录 <a href="https://github.com/moby/moby/pull/36107">Moby / moby＃36107</a></li><li>  将 Runc 更新到 6c55f98695e902427906eed2c799e566e3d3dfb5 <a href="https://github.com/moby/moby/pull/36222">moby/moby#36222</a></li><li>  修复守护程序上的容器清理重启 <a href="https://github.com/moby/moby/pull/36249">moby / moby＃36249</a></li><li>  支持 SCTP 端口映射（将 API 升级到 v1.37）<a href="https://github.com/moby/moby/pull/33922">moby / moby＃33922</a></li><li>  支持 SCTP 端口映射 <a href="https://github.com/docker/cli/pull/278">docker / cli＃278</a></li><li>  修复 ContainerConfig 的 Volumes 属性定义 <a href="https://github.com/moby/moby/pull/35946">Moby / moby＃35946 中</a></li><li>  升级 Moby 和依赖项 <a href="https://github.com/docker/cli/pull/829">docker / cli＃829</a></li><li>  C.RWLayer：在使用之前检查是否为零<a href="https://github.com/moby/moby/pull/36242">＃36242</a></li><li>  添加<code>REMOVE</code>并添加<code>ORPHANED</code>到 TaskState <a href="https://github.com/moby/moby/pull/36146">moby / moby＃36146</a></li><li>  使用固定的错误检测<code>IsErrNotFound</code>和<code>IsErrNotImplemented</code>对<code>ContainerStatPath</code>，<code>CopyFromContainer</code>和<code>CopyToContainer</code>方法 <a href="https://github.com/moby/moby/pull/35979">MOBY / MOBY＃35979</a></li><li>  添加集成 / 内部 / 容器帮助程序包 <a href="https://github.com/moby/moby/pull/36266">moby / moby＃36266</a></li><li>  添加规范的导入路径 <a href="https://github.com/moby/moby/pull/36194">Moby / Moby＃36194</a></li><li>  添加 / 使用 container.Exec（）到集成 <a href="https://github.com/moby/moby/pull/36326">Moby / Moby＃36326</a></li><li>  修复 “–node-generic-resource” 单 / 复数 <a href="https://github.com/moby/moby/pull/36125">moby / moby＃36125</a></li><li>  Daemon.cleanupContainer：在释放使容器 RWLayer 无效<a href="https://github.com/moby/moby/pull/36160">＃36160</a></li><li>  守护程序：将<code>--oom-kill-disable</code>选项传递给容器式 Moby <a href="https://github.com/moby/moby/pull/36201">Moby＃36201</a></li><li>  当存在绑定端口且网络模式为主机 <a href="https://github.com/moby/moby/pull/35510">moby / moby＃35510</a> 时显示警告消息</li><li>  在已重新启动的容器式 <a href="https://github.com/moby/moby/pull/36173">Moby / Moby</a> 上刷新容器式遥控器</li><li>  将守护程序根设置为使用共享传播 <a href="https://github.com/moby/moby/pull/36096">Moby / Moby＃36096</a></li><li>  递归卸载优化<a href="https://github.com/moby/moby/pull/34379">＃34379</a></li><li>  在运行时中执行插件安装<a href="https://github.com/moby/moby/pull/35829">＃35829</a></li><li>  Graphdriver：修复 RefCounter 内存泄漏 <a href="https://github.com/moby/moby/pull/36256">Moby＃36256</a></li><li>  使用连续性 fs 软件包进行卷复制 <a href="https://github.com/moby/moby/pull/36290">Moby / Moby＃36290</a></li><li>  使用 proc / exe 重新执行 <a href="https://github.com/moby/moby/pull/36124">Moby / Moby＃36124</a></li><li>  添加对模板化机密和配置的 API 支持，即 <a href="https://github.com/moby/moby/pull/33702">moby / moby＃33702</a> 和 <a href="https://github.com/moby/moby/pull/36366">moby / moby＃36366</a></li><li>  将 rslave 传播用于从守护程序 roo 进行的挂载 t <a href="https://github.com/moby/moby/pull/36055">moby / moby＃36055</a></li><li>  将 / proc / 键添加到被屏蔽的路径 <a href="https://github.com/moby/moby/pull/36368">moby / moby＃36368</a></li><li>  将 Runc 碰撞到 1.0.0-rc5 Moby <a href="https://github.com/moby/moby/pull/36449">/ Moby＃36449</a></li><li>  修复<code>runc exec</code>了 Big-endian 架构 <a href="https://github.com/moby/moby/pull/36449">Moby / Moby＃36449</a></li><li>  未提供安装名称空间时使用 chroot <a href="https://github.com/moby/moby/pull/36449">moby / moby＃36449</a></li><li>  修复系统切片扩展，以便 cAdvisor 可以使用它 <a href="https://github.com/moby/moby/pull/36449">moby / moby＃36449</a></li><li>  修复安装了错误的 uid / gid <a href="https://github.com/moby/moby/pull/36449">moby / moby 的设备＃36449</a></li><li>  使用 IPC 专用安装架<code>/dev/shm</code>只读修复只读容器 <a href="https://github.com/moby/moby/pull/36526">moby / moby＃36526</a></li></ul><h4 id="集群相关-5"><a href="#集群相关-5" class="headerlink" title="集群相关"></a>集群相关</h4><ul><li>  将木筏选择刻度增加到 10 倍心跳刻度 <a href="https://github.com/moby/moby/pull/36672">Moby / Moby＃36672</a></li><li>  将 EC 私钥替换为 PKCS＃8 PEM <a href="https://github.com/docker/swarmkit/pull/2246">docker / swarmkit＃2246</a></li><li>  修复 IP 与空 EndpointSpec 重叠 <a href="https://github.com/docker/swarmkit/pull/2505">docker / swarmkit＃2505</a></li><li>  添加对 Support SCTP 端口映射的支持 <a href="https://github.com/docker/swarmkit/pull/2298">docker / swarmkit＃2298</a></li><li>  如果仅放置约束发生更改并且已分配的节点满足要求，请不要重新计划任务 <a href="https://github.com/docker/swarmkit/pull/2496">docker / swarmkit＃2496</a></li><li>  确保任务收割者 stopChan 关闭不超过一次 <a href="https://github.com/docker/swarmkit/pull/2491">docker / swarmkit＃2491</a></li><li>  同步修复 <a href="https://github.com/docker/swarmkit/pull/2495">docker / swarmkit＃2495</a></li><li>  添加日志消息以指示如果流未实现的，则消息发送重试 <a href="https://github.com/docker/swarmkit/pull/2483">docker / swarmkit＃2483</a></li><li>  会话，调度程序上的节点事件，心跳调试日志 <a href="https://github.com/docker/swarmkit/pull/2486">docker / swarmkit＃2486</a></li><li>  将群类型添加到 bash 完成事件类型过滤器 <a href="https://github.com/docker/cli/pull/888">docker / cli＃888</a></li><li>  修正了网络检查不能显示群集范围内网络创建时间的问题 <a href="https://github.com/moby/moby/pull/36095">moby/moby#36095</a></li></ul><h3 id="版本号：18-02"><a href="#版本号：18-02" class="headerlink" title="版本号：18.02"></a>版本号：18.02</h3>  首次发布时间： 2018-02-07<h4 id="构造相关-5"><a href="#构造相关-5" class="headerlink" title="构造相关"></a>构造相关</h4><ul><li>  Gitutils：修复检查子模块 <a href="https://github.com/moby/moby/pull/35737">Moby / Moby＃35737</a></li></ul><h4 id="客户端相关-6"><a href="#客户端相关-6" class="headerlink" title="客户端相关"></a>客户端相关</h4><ul><li>  附加：确保附加退出代码与容器相匹配 <a href="https://github.com/docker/cli/pull/696">docker / cli＃696</a></li><li>  在撰写文件中添加了对 tmpfs-mode 的支持 <a href="https://github.com/docker/cli/pull/808">docker / cli＃808</a></li><li>  添加新的撰写文件版本 3.6 <a href="https://github.com/docker/cli/pull/808">docker / cli＃808</a></li><li>  在过滤器的修复问题<code>docker ps</code>，其中<code>health=starting</code>不返回任何 <a href="https://github.com/moby/moby/pull/35940">MOBY / MOBY＃35940</a></li><li>  改善已发布端口范围 <a href="https://github.com/docker/cli/pull/581">docker / cli＃581</a></li><li>  跳至 1.9.3 <a href="https://github.com/docker/cli/pull/827">docker / cli＃827</a></li><li>  修复损坏的 Kubernetes 堆栈标志 docker <a href="https://github.com/docker/cli/pull/831">/ cli＃831</a></li><li>  将 “stack” 命令注释为 “ swarm” 和“ kubernetes” docker <a href="https://github.com/docker/cli/pull/804">/ cli＃804</a></li></ul><h4 id="实验性功能-1"><a href="#实验性功能-1" class="headerlink" title="实验性功能"></a>实验性功能</h4><ul><li>  添加清单命令 <a href="https://github.com/docker/cli/pull/138">docker / cli＃138</a></li><li>  LCOW remotefs-Read（）实现中的返回错误 <a href="https://github.com/moby/moby/pull/36051">moby / moby＃36051</a></li><li>  LCOW：Coalesce 守护程序存储，允许双 LCOW 和 WCOW 模式 <a href="https://github.com/moby/moby/pull/34859">moby / moby＃34859</a></li><li>  LCOW：修复 OpenFile 参数 <a href="https://github.com/moby/moby/pull/36043">moby / moby＃36043</a></li><li>  LCOW：提高对 Windows RS3 RTM 内部版本（16299）最低要求 <a href="https://github.com/moby/moby/pull/36065">moby/moby#36065</a></li></ul><h4 id="日志相关-6"><a href="#日志相关-6" class="headerlink" title="日志相关"></a>日志相关</h4><ul><li>  改进守护程序配置重载；记录活动配置 <a href="https://github.com/moby/moby/pull/36019">moby / moby＃36019</a></li><li>  修复了对 ContainerLogs 方法使用 IsErrNotFound 和 IsErrNotImplemented 进行的错误检测 <a href="https://github.com/moby/moby/pull/36000">moby / moby＃36000</a></li><li>  将日记标记添加为 SYSLOG_IDENTIFIER <a href="https://github.com/moby/moby/pull/35570">moby / moby＃35570</a></li><li>  Splunk：在错误响应上限制读取器大小 <a href="https://github.com/moby/moby/pull/35509">Moby / Moby＃35509</a></li></ul><h4 id="网络相关-6"><a href="#网络相关-6" class="headerlink" title="网络相关"></a>网络相关</h4><ul><li>  在发布网络上禁用服务会导致零停机时间部署以及滚动升级 <a href="https://github.com/moby/moby/pull/35960">Moby / Moby＃35960</a></li><li>  如果不同空间中存在多个具有相同名称的网络，则修复服务无法启动 <a href="https://github.com/moby/moby/pull/30897">moby / moby＃30897</a></li><li>  修复使用添加的重复网络<code>docker service update --network-add</code><a href="https://github.com/docker/cli/pull/780">docker / cli＃780</a></li><li>  从 17.09 升级到 17.12 时修复入口网络。 <a href="https://github.com/moby/moby/pull/36003">moby/moby#36003</a></li><li>  修复 ndots 配置 <a href="https://github.com/docker/libnetwork/pull/1995">docker / libnetwork＃1995</a></li><li>  修复如果启用了实时还原，则正在取消配置 IPV6 网络 <a href="https://github.com/docker/libnetwork/pull/2043">docker / libnetwork＃2043</a></li><li>  在嵌入式 DNS 服务器添加对 MX 类型 DNS 查询的支持 <a href="https://github.com/docker/libnetwork/pull/2041">docker / libnetwork＃2041 中</a></li></ul><h4 id="打包相关-2"><a href="#打包相关-2" class="headerlink" title="打包相关"></a>打包相关</h4><ul><li>  在 aarch64 上增加了 Fedora 26、Fedora 27 和 Centos 7 的包装 <a href="https://github.com/docker/docker-ce-packaging/pull/71">docker/docker-ce-packaging#71</a></li><li>  删除了对 Ubuntu Zest 的支持 y <a href="https://github.com/docker/docker-ce-packaging/pull/73">docker / docker-ce-packaging＃73</a></li><li>  删除了对 Fedora 25 的支持 <a href="https://github.com/docker/docker-ce-packaging/pull/72">docker / docker-ce-packaging＃72</a></li></ul><h4 id="运行相关-6"><a href="#运行相关-6" class="headerlink" title="运行相关"></a>运行相关</h4><ul><li>  修复基于管道错误 Docker Daemon 意外关闭 <a href="https://github.com/moby/moby/pull/35968">Moby / Moby＃35968</a></li><li>  修复 Win32 中出现的 hcsshim :: ImportLayer 失败的情况：系统找不到指定的路径 <a href="https://github.com/moby/moby/pull/35924">moby / moby＃35924</a></li><li>  Windows：在构建期间将最大层大小增加到 127GB <a href="https://github.com/moby/moby/pull/35925">Moby / moby＃35925</a></li><li>  修复 Devicemapper：运行 DeleteDevice dm_task_run 失败，导致 Moby <a href="https://github.com/moby/moby/pull/35919">/</a> Moby 失败<a href="https://github.com/moby/moby/pull/35919">＃35919</a></li><li>  介绍 «exec_die» 事件 <a href="https://github.com/moby/moby/pull/35744">moby / moby＃35744</a></li><li>  将 API 更新到版本 1.36 <a href="https://github.com/moby/moby/pull/35744">Moby / Moby＃35744</a></li><li>  修复了<code>docker update</code>不更新 cpu 配额和正在运行的容器的 cpu 周期<a href="https://github.com/moby/moby/pull/36030">＃36030</a></li><li>  使容器 shm 父级成为不可绑定的 Moby <a href="https://github.com/moby/moby/pull/35830">/ Moby＃35830</a></li><li>  使用 pigz 使图片 (图层) 下载速度更快 <a href="https://github.com/moby/moby/pull/35697">moby/moby#35697</a></li><li>  保护守护进程不受体积插件缓慢或死锁的影响 <a href="https://github.com/moby/moby/pull/35441">moby/moby#35441</a></li><li>  修复<code>DOCKER_RAMDISK</code>环境变量未被识别的问题 <a href="https://github.com/moby/moby/pull/35957">moby/moby#35957</a></li><li>  容器升级到 1.0.1（9b55aab90508bd389d7654c4baf173a981477d55） <a href="https://github.com/moby/moby/pull/35986">moby/moby#35986</a></li><li>  更新 runc 以修复启动和执行期间的挂起 <a href="https://github.com/moby/moby/pull/36097">moby/moby#36097</a></li><li>  修复 “–node-generic-resource” 单 / 复数 <a href="https://github.com/moby/moby/pull/36125">moby / moby＃36125</a></li></ul><h3 id="版本号：18-01"><a href="#版本号：18-01" class="headerlink" title="版本号：18.01"></a>版本号：18.01</h3>  首次发布时间：2018-01-10<h4 id="构造相关-6"><a href="#构造相关-6" class="headerlink" title="构造相关"></a>构造相关</h4><ul><li>  如果启用了用户命名空间，则修复文件不会被删除 <a href="https://github.com/moby/moby/pull/35822">moby / moby＃35822</a></li><li>  支持在<code>docker commit --change ...</code>中添加扩展环境变量 <a href="https://github.com/moby/moby/pull/35582">＃35582</a></li></ul><h4 id="客户端相关-7"><a href="#客户端相关-7" class="headerlink" title="客户端相关"></a>客户端相关</h4><ul><li>  从堆栈部署配置中的客户端返回错误 <a href="https://github.com/docker/cli/pull/757">docker / cli＃757</a></li><li>  修复修剪命令中过滤器标记的描述 <a href="https://github.com/docker/cli/pull/774">docker / cli＃774</a></li><li>  将 “pid” 添加到不受支持的选项列表 <a href="https://github.com/docker/cli/pull/768">docker / cli＃768</a></li><li>  添加对实验性 Cli 配置的支持 <a href="https://github.com/docker/cli/pull/758">docker / cli＃758</a></li><li>  为 bash 完成 <a href="https://github.com/docker/cli/pull/749">docker / cli＃749</a> 添加对通用资源的支持</li><li>  修复在 docker exec 的 zsh 完成脚本的错误 <a href="https://github.com/docker/cli/pull/751">docker / cli＃751</a></li><li>  客户端关闭 WebSocket 附加连接时添加调试消息 <a href="https://github.com/moby/moby/pull/35720">Moby / Moby＃35720</a></li><li>  修复对于<code>&quot;docker swarm&quot;</code>完成 <a href="https://github.com/docker/cli/pull/772">docker / cli＃772</a></li></ul><h4 id="文档相关"><a href="#文档相关" class="headerlink" title="文档相关"></a>文档相关</h4><ul><li>  <code>--publish</code>在档中正确引用长语法 <a href="https://github.com/docker/cli/pull/746">docker / cli＃746</a> 文</li><li>  更正了 MAC_ADMIN 和 MAC_OVERRIDE 的描述 <a href="https://github.com/docker/cli/pull/761">docker/cli#761</a></li><li>  更新了开发人员文档以解释外部 CLI <a href="https://github.com/moby/moby/pull/35681">moby / moby＃35681</a></li><li>  修复<code>&quot;on-failure&quot;</code>重启策略被记录为 “失败” 的 <a href="https://github.com/docker/cli/pull/754">docker / cli＃754</a></li><li>  修复 “存储驱动程序选项” 问题 <a href="https://github.com/docker/cli/pull/748">docker/cli#748</a></li></ul><h4 id="实验性功能-2"><a href="#实验性功能-2" class="headerlink" title="实验性功能"></a>实验性功能</h4><ul><li>  将 kubernetes 支持添加到<code>docker stack</code>命令 docker <a href="https://github.com/moby/moby/pull/35765">moby/moby#35765</a></li><li>  不要将容器 ID 附加到自定义目录检查点。 <a href="https://github.com/moby/moby/pull/35726">moby/moby#35726</a></li></ul><h4 id="日志相关-7"><a href="#日志相关-7" class="headerlink" title="日志相关"></a>日志相关</h4><ul><li>  修正了当 GELF 服务器宕机时通过 TCP 使用 GELF 日志驱动程序时守护进程崩溃的问题 <a href="https://github.com/moby/moby/pull/35765">moby/moby#35765</a></li><li>  修复 awslogs 批量大小计算大日志 <a href="https://github.com/moby/moby/pull/35726">moby/moby#35726</a></li></ul><h4 id="网络相关-7"><a href="#网络相关-7" class="headerlink" title="网络相关"></a>网络相关</h4><ul><li>  修复允许 docker 服务在 Windows VM 上启动 <a href="https://github.com/docker/libnetwork/pull/1916">docker/libnetwork#1916</a></li><li>  修复 docker 拦截 DNS 请求在 ICS 网络 <a href="https://github.com/docker/libnetwork/pull/2014">docker/libnetwork#2014</a></li><li>  Windows：添加了新的网络创建驱动程序选项 <a href="https://github.com/docker/libnetwork/pull/2021">docker / libnetwork＃2021</a></li></ul><h4 id="运行相关-7"><a href="#运行相关-7" class="headerlink" title="运行相关"></a>运行相关</h4><ul><li>  在容器启动时验证安装规范，以防止丢失主机路径 <a href="https://github.com/moby/moby/pull/35833">moby/moby#35833</a></li><li>  修复用户名称空间内的 overlay2 存储驱动程序 <a href="https://github.com/moby/moby/pull/35794">moby/moby#35794</a></li><li>  修复繁忙的错误在容器停止 <a href="https://github.com/moby/moby/pull/35674">moby/moby#35674</a></li><li>  修复未使用容器的工作目录的运行状况检查 <a href="https://github.com/moby/moby/pull/35845">moby/moby#35845</a></li><li>  修正了由于设置 fs 配额失败而导致 VFS 图形驱动程序初始化失败的问题 <a href="https://github.com/moby/moby/pull/35827">moby/moby#35827</a></li><li>  修正了被处理的两次容器事件 <a href="https://github.com/moby/moby/pull/35896">moby/moby#35896</a></li></ul><h4 id="集群相关-6"><a href="#集群相关-6" class="headerlink" title="集群相关"></a>集群相关</h4><ul><li>  修正了当服务具有相同数量的主机模式发布端口且发布端口为 0 时发布端口未被更新的问题 <a href="https://github.com/docker/swarmkit/pull/2376">docker/swarmkit#2376</a></li><li>  使任务终止顺序具有确定性 <a href="https://github.com/docker/swarmkit/pull/2265">docker/swarmkit#2265</a></li></ul><h3 id="版本号：17-12"><a href="#版本号：17-12" class="headerlink" title="版本号：17.12"></a>版本号：17.12</h3>  首次发布时间： 2017-12-27<h4 id="日志相关-8"><a href="#日志相关-8" class="headerlink" title="日志相关"></a>日志相关</h4><ul><li>  awslogs：修正大型日志批量大小计算 <a href="https://github.com/moby/moby/pull/35726">Moby / moby＃35726 的</a></li><li>  在 splunk 日志驱动程序中支持代理 <a href="https://github.com/moby/moby/pull/36220">moby / moby＃36220</a></li><li>  Logentries 驱动程序 line-only = true [] byte 输出修复 <a href="https://github.com/moby/moby/pull/35612">moby / moby＃35612</a></li><li>  Logentries 仅行徽标修复程序可保持向后兼容性 <a href="https://github.com/moby/moby/pull/35628">Moby / Moby＃35628</a></li><li>  为日志添加<code>--until</code>标志 <a href="https://github.com/moby/moby/pull/32914">moby/moby#32914</a></li><li>  将 Gelf 日志驱动程序插件添加到 Windows 构建 <a href="https://github.com/moby/moby/pull/35073">Moby / Moby＃35073</a></li><li>  在 splunk 批处理上设置超时发送 Moby <a href="https://github.com/moby/moby/pull/35496">/ Moby＃35496</a></li><li>  更新 Graylog2 / go-gelf <a href="https://github.com/moby/moby/pull/35765">moby / moby＃35765</a></li></ul><h4 id="网络相关-8"><a href="#网络相关-8" class="headerlink" title="网络相关"></a>网络相关</h4><ul><li>  从 17.09 升级到 17.12 时修复入口网络 <a href="https://github.com/moby/moby/pull/36003">Moby / Moby＃36003</a></li><li>  将详细信息添加到部分叠加层 ID <a href="https://github.com/moby/moby/pull/35989">Moby / moby＃35989</a></li><li>  修复如果启用了实时还原功能则取消配置的 IPv6 网络 <a href="https://github.com/docker/libnetwork/pull/2043">docker / libnetwork＃2043</a></li><li>  修复 watchMiss 线程上下文 <a href="https://github.com/docker/libnetwork/pull/2051">docker / libnetwork＃2051</a></li><li>  将负载均衡器沙箱创建 / 删除移动到 libnetwork <a href="https://github.com/moby/moby/pull/35422">moby / moby＃35422</a></li><li>  仅在容器元数据内刷新网络文件 <a href="https://github.com/moby/moby/pull/34224">＃34224</a></li><li>  查找网络恢复时的错误问题 <a href="https://github.com/moby/moby/pull/35634">moby/moby#35634</a></li><li>  修复使用网络连接器的 MIME 类型 <a href="https://github.com/moby/moby/pull/35542">Moby / moby＃35542</a></li><li>  增加了对持久化 Windows 网络驱动程序特定选项的支持 <a href="https://github.com/moby/moby/pull/35563">moby/moby#35563</a></li><li>  修复 netlink 套接字超时和监视泄漏 <a href="https://github.com/moby/moby/pull/35677">moby/moby#35677</a></li><li>  用于网络诊新的守护程序配置断 <a href="https://github.com/moby/moby/pull/35677">Moby / Moby＃35677</a></li><li>  清理节点管理逻辑 <a href="https://github.com/docker/libnetwork/pull/2036">docker / libnetwork＃2036</a></li><li>  还原端点时分配 VIPs <a href="https://github.com/docker/swarmkit/pull/2474">docker / swarmkit＃2474</a></li></ul><h4 id="打包相关-3"><a href="#打包相关-3" class="headerlink" title="打包相关"></a>打包相关</h4><ul><li>  在 docker.service 中设置任务最大值 <a href="https://github.com/docker/docker-ce-packaging/pull/78">docker/docker-ce-packaging#78</a></li><li>  为 Fedora 27 添加包服务 <a href="https://github.com/docker/docker-ce-packaging/pull/59">docker/docker-ce-packaging#59</a></li><li>  除非为打包指定了默认版本控制方案，否则将默认版本控制方案更改为 0.0.0-dev<a href="https://github.com/docker/docker-ce-packaging/pull/67">docker / docker-ce-packaging＃67</a></li><li>  将 Version 传递给 engine 静态构建 <a href="https://github.com/docker/docker-ce-packaging/pull/70">docker / docker-ce-packaging＃70</a></li><li>  在 Debian (stretch/jessie) 和 Ubuntu Zesty 或更新版本上增加了对 aarch64 的支持 <a href="https://github.com/docker/docker-ce-packaging/pull/35">docker/docker-ce-packaging#35</a></li></ul><h4 id="运行相关-8"><a href="#运行相关-8" class="headerlink" title="运行相关"></a>运行相关</h4><ul><li>  将 Golang 升至 1.9.4</li><li>  将容器升至 1.0.1</li><li>  修复 dockerd 重新启动后无法重新连接到容器的问题 <a href="https://github.com/moby/moby/pull/36173">Moby / Moby＃36173</a></li><li>  修复已处理两容器化事件<a href="https://github.com/moby/moby/issues/35891">＃35891</a></li><li>  修复由于无法设置 fs 配额而导致 vfs 图形驱动程序无法初始化的的问题 <a href="https://github.com/moby/moby/pull/35827">Moby / Moby＃35827</a></li><li>  修复不使用容器工作目录进行健康检查的回归 <a href="https://github.com/moby/moby/pull/35845">moby / moby＃35845</a></li><li>  荣誉<code>DOCKER_RAMDISK</code>与集装箱 1.0 <a href="https://github.com/moby/moby/pull/35957">moby/moby＃35957</a></li><li>  更新 Runc 来修复启动和执行期间的挂起 <a href="https://github.com/moby/moby/pull/36097">Moby / Moby＃36097</a></li><li>  Windows：Microsoft / hcsshim @ v.0.6.8 的供应商，部分修复了导入层失败的 <a href="https://github.com/moby/moby/pull/35924">moby / moby＃35924</a></li><li>  不要图形处理器目录成为私人挂载 <a href="https://github.com/moby/moby/pull/36047">moby / moby＃36047</a></li><li>  对来自守护进程根的挂载使用 rslave 传播 <a href="https://github.com/moby/moby/pull/36055">moby/moby#36055</a></li><li>  将守护程序根目录设置为使用共享的挂载传播 <a href="https://github.com/moby/moby/pull/36096">Moby / moby＃36096</a></li><li>  验证启动容器时是否存在安装的路径，而不仅仅是在创建期间存在 <a href="https://github.com/moby/moby/pull/35833">Moby / moby＃35833</a></li><li>  添加<code>REMOVE</code>并添加<code>ORPHANED</code>到 TaskState <a href="https://github.com/moby/moby/pull/36146">moby / moby＃36146</a></li><li>  修复了网络检查未显示群集范围网络的创建时间的问题 <a href="https://github.com/moby/moby/pull/36095">Moby / moby＃36095</a></li><li>  在释放 <a href="https://github.com/moby/moby/pull/36160">Moby</a> <a href="https://github.com/moby/moby/pull/36242">/ Moby</a> <a href="https://github.com/moby/moby/pull/36160">＃36130</a> 和 <a href="https://github.com/moby/moby/pull/36160">Moby</a> <a href="https://github.com/moby/moby/pull/36242">/ Moby</a> <a href="https://github.com/moby/moby/pull/36160">＃36343</a> 时清空容器读写层</li><li>  更新到容器化 v1.0.0 <a href="https://github.com/moby/moby/pull/35707">Moby / Moby＃35707</a></li><li>  让 VFS graphdriver 使用加速的内核内复制 <a href="https://github.com/moby/moby/pull/35537">Moby / Moby＃35537</a></li><li>  修复如果在 docker 构建过程中缺少构建参数，则不会显示错误</li><li>  Go 升级到 1.9.2 <a href="https://github.com/moby/moby/pull/33892">Moby / Moby＃33892</a> <a href="https://github.com/docker/cli/pull/716">docker / cli＃716</a></li><li>  <code>/dev</code>应该可以用<code>--readonly</code>标记为只读<a href="https://github.com/moby/moby/pull/35344">＃35344</a></li><li>  添加自定义构建时图形处理器优先级列表 <a href="https://github.com/moby/moby/pull/35522">moby / moby＃35522</a></li><li>  LCOW：CLI 更改为添加平台标志 - 拉，运行，创建和构建 <a href="https://github.com/docker/cli/pull/474">docker / cli＃474</a></li><li>  在 windows 下调整了<code>docker exec</code>的宽高 <a href="https://github.com/moby/moby/pull/35631">＃35631</a></li><li>  检测 4.0 之前的内核对 overlay2 的支持 <a href="https://github.com/moby/moby/pull/35527">Moby / Moby＃35527</a></li><li>  分离器：在取消挂载以后移除根挂载目录 <a href="https://github.com/moby/moby/pull/34573">moby/moby#34573</a></li><li>  不允许在 NFS 之上覆盖 / 覆盖 2 <a href="https://github.com/moby/moby/pull/35483">moby/moby#35483</a></li><li>  修复插件设置期间可能出现的紧急情况。<a href="https://github.com/moby/moby/pull/35632">moby/moby＃35632</a></li><li>  修正了锁定容器的一些问题 <a href="https://github.com/moby/moby/pull/35501">moby/moby#35501</a></li><li>  修复插件重新计数的一些问题 <a href="https://github.com/moby/moby/pull/35265">moby/moby#35265</a></li><li>  添加 VFS 配额支持 <a href="https://github.com/moby/moby/pull/35231">Moby / Moby＃35231</a></li><li>  跳过先前的 Graphdriver 检测中的空目录 <a href="https://github.com/moby/moby/pull/35528">Moby/ Moby＃35528</a></li><li>  在用户命名空间中运行时跳过 XFS 配额测试 <a href="https://github.com/moby/moby/pull/35526">Moby / Moby</a></li><li>  向配置选项添加了 SubSecondPrecision。<a href="https://github.com/moby/moby/pull/35529">Moby / Moby＃35529</a></li><li>  更新 fsnotify 以修复删除手表时的死锁 <a href="https://github.com/moby/moby/pull/35453">moby/moby#35453</a></li><li>  修复使用<code>--tmpfs /dev/shm</code>时的 “duplicate mount point” 问题 <a href="https://github.com/moby/moby/pull/35467">＃35467</a></li><li>  修复用户使用 <code>/dev/shm</code> 挂载时调整 tmpf 大小的问题 <a href="https://github.com/moby/moby/pull/35316">moby/moby#35316</a></li><li>  修复覆盖和 v4.13 + 内核下的 EBUSY 错误 <a href="https://github.com/moby/moby/pull/34948">moby/moby#34948</a></li><li>  容器：保护健康监控器通道 <a href="https://github.com/moby/moby/pull/35482">Moby / Moby＃35482</a></li><li>  容器：使用互斥锁保护健康状况<a href="https://github.com/moby/moby/pull/35517">＃35517</a></li><li>  容器：更新实时资源 <a href="https://github.com/moby/moby/pull/33731">Moby / Moby＃33731</a></li><li>  当卷仅远程存在时创建标签 <a href="https://github.com/moby/moby/pull/34896">moby / moby＃34896</a></li><li>  修复泄漏的容器 / 执行器状态 <a href="https://github.com/moby/moby/pull/35484">Moby / Moby＃35484</a></li><li>  禁止使用旧版（v1）注册表 <a href="https://github.com/moby/moby/pull/35751">moby / moby＃35751</a> 和 <a href="https://github.com/moby/moby/pull/35751">docker</a> <a href="https://github.com/docker/cli/pull/747">/ cli＃747</a></li><li>  Windows：针对生成器缓存 <a href="https://github.com/moby/moby/pull/35793">Moby / moby＃35793</a> 修复不区分大小写的文件名匹配</li><li>  修复围绕流程处理和错误检查的竞争条件 <a href="https://github.com/moby/moby/pull/35809">Moby / Moby＃35809</a></li><li>  确保在守护程序启动时停止容器 <a href="https://github.com/moby/moby/pull/35805">moby / moby＃35805</a></li><li>  遵循容器命名空间约定 <a href="https://github.com/moby/moby/pull/35812">moby / moby＃35812</a></li></ul><h4 id="集群相关-7"><a href="#集群相关-7" class="headerlink" title="集群相关"></a>集群相关</h4><ul><li>  从群模式删除 watchMiss<a href="https://github.com/docker/libnetwork/pull/2047">docker / libnetwork＃20417</a></li><li>  添加了对集群服务隔离模式 <a href="https://github.com/moby/moby/pull/34424">moby / moby＃34424</a></li><li>  修复任务清理工作以完成 <a href="https://github.com/docker/swarmkit/pull/2477">docker / swarmkit＃2477</a></li></ul><h4 id="客户端相关-8"><a href="#客户端相关-8" class="headerlink" title="客户端相关"></a>客户端相关</h4><ul><li>  修复<code>node-generic-resource</code>错别字 <a href="https://github.com/moby/moby/pull/35970">Moby</a> <a href="https://github.com/moby/moby/pull/36125">/ Moby</a> <a href="https://github.com/moby/moby/pull/35970">＃35970</a> 和 <a href="https://github.com/moby/moby/pull/35970">Moby</a> <a href="https://github.com/moby/moby/pull/36125">/ Moby＃36125</a></li><li>  从堆栈部署配置上的守护程序返回错误创建 / 更新 <a href="https://github.com/docker/cli/pull/757">docker / cli＃757</a></li><li>  在 cli / compose 中删除密钥 / 配置重复项 <a href="https://github.com/docker/cli/pull/671">docker / cli＃671</a></li><li>  将<code>--local</code>标志添加到<code>docker trust sign</code> <a href="https://github.com/docker/cli/pull/575">docker / cli＃575</a></li><li>  添加<code>docker trust inspect</code> <a href="https://github.com/docker/cli/pull/694">docker / cli＃694</a></li><li>  <code>name</code>在机密和配置中添加字段以允许在 Compose 文件中进行插值 <a href="https://github.com/docker/cli/pull/668">docker / cli＃668</a></li><li>  添加<code>--isolation</code>用于设置集群服务隔离模式 <a href="https://github.com/docker/cli/pull/426">docker / cli＃426</a></li><li>  删除不建议使用的 “守护程序” 子命令 <a href="https://github.com/docker/cli/pull/689">docker / cli＃689</a></li><li>  修复<code>rmi -f</code>具有意外错误 <a href="https://github.com/docker/cli/pull/654">docker / cli＃654 的行为</a></li><li>  服务中的集成通用资源创建 <a href="https://github.com/docker/cli/pull/429">docker / cli＃429</a></li><li>  修复堆栈的外部网络 <a href="https://github.com/docker/cli/pull/743">docker / cli＃743</a></li><li>  删除对通过镜像 Shortid docker <a href="https://github.com/docker/cli/pull/753">/ cli＃753</a> 和 <a href="https://github.com/moby/moby/pull/35790">moby / moby＃35790</a> 引用镜像的支持</li><li>  使用 commit-sha 代替标记的集装箱式 <a href="https://github.com/moby/moby/pull/35770">Moby / Moby＃35770</a></li></ul><h4 id="文档相关-1"><a href="#文档相关-1" class="headerlink" title="文档相关"></a>文档相关</h4><ul><li>  更新 1.35 的 API 版本历史记录 <a href="https://github.com/moby/moby/pull/35724">Moby / moby＃35724</a></li></ul><h4 id="构造相关-7"><a href="#构造相关-7" class="headerlink" title="构造相关"></a>构造相关</h4><ul><li>  修正了为断开符号链接构建缓存散列的问题 <a href="https://github.com/moby/moby/pull/34271">moby/moby#34271</a></li><li>  修复长码流同步 <a href="https://github.com/moby/moby/pull/35404">Moby / Moby＃35404</a></li><li>  修复 dockerfile 解析器在长令牌上静默失败的问题 <a href="https://github.com/moby/moby/pull/35429">moby/moby#35429</a></li></ul><h4 id="已知问题-2"><a href="#已知问题-2" class="headerlink" title="已知问题"></a>已知问题</h4><ul><li>  运行状况检查不再使用容器的工作目录 <a href="https://github.com/moby/moby/issues/35843">moby / moby＃35843</a></li><li>  客户端未从堆栈部署配置中返回错误 <a href="https://github.com/docker/cli/pull/757">Moby / Moby＃757</a></li><li>  Docker 在使用 systemd 选项时不能使用内存限制 <a href="https://github.com/moby/moby/issues/35123">moby/moby#35123</a></li></ul><h3 id="版本号：17-11"><a href="#版本号：17-11" class="headerlink" title="版本号：17.11"></a>版本号：17.11</h3>  首次发布时间： 2017-11-20<blockquote><p><strong>重要提示</strong>：Docker CE 17.11 是基于<a href="https://github.com/containerd/containerd/releases/tag/v1.0.0-beta.2">容器化 1.0 beta</a> 的第一个 Docker 版本 。Docker CE 17.11 和更高版本无法识别以早期 Docker 版本开头的容器。如果使用 <a href="https://docs.docker.com/engine/admin/live-restore/#enable-the-live-restore-option">Live Restore</a>，则必须先停止所有容器，然后才能升级到 Docker CE 17.11。如果不这样做，那么在升级后，Docker 将无法识别早于 17.11 的 Docker 版本启动的任何容器，并且它们会在系统上不受管理地继续运行。</p></blockquote><h4 id="构造相关-8"><a href="#构造相关-8" class="headerlink" title="构造相关"></a>构造相关</h4><ul><li>  使用 rm / force-rm 矩阵测试和修复构建<a href="https://github.com/moby/moby/pull/35139">＃35139</a></li><li>  <code>--stream</code>使用大型上下文修复构建<a href="https://github.com/moby/moby/pull/35404">＃35404</a></li></ul><h4 id="客户端相关-9"><a href="#客户端相关-9" class="headerlink" title="客户端相关"></a>客户端相关</h4><ul><li>  从帮助输出隐藏帮助标志 <a href="https://github.com/docker/cli/pull/645">docker / cli＃645</a></li><li>  支持解析组成管道的命名管道 <a href="https://github.com/docker/cli/pull/560">docker / cli＃560</a></li><li>  [Compose] 在插值后将值转换为期望的类型 <a href="https://github.com/docker/cli/pull/601">docker / cli＃601</a></li><li>  在上添加 “秘密” 和“配置”的输出<code>docker stack deploy</code><a href="https://github.com/docker/cli/pull/593">docker / cli＃593</a></li><li>  修复标志说明<code>--host-add</code><a href="https://github.com/docker/cli/pull/648">docker / cli＃648</a></li><li>  不截断 docker service ps 上的 ID –quiet <a href="https://github.com/docker/cli/pull/579">docker / cli＃579</a></li></ul><h4 id="弃用-3"><a href="#弃用-3" class="headerlink" title="弃用"></a>弃用</h4><ul><li>  为同步服务更新更新 bash 完成和弃用 <a href="https://github.com/docker/cli/pull/610">docker / cli＃610</a></li></ul><h4 id="日志相关-9"><a href="#日志相关-9" class="headerlink" title="日志相关"></a>日志相关</h4><ul><li>  复制到日志驱动程序的 bufsize，修复＃34887 <a href="https://github.com/moby/moby/pull/34888">moby/moby#34888</a></li><li>  添加对 GELF 日志驱动程序 TCP 支持 <a href="https://github.com/moby/moby/pull/34758">moby / moby＃34758 的</a></li><li>  为 awslogs 驱动程序添加凭据端点选项 <a href="https://github.com/moby/moby/pull/35055">moby/moby#35055</a></li></ul><h4 id="网络相关-9"><a href="#网络相关-9" class="headerlink" title="网络相关"></a>网络相关</h4><ul><li>  修复删除网络名称掩盖网络 ID<a href="https://github.com/moby/moby/pull/34509">Moby / moby＃34509</a></li><li>  修复了从 500 到 409 的网络创建返回的错误代码 <a href="https://github.com/moby/moby/pull/35030">Moby / Moby＃35030</a></li><li>  修复任务失败，错误为 “无法完成原子操作，已修改密钥” <a href="https://github.com/docker/libnetwork/pull/2004">docker / libnetwork＃2004</a></li></ul><h4 id="运行相关-9"><a href="#运行相关-9" class="headerlink" title="运行相关"></a>运行相关</h4><ul><li>  切换到 Containered 1.0 客户端 <a href="https://github.com/moby/moby/pull/34895">Moby / Moby＃34895</a></li><li>  在 Windows 上增加容器默认关闭超时 <a href="https://github.com/moby/moby/pull/35184">Moby / Moby＃35184</a></li><li>  LCOW：API：添加<code>platform</code>到 / images / create 和 / build <a href="https://github.com/moby/moby/pull/34642">moby / moby＃34642</a></li><li>  停止按版本过滤 Windows 清单列表 <a href="https://github.com/moby/moby/pull/35117">Moby / Moby＃35117</a></li><li>  使用来自 Azure / go-ansiterm 的 Windows 控制台模式常量 <a href="https://github.com/moby/moby/pull/35056">moby / moby＃35056</a></li><li>  Windows 守护程序应遵守 DOCKER_TMPDIR Moby <a href="https://github.com/moby/moby/pull/35077">/ moby＃35077</a></li><li>  Windows：修复启动日志记录 <a href="https://github.com/moby/moby/pull/35253">Moby / Moby＃35253</a></li><li>  在 Windows 版本拉取筛选的支持 <a href="https://github.com/moby/moby/pull/35090">moby / moby＃35090</a></li><li>  在容器 1.0 引入回归后修正了 LCOW <a href="https://github.com/moby/moby/pull/35320">moby/moby#35320</a></li><li>  ContainerWait on remove：不要卡在 rm 上失败 <a href="https://github.com/moby/moby/pull/34999">moby / moby＃34999</a></li><li>  oci：对于用户命名空间的守护程序, 遵循 CL_UNPRIVILEGED <a href="https://github.com/moby/moby/pull/35205">＃35205</a></li><li>  设置 may_detach_mounts 时不要中止 <a href="https://github.com/moby/moby/pull/35172">moby / moby＃35172</a></li><li>  实时还原容器时修复 get 容器 pid 上的异常<a href="https://github.com/moby/moby/pull/35157">＃35157</a></li><li>  <code>/proc/scsi</code>容器的遮罩路径，以防止移除设备（CVE-2017-16539）Moby <a href="https://github.com/moby/moby/pull/35399">/</a> Moby <a href="https://github.com/moby/moby/pull/35399">＃35399</a></li><li>  更新至 github.com/vbatts/<a href="mailto:&#x74;&#97;&#x72;&#45;&#115;&#x70;&#x6c;&#105;&#x74;&#x40;&#118;&#x30;&#x2e;&#x31;&#48;&#x2e;&#x32;">&#x74;&#97;&#x72;&#45;&#115;&#x70;&#x6c;&#105;&#x74;&#x40;&#118;&#x30;&#x2e;&#x31;&#48;&#x2e;&#x32;</a>（CVE-2017-14992）moby <a href="https://github.com/moby/moby/pull/35424">/ moby＃35424</a></li></ul><h4 id="集群相关-8"><a href="#集群相关-8" class="headerlink" title="集群相关"></a>集群相关</h4><ul><li>  由于 swarmkit 中新的 ipam 选项而修改了集成测试<a href="https://github.com/moby/moby/pull/35103">＃35103</a></li><li>  修复获取集群信息的僵局 [Moby / Moby＃35388(<a href="https://github.com/moby/moby/pull/35388">https://github.com/moby/moby/pull/35388</a>)</li><li>  扩展 TaskStatus 中的 Err 字段的范围，以同时覆盖阻止任务进行的非终端错误 <a href="https://github.com/docker/swarmkit/pull/2287">docker/swarmkit#2287</a></li></ul><h4 id="打包相关-4"><a href="#打包相关-4" class="headerlink" title="打包相关"></a>打包相关</h4><ul><li>  为 Debian 10（Buster）构建软件包 <a href="https://github.com/docker/docker-ce-packaging/pull/50">docker / docker-ce-packaging＃50</a></li><li>  为 Ubuntu 17.10（Artful）构建软件包 <a href="https://github.com/docker/docker-ce-packaging/pull/55">docker / docker-ce-packaging＃55</a></li></ul><h3 id="版本号：17-10"><a href="#版本号：17-10" class="headerlink" title="版本号：17.10"></a>版本号：17.10</h3>  首次发布时间： 2017-10-17<blockquote><p><strong>重要提示</strong>：本版本开始，<code>docker service create</code>，<code>docker service update</code>， <code>docker service scale</code>和<code>docker service rollback</code>使用非分离模式作为默认情况下，使用<code>--detach</code>以保持原来的行为。</p></blockquote><h4 id="构造相关-9"><a href="#构造相关-9" class="headerlink" title="构造相关"></a>构造相关</h4><ul><li>  在上传的构建上下文中将 uid / gid 重置为 0 以与其他客户端共享构建缓存 <a href="https://github.com/docker/cli/pull/513">docker / cli＃513</a></li><li>  添加对<code>ADD</code>没有任何子路的 URL 支持路径 <a href="https://github.com/moby/moby/pull/34217">Moby / Moby＃34217</a></li></ul><h4 id="客户端相关-10"><a href="#客户端相关-10" class="headerlink" title="客户端相关"></a>客户端相关</h4><ul><li>  将输出<code>docker stack rm</code>移至 stdout <a href="https://github.com/docker/cli/pull/491">docker / cli＃491</a></li><li>  在 cli 中将自然排序用于机密和配置 <a href="https://github.com/docker/cli/pull/307">docker / cli＃307</a></li><li>  <code>docker service</code>命令默认使用非分离模式 <a href="https://github.com/docker/cli/pull/525">docker / cli＃525</a></li><li>  在客户端设置 APIVersion，即使 Ping 失败 <a href="https://github.com/docker/cli/pull/546">docker/cli#546</a></li><li>  修复关于<code>docker stack deploy</code> 在不同编译语法的加载器错误 <a href="https://github.com/docker/cli/pull/544">docker/cli#544</a></li><li>  更改默认<code>docker container stats</code>显示格式为 show <code>CONTAINER ID</code>和<code>NAME</code> <a href="https://github.com/docker/cli/pull/565">docker / cli＃565</a></li><li>  将<code>--no-trunc</code>标志添加到<code>docker container stats</code> <a href="https://github.com/docker/cli/pull/565">docker / cli＃565</a></li><li>  添加实验<code>docker trust</code>：<code>view</code>，<code>revoke</code>，<code>sign</code>子<a href="https://github.com/docker/cli/pull/472">泊坞窗 / CLI＃472</a></li><li>  各种文档和 Shell 完成修复程序 <a href="https://github.com/docker/cli/pull/610">docker / cli＃610</a> <a href="https://github.com/docker/cli/pull/611">docker / cli＃611</a> <a href="https://github.com/docker/cli/pull/618">docker / cli＃618</a> <a href="https://github.com/docker/cli/pull/580">docker / cli＃580</a> <a href="https://github.com/docker/cli/pull/598">docker / cli＃598</a> <a href="https://github.com/docker/cli/pull/603">docker / cli＃603</a></li></ul><h4 id="网络相关-10"><a href="#网络相关-10" class="headerlink" title="网络相关"></a>网络相关</h4><ul><li>  在 windows 上使用每个节点、每个网络 LB 端点启用 ILB/ELB <a href="https://github.com/moby/moby/pull/34674">moby/moby#34674</a></li><li>  临时 IP 重用的覆盖修复 <a href="https://github.com/docker/libnetwork/pull/1935">docker / libnetwork＃1935</a></li><li>  序列化 bitseq alloc <a href="https://github.com/docker/libnetwork/pull/1788">docker / libnetwork＃1788</a></li><li>  在链上禁用主机名查找检查 <a href="https://github.com/docker/libnetwork/pull/1974">docker / libnetwork＃1974</a></li></ul><h4 id="运行相关-10"><a href="#运行相关-10" class="headerlink" title="运行相关"></a>运行相关</h4><ul><li>  LCOW：在拆解 Moby / Moby 之前抓住日志来增加 UVM 的可调试性<a href="https://github.com/moby/moby/pull/34846">＃34846</a></li><li>  LCOW：为绑定安装做准备 <a href="https://github.com/moby/moby/pull/34258">Moby / moby＃34258</a></li><li>  LCOW：支持 docker cp，在 builda 上添加 / 复制 <a href="https://github.com/moby/moby/pull/34252">moby/moby#34252</a></li><li>  LCOW：VHDX 引导到只读 <a href="https://github.com/moby/moby/pull/34754">Moby / Moby＃34754</a></li><li>  卷: 在重新标记挂载源之前评估符号链接 <a href="https://github.com/moby/moby/pull/34792">moby/moby#34792</a></li><li>  修改 “docker cp” 以允许在主机 symlinked 目录中添加新的目标文件名 <a href="https://github.com/moby/moby/pull/31993">moby/moby#31993</a></li><li>  增加了对 Windows 的拉取版本过滤 <a href="https://github.com/moby/moby/pull/35090">moby/moby#35090</a></li></ul><h4 id="集群相关-9"><a href="#集群相关-9" class="headerlink" title="集群相关"></a>集群相关</h4><ul><li>  如果<code>docker swarm init --force-new-cluster</code>在辅助节点上执行, 则会产生错误 <a href="https://github.com/moby/moby/pull/34881">Moby / moby＃34881</a></li><li>  加对. node 的支持。群集服务中的主机名模板 <a href="https://github.com/moby/moby/pull/34686">moby/moby#34686</a></li><li>  将 gRPC 请求超时增加到 20 秒以发送快照 <a href="https://github.com/docker/swarmkit/pull/2391">docker / swarmkit＃2391</a></li><li>  如果日志驱动程序设置为<code>none</code>，不要过滤节点 <a href="https://github.com/docker/swarmkit/pull/2396">docker/swarmkit#2396</a></li><li>  将 ipam 选项添加到 ipam 驱动程序请求 <a href="https://github.com/docker/swarmkit/pull/2324">docker / swarmkit＃2324</a></li></ul><h3 id="版本号：17-09"><a href="#版本号：17-09" class="headerlink" title="版本号：17.09"></a>版本号：17.09</h3>  首次发布时间： 2017-12-07<h4 id="构造相关-10"><a href="#构造相关-10" class="headerlink" title="构造相关"></a>构造相关</h4><ul><li>修复共享父级上的配置泄漏 <a href="https://github.com/moby/moby/issues/33753">Moby / Moby＃33753</a></li><li>仅在空的连续行上警告，而不仅仅在注释行上警告 <a href="https://github.com/moby/moby/pull/35004">moby / moby＃35004</a></li><li>将<code>--chown</code>标记添加到<code>ADD/COPY</code>Dockerfile Moby <a href="https://github.com/moby/moby/pull/34263">/ moby＃34263 中的命令</a></li><li>  从 git 仓库构建时修复克隆不需要的文件 <a href="https://github.com/moby/moby/pull/33704">moby / moby＃33704</a></li></ul><h4 id="客户端相关-11"><a href="#客户端相关-11" class="headerlink" title="客户端相关"></a>客户端相关</h4><ul><li>  即使 Ping 失败也可以在客户端上设置 API 版本 <a href="https://github.com/docker/cli/pull/546">docker / cli＃546</a></li><li>  允许使用构成格式为 v3.4 版本的扩展字段 <a href="https://github.com/docker/cli/pull/452">docker / cli＃452</a></li><li>  撰写文件允许为非外部卷指定名称 <a href="https://github.com/docker/cli/pull/306">docker / cli＃306</a></li><li>  支持<code>--compose-file -</code>作为标准 <a href="https://github.com/docker/cli/pull/347">docker/ CLI＃347</a></li><li>  <code>start_period</code>在 Docker Compose 中持运行状况检查 <a href="https://github.com/docker/cli/pull/475">docker / cli＃475</a></li><li>  支持<code>stop-signal</code>在 Docker 堆栈命令 <a href="https://github.com/docker/cli/pull/388">docker / cli＃388 中</a></li><li>  在撰写部署添加对更新顺序的支持 <a href="https://github.com/docker/cli/pull/360">docker / cli＃360 中</a></li><li>  将 ulimits 添加到不受支持的撰写字段 <a href="https://github.com/docker/cli/pull/482">docker / cli＃482</a></li><li>  添加<code>--format</code>到<code>docker-search</code> <a href="https://github.com/docker/cli/pull/440">docker / cli＃440</a></li><li>  以<code>&#123;&#123;.Digest&#125;&#125;</code>格式显示镜像摘要 <a href="https://github.com/docker/cli/pull/439">docker / cli＃439</a></li><li>  在<code>docker stack rm</code>on <code>stdout</code>而不是<code>stderr</code>上打印输出 <a href="https://github.com/docker/cli/pull/491">docker / cli＃491</a></li><li>  修复<code>docker history --format &#123;&#123;json .&#125;&#125;</code>时打印人类可读的时间戳而不是 ISO8601 的时间戳<code>--human=true</code><a href="https://github.com/docker/cli/pull/438">docker / cli＃438</a></li><li>  修复<code>docker stack deploy</code>何时使用秘密或配置的幂等性 <a href="https://github.com/docker/cli/pull/509">docker / cli＃509</a></li><li>  修复随机主机端口显示 <a href="https://github.com/docker/cli/pull/404">docker / cli＃404 的</a></li><li>  修复使用多个加密连接的时候创建服务时重启冗余服务 <a href="https://github.com/moby/moby/issues/34746">Moby / Moby＃34746</a></li></ul><h4 id="网络相关-11"><a href="#网络相关-11" class="headerlink" title="网络相关"></a>网络相关</h4><ul><li>  临时 IP 重用的覆盖修复 <a href="https://github.com/docker/libnetwork/pull/2016">docker / libnetwork＃2016</a></li><li>  修复 NetworkDB 中的 reapTime 逻辑并处理可连接容器的 DNS 清理 <a href="https://github.com/docker/libnetwork/pull/2017">docker / libnetwork＃2017</a></li><li>  在链上禁用主机名查找检查 <a href="https://github.com/docker/libnetwork/pull/2019">docker / libnetwork＃2019</a></li><li>  修复皮棉问题 <a href="https://github.com/docker/libnetwork/pull/2020">docker / libnetwork＃2020</a></li><li>  在 FindNetwork Moby <a href="https://github.com/moby/moby/pull/35634">/</a> Moby 中恢复错误类型<a href="https://github.com/moby/moby/pull/35634">＃35634</a></li><li>  在守护程序配置添加控制平面 MTU 选项 <a href="https://github.com/moby/moby/pull/34103">moby / moby＃34103 中</a></li><li>  将服务虚拟 IP 添加到沙箱的环回地址 <a href="https://github.com/docker/libnetwork/pull/1877">docker / libnetwork＃1877</a></li></ul><h4 id="运行相关-11"><a href="#运行相关-11" class="headerlink" title="运行相关"></a>运行相关</h4><ul><li>  保护<code>health monitor</code>Go Channel <a href="https://github.com/moby/moby/pull/35482">Moby / Moby＃35482</a></li><li>  修复泄漏的容器 / 执行器状态 <a href="https://github.com/moby/moby/pull/35484">Moby / Moby＃35484</a></li><li>  将 / proc / scsi 添加到被屏蔽的路径（补丁程序可解决 [moby / moby /＃35399](<a href="http://cve.mitre.org/cgi-bin/cvename.cgi?&gt;CVE-2017-16539">http://cve.mitre.org/cgi-bin/cvename.cgi?&gt;CVE-2017-16539</a></a>）&lt;a href=)</li><li>  供应商 tar 拆分：修复了防止内存耗尽的问题，该问题可能导致 Docker 守护进程 <a href="https://github.com/moby/moby/pull/35424">moby / moby /＃35424 崩溃</a>修复了 [＃34837](<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?&gt;CVE-2017-14992">https://cve.mitre.org/cgi-bin/cvename.cgi?&gt;CVE-2017-14992</a></a></li><li> 修复 P / Z HubPullSuite 测试 Moby / Moby &lt;a href=)</li><li>  Windows：增加对拉取版本过滤的支持 <a href="https://github.com/moby/moby/pull/35090">moby / moby＃35090</a></li><li>  Windows：停止按版本过滤 Windows 清单列表 <a href="https://github.com/moby/moby/pull/35117">Moby / moby＃35117</a></li><li>  在 chroot 存档中使用 rslave 而不是 rprivate <a href="https://github.com/moby/moby/pull/35217">moby/moby/#35217</a></li><li>  卸载后删除容器 rootfs 挂载路径 <a href="https://github.com/moby/moby/pull/34573">moby/moby#34573</a></li><li>  修正用户 / dev / shm mount 的 tmpfs 大小 <a href="https://github.com/moby/moby/pull/35316">moby / moby＃35316</a></li><li>  设置 may_detach_mounts 时不要中止（改为记录错误） <a href="https://github.com/moby/moby/pull/35172">moby / moby＃35172</a></li><li>  兼容 API 版本时修复版本比较 <a href="https://github.com/moby/moby/pull/35008">Moby / Moby＃35008</a></li><li>  Graphdriver：在 Aufs Moby <a href="https://github.com/moby/moby/pull/34430">/</a> Moby 上提升 overlay2 <a href="https://github.com/moby/moby/pull/34430">＃34430</a></li><li>  LCOW：VHD 启动其他标志 <a href="https://github.com/moby/moby/pull/34451">moby / moby＃34451</a></li><li>  LCOW：请勿阻止出口 <a href="https://github.com/moby/moby/pull/34448">moby/moby#34448</a></li><li>  LCOW：动态沙箱管理 <a href="https://github.com/moby/moby/pull/34170">Moby / Moby＃34170</a></li><li>  LCOW：强制 Hyper-V 隔离 <a href="https://github.com/moby/moby/pull/34468">Moby / Moby＃34468</a></li><li>  LCOW：将 toolsScratchPath 移至 / tmp <a href="https://github.com/moby/moby/pull/34396">moby / moby＃34396</a></li><li>  LCOW：删除硬编码 <a href="https://github.com/moby/moby/pull/34398">Moby / moby＃34398</a></li><li>  LCOW：WORKDIR 正确处理 Moby <a href="https://github.com/moby/moby/pull/34405">/ Moby＃34405</a></li><li>  Windows：命名管道安装 <a href="https://github.com/moby/moby/pull/33852">Moby / Moby＃33852</a></li><li>  修复使用 SELinux 强制模式访问卷时的 “权限被拒绝” 错误 <a href="https://github.com/moby/moby/pull/34684">moby / moby＃34684</a></li><li>  修复层大小报告在 <code>docker system df</code> 为<code>0</code> <a href="https://github.com/moby/moby/pull/34826">moby/moby#34826</a></li><li>  修复了在基于 RHEL 7.4 的内核上删除容器时一些 “设备或资源繁忙” 的错误 <a href="https://github.com/moby/moby/pull/34886">moby / moby＃34886</a></li></ul><h4 id="集群相关-10"><a href="#集群相关-10" class="headerlink" title="集群相关"></a>集群相关</h4><ul><li>  发送快照时增加 gRPC 请求超时 <a href="https://github.com/docker/swarmkit/pull/2404">docker / swarmkit＃2404</a></li><li>  在没有日志驱动程序时修复节点过滤 <a href="https://github.com/docker/swarmkit/pull/2442">docker / swarmkit＃2442</a></li><li>  在尝试更改群集名称时添加错误 <a href="https://github.com/docker/swarmkit/pull/2454">docker / swarmkit /＃2454</a></li><li>  删除节点后删除节点附件 <a href="https://github.com/docker/swarmkit/pull/2456">docker / swarmkit /＃2456</a></li><li>  提供自定义 gRPC 拨号程序以覆盖默认代理拨号程序 <a href="https://github.com/docker/swarmkit/pull/2457">docker / swarmkit /＃2457</a></li><li>  避免对群信息进行递归读取 <a href="https://github.com/moby/moby/pull/35388">moby/moby#35388</a></li><li>  包括是否将群中的管理器作为一部分自动锁定为<code>docker info</code>部分 <a href="https://github.com/docker/cli/pull/471">docker / cli＃471</a></li><li>  添加’docker service rollback’子命令 <a href="https://github.com/docker/cli/pull/205">docker / cli＃205</a></li><li>  如果 gRPC 快照大于 4MB, 则修复管理器无法加入 <a href="https://github.com/docker/swarmkit/pull/2375">docker / swarmkit＃2375</a></li><li>  修复启用 SELinux 的容器中配置文件的 “权限被拒绝” 错误 <a href="https://github.com/moby/moby/pull/34732">moby / moby＃34732</a></li><li>  修复无法在 ARM 节点上部署服务 <a href="https://github.com/moby/moby/pull/34021">Moby / Moby＃34021</a></li></ul><h4 id="日志相关-10"><a href="#日志相关-10" class="headerlink" title="日志相关"></a>日志相关</h4><ul><li>  修复 Splunk 记录器在标签为空且使用原始模式时不传输日志数据的问题 <a href="https://github.com/moby/moby/pull/34520">Moby / Moby＃34520</a></li></ul><h4 id="打包相关-5"><a href="#打包相关-5" class="headerlink" title="打包相关"></a>打包相关</h4><ul><li>  在 Ubuntu 上为 ppc64el 构建脚本 <a href="https://github.com/docker/docker-ce-packaging/pull/43">docker/docker-ce-packaging#43</a></li></ul><h4 id="弃用-4"><a href="#弃用-4" class="headerlink" title="弃用"></a>弃用</h4><ul><li>  删除不赞成使用的<code>--enable-api-cors</code>守护程序标志 <a href="https://github.com/moby/moby/pull/34821">moby / moby＃34821</a></li></ul><h3 id="版本号：17-07"><a href="#版本号：17-07" class="headerlink" title="版本号：17.07"></a>版本号：17.07</h3>  首次发布时间： 2017-08-29<h4 id="API-和客户端"><a href="#API-和客户端" class="headerlink" title="API 和客户端"></a>API 和客户端</h4><ul><li>  在 config.json 添加对代理配置的支持 <a href="https://github.com/docker/cli/pull/93">docker / cli＃93</a></li><li>  默认情况下启用 pprof / debug 端点 <a href="https://github.com/moby/moby/pull/32453">moby / moby＃32453</a></li><li>  现在可以使用上的<code>STDIN</code>new <code>--password-stdin</code>标志来传递密码<code>docker login</code><a href="https://github.com/docker/cli/pull/271">docker / cli＃271</a></li><li>  添加<code>--detach</code>到 docker scale <a href="https://github.com/docker/cli/pull/243">docker / cli＃243</a></li><li>  防止<code>docker logs --no-stream</code>由于不存在的容器而挂起 <a href="https://github.com/moby/moby/pull/34004">Moby / Moby＃34004</a></li><li>  修复<code>docker stack ps</code>打印错误，<code>stdout</code>而不是<code>stderr</code> <a href="https://github.com/docker/cli/pull/298">docker / cli＃298</a></li><li>  修复<code>docker service create</code>在部署期间发生错误时进度条卡住的问题 <a href="https://github.com/docker/cli/pull/259">docker / cli＃259</a></li><li>  改进交互模式下进度条的显示方式 <a href="https://github.com/docker/cli/pull/260">docker / cli＃260</a> <a href="https://github.com/docker/cli/pull/237">docker / cli＃237</a></li><li>  如果<code>docker login --password</code>使用警告，打印警告，并建议使用<code>--password-stdin</code> <a href="https://github.com/docker/cli/pull/270">docker / cli＃270</a></li><li>  使 API 版本兼容更加健壮 <a href="https://github.com/moby/moby/pull/33827">moby / moby＃33827</a></li><li>  当连接到比 Docker 17.05 更老的守护进程时隐藏 <code>--detach</code> <a href="https://github.com/docker/cli/pull/219">docker / cli＃219</a></li><li>  在 <code>GET /networks/(id or name)</code> 添加 <code>scope</code> 过滤器 <a href="https://github.com/moby/moby/pull/33630">moby/moby#33630</a></li></ul><h4 id="构建相关"><a href="#构建相关" class="headerlink" title="构建相关"></a>构建相关</h4><ul><li>  实现长时间运行的交互式会话并逐步发送构建上下文 <a href="https://github.com/moby/moby/pull/32677">moby / moby＃32677 docker</a> <a href="https://github.com/docker/cli/pull/231">/ cli＃231</a> <a href="https://github.com/moby/moby/pull/33859">moby / moby＃33859</a></li><li>  警告空的连续行 <a href="https://github.com/moby/moby/pull/33719">Moby / Moby＃33719</a></li><li>  修复. dockerignore 包含前导 / 不匹配的条目 <a href="https://github.com/moby/moby/pull/32088">moby/moby#32088</a></li></ul><h4 id="日志相关-11"><a href="#日志相关-11" class="headerlink" title="日志相关"></a>日志相关</h4><ul><li>  修复错误的文件模式以旋转日志文件 <a href="https://github.com/moby/moby/pull/33926">Moby / Moby＃33926</a></li><li>  修复 Stderr 日志记录的日志记录和系统日志 Moby <a href="https://github.com/moby/moby/pull/33832">/</a> Moby <a href="https://github.com/moby/moby/pull/33832">＃33832</a></li></ul><h4 id="运行相关-12"><a href="#运行相关-12" class="headerlink" title="运行相关"></a>运行相关</h4><ul><li>  允许停止暂停的容器 <a href="https://github.com/moby/moby/pull/34027">Moby / Moby＃34027</a></li><li>  添加对 overlay2 存储驱动程序的配额支持 <a href="https://github.com/moby/moby/pull/32977">moby/moby#32977</a></li><li>  卸下上的容器锁<code>docker ps</code> <a href="https://github.com/moby/moby/pull/31273">＃31273</a></li><li>  将容器名称存储在 memdb 中 <a href="https://github.com/moby/moby/pull/33886">moby / moby＃33886</a></li><li>  修复<code>docker exec</code>和<code>docker pause</code>之间的竞争状况 <a href="https://github.com/moby/moby/pull/32881">＃32881</a><a href="https://github.com/moby/moby/pull/32881">Moby / Moby</a></li><li>  Devicemapper：重做日志记录并添加<code>--storage-opt dm.libdm_log_level</code> <a href="https://github.com/moby/moby/pull/33845">moby / moby＃33845</a></li><li>  Devicemapper：如果启用了延迟删除，但没有延迟删除，则防止 “设备正在使用” 错误 <a href="https://github.com/moby/moby/pull/33877">moby / moby＃33877</a></li><li>  Devicemapper：使用 KeepAlive 可以防止仍在使用中的任务垃圾收集 <a href="https://github.com/moby/moby/pull/33376">moby / moby＃33376</a></li><li>  如果取消修剪，请报告中间修剪结果 <a href="https://github.com/moby/moby/pull/33979">Moby / moby＃33979</a></li><li>  修复<code>docker rename new_name</code>同时运行导致具有多个名称 <a href="https://github.com/moby/moby/pull/33940">moby / moby＃33940</a></li><li>  修复文件描述符泄漏和错误处理 <a href="https://github.com/moby/moby/pull/33713">Moby / Moby＃33713</a></li><li>  在运行容器时修复 SIGSEGV<a href="https://github.com/docker/cli/pull/303">docker / cli＃303</a></li><li>  停止健康检查时防止 goroutine 泄漏 <a href="https://github.com/moby/moby/pull/33781">Moby / Moby＃33781</a></li><li>  图片：改进商店锁定 <a href="https://github.com/moby/moby/pull/33755">Moby / Moby＃33755</a></li><li>  修复在销毁容器时不会删除 Btrfs 配额组的问题 <a href="https://github.com/moby/moby/pull/29427">Moby / Moby＃29427</a></li><li>  Libcontainerd：修复无法正常获得已停用的容器进程 <a href="https://github.com/moby/moby/pull/33419">Moby / Moby＃33419</a></li><li>Windows 上 Linux 容器的准备<ul><li>  LCOW：服务 VM 公用程序专用暂存空间 <a href="https://github.com/moby/moby/pull/33809">moby / moby＃33809 的</a></li><li>  LCOW：支持大多数操作，但不包括远程文件系统 <a href="https://github.com/moby/moby/pull/33241">moby / moby＃33241</a> <a href="https://github.com/moby/moby/pull/33826">moby / moby＃33826</a></li><li>  LCOW：将目录从 lcow 更改为 “Linux 容器” <a href="https://github.com/moby/moby/pull/33835">moby / moby＃33835</a></li><li>  LCOW：传递命令参数而无需额外引用 <a href="https://github.com/moby/moby/pull/33815">moby / moby＃33815</a></li><li>  LCOW：由于平台架构更改需要进行更新 <a href="https://github.com/moby/moby/pull/33785">moby / moby＃33785</a></li></ul></li></ul><h4 id="集群相关-11"><a href="#集群相关-11" class="headerlink" title="集群相关"></a>集群相关</h4><ul><li>  支持可插入的加密后端 <a href="https://github.com/moby/moby/pull/34157">Moby</a> <a href="https://github.com/moby/moby/pull/34123">/</a> <a href="https://github.com/moby/moby/pull/34157">Moby＃34157 Moby</a> <a href="https://github.com/moby/moby/pull/34123">/</a> <a href="https://github.com/moby/moby/pull/34157">Moby＃34123</a></li><li>  使用自然排序群体堆栈和节点进行排序 <a href="https://github.com/docker/cli/pull/315">docker / cli＃315</a> 对</li><li>  engine 支持群集配置事件 <a href="https://github.com/moby/moby/pull/34032">Moby / Moby＃34032</a></li><li>  只有在加入集群的过程中才传递一个连接地址 <a href="https://github.com/docker/cli/pull/184">docker/cli#184</a></li><li>  修正服务创建时的错误，如果同名网络同时存在于 “本地” 和“群”范围内的网络 <a href="https://github.com/docker/cli/pull/184">docker/cli#184</a></li><li>  （实验性）添加对 swarm 的插件的支持 <a href="https://github.com/moby/moby/pull/33575">moby/moby#33575</a></li></ul><h3 id="版本号：17-06"><a href="#版本号：17-06" class="headerlink" title="版本号：17.06"></a>版本号：17.06</h3>  首次发布时间： 2017-06-28<blockquote><p><strong>注意</strong>：</p><ul><li>  Docker 17.06.0 在映像构建器中存在问题，导致<code>ADD</code>在引用远程<code>.tar.gz</code>文件时 Dockerfile 指令的行为发生变化。该问题将在 Docker 17.06.1 中修复。</li><li>  从 Docker CE 17.06 开始，使用 s390x 架构的 IBM Z 也可以使用 Ubuntu 软件包。</li><li>  默认情况下，Docker 17.06 禁用与旧版（v1）注册表的通信。如果需要与尚未迁移到 v2 协议的注册表进行交互，请设置<code>--disable-legacy-registry=false</code>守护程序选项。与 v1 注册表的交互将在 Docker 17.12 中删除。</li></ul></blockquote><h4 id="客户端相关-12"><a href="#客户端相关-12" class="headerlink" title="客户端相关"></a>客户端相关</h4><ul><li>  在客户端中启用 TCP 保持存活以防止失去连接 <a href="https://github.com/docker/cli/pull/415">docker / cli＃415</a></li><li>  在运行时将挂载卷设为可选<code>docker system prune</code>，并添加<code>--volumes</code>标志<a href="https://github.com/docker/docker-ce/pull/109">＃109</a></li><li>  在分配复制任务之前显示它们的进度<a href="https://github.com/docker/docker-ce/pull/97">＃97</a></li><li>  如果容器不存在，修复<code>docker wait</code>悬挂问题<a href="https://github.com/docker/docker-ce/pull/106">＃106</a></li><li>  如果<code>docker swarm ca</code>在没有<code>--rotate</code>标志的情况下被调用，则警告是否传递了其他标志<a href="https://github.com/docker/docker-ce/pull/110">＃110</a></li><li>  如果守护程序返回错误，则修复 API 版本协商不起作用 <a href="https://github.com/docker/docker-ce/pull/115">#115</a></li><li>  如果在系统修剪中将 “until” 过滤器与 “ –volumes” 结合使用，则打印错误<a href="https://github.com/docker/docker-ce/pull/154">＃154</a></li><li>  添加<code>--format</code>选项到<code>docker stack ls</code> <a href="https://github.com/moby/moby/pull/31557">＃31557</a></li><li>  在撰写的初始版本中添加对标签的支持 <a href="https://github.com/moby/moby/pull/32632">＃32632</a> <a href="https://github.com/moby/moby/pull/32972">＃32972</a></li><li>  添加<code>--format</code>选项到<code>docker history</code> <a href="https://github.com/moby/moby/pull/30962">＃30962</a></li><li>  添加<code>--format</code>选项到<code>docker system df</code> <a href="https://github.com/moby/moby/pull/31482">＃31482</a></li><li>  允许在堆栈文件中指定名称服务器和搜索域<a href="https://github.com/moby/moby/pull/32059">＃32059</a></li><li>  将<code>read_only</code>服务支持添加到<code>docker stack deploy</code> <a href="https://github.com/docker/cli/pull/73">＃docker / cli / 73</a></li><li>  显示 Swarm 集群和节点 TLS 信息<a href="https://github.com/docker/cli/pull/44">＃docker / cli / 44</a></li><li>  添加对位置设置的支持 <code>docker stack deploy</code> <a href="https://github.com/docker/cli/pull/35">#docker/cli/35</a></li><li>  添加新的<code>ca</code>子命令到<code>docker swarm</code>允许管理集群 CA <a href="https://github.com/docker/cli/pull/48">＃docker / cli / 48</a></li><li>  添加凭据规范<a href="https://github.com/docker/cli/pull/71">＃docker / cli / 71</a></li><li>  支持对 csv 格式的选项<code>--network</code>和<code>--network-add</code> <a href="https://github.com/docker/cli/pull/62">#docker/cli/62</a> <a href="https://github.com/moby/moby/pull/33130">#33130</a></li><li>  修复在 Windows 上堆栈绑定卷 <a href="https://github.com/docker/cli/pull/136">#docker/cli/136</a></li><li>  正确处理没有注册表信息的 Docker 守护程序<a href="https://github.com/docker/cli/pull/126">＃docker / cli / 126</a></li><li>  当使用 using –rollbac 时, 允许使用<code>--detach</code> and <code>--quiet</code> <a href="https://github.com/docker/cli/pull/144">#docker/cli/144</a></li><li>  从<code>docker login</code>中移除<code>--email</code> <a href="https://github.com/docker/cli/pull/143">#docker/cli/143</a></li><li>  调整<code>docker stats</code>内存输出<a href="https://github.com/docker/cli/pull/80">＃docker / cli / 80</a></li></ul><h4 id="集群相关-12"><a href="#集群相关-12" class="headerlink" title="集群相关"></a>集群相关</h4><ul><li>  忽略运行任务的 PullOptions <a href="https://github.com/docker/swarmkit/pull/2351">docker/swarmkit#2351</a></li><li>  不要将重复的平台信息添加到服务规格<a href="https://github.com/docker/docker-ce/pull/107">＃107</a></li><li>  集群更新和内存问题修复<a href="https://github.com/docker/docker-ce/pull/114">＃114</a></li><li>  更改获取网络请求以返回集群中的预定义网络 <a href="https://github.com/docker/docker-ce/pull/150">#150</a></li><li>  使用–data-path-addr 将 Swarm 控制面流量与应用程序数据流量隔离 <a href="https://github.com/moby/moby/pull/32717">＃32717</a></li><li>  允许在容器内指定一个秘密位置<a href="https://github.com/moby/moby/pull/32571">＃32571</a></li><li>  添加 Windows 加密支持 <a href="https://github.com/moby/moby/pull/32208">＃32208</a></li><li>  将 TLS 信息添加到集群信息和节点信息终端<a href="https://github.com/moby/moby/pull/32875">＃32875</a></li><li>  添加对服务的支持以携带任意配置对象<a href="https://github.com/moby/moby/pull/32336">＃32336</a>，<a href="https://github.com/docker/cli/pull/45">＃</a><a href="https://github.com/moby/moby/pull/32336">docker</a> <a href="https://github.com/docker/cli/pull/45">/ cli / 45</a>，<a href="https://github.com/moby/moby/pull/33169">＃33169</a></li><li>  添加 API 远程集群 CA 证书<a href="https://github.com/moby/moby/pull/32993">＃32993</a></li><li>  服务摘要提取现在在客户端处理 <a href="https://github.com/moby/moby/pull/32388">#32388</a>, <a href="https://github.com/moby/moby/pull/33239">#33239</a></li><li>  Placement 也考虑放到平台<a href="https://github.com/moby/moby/pull/33144">＃33144</a></li><li>  修复连接失败时可能挂起的问题<a href="https://github.com/docker/docker-ce/pull/19">＃docker-ce / 19</a></li><li>  修复了阻止外部 CA 被接受的问题<a href="https://github.com/moby/moby/pull/33341">＃33341</a></li><li>  修复混合版本集群中可能的编排异常<a href="https://github.com/docker/swarmkit/pull/2233">＃swarmkit / 2233</a></li><li>  避免在初始化期间分配重复的 IP <a href="https://github.com/docker/swarmkit/pull/2237">＃swarmkit / 2237</a></li></ul><h4 id="运行相关-13"><a href="#运行相关-13" class="headerlink" title="运行相关"></a>运行相关</h4><ul><li>  Devmapper: 确保 UdevWait 在调用 setCookie 之后被调用 <a href="https://github.com/moby/moby/pull/33732">moby/moby#33732</a></li><li>  Aufs: 确保差异层被正确地删除，以防止剩余的文件使用完存储空间 <a href="https://github.com/moby/moby/pull/34587">moby/moby#34587</a></li><li>  <code>healthcheck</code>停止时, 防止<code>goroutine</code> 泄露 <a href="https://github.com/docker/docker-ce/pull/90">#90</a></li><li>  不错误的重新标签时，重新标签不支持 <a href="https://github.com/docker/docker-ce/pull/92">＃92</a></li><li>  将 GRPC 连接的最大退避延迟限制为 2 秒<a href="https://github.com/docker/docker-ce/pull/94">＃94</a></li><li>  修复了由于某些内核中的错误而在指定内存 cgroup 时阻止容器运行的问题<a href="https://github.com/docker/docker-ce/pull/102">＃102</a></li><li>  修复暂停时容器不响应 SIGKILL 问题<a href="https://github.com/docker/docker-ce/pull/102">＃102</a></li><li>  改善了错误消息: 如果加载了不兼容的操作系统的映像<a href="https://github.com/docker/docker-ce/pull/108">＃108</a></li><li>  修复的手柄泄漏<code>go-winio[＃112](https://github.com/docker/docker-ce/pull/112)</code></li><li>  修复升级时的问题，阻止 Docker 在<code>--live-restore</code>启用时显示正在运行的容器<a href="https://github.com/docker/docker-ce/pull/117">＃117</a></li><li>  修复以下错误：使用机密的服务无法在使用<code>userns-remap</code>功能的守护程序上启动<a href="https://github.com/docker/docker-ce/pull/121">＃121</a></li><li>  修复错误处理并将<code>not-exist</code>错误移除<a href="https://github.com/docker/docker-ce/pull/142">＃142</a></li><li>  修复了显示不能用 SwaggerUI 加载 REST API Swagger <a href="https://github.com/docker/docker-ce/pull/156">#156</a></li><li>  添加构建和 engine 信息 Prometheus 指标<a href="https://github.com/moby/moby/pull/32792">＃32792</a></li><li>  更新容器到 d24f39e203aa6be4944f06dd0fe38a618a36c764 <a href="https://github.com/moby/moby/pull/33007">＃33007</a></li><li>  将 Runc 更新到 992a5be178a62e026f4069f443c6164912adbf09 <a href="https://github.com/moby/moby/pull/33007">＃33007</a></li><li>  为 devmapper 自动配置 blkdev 添加选项 <a href="https://github.com/moby/moby/pull/31104">＃31104</a></li><li>  将日志驱动程序列表添加到<code>docker info</code> <a href="https://github.com/moby/moby/pull/32540">＃32540</a></li><li>  添加 API 端点以允许检索镜像清单<a href="https://github.com/moby/moby/pull/32061">＃32061</a></li><li>  不删除容器从内存错误<code>forceremove</code> <a href="https://github.com/moby/moby/pull/31012">#31012</a></li><li>  添加对度量插件的支持<a href="https://github.com/moby/moby/pull/32874">＃32874</a></li><li>  当<code>prune</code>命令中使用了无效的过滤器时，返回错误<a href="https://github.com/moby/moby/pull/33023">＃33023</a></li><li>  添加守护程序选项以允许推送外部图层<a href="https://github.com/moby/moby/pull/33151">＃33151</a></li><li>  修复了阻止容器在死亡后重新启动的问题<a href="https://github.com/moby/moby/pull/32986">＃32986</a></li><li>  将集群事件添加到 Docker 事件流中。<a href="https://github.com/moby/moby/pull/32421">＃32421</a></li><li>  在 Windows 上添加对 DNS 搜索的支持<a href="https://github.com/moby/moby/pull/33311">＃33311</a></li><li>  升级到 Go 1.8.3 <a href="https://github.com/moby/moby/pull/33387">＃33387</a></li><li>  防止日记重新启动时发生容器崩溃 <a href="https://github.com/containerd/containerd/pull/930">＃containerd/ 930</a></li><li>  修复由于无效的环境变量而导致的运行状况检查失败<a href="https://github.com/moby/moby/pull/33249">＃33249</a></li><li>  禁止在停机期间重新启动安装容器的目录时，代替守护进程套接字创建目录<a href="https://github.com/moby/moby/pull/33330">＃30348</a></li><li>  如果容器的停止信号设置为<code>SIGKILL</code>吗, 则防止容器在停止时重新启动<a href="https://github.com/moby/moby/pull/33335">＃33335</a></li><li>  确保日志驱动程序将相同的文件名传递给 StartLogging 和 StopLogging 端点<a href="https://github.com/moby/moby/pull/33583">＃33583</a></li><li>  删除守护程序数据结构转储<code>SIGUSR1</code>以避免出现紧急情况<a href="https://github.com/moby/moby/pull/33598">＃33598</a></li></ul><h4 id="构造相关-11"><a href="#构造相关-11" class="headerlink" title="构造相关"></a>构造相关</h4><ul><li>  修复回退，当使用<code>ADD</code>从远程 URL 提取的存档<a href="https://github.com/docker/docker-ce/pull/89">＃89</a></li><li>  修复了对远程 “git @” 符号<a href="https://github.com/docker/docker-ce/pull/100">＃100 的处理</a></li><li>  修复复制<code>--from</code>冲突与强制拉取<a href="https://github.com/docker/docker-ce/pull/86">＃86</a></li><li>  添加<code>--iidfile</code>选项到 docker 构建。它允许指定保存结果镜像 ID 的位置</li><li>  允许在 git checkout URLs 中指定任何远程引用<a href="https://github.com/moby/moby/pull/32502">＃32502</a></li></ul><h4 id="日志相关-12"><a href="#日志相关-12" class="headerlink" title="日志相关"></a>日志相关</h4><ul><li>  修复 stderr 记录<code>journald</code>和<code>syslog</code> <a href="https://github.com/docker/docker-ce/pull/95">＃95</a></li><li>  修复日志读取器可以无限期阻止写入<a href="https://github.com/docker/docker-ce/pull/98">＃98</a></li><li>  修复<code>awslogs</code>驱动程序重复上一次事件<a href="https://github.com/docker/docker-ce/pull/151">＃151</a></li><li>  为 GCP 日志记录驱动程序添加监视的资源类型元数据<a href="https://github.com/moby/moby/pull/32930">＃32930</a></li><li>  将多行处理添加到 AWS CloudWatch 日志驱动程序<a href="https://github.com/moby/moby/pull/30891">＃30891</a></li></ul><h4 id="网络相关-12"><a href="#网络相关-12" class="headerlink" title="网络相关"></a>网络相关</h4><ul><li>  修复网络驱动程序未接收到的驱动程序选项的问题<a href="https://github.com/docker/docker-ce/pull/127">＃127</a></li><li>  通过节点本地网络（例如 macvlan，ipvlan，网桥，主机）添加支持群模式服务<a href="https://github.com/moby/moby/pull/32981">＃32981</a></li><li>  在创建服务时将驱动程序选项传递给网络驱动程序<a href="https://github.com/moby/moby/pull/33130">＃32981</a></li><li>  使用–data-path-addr 将 Swarm 控制面流量与应用程序数据流量 <a href="https://github.com/moby/moby/pull/32717">＃32717</a></li><li>  对服务进行了一些改进 <a href="https://github.com/docker/libnetwork/pull/1796">#docker/libnetwork/1796</a></li></ul><h4 id="插件相关"><a href="#插件相关" class="headerlink" title="插件相关"></a>插件相关</h4><ul><li>  插件删除失败更有保障 <a href="https://github.com/docker/docker-ce/pull/91">#91</a></li></ul><h4 id="安全相关-1"><a href="#安全相关-1" class="headerlink" title="安全相关"></a>安全相关</h4><ul><li>  编辑有关秘密创建秘密数据<a href="https://github.com/docker/docker-ce/pull/99">＃99 的</a></li><li>  允许使用默认 seccomp 配置文件设置的 UNAME26 位<a href="https://github.com/moby/moby/pull/32965">＃32965</a></li></ul><h4 id="发行相关"><a href="#发行相关" class="headerlink" title="发行相关"></a>发行相关</h4><ul><li>  在提取期间同时提供摘要时，选择标记之上的摘要<a href="https://github.com/moby/moby/pull/33214">＃33214</a></li></ul><h4 id="打包相关-6"><a href="#打包相关-6" class="headerlink" title="打包相关"></a>打包相关</h4><ul><li>  <code>container-selinux</code>可用时依靠 Centos / Fedora / RHEL <a href="https://github.com/moby/moby/pull/32437">＃32437</a></li></ul><h4 id="弃用-5"><a href="#弃用-5" class="headerlink" title="弃用"></a>弃用</h4><ul><li>  默认情况下禁用旧式注册表（v1）<a href="https://github.com/moby/moby/pull/33629">＃33629</a></li></ul><h3 id="版本号：17-05"><a href="#版本号：17-05" class="headerlink" title="版本号：17.05"></a>版本号：17.05</h3>  首次发布时间： 2017-05-04<h4 id="运行相关-14"><a href="#运行相关-14" class="headerlink" title="运行相关"></a>运行相关</h4><ul><li>  当容器退出时，确保运行状况探针已停止； Github 节点说明：； Github 节点说明：<a href="https://github.com/docker/docker/pull/32274">＃32274</a></li></ul><h4 id="网络相关-13"><a href="#网络相关-13" class="headerlink" title="网络相关"></a>网络相关</h4><ul><li>  允许用户替换和自定义入口网络；<a href="https://github.com/docker/docker/pull/31714">＃31714</a></li><li>  修复容器重启后容器中的 UDP 通信无法正常工作的情况； <a href="https://github.com/docker/docker/pull/32505">＃32505</a></li><li>  如果设置了其他数据根，则修复将文件写入<code>/var/lib/docker</code>的问题 ； Github 节点说明：<a href="https://github.com/docker/docker/pull/32505">＃32505</a></li></ul><h4 id="集群相关-13"><a href="#集群相关-13" class="headerlink" title="集群相关"></a>集群相关</h4><ul><li>  添加服务的更新 / 回滚顺序到（<code>--update-order</code>/ <code>--rollback-order</code>）<a href="https://github.com/docker/docker/pull/30261">＃30261</a></li><li>  添加对同步<code>service create</code>和<a href="https://github.com/docker/docker/pull/31144">＃31144 的</a>支持<code>service update Github节点说明：</code></li><li>  添加在健康检查 “宽限期”，通过支持<code>HEALTHCHECK --start-period</code>和<code>--health-start-period</code>标志 <code>docker service create</code>，<code>docker service update</code>，<code>docker create</code>，和<code>docker run</code>以支撑容器的初始启动时间 <a href="https://github.com/docker/docker/pull/28938">＃28938</a></li><li>  <code>docker service create</code>现在，在可能的情况下会忽略用户未指定的字段。允许在管理器中应用默认设置<a href="https://github.com/docker/docker/pull/32284">＃32284</a></li><li>  <code>docker service inspect</code>显示用户未指定的字段的默认值<a href="https://github.com/docker/docker/pull/32284">＃32284</a></li><li>  将<code>docker service logs</code>移出实验功能<a href="https://github.com/docker/docker/pull/32462">＃32462</a></li><li>  将对凭据规范和 SELinux 的支持添加到 API 服务 <a href="https://github.com/docker/docker/pull/32339">＃32339</a></li><li>  将<code>--entrypoint</code>标志添加到<code>docker service create</code>和<code>docker service update</code> <a href="https://github.com/docker/docker/pull/29228">＃29228</a></li><li>  添加<code>--network-add</code>到<code>--network-rm</code>和<code>docker service update</code> <a href="https://github.com/docker/docker/pull/32062">＃32062</a></li><li>  将<code>--credential-spec</code>标志添加到<code>docker service create</code>和<code>docker service update</code> <a href="https://github.com/docker/docker/pull/32339">＃32339</a></li><li>  添加<code>--filter mode</code>到<code>docker service ls</code> <a href="https://github.com/docker/docker/pull/31538">＃31538</a></li><li>  创建服务时，在客户端而不是在守护程序中解析网络 ID <a href="https://github.com/docker/docker/pull/32062">＃32062</a></li><li>  添加<code>--format</code>选项到<code>docker node ls</code><a href="https://github.com/docker/docker/pull/30424">＃30424</a></li><li>  添加<code>--prune</code>选项到<code>docker stack deploy</code>删除不再在 docker-compose 文件中定义的服务 <a href="https://github.com/docker/docker/pull/31302">#31302</a></li><li>  当使用<code>ingress</code> 将 <code>PORTS</code> 列添加到 <code>docker service ls</code> 中 <a href="https://github.com/docker/docker/pull/30813">#30813</a></li><li>  修复了使用环境变量时不必要的任务重新部署<a href="https://github.com/docker/docker/pull/32364">＃32364</a></li><li>  修复从 Docker 撰写文件进行部署时<code>docker stack deploy</code>不支持<code>endpoint_mode</code> <a href="https://github.com/docker/docker/pull/32333">＃32333</a></li><li>  如果无法创建群集组件允许从损坏的群集设置中恢复，然后继续启动。<a href="https://github.com/docker/docker/pull/31631">＃31631</a></li></ul><h4 id="构造相关-12"><a href="#构造相关-12" class="headerlink" title="构造相关"></a>构造相关</h4><ul><li>  添加多阶段构建支持<a href="https://github.com/docker/docker/pull/31257">＃31257</a> <a href="https://github.com/docker/docker/pull/32063">＃32063</a></li><li>  允许构建时在<code>FROM</code>中使用<code>ARG</code>参数 <a href="https://github.com/docker/docker/pull/31352">#31352</a></li><li>  添加用于指定构建目标的选项<a href="https://github.com/docker/docker/pull/32496">＃32496</a></li><li>  接受<code>-f -</code>从 <code>stdin</code>读取 Dockerfile，但使用本地上下文进行构建<a href="https://github.com/docker/docker/pull/31236">＃31236</a></li><li>  除非在 Dockerfile 中编写了相应的<code>ARG</code>指令，否则默认构建时间参数的值（例如<code>HTTP_PROXY</code>）将不再显示在 Docker 镜像历史记录中 。<a href="https://github.com/docker/docker/pull/31584">＃31584</a></li><li>  如果在父镜像中使用了 shell，则修复设置命令<a href="https://github.com/docker/docker/pull/32236">＃32236</a></li><li>  修复<code>docker build --label</code>标签包含单引号和空格的情况<a href="https://github.com/docker/docker/pull/31750">＃31750</a></li></ul><h4 id="客户端相关-13"><a href="#客户端相关-13" class="headerlink" title="客户端相关"></a>客户端相关</h4><ul><li>  将<code>--mount</code>标志添加到<code>docker run</code>和<code>docker create</code> <a href="https://github.com/docker/docker/pull/32251">＃32251</a></li><li>  添加<code>--type=secret</code>到<code>docker inspect</code> <a href="https://github.com/docker/docker/pull/32124">＃32124</a></li><li>  添加<code>--format</code>选项到<code>docker secret ls</code> <a href="https://github.com/docker/docker/pull/31552">＃31552</a></li><li>  添加 <code>--filter</code> 选项到 <code>docker secret ls</code> <a href="https://github.com/docker/docker/pull/30810">#30810</a></li><li>  添加<code>--filter scope=&lt;swarm|local&gt;</code>到<code>docker network ls</code> <a href="https://github.com/docker/docker/pull/31529">＃31529</a></li><li>  添加 <code>--cpus</code> 命令到 <code>docker update</code> <a href="https://github.com/docker/docker/pull/31148">#31148</a></li><li>  将标签过滤器添加到<code>docker system prune</code>和其他<code>prune</code>命令<a href="https://github.com/docker/docker/pull/30740">＃30740</a></li><li>  <code>docker stack rm</code>现在接受多个堆栈作为输入<a href="https://github.com/docker/docker/pull/32110">＃32110</a></li><li>  当客户端降级 API 版本改进<code>docker version --format</code>时，选项<a href="https://github.com/docker/docker/pull/31022">＃31022</a></li><li>  使用加密的客户端证书连接 docker 守护程序时提示<a href="https://github.com/docker/docker/pull/31364">＃31364</a></li><li>  成功的显示创建标签<code>docker build</code> <a href="https://github.com/docker/docker/pull/32077">＃32077</a></li><li>  清理撰写转换错误消息<a href="https://github.com/moby/moby/pull/32087">＃32087</a></li></ul><h4 id="日志相关-13"><a href="#日志相关-13" class="headerlink" title="日志相关"></a>日志相关</h4><ul><li>  添加对日志记录驱动程序插件的支持<a href="https://github.com/docker/docker/pull/28403">＃28403</a></li><li>  添加对显示单个任务日志的支持<code>docker service logs</code>，并添加<code>/task/&#123;id&#125;/logs</code>REST 端点<a href="https://github.com/docker/docker/pull/32015">＃32015</a></li><li>  <code>--log-opt env-regex</code>使用正则表达式添加选项以匹配环境变量<a href="https://github.com/docker/docker/pull/27565">＃27565</a></li></ul><h4 id="第三方库相关"><a href="#第三方库相关" class="headerlink" title="第三方库相关"></a>第三方库相关</h4><ul><li>  在 Ubuntu 17.04 Zesty amd64 是支持 docker 构建<a href="https://github.com/docker/docker/pull/32435">＃32435</a></li></ul><h4 id="守护进程相关"><a href="#守护进程相关" class="headerlink" title="守护进程相关"></a>守护进程相关</h4><ul><li>  修复如果<code>--api-enable-cors</code>未设置则忽略<code>--api-cors-header</code><a href="https://github.com/docker/docker/pull/32174">＃32174</a></li><li>  启动时清理 <a href="https://github.com/docker/docker/pull/31741">docker</a> tmp 目录 <a href="https://github.com/docker/docker/pull/31741">＃31741</a></li><li>  赞成使用<code>--graph</code>或<code>--data-root</code> <a href="https://github.com/docker/docker/pull/28696">＃28696</a></li></ul><h4 id="安全相关-2"><a href="#安全相关-2" class="headerlink" title="安全相关"></a>安全相关</h4><ul><li>  允许设置 SELinux 类型或 MCS 标签 是使用<code>--ipc=container:</code> 或者 <code>--ipc=host</code> <a href="https://github.com/docker/docker/pull/30652">#30652</a></li></ul><h4 id="弃用-6"><a href="#弃用-6" class="headerlink" title="弃用"></a>弃用</h4><ul><li>  弃用<code>--api-enable-cors</code>守护程序标志。该标志在 Docker 1.6.0 中被标记为不推荐使用，但未在不推荐使用的功能中列出<a href="https://github.com/docker/docker/pull/32352">＃32352</a></li><li>  删除 Ubuntu 12.04（Precise Pangolin）作为受支持的平台。Ubuntu 12.04 已停产，并且不再更新<a href="https://github.com/docker/docker/pull/32520">＃32520</a></li></ul><h3 id="版本号：17-04"><a href="#版本号：17-04" class="headerlink" title="版本号：17.04"></a>版本号：17.04</h3>  首次发布时间： 2017-04-05<h4 id="运行相关-15"><a href="#运行相关-15" class="headerlink" title="运行相关"></a>运行相关</h4><ul><li>  在不设置实时还原的情况下进行还原时，要处理已暂停的容器； <a href="https://github.com/docker/docker/pull/31704">＃31704</a></li><li>  不允许在 Dockerfile 中运行状况中检查选项中的秒数；<a href="https://github.com/docker/docker/pull/31177">#31177</a></li><li>  支持在 <code>secret update</code> 语句中命名和 id 前缀；<a href="https://github.com/docker/docker/pull/30856">#30856</a></li><li>  将二进制框架用于 websocket 附加终端；<a href="https://github.com/docker/docker/pull/30460">＃30460</a></li><li>  修复 Linux 挂载调用不允许传播类型更改的问题；<a href="https://github.com/docker/docker/pull/30416">＃30416</a></li><li>  修复<code>exec -i</code>中 ExecIds 泄漏失败的问题 ； <a href="https://github.com/docker/docker/pull/30340">＃30340</a></li><li>  当<code>danglingOnly=true</code>时，删除命名但未标记的镜像 ；<a href="https://github.com/docker/docker/pull/30330">#30330</a></li><li>  添加守护程序标志以将 no_new_priv 设置为非特权容器的默认值 ；<a href="https://github.com/docker/docker/pull/29984">＃29984</a></li><li>  添加守护程序选项<code>--default-shm-size</code> ； <a href="https://github.com/docker/docker/pull/29692">＃29692</a></li><li>  支持注册表镜像配置重新加载；<a href="https://github.com/docker/docker/pull/29650">＃29650</a></li><li>  构建镜像时忽略守护程序日志配置； <a href="https://github.com/docker/docker/pull/29552">＃29552</a></li><li>  将解析的机密名称或 ID 前缀从客户端移动到守护程序； <a href="https://github.com/docker/docker/pull/29218">＃29218</a></li><li>  允许将规则添加到<code>cgroup devices.allow</code>容器创建 / 运行；<a href="https://github.com/docker/docker/pull/22563">＃22563</a></li><li>  修复在允许<code>systemd daemon-reload</code>命令时，<code>cpu.cfs_quota_us</code>被重置的问题； <a href="https://github.com/docker/docker/pull/31736">＃31736</a></li></ul><h4 id="网络相关-14"><a href="#网络相关-14" class="headerlink" title="网络相关"></a>网络相关</h4><ul><li>  检查在<code>docker network connect</code> 中的<code>--ip</code>，<code>--ip6</code>和<code>--link-local-ip</code>参数；<a href="https://github.com/docker/docker/pull/30807">＃30807</a></li><li>  添加支持 <code>dns-search</code> ；<a href="https://github.com/docker/docker/pull/30117">#30117</a></li><li>  增加 - 详细选项 docker 网络检查，会所有群节点显示任务细节 ；<a href="https://github.com/docker/docker/pull/31710">#31710</a></li><li>  加入集群时清除旧的数据路径加密状态 ； <a href="https://github.com/docker/libnetwork/pull/1354">docker/libnetwork#1354</a></li><li>  确保 iptables 初始化只发生一次 ； <a href="https://github.com/docker/libnetwork/pull/1676">docker/libnetwork#1676</a></li><li>  修复 iptables 过滤规则的错误顺序； <a href="https://github.com/docker/libnetwork/pull/961">docker / libnetwork＃961</a></li><li>  在可附加网络上的服务记录中添加匿名容器别名 ； <a href="https://github.com/docker/libnetwork/pull/1651">docker/libnetwork#1651</a></li><li>  支持<code>com.docker.network.container_interface_prefix</code>驱动程序标签；<a href="https://github.com/docker/libnetwork/pull/1667">docker / libnetwork＃1667</a></li><li>  通过省略不使用的网络详细信息来提高网络列表的性能；<a href="https://github.com/docker/docker/pull/30673">＃30673</a></li></ul><h4 id="集群相关-14"><a href="#集群相关-14" class="headerlink" title="集群相关"></a>集群相关</h4><ul><li>  拓扑感知调度；<a href="https://github.com/docker/docker/pull/30725">＃30725</a></li><li>  故障时自动回滚服务；<a href="https://github.com/docker/docker/pull/31108">＃31108</a></li><li>  在同一节点上的辅助服务器和管理器通过 UNIX 套接字连接； <a href="https://github.com/docker/swarmkit/pull/1828">docker/swarmkit#1828</a>。<a href="https://github.com/docker/swarmkit/pull/1850">docker/swarmkit#1850</a>, <a href="https://github.com/docker/swarmkit/pull/1851">docker/swarmkit#1851</a></li><li>  改进运输包方案； <a href="https://github.com/docker/swarmkit/pull/1748">docker/swarmkit#1748</a></li><li>  降级 / 删除时没有自动关闭管理器的问题； <a href="https://github.com/docker/swarmkit/pull/1829">docker/swarmkit#1829</a></li><li>  使用 TransferLeadership 使主服务器降级更安全； <a href="https://github.com/docker/swarmkit/pull/1939">docker/swarmkit#1939</a></li><li>  减少默认监控周期； <a href="https://github.com/docker/swarmkit/pull/1967">docker/swarmkit#1967</a></li><li>  添加服务日志格式； <a href="https://github.com/docker/docker/pull/31672">＃31672</a></li><li>  修复服务日志 API，使其能够指定流； <a href="https://github.com/docker/docker/pull/31313">＃31313</a></li><li>  添加<code>--stop-signal</code>到<code>service create</code>和<code>service update</code>； <a href="https://github.com/docker/docker/pull/30754">＃30754</a></li><li>  添加<code>--read-only</code>到<code>service create</code>和<code>service update</code>； <a href="https://github.com/docker/docker/pull/30162">＃30162</a></li><li>  与注册表通信后更新上下文；<a href="https://github.com/docker/docker/pull/31586">＃31586</a></li><li>  （实验性）添加<code>--tail</code>和<code>--since</code>选项到<code>docker service logs</code>； <a href="https://github.com/docker/docker/pull/31500">#31500</a></li><li>  （实验性）添加<code>--no-task-ids</code>和<code>--no-trunc</code>选项到<code>docker service logs</code>； <a href="https://github.com/docker/docker/pull/31672">#31672</a></li></ul><h4 id="日志相关-14"><a href="#日志相关-14" class="headerlink" title="日志相关"></a>日志相关</h4><ul><li>  为容器日志实现可选的环形缓冲区； <a href="https://github.com/docker/docker/pull/28762">＃28762</a>。</li><li>  为 awslogs（CloudWatch）添加<code>--log-opt awslogs-create-group = &lt;true | false&gt;</code>，以根据需要支持创建日志组； <a href="https://github.com/docker/docker/pull/29504">#29504</a> 。</li><li>  将 gcplogs 日志记录驱动程序与 “静态” 二进制文件一起使用时，修复 segfault； <a href="https://github.com/docker/docker/pull/29478">＃29478</a>。</li></ul><h4 id="构造相关-13"><a href="#构造相关-13" class="headerlink" title="构造相关"></a>构造相关</h4><ul><li>  禁用构建容器的容器日志记录； <a href="https://github.com/docker/docker/pull/29552">＃29552。</a></li><li>  修复<code>**/</code>在<code>.dockerignore</code>的使用； <a href="https://github.com/docker/docker/pull/29043">＃29043</a>。</li></ul><h4 id="客户端相关-14"><a href="#客户端相关-14" class="headerlink" title="客户端相关"></a>客户端相关</h4><ul><li>  <code>docker stack ls</code>按照名称排序；<a href="https://github.com/docker/docker/pull/31085">＃31085</a>。</li><li>  用于指定绑定安装一致性的标志； <a href="https://github.com/docker/docker/pull/31047">＃31047</a>。</li><li>  docker CLI 的输出——帮助现在包装到终端宽度 ；<a href="https://github.com/docker/docker/pull/28751">＃28751</a>。</li><li>  废除 docker ps 中的镜像摘要；<a href="https://github.com/docker/docker/pull/30848">＃30848</a>。</li><li>  隐藏与 Windows 相关的命令选项； <a href="https://github.com/docker/docker/pull/30788">#30788</a> 。</li><li>  修正<code>docker plugin install</code>提示接受默认值为 “N” 的“ enter”； <a href="https://github.com/docker/docker/pull/30769">＃30769。</a></li><li>  添加<code>truncate</code>功能到 Go 模板；<a href="https://github.com/docker/docker/pull/30484">＃30484</a>。</li><li>  支持在<code>stack deploy</code>中的端口扩展语法； <a href="https://github.com/docker/docker/pull/30476">#30476</a> 。</li><li>  支持在<code>stack deploy</code>中的挂载扩展语法； <a href="https://github.com/docker/docker/pull/30597">#30597</a> <a href="https://github.com/docker/docker/pull/31795">#31795</a> 。</li><li>  在 dockers build 中提供<code>--add-host</code>语句； <a href="https://github.com/docker/docker/pull/30383">#30383</a> 。</li><li>  在<code>docker network ls --format</code>添加<code>docker network ls --format</code>占位符； <a href="https://github.com/docker/docker/pull/29900">#29900</a> 。</li><li>  更新<code>--secret-rm</code>和<code>--secret-add</code>的顺序； <a href="https://github.com/docker/docker/pull/29802">#29802</a> 。</li><li>  添加<code>--filter enabled=true</code>到<code>docker plugin ls</code>中； <a href="https://github.com/docker/docker/pull/28627">＃28627。</a></li><li>  添加<code>--format</code>到<code>docker service ls</code>； <a href="https://github.com/docker/docker/pull/28199">＃28199</a>。</li><li>  添加<code>publish</code>和<code>expose</code>过滤器到<code>docker ps --filter</code>； <a href="https://github.com/docker/docker/pull/27557">＃27557</a>。</li><li>  支持多个服务 ID <code>docker service ps</code> ； <a href="https://github.com/docker/docker/pull/25234">#25234</a> 。</li><li>  允许以<code>--availability=drain</code>加入集群； <a href="https://github.com/docker/docker/pull/24993">＃24993。</a></li><li>  启用 AppArmor 并且未定义其他配置文件时，Docker 检查现在显示 “docker-default”； <a href="https://github.com/docker/docker/pull/27083">＃27083</a>。</li></ul><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4>  <strong>Windows 相关</strong><ul><li>  阻止在非 Windows 守护程序上拉取 Windows 镜像； <a href="https://github.com/docker/docker/pull/29001">＃29001</a></li></ul><h3 id="版本号：17-03"><a href="#版本号：17-03" class="headerlink" title="版本号：17.03"></a>版本号：17.03</h3>  首次发布时间： 2017-05-29<h4 id="运行相关-16"><a href="#运行相关-16" class="headerlink" title="运行相关"></a>运行相关</h4><ul><li>将 go-connections 更新为 d217f8e 版本； <a href="https://github.com/docker/engine/pull/28">＃28</a></li><li>重新标记安全路径以避免在启用 selinux 的系统上被拒绝； <a href="https://github.com/moby/moby/pull/33236">＃33236</a>（ref <a href="https://github.com/moby/moby/pull/32529">＃32529</a></li><li>修复了一些需要的本地卷无法被重新标记的情况； <a href="https://github.com/moby/moby/pull/33236">＃33236</a>（ref <a href="https://github.com/moby/moby/pull/29428">＃29428</a>）</li><li>修复在升级插件 rootfs 时仍然挂载的问题 ；<a href="https://github.com/moby/moby/pull/33236">＃33236</a>（ref <a href="https://github.com/moby/moby/pull/32525">＃32525</a>）</li><li>修复卷不会默认为 rprivate 传播模式的问题 ； <a href="https://github.com/moby/moby/pull/33236">#33236</a> (ref <a href="https://github.com/moby/moby/pull/32851">#32851</a>)</li><li>修复无法检索卷驱动程序时可能出现的紧急情况； <a href="https://github.com/moby/moby/pull/33236">＃33236</a>（ref <a href="https://github.com/moby/moby/pull/32347">＃32347</a>）</li><li>在<code>docker info</code>中添加了警告，用于警示在不支持<code>d_type</code>的文件系统上使用<code>overlay</code>或者<code>overlay 2</code>驱动； <a href="https://github.com/moby/moby/pull/33236">#33236</a> (ref <a href="https://github.com/moby/moby/pull/31290">#31290</a>)</li><li>修复将挂载规范反向移植到旧卷的问题 ； <a href="https://github.com/moby/moby/pull/33207">＃33207</a></li><li>修复取消挂载失败后可能导致本地卷丢失数据的问题； <a href="https://github.com/moby/moby/pull/33120">＃33120</a></li><li>将 Runc 更新为 54296cf40ad8143b62dbcaa1d90e520a2136ddfe 版本； <a href="https://github.com/docker/docker/pull/31666">＃31666</a></li><li>忽略 cgroup2 挂载点； <a href="https://github.com/opencontainers/runc/pull/1266">opencontainers / runc＃1266</a></li><li>将容器更新为 4ab9917febca54791c5f071a9d1f404867857fcc 版本； <a href="https://github.com/docker/docker/pull/31662">＃31662</a> <a href="https://github.com/docker/docker/pull/31852">＃31852</a></li><li>在调用 restore() 之前注册 healtcheck 服务 ； <a href="https://github.com/docker/containerd/pull/609">docker/containerd#609</a></li><li>修复<code>docker exec</code>在自动升级后无法工作，重新加载设备配置文件的问题 ；<a href="https://github.com/docker/docker/pull/31773">＃31773</a></li><li>修复不使用 Overlay2 合并目录的卸载层；<a href="https://github.com/docker/docker/pull/31069">＃31069</a></li><li>在强制删除时不忽略 “volume in use” 错误 ；<a href="https://github.com/docker/docker/pull/31450">＃31450</a></li><li>修复 Docker 日志中的死锁； <a href="https://github.com/docker/docker/pull/30223">＃30223</a></li><li>修复 CPU 空闲等待日志写入的问题；<a href="https://github.com/docker/docker/pull/31070">＃31070</a></li><li>修复使用日志记录可能导致崩溃的问题； <a href="https://github.com/docker/docker/pull/31231">#31231</a> <a href="https://github.com/docker/docker/pull/31263">#31263</a></li><li>修复关闭未持有内存通道的紧急情况； ：<a href="https://github.com/docker/docker/pull/31274">＃31274</a></li><li>修复在<code>docker run</code>中使用<code>--volumes-from</code>重复挂载的情况； <a href="https://github.com/docker/docker/pull/29563">＃29563</a></li><li>  修复<code>--cache-from</code>不能缓存最后一步的情况； Github 节点说明：<a href="https://github.com/docker/docker/pull/31189">＃31189</a></li></ul><h4 id="网络相关-15"><a href="#网络相关-15" class="headerlink" title="网络相关"></a>网络相关</h4><ul><li>修复阻止网络创建的并发问题；<a href="https://github.com/moby/moby/pull/33273">＃33273</a></li><li>修正交叉数据中心群中叠加加密密钥旋转的错误 ；<a href="https://github.com/docker/docker/pull/30727">＃30727</a></li><li>修正主服务器频繁更换引起的叠加加密和网络控制平面通信失败的错误（“已安装的密钥中没有可以解密消息”）；<a href="https://github.com/docker/docker/pull/25608">＃25608</a></li><li>对使用覆盖网络和外部 kv-store 时，对系统响应性和数据路径编程进行了处理； Github 节点说明： <a href="https://github.com/docker/libnetwork/pull/1639">docker/libnetwork#1639</a>, <a href="https://github.com/docker/libnetwork/pull/1632">docker/libnetwork#1632</a> ……</li><li>丢弃进入加密覆盖网络的普通 vxlan 数据包 ；＃31170](<a href="https://github.com/docker/docker/pull/31170">https://github.com/docker/docker/pull/31170</a>)</li><li>在分配失败时释放网络附件 ；<a href="https://github.com/docker/docker/pull/31073">＃31073</a></li><li>  修正了多个已发布端口映射到相同目标端口时的端口分配问题 ; <a href="https://github.com/docker/swarmkit/pull/1835">docker/swarmkit#1835</a></li></ul><h4 id="集群相关-15"><a href="#集群相关-15" class="headerlink" title="集群相关"></a>集群相关</h4><ul><li>  修复任务可能会被意外关闭的情况；<a href="https://github.com/moby/moby/pull/33118">＃33118</a></li><li>  修复了尽管无法访问注册中心，但本地存在所需镜像却无法部署的情况；<a href="https://github.com/moby/moby/pull/33117">＃33117</a></li><li>  将 swarmkit 更新到 17756457ad6dc4d8a639a1f0b7a85d1b65a617bb 版本；<a href="https://github.com/docker/docker/pull/31807">＃31807</a></li><li>  调度器现在可以合理处理任务被分配给节点但未正常运行的情况；<a href="https://github.com/docker/swarmkit/pull/1980">docker/swarmkit#1980</a></li><li>  允许删除只被无效任务访问的网络； <a href="https://github.com/docker/swarmkit/pull/2018">docker/swarmkit#2018</a></li><li>  降低无法访问网络的分配频率； <a href="https://github.com/docker/swarmkit/pull/2021">docker/swarmkit#2021</a></li><li>  避免对不再运行的任务进行网络分配 ； <a href="https://github.com/docker/swarmkit/pull/2017">docker/swarmkit#2017</a></li><li>  统计内部网络分配器的分配情况 ；<a href="https://github.com/docker/swarmkit/pull/2019">docker/swarmkit#2019</a> <a href="https://github.com/docker/swarmkit/pull/2020">docker/swarmkit#2020</a></li><li>  关闭未曾启动容器引发的错误；<a href="https://github.com/docker/docker/pull/31279">＃31279</a></li><li>  修复主要主机在因故障问题进行切换时，任务状态变为 “NEW” 的情况；<a href="https://github.com/docker/swarmkit/pull/1938">docker/swarmkit＃1938</a></li><li>  修复在<code>docker service ls</code>中未全局服务创建的冗余任务而引发副本计数混乱的问题；<a href="https://github.com/docker/swarmkit/pull/1957">docker/swarmkit#1957</a></li><li>  修复在<code>task-history-limit</code>设置为 1 时使滚动更新变慢的问题;<a href="https://github.com/docker/swarmkit/pull/1948">docker/swarmkit＃1948</a>。</li><li>  当由于节点不再满足约束条件而被关闭时，在适当的地方重新启动任务；<a href="https://github.com/docker/swarmkit/pull/1958">docker/swarmkit＃1958</a>。</li><li>  （测试版本）</li></ul><h4 id="远程-API-和客户端相关"><a href="#远程-API-和客户端相关" class="headerlink" title="远程 API 和客户端相关"></a>远程 API 和客户端相关</h4><ul><li>  修复自动删除旧的 API；<a href="https://github.com/docker/docker/pull/31692">＃31692</a></li><li>  修复堆栈的默认网络自定义；<a href="https://github.com/docker/docker/pull/31258/">＃31258</a></li><li>  存在脱机 CPU 和较新的 Linux 的情况下，更正 CPU 使用率计算；<a href="https://github.com/docker/docker/pull/31802">＃31802</a></li><li>  修复远程 API 中服务健康检查为 {} 的问题 ；<a href="https://github.com/docker/docker/pull/30197">＃30197</a></li><li>  解决<code>docker stats --format</code>问题 ；<a href="https://github.com/docker/docker/pull/30776">＃30776</a></li></ul><h4 id="第三方库相关-1"><a href="#第三方库相关-1" class="headerlink" title="第三方库相关"></a>第三方库相关</h4><ul><li>  更新<code>bash</code>和<code>zsh</code>脚本；＃30823](<a href="https://github.com/docker/docker/pull/30823)%EF%BC%8C[%EF%BC%8330945](https://github.com/docker/docker/pull/30945)%E2%80%A6%E2%80%A6">https://github.com/docker/docker/pull/30823)，[＃30945](https://github.com/docker/docker/pull/30945)……</a></li><li>  在默认的 seccomp 配置文件中阻止过时的套接字系列 - 缓解未修补内核的 CVE-2017-6074；＃29076](<a href="https://github.com/docker/docker/pull/29076">https://github.com/docker/docker/pull/29076</a>)</li></ul><h4 id="其它-1"><a href="#其它-1" class="headerlink" title="其它"></a>其它</h4>  <strong>Windows 相关</strong><ul><li>  还原时清理 HCS；<a href="https://github.com/docker/docker/pull/31503">#31503</a></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 毕设 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转载】使用 Cockpit 管理你的树莓派</title>
      <link href="/posts/29824.html"/>
      <url>/posts/29824.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址 <a href="https://linux.cn/article-13487-1.html">linux.cn</a></p></blockquote><blockquote><p>2021-12-06 更新<br>修复无法开启自启的问题</p></blockquote><h2 id="在树莓派-OS-上安装-Cockpit"><a href="#在树莓派-OS-上安装-Cockpit" class="headerlink" title="在树莓派 OS 上安装 Cockpit"></a>在树莓派 OS 上安装 Cockpit</h2><p>在树莓派 OS 上安装 Cockpit Web 控制台：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install cockpit</span></span><br></pre></td></tr></table></figure><p>Cockpit 只需要 60.4 KB 的磁盘空间。加上它的几个包依赖项，总使用量是 115MB。</p><p>安装过程将负责设置和启动服务。你可以使用 <code>systemctl</code> 命令来验证状态：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> systemctl status cockpit.socket</span></span><br><span class="line">● cockpit.socket - Cockpit Web Service Socket</span><br><span class="line">   Loaded: loaded (/lib/systemd/system/cockpit.socket; enabled; vendor preset: enabled)</span><br><span class="line">   Active: active (listening) since Tue 2021-05-04 10:24:43 EDT; 35s ago</span><br><span class="line">     Docs: man:cockpit-ws(8)</span><br><span class="line">   Listen: 0.0.0.0:9090 (Stream)</span><br><span class="line">  Process: 6563 ExecStartPost=/usr/share/cockpit/motd/update-motd  localhost (code=exited, status=0/SUCCESS)</span><br><span class="line">  Process: 6570 ExecStartPost=/bin/ln -snf active.motd /run/cockpit/motd (code=exited, status=0/SUCCESS)</span><br><span class="line">    Tasks: 0 (limit: 2181)</span><br><span class="line">   CGroup: /system.slice/cockpit.socket</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="设置开机自启"><a href="#设置开机自启" class="headerlink" title="设置开机自启"></a>设置开机自启</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /usr/lib/systemd/system/cockpit.service</span><br></pre></td></tr></table></figure><p>在文件的最后新增如下内容</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>输入一下命令开启开机自启</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl <span class="built_in">enable</span> cockpit.service</span><br></pre></td></tr></table></figure><h3 id="更改端口"><a href="#更改端口" class="headerlink" title="更改端口"></a>更改端口</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/systemd/system/sockets.target.wants/cockpit.socket</span><br></pre></td></tr></table></figure><p>将下面 9090 改为所需端口</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ListenStream=9090</span><br></pre></td></tr></table></figure><p>生效命令（是重启cockpit.socket 不是重启 cockpit.service）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart cockpit.socket </span><br></pre></td></tr></table></figure><h3 id="使用-Cockpit"><a href="#使用-Cockpit" class="headerlink" title="使用 Cockpit"></a>使用 Cockpit</h3><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>默认的监听端口号是 9090。打开浏览器并输入地址，例如： <code>http://IP:9090</code>。</p><p><img src="https://images.961110.xyz/images/2021/10/23/cockpit.png"></p><p><em>Cockpit home page</em></p><p>使用树莓派的账户登录，但是需要有使用 <code>sudo</code> 的权限。<strong>一定要勾选 “为特权任务重用我的密码”。</strong></p><h4 id="管理你的树莓派"><a href="#管理你的树莓派" class="headerlink" title="管理你的树莓派"></a>管理你的树莓派</h4><p>Cockpit 的初始屏幕以 “System” 页开始，提供当前 CPU 和内存使用的详细信息和图表。</p><img src="https://images.961110.xyz/images/2021/10/23/cockpit940fb5d3fdcf1fa9.png" style="zoom:50%;" /><p><em>Initial Cockpit screen</em></p><p>可以从这个屏幕看到硬件细节。</p><p><img src="https://images.961110.xyz/images/2021/10/23/cockpitc1d145ff9daceb13.png"></p><p><em>Cockpit hardware details</em></p><p>通过点击每一项来展开左边的列（例如，日志、存储、服务等）。这些是标准的 Cockpit 部分，不言自明。让我快速描述一下每个部分。</p><ol><li><p>日志</p><p>这部分展示了日志。它们可以根据日期和严重程度来过滤。</p></li><li><p>存储</p><p>存储部分展示了已经安装的物理驱动器和 RAID 设备。例如大小、序列号等细节都被展示了出来。还展示了读 / 写活动和实际空间使用的图表。存储的具体日志显示在底部。</p></li><li><p>网络</p><p>这部分展示了发送和接收活动、IP 地址以及网络特定的日志。你还可以使用相应的按钮添加更多的网络设备，如绑定、网桥和 VLAN。</p></li><li><p>账户</p><p>这里展示了已有的账户。点击每个账户来管理，或使用创建新账户按钮来添加用户。账户也可以被删除。</p></li><li><p>服务</p><p>这部分可以让管理员查看系统所有服务的状态。点击任何服务都会转到一个包含启动、重启和禁用的标准任务的屏幕。</p></li><li><p>应用程序</p><p>通常，这个屏幕提供了各种用于管理功能的应用程序，例如 389 目录服务器或创建 Podman 容器。但在我的树莓派 OS 上，这个屏幕只显示 “没有安装或可用的应用程序”。在写这篇文章的时候，这个或许还没有实现。虽然，你可能会怀疑这类型的程序对于树莓派硬件来说是否太过沉重。</p></li><li><p>软件更新</p><p>对任何系统管理员来说，保持软件最新是最重要的任务之一。Cockpit 的软件更新部分可以检查并进行更新。</p></li></ol><p><img src="https://images.961110.xyz/images/2021/10/23/cockpit10383030be25b5ea.png"></p><p><em>Software updates in Cockpit</em></p><h4 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h4><p>Cockpit 最方便的特点之一是终端。你可以使用它，而不是打开一个单独的终端模拟器并使用 SSH。我使用终端来安装 <a href="https://opensource.com/article/20/1/screenfetch-neofetch">ScreenFetch</a>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install screenfetch</span></span><br></pre></td></tr></table></figure><p>使用 ScreenFetch 生成了这张截图：</p><p><img src="https://images.961110.xyz/images/2021/10/23/cockpit-shell.png"></p><p><em>Terminal in Cockpit</em></p><h3 id="使用-Cockpit-的中心控制"><a href="#使用-Cockpit-的中心控制" class="headerlink" title="使用 Cockpit 的中心控制"></a>使用 Cockpit 的中心控制</h3><p>Cockpit 在树莓派上的表现就像它在其他 Linux 系统上一样。你可以将它添加到仪表盘上进行集中控制。它允许企业在 Cockpit 作为管理仪表盘解决方案的任何地方，将基于树莓派的服务和系统整合到他们的整体 Linux 基础设施中。因为树莓派经常在高密度机架数据中心以无外接控制 headless 方式运行，而这些数据中心通常会缺乏 KVM 访问方式，这是非常方便的。</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> 教程 </tag>
            
            <tag> 配置 </tag>
            
            <tag> 监控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转载】如何搭建 GTA 5 私服 - FiveM 的搭建</title>
      <link href="/posts/17578.html"/>
      <url>/posts/17578.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址 <a href="https://leif.fun/articles/2019/11/14/1573715853549.html">leif.fun</a></p></blockquote><p>打开官网（<a href="https://fivem.net.cn/">中</a> <a href="https://fivem.net/">英</a>文皆可），点击 _下载服务端 (非商业)_，如图所示<br><img src="https://img.hacpai.com/file/2019/11/image-29f540e4.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"></p><p>网页跳转到官方说明文档<br><img src="https://img.hacpai.com/file/2019/11/image-2949be7b.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"></p><p>该说明文档提供了安装在 Windows 和 Linux 上的方法，下面逐一介绍。</p><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件:"></a>前提条件:</h3><p>1.<a href="https://aka.ms/vs/16/release/VC_redist.x64.exe">Visual C++ Redistributable 2019</a></p><p>2.<a href="https://git-scm.com/download/win">Git</a></p><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><ol><li><p>创建新文件夹为<code>D:\FxServer</code><br><img src="https://img.hacpai.com/file/2019/11/image-863a8272.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"></p></li><li><p>下载最新 Windows 端服务器文件：<a href="https://runtime.fivem.net/artifacts/fivem/build_server_windows/master/">artifacts server</a></p></li></ol><p><img src="https://img.hacpai.com/file/2019/11/image-579d6bad.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"></p><ol start="3"><li><p>解压下载的服务器文件到<code>FxServer</code>文件夹中<br><img src="https://img.hacpai.com/file/2019/11/image-5d5a8984.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"></p></li><li><p>克隆 <a href="https://github.com/citizenfx/cfx-server-data">cfx-server-data</a> 到<code>D:\FxServer</code>中，并重名名为<code>server-data</code>，且与服务器文件夹<code>server</code>同级. 命令：<code>git clone https://github.com/citizenfx/cfx-server-data.git server-data</code><br><img src="https://img.hacpai.com/file/2019/11/image-1a91e8d5.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"></p></li></ol><p><img src="https://img.hacpai.com/file/2019/11/image-5f964c0d.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"></p><ol start="5"><li>在<code>server-data</code>文件夹下创建<code>server.cfg</code>配置文件，文件内容来自 <a href="https://docs.fivem.net/server-manual/setting-up-a-server/#servercfgexample">example server.cfg</a>, 内容如下：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Only change the IP if you&#x27;re using a server with multiple network interfaces, otherwise change the port only.</span><br><span class="line">endpoint_add_tcp &quot;0.0.0.0:30120&quot;</span><br><span class="line">endpoint_add_udp &quot;0.0.0.0:30120&quot;</span><br><span class="line"></span><br><span class="line"># These resources will start by default.</span><br><span class="line">ensure mapmanager</span><br><span class="line">ensure chat</span><br><span class="line">ensure spawnmanager</span><br><span class="line">ensure sessionmanager</span><br><span class="line">ensure fivem</span><br><span class="line">ensure hardcap</span><br><span class="line">ensure rconlog</span><br><span class="line">ensure scoreboard</span><br><span class="line"></span><br><span class="line"># This allows players to use scripthook-based plugins such as the legacy Lambda Menu.</span><br><span class="line"># Set this to 1 to allow scripthook. Do note that this does _not_ guarantee players won&#x27;t be able to use external plugins.</span><br><span class="line">sv_scriptHookAllowed 0</span><br><span class="line"></span><br><span class="line"># Uncomment this and set a password to enable RCON. Make sure to change the password - it should look like rcon_password &quot;YOURPASSWORD&quot;</span><br><span class="line">#rcon_password &quot;&quot;</span><br><span class="line"></span><br><span class="line"># A comma-separated list of tags for your server.</span><br><span class="line"># For example:</span><br><span class="line"># - sets tags &quot;drifting, cars, racing&quot;</span><br><span class="line"># Or:</span><br><span class="line"># - sets tags &quot;roleplay, military, tanks&quot;</span><br><span class="line">sets tags &quot;default&quot;</span><br><span class="line"></span><br><span class="line"># A valid locale identifier for your server&#x27;s primary language.</span><br><span class="line"># For example &quot;en-US&quot;, &quot;fr-CA&quot;, &quot;nl-NL&quot;, &quot;de-DE&quot;, &quot;en-GB&quot;, &quot;pt-BR&quot;</span><br><span class="line">sets locale &quot;root-AQ&quot; </span><br><span class="line"># please DO replace root-AQ on the line ABOVE with a real language! :)</span><br><span class="line"></span><br><span class="line"># Set an optional server info and connecting banner image url.</span><br><span class="line"># Size doesn&#x27;t matter, any banner sized image will be fine.</span><br><span class="line">#sets banner_detail &quot;https://url.to/image.png&quot;</span><br><span class="line">#sets banner_connecting &quot;https://url.to/image.png&quot;</span><br><span class="line"></span><br><span class="line"># Set your server&#x27;s hostname</span><br><span class="line">sv_hostname &quot;FXServer, but unconfigured&quot;</span><br><span class="line"></span><br><span class="line"># Nested configs!</span><br><span class="line">#exec server_internal.cfg</span><br><span class="line"></span><br><span class="line"># Loading a server icon (96x96 PNG file)</span><br><span class="line">#load_server_icon myLogo.png</span><br><span class="line"></span><br><span class="line"># convars which can be used in scripts</span><br><span class="line">set temp_convar &quot;hey world!&quot;</span><br><span class="line"></span><br><span class="line"># Uncomment this line if you do not want your server to be listed in the server browser.</span><br><span class="line"># Do not edit it if you *do* want your server listed.</span><br><span class="line">#sv_master1 &quot;&quot;</span><br><span class="line"></span><br><span class="line"># Add system admins</span><br><span class="line">add_ace group.admin command allow # allow all commands</span><br><span class="line">add_ace group.admin command.quit deny # but don&#x27;t allow quit</span><br><span class="line">add_principal identifier.fivem:1 group.admin # add the admin to the group</span><br><span class="line"></span><br><span class="line"># Hide player endpoints in external log output.</span><br><span class="line">sv_endpointprivacy true</span><br><span class="line"></span><br><span class="line"># Server player slot limit (must be between 1 and 32, unless using OneSync)</span><br><span class="line">sv_maxclients 32</span><br><span class="line"></span><br><span class="line"># Steam Web API key, if you want to use Steam authentication (https://steamcommunity.com/dev/apikey)</span><br><span class="line"># -&gt; replace &quot;&quot; with the key</span><br><span class="line">set steam_webApiKey &quot;&quot;</span><br><span class="line"></span><br><span class="line"># License key for your server (https://keymaster.fivem.net)</span><br><span class="line">sv_licenseKey changeme</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>中文解释：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 一般情况下不用修改!</span><br><span class="line"># 只有使用多个服务器协议的时候才需要更改。默认的TCP和UDP端口为30120</span><br><span class="line">endpoint_add_tcp &quot;0.0.0.0:30120&quot;</span><br><span class="line">endpoint_add_udp &quot;0.0.0.0:30120&quot;</span><br><span class="line"></span><br><span class="line"># 默认启动资源。</span><br><span class="line">start mapmanager</span><br><span class="line">start chat</span><br><span class="line">start spawnmanager</span><br><span class="line">start sessionmanager</span><br><span class="line">start fivem</span><br><span class="line">start hardcap</span><br><span class="line">start rconlog</span><br><span class="line">start scoreboard</span><br><span class="line">start playernames</span><br><span class="line"></span><br><span class="line"># 允许玩家使用scripthook挂载的修改器，例如lambda菜单。</span><br><span class="line"># 设置为0可以禁用。</span><br><span class="line">sv_scriptHookAllowed 1</span><br><span class="line"></span><br><span class="line"># 取消前面的#可以启动RCON，记住你更改的密码。</span><br><span class="line">#rcon_password changeme#一般用不到</span><br><span class="line"></span><br><span class="line"># 服务器标签，中间用逗号隔开</span><br><span class="line"># 例如：</span><br><span class="line"># - sets tags &quot;drifting, cars, racing&quot;</span><br><span class="line"># 或者：</span><br><span class="line"># - sets tags &quot;roleplay, military, tanks&quot;</span><br><span class="line">sets tags &quot;default&quot;</span><br><span class="line"></span><br><span class="line"># 设置服务器横幅或者链接横幅的URL</span><br><span class="line"># 大小没有限制，任何图像都可以.</span><br><span class="line">#sets banner_detail &quot;http://url.to/image.png&quot;</span><br><span class="line">#sets banner_connecting &quot;http://url.to/image.png&quot;</span><br><span class="line"></span><br><span class="line"># 设置服务器名称</span><br><span class="line">sv_hostname &quot;My new FXServer!&quot;</span><br><span class="line"></span><br><span class="line"># 嵌套配置！一般不改。</span><br><span class="line">#exec server_internal.cfg</span><br><span class="line"></span><br><span class="line"># 服务器LOGO图标 (96x96 PNG文件)</span><br><span class="line">#load_server_icon myLogo.png</span><br><span class="line"></span><br><span class="line"># 可以在脚本中使用的封面。</span><br><span class="line">set temp_convar &quot;hey world!&quot;</span><br><span class="line"></span><br><span class="line"># #如果你不想服务器显示在FiveM网页服务器列表，可以把#号删掉。</span><br><span class="line">#sv_master1 &quot;&quot;</span><br><span class="line"></span><br><span class="line"># 只能让Steam或者第三方运营商进入你的FiveM服务器?</span><br><span class="line"># 不要忘记Social Club也是第三方提供商!</span><br><span class="line"># 一般不改</span><br><span class="line">#sv_authMaxVariance 1</span><br><span class="line">#sv_authMinTrust 5</span><br><span class="line"></span><br><span class="line"># 添加系统管理员。</span><br><span class="line">add_ace group.admin command allow # allow all commands</span><br><span class="line">add_ace group.admin command.quit deny # but don&#x27;t allow quit</span><br><span class="line">add_principal identifier.steam:1 group.admin # add the admin to the group</span><br><span class="line"></span><br><span class="line"># 在外部输出日志上不显示玩家的信息。</span><br><span class="line">sv_endpointprivacy true</span><br><span class="line"></span><br><span class="line"># 服务器人数设置 (必须在 1 到 32)</span><br><span class="line">sv_maxclients 32</span><br><span class="line"></span><br><span class="line"># 服务器密钥 (https://keymaster.fivem.net)</span><br><span class="line">sv_licenseKey changeme</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>需要修改的几项有：<br>_sv_hostname_：服务器名称，随便写<br>_load_server_icon_：服务器列表显示的图标，去掉 #表示开启，自定义图片必须是 96x96 分辨率的 png 图片而且放在<code>server-data</code>目录中与配置文件同级目录<br><em>add_principal identifier.steam</em>: 根据注册的账号 ID 添加管理员</p></blockquote><ol start="6"><li><p>去 <a href="https://forum.fivem.net/">FiveM 论坛</a>注册账户</p></li><li><p>再去获取<a href="https://keymaster.fivem.net/">服务器密钥</a>（序列号申请次数无上限）<br><img src="https://img.hacpai.com/file/2019/11/image-4d7563f5.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"></p></li></ol><p><img src="https://img.hacpai.com/file/2019/11/image-f00d3b0f.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"></p><ol start="8"><li><p>申请序列号之后将<code>server.cfg</code>配置文件最后一项的<code>changeme</code>部分替换成上一步申请的序列号即可<br><img src="https://img.hacpai.com/file/2019/11/image-f0df0149.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"></p></li><li><p>打开终端，输入下面两句命令即可启动 FiveM 服务器：</p></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd  /d D:\FXServer\server-data</span><br><span class="line">D:\FXServer\server\run.cmd +exec server.cfg</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img.hacpai.com/file/2019/11/image-92cad1ac.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"></p><blockquote><p>注意：若觉得每次启动服务器麻烦，可以新建一个 bat 文件，将上述两句命令粘贴进去，每次启动服务器的时候双击 bat 文件即可</p></blockquote><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>由于 Linux 搭建方法与 Windows 大同小异，故整理了一个自动化部署脚本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#下载服务器文件</span><br><span class="line">wget https://runtime.fivem.net/artifacts/fivem/build_proot_linux/master/1688-c814f804e64c28952269bc5abbac92d7c956f844/fx.tar.xz</span><br><span class="line"></span><br><span class="line">#下载资源文件</span><br><span class="line">git clone https://github.com/citizenfx/cfx-server-data.git server-data</span><br><span class="line"></span><br><span class="line">#创建文件夹</span><br><span class="line">mkdir -p /usr/local/src/FiveM/server</span><br><span class="line"></span><br><span class="line">#解压服务器文件到指定文件夹</span><br><span class="line">tar -xf fx.tar.xz -C /usr/local/src/FiveM/server</span><br><span class="line"></span><br><span class="line">#复制资源文件到指定文件夹</span><br><span class="line">cp -r server-data /usr/local/src/FiveM/</span><br><span class="line"></span><br><span class="line">#创建配置文件</span><br><span class="line">cat &lt;&lt;EOF &gt;/usr/local/src/FiveM/server-data/server.cfg</span><br><span class="line"># Only change the IP if you&#x27;re using a server with multiple network interfaces, otherwise change the port only.</span><br><span class="line">endpoint_add_tcp &quot;0.0.0.0:30120&quot;</span><br><span class="line">endpoint_add_udp &quot;0.0.0.0:30120&quot;</span><br><span class="line"></span><br><span class="line"># These resources will start by default.</span><br><span class="line">ensure mapmanager</span><br><span class="line">ensure chat</span><br><span class="line">ensure spawnmanager</span><br><span class="line">ensure sessionmanager</span><br><span class="line">ensure fivem</span><br><span class="line">ensure hardcap</span><br><span class="line">ensure rconlog</span><br><span class="line">ensure scoreboard</span><br><span class="line"></span><br><span class="line"># This allows players to use scripthook-based plugins such as the legacy Lambda Menu.</span><br><span class="line"># Set this to 1 to allow scripthook. Do note that this does _not_ guarantee players won&#x27;t be able to use external plugins.</span><br><span class="line">sv_scriptHookAllowed 0</span><br><span class="line"></span><br><span class="line"># Uncomment this and set a password to enable RCON. Make sure to change the password - it should look like rcon_password &quot;YOURPASSWORD&quot;</span><br><span class="line">#rcon_password &quot;&quot;</span><br><span class="line"></span><br><span class="line"># A comma-separated list of tags for your server.</span><br><span class="line"># For example:</span><br><span class="line"># - sets tags &quot;drifting, cars, racing&quot;</span><br><span class="line"># Or:</span><br><span class="line"># - sets tags &quot;roleplay, military, tanks&quot;</span><br><span class="line">sets tags &quot;default&quot;</span><br><span class="line"></span><br><span class="line"># A valid locale identifier for your server&#x27;s primary language.</span><br><span class="line"># For example &quot;en-US&quot;, &quot;fr-CA&quot;, &quot;nl-NL&quot;, &quot;de-DE&quot;, &quot;en-GB&quot;, &quot;pt-BR&quot;</span><br><span class="line">sets locale &quot;root-AQ&quot; </span><br><span class="line"># please DO replace root-AQ on the line ABOVE with a real language! :)</span><br><span class="line"></span><br><span class="line"># Set an optional server info and connecting banner image url.</span><br><span class="line"># Size doesn&#x27;t matter, any banner sized image will be fine.</span><br><span class="line">#sets banner_detail &quot;https://url.to/image.png&quot;</span><br><span class="line">#sets banner_connecting &quot;https://url.to/image.png&quot;</span><br><span class="line"></span><br><span class="line"># Set your server&#x27;s hostname</span><br><span class="line">sv_hostname &quot;FXServer, but unconfigured&quot;</span><br><span class="line"></span><br><span class="line"># Nested configs!</span><br><span class="line">#exec server_internal.cfg</span><br><span class="line"></span><br><span class="line"># Loading a server icon (96x96 PNG file)</span><br><span class="line">#load_server_icon myLogo.png</span><br><span class="line"></span><br><span class="line"># convars which can be used in scripts</span><br><span class="line">set temp_convar &quot;hey world!&quot;</span><br><span class="line"></span><br><span class="line"># Uncomment this line if you do not want your server to be listed in the server browser.</span><br><span class="line"># Do not edit it if you *do* want your server listed.</span><br><span class="line">#sv_master1 &quot;&quot;</span><br><span class="line"></span><br><span class="line"># Add system admins</span><br><span class="line">add_ace group.admin command allow # allow all commands</span><br><span class="line">add_ace group.admin command.quit deny # but don&#x27;t allow quit</span><br><span class="line">add_principal identifier.fivem:1 group.admin # add the admin to the group</span><br><span class="line"></span><br><span class="line"># Hide player endpoints in external log output.</span><br><span class="line">sv_endpointprivacy true</span><br><span class="line"></span><br><span class="line"># Server player slot limit (must be between 1 and 32, unless using OneSync)</span><br><span class="line">sv_maxclients 32</span><br><span class="line"></span><br><span class="line"># Steam Web API key, if you want to use Steam authentication (https://steamcommunity.com/dev/apikey)</span><br><span class="line"># -&gt; replace &quot;&quot; with the key</span><br><span class="line">set steam_webApiKey &quot;&quot;</span><br><span class="line"></span><br><span class="line"># License key for your server (https://keymaster.fivem.net)</span><br><span class="line">sv_licenseKey changeme</span><br><span class="line"></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将脚本中的<code>changeme</code>替换成服务器密钥即可部署</p><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>使用如下命令启动：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local/src/FiveM/server-data </span><br><span class="line">/usr/local/src/FiveM/server/run.sh +exec server.cfg</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>切记，不可用<code>/usr/local/src/FiveM/server/run.sh +exec /usr/local/src/FiveM/server-data/server.cfg</code>命令启动，会失败，具体原因未知</p></blockquote><h3 id="开机自启"><a href="#开机自启" class="headerlink" title="开机自启"></a>开机自启</h3><p>为了做到开机自启，我采用了 Supervisor 的方式 (使用 systemctl 方式会无限重启，原因未知)：<br>先创建一个启动服务的脚本<code>/usr/local/src/FiveM/start.sh</code>:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local/src/FiveM/server-data &amp;&amp; /usr/local/src/FiveM/server/run.sh +exec server.cfg</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后在 Supervisor 的配置文件夹<code>/etc/supervisor/conf.d/</code>中新建 FiveM 的启动文件<code>fivem.conf</code>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[program:fivem]</span><br><span class="line">command=/usr/bin/bash /usr/local/src/FiveM/start.sh</span><br><span class="line">directory=/usr/local/src/FiveM</span><br><span class="line">user=root</span><br><span class="line">stdout_logfile=/var/log/fivem.log</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br><span class="line">redirect_stderr=true</span><br><span class="line">stopsignal=QUIT</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后使用<code>supervisorctl reload</code>，选择<code>y</code>即可开机自启 FiveM 服务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@centos ~]# supervisorctl status</span><br><span class="line">fivem                            RUNNING   pid 3316, uptime 5:24:59</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实时日志如下 (每三分钟发一次心跳)：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@centos ~]# tail /var/log/fivem.log -f</span><br><span class="line">Sending heartbeat to live-internal.fivem.net:30110</span><br><span class="line">Sending heartbeat to live-internal.fivem.net:30110</span><br><span class="line">Sending heartbeat to live-internal.fivem.net:30110</span><br><span class="line">Sending heartbeat to live-internal.fivem.net:30110</span><br><span class="line">Sending heartbeat to live-internal.fivem.net:30110</span><br><span class="line">Sending heartbeat to live-internal.fivem.net:30110</span><br><span class="line">Sending heartbeat to live-internal.fivem.net:30110</span><br><span class="line">Sending heartbeat to live-internal.fivem.net:30110</span><br><span class="line">Sending heartbeat to live-internal.fivem.net:30110</span><br><span class="line">Sending heartbeat to live-internal.fivem.net:30110</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>连接情况 (若是云服务器或者是非本机的电脑需要添加 30120 的 TCP 和 UDP 入站规则)：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@VM_0_7_centos ~]# lsof -i:30120</span><br><span class="line">COMMAND    PID USER   FD   TYPE   DEVICE SIZE/OFF NODE NAME</span><br><span class="line">ld-musl-x 3317 root   28u  IPv4 36571478      0t0  TCP VM_0_7_centos:30120-&gt;150.116.85.124:55130 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   31u  IPv4 36470180      0t0  TCP *:30120 (LISTEN)</span><br><span class="line">ld-musl-x 3317 root   33u  IPv6 36470181      0t0  UDP *:30120</span><br><span class="line">ld-musl-x 3317 root   35u  IPv4 36476879      0t0  TCP VM_0_7_centos:30120-&gt;201.75.45.121:52624 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   36u  IPv4 36477004      0t0  TCP VM_0_7_centos:30120-&gt;67.166.27.29:57882 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   37u  IPv4 36509773      0t0  TCP VM_0_7_centos:30120-&gt;adria.kvarteto.net:50084 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   38u  IPv4 36483951      0t0  TCP VM_0_7_centos:30120-&gt;cable-188-2-205-27.dynamic.sbb.rs:52447 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   39u  IPv4 36484090      0t0  TCP VM_0_7_centos:30120-&gt;49.230.56.194:50631 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   40u  IPv4 36571801      0t0  TCP VM_0_7_centos:30120-&gt;176.148.208.253:58608 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   41u  IPv4 36484632      0t0  TCP VM_0_7_centos:30120-&gt;179.219.232.155:55005 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   42u  IPv4 36488632      0t0  TCP VM_0_7_centos:30120-&gt;client-201.230.158.233.speedy.net.pe:13723 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   43u  IPv4 36489318      0t0  TCP VM_0_7_centos:30120-&gt;112.201.139.65.pldt.net:ema-sent-lm (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   44u  IPv4 36504202      0t0  TCP VM_0_7_centos:30120-&gt;cpc69049-oxfd25-2-0-cust839.4-3.cable.virginm.net:55972 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   45u  IPv4 36509900      0t0  TCP VM_0_7_centos:30120-&gt;106.203.63.106:64732 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   46u  IPv4 36490560      0t0  TCP VM_0_7_centos:30120-&gt;177.155.219.25:58726 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   47u  IPv4 36510686      0t0  TCP VM_0_7_centos:30120-&gt;187.21.113.230:51463 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   48u  IPv4 36509557      0t0  TCP VM_0_7_centos:30120-&gt;pc-252-52-100-190.cm.vtr.net:50904 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   49u  IPv4 36492966      0t0  TCP VM_0_7_centos:30120-&gt;170.254.133.248:4657 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   50u  IPv4 36512199      0t0  TCP VM_0_7_centos:30120-&gt;93-86-107-145.dynamic.isp.telekom.rs:58530 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   51u  IPv4 36523715      0t0  TCP VM_0_7_centos:30120-&gt;c-71-193-90-215.hsd1.mn.comcast.net:64846 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   52u  IPv4 36515098      0t0  TCP VM_0_7_centos:30120-&gt;37.236.124.65:60517 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   53u  IPv4 36524821      0t0  TCP VM_0_7_centos:30120-&gt;ppp-223-24-144-28.revip6.asianet.co.th:11693 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   54u  IPv4 36522366      0t0  TCP VM_0_7_centos:30120-&gt;c-98-192-236-150.hsd1.de.comcast.net:58986 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   55u  IPv4 36522517      0t0  TCP VM_0_7_centos:30120-&gt;190.200.255.39:17832 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   56u  IPv4 36525992      0t0  TCP VM_0_7_centos:30120-&gt;cm-27-145-135-149.revip12.asianet.co.th:52631 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   57u  IPv4 36531724      0t0  TCP VM_0_7_centos:30120-&gt;73.126.70.158:50722 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   58u  IPv4 36555357      0t0  TCP VM_0_7_centos:30120-&gt;cpc139088-jarr15-2-0-cust109.16-2.cable.virginm.net:52928 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   59u  IPv4 36531740      0t0  TCP VM_0_7_centos:30120-&gt;c-174-50-61-97.hsd1.la.comcast.net:52188 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   60u  IPv4 36551137      0t0  TCP VM_0_7_centos:30120-&gt;187.21.84.137:65142 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   61u  IPv4 36555172      0t0  TCP VM_0_7_centos:30120-&gt;77.202.162.69:54845 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   62u  IPv4 36563973      0t0  TCP VM_0_7_centos:30120-&gt;199.199.246.200:63485 (ESTABLISHED)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注意：因为我是放在云服务器上的，所以刚搭建完没多久就有客户端连接上来了</p></blockquote><p>资源占用情况：<br><img src="https://img.hacpai.com/file/2019/11/image-cfe46be4.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Linux </tag>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派（raspberry）启用 root 账户</title>
      <link href="/posts/48985.html"/>
      <url>/posts/48985.html</url>
      
        <content type="html"><![CDATA[<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>树莓派使用的 linux 是 debian 系统，所以树莓派启用 root 和 debian 是相同的。</p><p>debian 里 root 账户默认没有密码，但账户锁定。</p><p>当需要 root 权限时，由默认账户经由 sudo 执行，Raspberry pi 系统中的 Raspbian</p><p>默认用户是 pi 密码为 raspberry</p><p>重新开启 root 账号，可由 pi 用户登录后，在命令行下执行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo passwd root</span><br></pre></td></tr></table></figure><p>执行此命令后系统会提示输入两遍的 root 密码，输入你想设的密码即可，然后在执行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo passwd --unlock root</span><br></pre></td></tr></table></figure><p>这样就可以解锁 root 账户了。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://leif.fun/articles/2019/08/27/1566891673134.html">树莓派（raspberry）启用root账户 - 琴声已散丶弦犹微振 (leif.fun)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> 教程 </tag>
            
            <tag> 配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派安装字体</title>
      <link href="/posts/32391.html"/>
      <url>/posts/32391.html</url>
      
        <content type="html"><![CDATA[<h2 id="安装字体"><a href="#安装字体" class="headerlink" title="安装字体"></a>安装字体</h2><p>1、下载字体</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://assets.ubuntu.com/v1/0cef8205-ubuntu-font-family-0.83.zip</span><br></pre></td></tr></table></figure><p>或者复制字体到linux上</p><p>2、用命令将要的字体复制到 <code>/usr/share/fonts/TrueType</code> 目录下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cp -r ubuntu-font-family-0.83/ /usr/share/fonts/truetype/</span><br></pre></td></tr></table></figure><p>3、修改字体权限，使root以外的用户可以使用这些字体。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chmod 755 /usr/share/fonts/truetype/ubuntu-font-family-0.83/ -R</span><br></pre></td></tr></table></figure><p>4、建立字体缓存，命令：<code>cd /usr/share/fonts/TrueType</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkfontscale</span><br><span class="line">mkfontdir </span><br><span class="line">fc-cache -fv </span><br></pre></td></tr></table></figure><p>5、重启，即可使用。</p><h2 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h2><p>没有这两个命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkfontscale</span><br><span class="line">mkfontdir </span><br></pre></td></tr></table></figure><p>需要安装一下两个包</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使mkfontscale和mkfontdir命令正常运行</span></span><br><span class="line">sudo apt-get install ttf-mscorefonts-installer</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使fc-cache命令正常运行</span></span><br><span class="line">sudo apt-get install fontconfig</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://leif.fun/articles/2019/08/27/1566889848431.html">树莓派安装字体 - 琴声已散丶弦犹微振 (leif.fun)</a></li><li><a href="https://blog.csdn.net/soulmate_P/article/details/87856420?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-1.no_search_link&spm=1001.2101.3001.4242.1">Linux(Ubuntu，Cent OS)环境安装mkfontscale mkfontdir命令以及中文字库_soulmate_P的博客-CSDN博客</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> 教程 </tag>
            
            <tag> 配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派 zsh 终端配置</title>
      <link href="/posts/3295.html"/>
      <url>/posts/3295.html</url>
      
        <content type="html"><![CDATA[<h2 id="安装zsh"><a href="#安装zsh" class="headerlink" title="安装zsh"></a>安装zsh</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get update #更新软件源索引</span><br><span class="line">sudo apt-get install zsh #安装zsh</span><br></pre></td></tr></table></figure><p>zsh安装完成后，执行:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/shells</span><br></pre></td></tr></table></figure><p>不出意外的话，终端应该会返回包含<code>/bin/zsh</code>或<code>/usr/bin/zsh</code>字样的结果了。</p><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><p>使用oh-my-zsh来配置zsh，oh-my-zsh是一个快速&amp;自动化配置zsh的项目，项目地址:<a href="https://github.com/robbyrussell/oh-my-zsh">https://github.com/robbyrussell/oh-my-zsh</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line"><span class="meta">#</span><span class="bash">下载并执行oh-my-zsh自动配置脚本</span></span><br><span class="line">wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh </span><br></pre></td></tr></table></figure><p>如果无法访问 github，可以做如下步骤</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://gitee.com/designer/ohmyzsh/raw/master/tools/install.sh</span><br><span class="line"></span><br><span class="line">vim install.sh</span><br><span class="line"><span class="comment"># 将前几行改为如下内容</span></span><br><span class="line"><span class="comment"># Default settings</span></span><br><span class="line">ZSH=<span class="variable">$&#123;ZSH:-~/.oh-my-zsh&#125;</span></span><br><span class="line">REPO=<span class="variable">$&#123;REPO:-designer/ohmyzsh&#125;</span></span><br><span class="line">REMOTE=<span class="variable">$&#123;REMOTE:-https://gitee.com/<span class="variable">$&#123;REPO&#125;</span>.git&#125;</span></span><br><span class="line">BRANCH=<span class="variable">$&#123;BRANCH:-master&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#保存后赋予执行权限</span></span><br><span class="line">chmod +x install.sh</span><br><span class="line"><span class="comment"># 然后执行</span></span><br><span class="line">sh install.sh</span><br></pre></td></tr></table></figure><p>执行此命令后，脚本将会下载zsh所需的资源和配置文件至<code>~/oh-my-zsh/</code>目录，并将根据你的系统环境变量完成对zsh的配置。</p><p>接着，我们可以执行以下命令将zsh切换为此用户的默认Shell(可能需要用户的密码):</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chsh -s /bin/zsh #无需加sudo</span><br></pre></td></tr></table></figure><p>退出终端并再次登录终端，这时命令指示符应该有变化了，说明zsh的基础配置完成。</p><h2 id="进阶配置"><a href="#进阶配置" class="headerlink" title="进阶配置"></a>进阶配置</h2><p>通过更改<code>~/.zshrc</code>文件来对zsh进行进一步的配置:</p><h3 id="更改主题"><a href="#更改主题" class="headerlink" title="更改主题"></a>更改主题</h3><p>对应的主题应该都有介绍，链接：<a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Themes">https://github.com/ohmyzsh/ohmyzsh/wiki/Themes</a></p><p>博主选用的是 agnoster</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ZSH_THEME=<span class="string">&quot;agnoster&quot;</span></span><br></pre></td></tr></table></figure><h3 id="自动纠错"><a href="#自动纠错" class="headerlink" title="自动纠错"></a>自动纠错</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENABLE_CORRECTION=&quot;true&quot;    #(去掉ENABLE前的&quot;#&quot;)打开zsh的自动纠错功能</span><br></pre></td></tr></table></figure><p>当纠错功能开启后，当你键入的命令被zsh判定为”可能错误的命令”时，将会提示你是否将此命令重定向为”zsh认为可能正确的命令”，比如键入<code>iconfig</code>命令时，zsh将会返回以下提示:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zsh: correct &#x27;iconfig&#x27; to &#x27;ifconfig&#x27; [nyae]?</span><br></pre></td></tr></table></figure><p>键入 y 即可将刚刚输入的iconfig命令重定向到ifconfig命令</p><h3 id="命令别名"><a href="#命令别名" class="headerlink" title="命令别名"></a>命令别名</h3><p>将以下内容添加到文件的末尾以重定向默认命令或添加自定义命令:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Alias Settings</span><br><span class="line">alias ll=&#x27;ls -all&#x27;</span><br><span class="line">alias vi=&#x27;vim&#x27;</span><br><span class="line">alias ps=&#x27;ps -A&#x27;</span><br><span class="line">alias ifconfig=&#x27;sudo ifconfig&#x27;</span><br></pre></td></tr></table></figure><p>其中，<code>alias ifconfig=&#39;sudo ifconfig&#39;</code>这一句比较重要，如果不加此内容，在当前用户下可能会出现无法执行ifconfig命令的情况。</p><p>如在终端中执行<code>ll</code>命令，相当于执行<code>ls -all</code>文件，执行<code>ps</code>命令则相当于执行<code>ps -A</code>命令:</p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>安装插件时可能因为网络问题无法连接到github仓库，可以到gitee上看看有没有对应的克隆库，替换一下即可。</p><h4 id="Autojump"><a href="#Autojump" class="headerlink" title="Autojump"></a>Autojump</h4><p>我们还可以安装Autojump插件，以实现快捷定位常用目录(需要在安装之前配置Python环境):</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="comment"># 从 Github 克隆 Autojump 项目</span></span><br><span class="line">git <span class="built_in">clone</span> git://github.com/joelthelion/autojump.git</span><br><span class="line"><span class="comment"># 或者从 Gitee 克隆</span></span><br><span class="line">git <span class="built_in">clone</span> https://gitee.com/watson8544/mirrors-autojump.git autojump</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> autojump</span><br><span class="line">sudo chmod +x install.py</span><br><span class="line"><span class="comment">#执行安装脚本，安装Autojump</span></span><br><span class="line">./install.py</span><br></pre></td></tr></table></figure><p>在脚本执行结果的末尾，你将会看到类似这样的内容(实际内容可能不一样):</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[[ -s /home/pi/.autojump/etc/profile.d/autojump.sh ]] &amp;&amp; source /home/pi/.autojump/etc/profile.d/autojump.sh</span><br><span class="line">autoload -U compinit &amp;&amp; compinit -u</span><br></pre></td></tr></table></figure><p>复制终端中这段内容，添加到<code>~/.zshrc</code>文件末尾即可启用Autojump。接着，我们可以执行以下命令重载<code>.zshrc</code>文件以更新zsh配置:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source .zshrc #重载zsh配置文件</span><br></pre></td></tr></table></figure><p>启用Autojump插件后，插件将记录你经常定位的目录，存储到数据库中，当之后想要访问此目录时，只需要键入:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">j &lt;目录简称&gt;</span><br></pre></td></tr></table></figure><p>即可快速定位。比如<code>/var/www/html</code>是我经常定位的目录。如果我想快捷访问此目录，只需要键入:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">j html</span><br></pre></td></tr></table></figure><p>即可快速定位。</p><h4 id="Tab补全命令忽略大小写"><a href="#Tab补全命令忽略大小写" class="headerlink" title="Tab补全命令忽略大小写"></a>Tab补全命令忽略大小写</h4><p>如果安装了autojump插件，并且已经配置好，只需在.zshrc增加下面一行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zstyle &#x27;:completion:*&#x27; matcher-list &#x27;m:&#123;[:lower:][:upper:]&#125;=&#123;[:upper:][:lower:]&#125;&#x27; &#x27;m:&#123;[:lower:][:upper:]&#125;=&#123;[:upper:][:lower:]&#125; l:|=* r:|=*&#x27; &#x27;m:&#123;[:lower:][:upper:]&#125;=&#123;[:upper:][:lower:]&#125; l:|=* r:|=*&#x27; &#x27;m:&#123;[:lower:][:upper:]&#125;=&#123;[:upper:][:lower:]&#125; l:|=* r:|=*&#x27;</span><br></pre></td></tr></table></figure><p>如果没有安装，增加下面两行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">autoload -Uz compinit &amp;&amp; compinit -u</span><br><span class="line">zstyle &#x27;:completion:*&#x27; matcher-list &#x27;m:&#123;[:lower:][:upper:]&#125;=&#123;[:upper:][:lower:]&#125;&#x27; &#x27;m:&#123;[:lower:][:upper:]&#125;=&#123;[:upper:][:lower:]&#125; l:|=* r:|=*&#x27; &#x27;m:&#123;[:lower:][:upper:]&#125;=&#123;[:upper:][:lower:]&#125; l:|=* r:|=*&#x27; &#x27;m:&#123;[:lower:][:upper:]&#125;=&#123;[:upper:][:lower:]&#125; l:|=* r:|=*&#x27;</span><br></pre></td></tr></table></figure><h4 id="sudo插件"><a href="#sudo插件" class="headerlink" title="sudo插件"></a>sudo插件</h4><p>开启sudo插件后，如果遇到上一条命令因为未在命令头部添加sudo命令而保存的情况时，只需要双击”Esc”键，即可自动为刚才键入的最后一条命令补全sudo。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plugins=(git sudo)    #为zsh添加git和sudo插件</span><br></pre></td></tr></table></figure><h4 id="highlighting插件"><a href="#highlighting插件" class="headerlink" title="highlighting插件"></a>highlighting插件</h4><p>命令高亮插件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://gitee.com/unrogue007/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure><p>在<code>.zshrc</code>配置文件的插件配置项增加高亮插件即可。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plugins=(git sudo zsh-syntax-highlighting )</span><br></pre></td></tr></table></figure><h4 id="autosuggestions插件"><a href="#autosuggestions插件" class="headerlink" title="autosuggestions插件"></a>autosuggestions插件</h4><p>命令提示插件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line">git clone https://gitee.com/who7708/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure><p>在<code>.zshrc</code>配置文件的插件配置项增加高亮插件即可。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plugins=(git sudo zsh-syntax-highlighting zsh-autosuggestions)</span><br></pre></td></tr></table></figure><p><strong>别忘了<code>source .zshrc</code> 重载zsh配置文件</strong></p><h3 id="隐藏用户名或者主机名"><a href="#隐藏用户名或者主机名" class="headerlink" title="隐藏用户名或者主机名"></a>隐藏用户名或者主机名</h3><p>修改<code>vim ~/.zshrc</code>文件,在文件底部增加</p><ul><li><p>隐藏用户名和主机名</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">prompt_context() &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>只保留用户名，隐藏主机名</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">prompt_context() &#123;</span><br><span class="line">  if [[ &quot;$USER&quot; != &quot;$DEFAULT_USER&quot; || -n &quot;$SSH_CLIENT&quot; ]]; then</span><br><span class="line">    prompt_segment black default &quot;%(!.%&#123;%F&#123;yellow&#125;%&#125;.)$USER&quot;</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>只保留主机名，隐藏用户名</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">prompt_context() &#123;</span><br><span class="line">  if [[ &quot;$USER&quot; != &quot;$DEFAULT_USER&quot; || -n &quot;$SSH_CLIENT&quot; ]]; then</span><br><span class="line">    prompt_segment black default &quot;%(!.%&#123;%F&#123;yellow&#125;%&#125;.)$HOST&quot;</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>修改后记得执行 <code>source ~/.zshrc</code></p><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><h3 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h3><ol><li>命令历史记录<ul><li>一旦在 shell 敲入正确命令并能执行后，shell 就会存储你所敲入命令的历史记录（存放在<code>~/.zsh_history</code> 文件中），方便再次运行之前的命令。可以按方向键 ↑ 和 ↓ 来查看之前执行过的命令</li><li>可以用 <code>r</code> 来执行上一条命令</li><li>使用 <code>ctrl-r</code> 来搜索命令历史记录</li></ul></li><li>命令别名<ul><li>可以简化命令输入，在 <code>.zshrc</code> 中添加 <code>alias shortcut=&#39;this is the origin command&#39;</code> 一行就相当于添加了别名</li><li>在命令行中输入 <code>alias</code> 可以查看所有的命令别名</li></ul></li></ol><h3 id="使用技巧-1"><a href="#使用技巧-1" class="headerlink" title="使用技巧"></a>使用技巧</h3><ul><li>连按两次 Tab 会列出所有的补全列表并直接开始选择，补全项可以使用 <code>ctrl+n/p/f/b</code> 上下左右切换</li><li>智能跳转，安装了 autojump 之后，zsh 会自动记录你访问过的目录，通过 j 目录名 可以直接进行目录跳转，而且目录名支持模糊匹配和自动补全，例如你访问过 hadoop-1.0.0 目录，输入 <code>j hado</code> 即可正确跳转。<code>j --stat</code> 可以看你的历史路径库。</li><li>命令选项补全。在 zsh 中只需要键入 tar -<tab> 就会列出所有的选项和帮助说明</li><li>在当前目录下输入 <code>..</code> 或 <code>...</code> ，或直接输入当前目录名都可以跳转，你甚至不再需要输入 <code>cd</code> 命令了。在你知道路径的情况下，比如 <code>/usr/local/bin</code> 你可以输入 <code> cd /u/l/b</code> 然后按进行补全快速输入</li><li>目录浏览和跳转：输入 <code>d</code>，即可列出你在这个会话里访问的目录列表，输入列表前的序号，即可直接跳转。</li><li>命令参数补全。键入<code> kill &lt;tab&gt;</code> 就会列出所有的进程名和对应的进程号</li><li>更智能的历史命令。在用或者方向上键查找历史命令时，zsh 支持限制查找。比如，输入<code>ls</code>, 然后再按方向上键，则只会查找用过的 <code>ls</code> 命令。而此时使用则会仍然按之前的方式查找，忽略 ls</li><li>多个终端会话共享历史记录</li><li>通配符搜索：<code>ls -l **/*.sh</code>，可以递归显示当前目录下的 shell 文件，文件少时可以代替 <code>find</code>。使用 <code>**/</code> 来递归搜索</li><li>扩展环境变量，输入环境变量然后按 就可以转换成表达的值</li><li>在 .zshrc 中添加 <code>setopt HIST_IGNORE_DUPS</code> 可以消除重复记录，也可以利用<code>sort -t &quot;;&quot; -k 2 -u ~/.zsh_history | sort -o ~/.zsh_history</code>手动清除</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://mlapp.cn/310.html">树莓派折腾记:安装并配置zsh | 美丽应用 (mlapp.cn)</a></li><li><a href="https://www.jianshu.com/p/3158a2116fdf">ZSH的配置 - 简书 (jianshu.com)</a></li><li><a href="https://blog.csdn.net/a_zhon/article/details/111397861">Mac上终端使用zsh，设置不区分大小写进行Tab补全_我们不生产代码，我们只是代码的搬运工-CSDN博客</a></li><li><a href="https://segmentfault.com/a/1190000013612471">zsh+on-my-zsh配置教程指南（程序员必备）</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> 教程 </tag>
            
            <tag> zsh </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派安装Clash代理</title>
      <link href="/posts/60310.html"/>
      <url>/posts/60310.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>更新时间：2021-12-03 16:22<br>感谢 shgm 提出的意见。</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>到 <a href="https://github.com/Dreamacro/clash/releases">官方Releases页面</a> 下，选择合适的版本下载。</p><p>我这里下载的是 <a href="https://github.com/Dreamacro/clash/releases/download/v1.7.1/clash-linux-armv8-v1.7.1.gz">clash-linux-armv8-v1.7.1.gz</a></p><h3 id="解压并安装"><a href="#解压并安装" class="headerlink" title="解压并安装"></a>解压并安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget -O clash-linux-armv8-v1.7.1.gz https://github.com/Dreamacro/clash/releases/download/v1.7.1/clash-linux-armv8-v1.7.1.gz</span><br><span class="line"></span><br><span class="line">gzip -dv clash-linux-armv8-v1.7.1.gz</span><br><span class="line"></span><br><span class="line">sudo mv clash-linux-armv8-v1.7.1 /usr/local/bin/clash</span><br><span class="line"></span><br><span class="line">sudo chmod a+x /usr/local/bin/clash</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>首次运行，初始化一下 config 目录<br>输入</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clash</span><br></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">INFO[0000] Can<span class="string">&#x27;t find config, create a initial config file</span></span><br><span class="line"><span class="string">INFO[0000] Can&#x27;</span>t find MMDB, start download</span><br><span class="line">INFO[0005] Mixed(http+socks) proxy listening at: 127.0.0.1:7890</span><br></pre></td></tr></table></figure><p>然后 ctrl+c 终止运行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载配置文件（如果是root用户安装clash的那么配置文件应放在/root/.config/clash目录下）</span></span><br><span class="line">wget -O /home/pi/.config/clash/config.yaml &quot;https://xxxx.xx/xxx&quot;</span><br></pre></td></tr></table></figure><p>这里的 <code>https://xxxx.xx/xxx</code> 指的是购买渠道提供的配置文件链接（一般会有一个一键订阅的按钮，找一下哪里有复制订阅地址的按钮）。我电脑上也在用，所以直接复制过来了。<strong>名字一定要是 config.yaml</strong>，不然会读取不了配置。</p><table>    <tr>        <td>            <center><img src="https://images.961110.xyz/images/2021/12/03/9852a787ca4a9b1526c374db92b5e3c7.png">                图1 购买渠道订阅地址 </center>        </td>        <td>            <center><img src="https://images.961110.xyz/images/2021/10/22/clash.png" style="zoom: 50%">                图2 本机 Clash 已有链接 </center>        </td>    </tr></table><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">less /home/pi/.config/clash/config.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">port: 7890</span><br><span class="line">socks-port: 7891</span><br><span class="line">allow-lan: <span class="literal">false</span></span><br><span class="line">mode: Rule</span><br><span class="line">log-level: info</span><br><span class="line">external-controller: 0.0.0.0:9091</span><br><span class="line"></span><br><span class="line"><span class="comment"># :q 退出</span></span><br></pre></td></tr></table></figure><p>port 为代理的端口<br>allow-lan 为是否开启局域网访问<br>external-controller 为 Clash 控制端口与允许访问该端口的设备</p><p><strong>这里 mode 先设置为 Global，方便之后测试。</strong></p><h3 id="配置开机启动"><a href="#配置开机启动" class="headerlink" title="配置开机启动"></a>配置开机启动</h3><p>官方教程：<a href="https://github.com/Dreamacro/clash/wiki/clash-as-a-daemon#systemd">https://github.com/Dreamacro/clash/wiki/clash-as-a-daemon#systemd</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将配置文件复制到/etc/clash文件夹中</span></span><br><span class="line">sudo mkdir /etc/clash</span><br><span class="line"></span><br><span class="line">sudo cp /home/pi/.config/clash/config.yaml /etc/clash/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 虽然前面的步骤中没见过这个文件，但是它是自动生成的</span></span><br><span class="line">sudo cp /home/pi/.config/clash/Country.mmdb /etc/clash/</span><br></pre></td></tr></table></figure><p>在systemd配置目录中新建配置文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/systemd/system/clash.service</span><br></pre></td></tr></table></figure><p>输入一下内容</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Clash daemon, A rule-based proxy in Go.</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">Restart=always</span><br><span class="line">ExecStart=/usr/local/bin/clash -d /etc/clash</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>启动开机自启</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> clash</span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl start clash</span><br></pre></td></tr></table></figure><p>检查状态</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssystemctl status clash</span><br><span class="line"></span><br><span class="line">pi@pi-desktop:~$ systemctl status clash</span><br><span class="line">● clash.service - Clash daemon, A rule-based proxy <span class="keyword">in</span> Go.</span><br><span class="line">     Loaded: loaded (/etc/systemd/system/clash.service; enabled; vendor preset: <span class="built_in">enable</span>&gt;</span><br><span class="line">     Active: active (running) since Fri 2021-12-03 16:09:24 CST; 4min 49s ago</span><br><span class="line">   Main PID: 134991 (clash)</span><br><span class="line">      Tasks: 10 (<span class="built_in">limit</span>: 8895)</span><br><span class="line">     Memory: 10.1M</span><br><span class="line">        CPU: 2.999s</span><br><span class="line">     CGroup: /system.slice/clash.service</span><br><span class="line">             └─134991 /usr/<span class="built_in">local</span>/bin/clash -d /etc/clash</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> <code>Active: active (running)</code> 表明 Clash 已经运行起来了。</p><h3 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h3><p>因为 Clash 没有原生的管理方式，需要通过以下网站可以管理 Clash</p><p><a href="http://clash.razord.top/#/settings">http://clash.razord.top/#/settings</a></p><img src="https://images.961110.xyz/images/2021/10/22/clashe8aa2ec8d51bee0e.png" alt="image-20211022174624218" style="zoom:50%;" /><p>Host 填写树莓派的 IP，端口填写 clash 配置文件中<code>external-controller</code>填写的端口。</p><img src="https://images.961110.xyz/images/2021/10/22/clash49c32381cceff753.png" alt="image-20211022174803075" style="zoom:50%;" /><p>在设置页面也可以控制全局代理还是规则代理还是直连，配置完成后进入代理界面，选择可用的节点。</p><h3 id="开启代理"><a href="#开启代理" class="headerlink" title="开启代理"></a>开启代理</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=127.0.0.1:7890</span><br><span class="line"><span class="built_in">export</span> https_proxy=127.0.0.1:7890</span><br></pre></td></tr></table></figure><p>取消代理</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unset</span> http_proxy</span><br><span class="line"><span class="built_in">unset</span> https_proxy</span><br></pre></td></tr></table></figure><p>验证代理是否成功</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl www.google.com -I</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Cache-Control: private</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure><p><strong>返回 200 说明配置成功</strong>。</p><p>如果提示未安装 curl，输入以下命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt install curl</span><br></pre></td></tr></table></figure><p>上面的配置方式是临时的，可开关的配置可以参考 <a href="https://blog.961110.xyz/posts/60538.html#%E7%BB%88%E7%AB%AF%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE">VMware虚拟机使用主机代理</a> ，IP 改为 127.0.0.1 </p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="http://events.jianshu.io/p/f0daa2d9eae6">树莓派4B 通过Clash实现代理 - 简书 (jianshu.io)</a></li><li><a href="https://www.cnblogs.com/rogunt/p/15127947.html">在Linux终端中使用Clash（clash for linux) - Rogunt - 博客园 (cnblogs.com)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> 教程 </tag>
            
            <tag> 代理 </tag>
            
            <tag> 科学上网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux通过dd命令备份及还原SD卡</title>
      <link href="/posts/2965.html"/>
      <url>/posts/2965.html</url>
      
        <content type="html"><![CDATA[<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>dd：用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换。</p><p>参数：</p><ol><li>if=文件名：输入文件名，缺省为标准输入。即指定源文件。&lt; if=input file &gt;</li><li>of=文件名：输出文件名，缺省为标准输出。即指定目的文件。&lt; of=output file &gt;</li></ol><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li><p>将读卡器连接到Linux虚拟机中；</p></li><li><p>使用<code>sudo fdisk -l</code>命令列出所有存储设备，找到SD对应的盘符，/dev/sdb</p><img src="https://images.961110.xyz/images/2021/10/21/fdisk--l.png" alt="image-20211021164046598" style="zoom:50%;" /></li><li><p>输入<code>sudo dd if=/dev/sdb status=progress | gzip &gt; /path2backup/backup.gz</code>将镜像备份到指定目录，并用gzip压缩</p></li><li><p>要恢复的话，输入<code>gzip -dc /path2backup/backup.gz | dd of=/dev/sdb</code></p><p>如果提示权限不足，直接赋予权限即可 <code>sudo chmod 777 /dev/sdb</code></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> 教程 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派4B启动配置</title>
      <link href="/posts/59454.html"/>
      <url>/posts/59454.html</url>
      
        <content type="html"><![CDATA[<h2 id="镜像及工具"><a href="#镜像及工具" class="headerlink" title="镜像及工具"></a>镜像及工具</h2><h3 id="系统镜像"><a href="#系统镜像" class="headerlink" title="系统镜像"></a>系统镜像</h3><h4 id="Raspberry-Pi-OS"><a href="#Raspberry-Pi-OS" class="headerlink" title="Raspberry Pi OS"></a>Raspberry Pi OS</h4><p>官方镜像，基于Debian的一个发行版，针对树莓派做了优化。</p><p>一共提供了三个版本，镜像大小逐个递减。</p><ol><li>Raspberry Pi OS with desktop and recommended software：有图形界面，内置各种软件，比如博主的世界、Python、游戏等；</li><li>Raspberry Pi OS with desktop：有图形界面、浏览器，没有一些乱七八糟的软件；</li><li>Raspberry Pi OS Lite：无图形界面，有核心依赖，比如Python等。</li></ol><p>需要图形化界面的更推荐Raspberry Pi OS with desktop这个版本，不大不小。不过<strong>官网默认提供的是32bit的版本</strong>，树莓派RaspBerry4B的CPU是博通的BCM2711，一颗ARM Cortex-A72架构的64位处理器，所以使用64位系统才能更好释放性能。</p><blockquote><p><a href="https://www.raspberrypi.com/software/operating-systems/">32bit镜像官网链接</a></p><p><a href="https://www.raspberrypi.com/software/operating-systems/#raspberry-pi-os-64-bit">64bit镜像官网链接</a></p><p><a href="https://www.raspberrypi.com/software/operating-systems/">镜像的官方介绍及各个版本</a></p></blockquote><h3 id="SD卡格式化工具"><a href="#SD卡格式化工具" class="headerlink" title="SD卡格式化工具"></a>SD卡格式化工具</h3><p>SD Card Formatter</p><p><a href="https://www.sdcard.org/downloads/formatter/sd-memory-card-formatter-for-windows-download/">官网下载链接</a></p><h3 id="写镜像工具"><a href="#写镜像工具" class="headerlink" title="写镜像工具"></a>写镜像工具</h3><p>Win32DiskImager</p><p><a href="https://sourceforge.net/projects/win32diskimager/files/latest/download">官方下载链接</a></p><h3 id="远程桌面工具"><a href="#远程桌面工具" class="headerlink" title="远程桌面工具"></a>远程桌面工具</h3><h5 id="VNC-Viewer"><a href="#VNC-Viewer" class="headerlink" title="VNC Viewer"></a>VNC Viewer</h5><p><a href="https://www.realvnc.com/en/connect/download/viewer/">官方下载链接</a></p><h2 id="刷写系统"><a href="#刷写系统" class="headerlink" title="刷写系统"></a>刷写系统</h2><h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><p>此处博主下载的是64位的最新镜像，官方文件名为：2021-05-07-raspios-buster-arm64</p><p>下载之后可以Windows 10终端里输入下面命令来计算SHA256进行完整性校验。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">certutil -hashfile 镜像存放路径\2021-05-07-raspios-buster-arm64.zip SHA256</span><br></pre></td></tr></table></figure><p>BTW，可选哈希算法参数有MD2 MD4 MD5 SHA1 SHA256 SHA384 SHA512</p><p><img src="https://images.961110.xyz/images/2021/10/19/Raspberry-Pi-OS-with-desktop-.png" alt="image-20211016201407578" style="zoom:50%;" /><img src="https://images.961110.xyz/images/2021/10/19/Raspberry-Pi-OS-with-desktop-dc4e0e6197208ff1.png" alt="image-20211016201252081" style="zoom:50%;" /></p><p>两个不同的下载通道都可以看到SHA256的值，最好校验一下。</p><p>校验无误后，解压得到<code>.img</code>镜像文件，待会写到SD卡中。</p><h3 id="格式化SD卡"><a href="#格式化SD卡" class="headerlink" title="格式化SD卡"></a>格式化SD卡</h3><p>选择好SD卡对应的盘符，选择Quick format，点击右下角Format，稍等片刻即可。<strong>注意不要选择错了盘符，否则后果不堪设想。</strong></p><p><img src="https://images.961110.xyz/images/2021/10/19/SD-Card-Formatter.png" alt="image-20211016201935243" style="zoom: 67%;" /><img src="https://images.961110.xyz/images/2021/10/19/SD.png" alt="image-20211016202211668" style="zoom:67%;" /></p><h3 id="刷写镜像"><a href="#刷写镜像" class="headerlink" title="刷写镜像"></a>刷写镜像</h3><p>选择刚刚解压出来的镜像文件，选择好盘符，然后点击写入即可，完成速度取决于SD卡及读卡器的速度。</p><p><img src="https://images.961110.xyz/images/2021/10/19/f28e57496b9b60234c05963587aebae3.png" alt="image-20211016202444369" style="zoom:67%;" /><img src="https://images.961110.xyz/images/2021/10/19/1163840ac01b2da689eb0dc2686f4eb3.png" alt="image-20211016203816344" style="zoom:67%;" /></p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="开启ssh"><a href="#开启ssh" class="headerlink" title="开启ssh"></a>开启ssh</h4><p>写入镜像后，会有一个boot分区，在boot分区下新建一个<strong>删掉格式后缀</strong>的名为ssh的<strong>文件</strong>，以便启动后使用ssh连接树莓派。</p><h4 id="通过网线共享电脑的网络"><a href="#通过网线共享电脑的网络" class="headerlink" title="通过网线共享电脑的网络"></a>通过网线共享电脑的网络</h4><blockquote><p>设置–&gt;状态–&gt;高级网络设置：更改适配器选项–&gt;选择电脑联网的适配器–&gt;右键选择属性，点击共享–&gt;打开下图中的选项–&gt;选择树莓派要连接的适配器–&gt;确定</p></blockquote><img src="https://images.961110.xyz/images/2021/10/19/2d3ddc0a200c6e2f6386bbfe718cb969.png" alt="image-20211017133126324" style="zoom:50%;" /><p>此种方式的默认的网关IP是192.168.137.1，所以分配给树莓派的IP是192.168.137.XXX，具体查看方式见下文。</p><h4 id="通过配置WiFi上网"><a href="#通过配置WiFi上网" class="headerlink" title="通过配置WiFi上网"></a>通过配置WiFi上网</h4><p>在boot分区新建一个wpa_supplicant.conf文件，内容如下:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">country=CN</span><br><span class="line">ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev</span><br><span class="line">update_config=1</span><br><span class="line"></span><br><span class="line">network=&#123;</span><br><span class="line">       ssid=&quot;XXXXXXX&quot;</span><br><span class="line">       psk=&quot;password&quot;</span><br><span class="line">       key_mgmt=WPA-PSK</span><br><span class="line">       priority=1</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>ssid</code>就是WIFI名，<code>psk</code>就是WiFi密码，<code>key_mgmt</code>就是WiFi的加密方式，一般在路由器管理界面的WiFi设置中可以看到。</p><p>和一般的不同，这里**<code>priority</code>值越大，优先级越大**。</p><h4 id="连接风扇"><a href="#连接风扇" class="headerlink" title="连接风扇"></a>连接风扇</h4><img src="https://images.961110.xyz/images/2021/10/19/4B-.jpg" alt="树莓派4B 连接风扇" style="zoom:50%;" /><p>树莓派4B的GPIO口外侧是偶数口，内侧是奇数口，如图示从左到右需要依次增大。风扇需要连接在第4和6号引脚上，正极（红线）连接在4号引脚，负极（黑线）连接在6号引脚。</p><h3 id="通电"><a href="#通电" class="headerlink" title="通电"></a>通电</h3><h4 id="状态检查"><a href="#状态检查" class="headerlink" title="状态检查"></a>状态检查</h4><p>插入SD卡，插入网线，连接电源自动开机：</p><ul><li>红灯常亮：未能检测到TF卡；</li><li>双灯常亮：未能检测到系统；</li><li>绿灯闪烁：系统运行正常。、</li></ul><p>等个几十秒进行下一步</p><h4 id="通过网线联网，查看树莓派Raspberry-4B的IP"><a href="#通过网线联网，查看树莓派Raspberry-4B的IP" class="headerlink" title="通过网线联网，查看树莓派Raspberry 4B的IP"></a>通过网线联网，查看树莓派Raspberry 4B的IP</h4><p>打开cmd或其他shell工具，通过<code>arp -a</code>查看本机的arp表，找到接口为192.168.137.1下的内容</p><p>可以看到树莓派Raspberry 4B获得的IP: 192.168.137.XXX</p><h4 id="通过配置WiFi上网，查看树莓派Raspberry-4B的IP"><a href="#通过配置WiFi上网，查看树莓派Raspberry-4B的IP" class="headerlink" title="通过配置WiFi上网，查看树莓派Raspberry 4B的IP"></a>通过配置WiFi上网，查看树莓派Raspberry 4B的IP</h4><p>进入路由器后台，查看接入网络的设备列表，记录其IP即可。</p><p>此处博主通过Windows 10开启移动热点，树莓派连接上WIFI之后可以直接看到IP地址</p><img src="https://images.961110.xyz/images/2021/10/21/Windows104a0509f4c0915e31.png" alt="image-20211021162133259" style="zoom:50%;" /><img src="https://images.961110.xyz/images/2021/10/21/Windows10851671f235bebad9.png" alt="image-20211021162217862" style="zoom:50%;" /><h3 id="ssh连接"><a href="#ssh连接" class="headerlink" title="ssh连接"></a>ssh连接</h3><p>获取IP后，直接 <code>ssh pi@IP</code> 即可</p><p>密码是 raspberry</p><h3 id="VNC连接"><a href="#VNC连接" class="headerlink" title="VNC连接"></a>VNC连接</h3><h4 id="开启VNC"><a href="#开启VNC" class="headerlink" title="开启VNC"></a>开启VNC</h4><p>使用ssh登录之后，输入<code>sudo raspi-config</code>进行配置</p><p><img src="https://images.961110.xyz/images/2021/10/21/config.png" alt="image-20211021162433139" style="zoom: 40%;" /><img src="https://images.961110.xyz/images/2021/10/21/VNC.png" alt="image-20211021161625685" style="zoom:45%;" /></p><p>此种方式是<strong>开机自动开启</strong>VNC服务的。</p><p>在终端输入<code>vncserver</code>开启NVC服务的方式，每次启动必须手动执行才可以。</p><h4 id="使用VNC连接"><a href="#使用VNC连接" class="headerlink" title="使用VNC连接"></a>使用VNC连接</h4><img src="https://images.961110.xyz/images/2021/10/21/VNC7439f5bdc8e20c2c.png" alt="image-20211021162832932" style="zoom: 50%;" /><p>直接输入树莓派的IP地址即可。</p><h3 id="使用微软远程桌面连接"><a href="#使用微软远程桌面连接" class="headerlink" title="使用微软远程桌面连接"></a>使用微软远程桌面连接</h3><h4 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装 xrdp</span></span><br><span class="line">sudo apt-get install xrdp</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动xrdp</span></span><br><span class="line">sudo /etc/init.d/xrdp start</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将Xrdp服务添加到系统默认启动服务中</span></span><br><span class="line">sudo update-rc.d xrdp defaults</span><br></pre></td></tr></table></figure><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>打开Windows远程桌面，输入树莓派4B的IP，连接即可。默认用户名：pi，默认密码：raspberry。</p><h3 id="安装中文字体"><a href="#安装中文字体" class="headerlink" title="安装中文字体"></a>安装中文字体</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get -y install fonts-wqy-zenhei</span><br></pre></td></tr></table></figure><h3 id="安装虚拟键盘"><a href="#安装虚拟键盘" class="headerlink" title="安装虚拟键盘"></a>安装虚拟键盘</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install matchbox-keyboard</span><br></pre></td></tr></table></figure><p>安装之后可以在附件中找到快捷方式。</p><img src="https://images.961110.xyz/images/2021/10/23/fc94eb07ca8e02d7fc2d1b1e7170f0fe.png" alt="image-20211023170143928" style="zoom: 50%;" /><h2 id="更换软件源"><a href="#更换软件源" class="headerlink" title="更换软件源"></a>更换软件源</h2><h3 id="Debian系统源"><a href="#Debian系统源" class="headerlink" title="Debian系统源"></a>Debian系统源</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure><p>清空原文件中的内容，填入清华大学的源</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster main contrib non-free</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster main contrib non-free</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-updates main contrib non-free</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-updates main contrib non-free</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-backports main contrib non-free</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-backports main contrib non-free</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian-security buster/updates main contrib non-free</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/debian-security buster/updates main contrib non-free</span><br></pre></td></tr></table></figure><h3 id="树莓派软件源"><a href="#树莓派软件源" class="headerlink" title="树莓派软件源"></a>树莓派软件源</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /etc/apt/sources.list.d/raspi.list /etc/apt/sources.list.d/raspi.list.bak</span><br></pre></td></tr></table></figure><p>清空原文件中的内容，填入清华大学的源</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui</span><br></pre></td></tr></table></figure><h3 id="刷新软件包信息"><a href="#刷新软件包信息" class="headerlink" title="刷新软件包信息"></a>刷新软件包信息</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><h3 id="版本信息"><a href="#版本信息" class="headerlink" title="版本信息"></a>版本信息</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pi@raspberrypi:~ $ uname -a</span><br><span class="line">Linux raspberrypi 5.10.63-v8+ #1459 SMP PREEMPT Wed Oct 6 16:42:49 BST 2021 aarch64 GNU/Linux</span><br><span class="line"></span><br><span class="line">pi@raspberrypi:~ $ cat /proc/version</span><br><span class="line">Linux version 5.10.63-v8+ (dom@buildbot) (aarch64-linux-gnu-gcc-8 (Ubuntu/Linaro 8.4.0-3ubuntu1) 8.4.0, GNU ld (GNU Binutils for Ubuntu) 2.34) #1459 SMP PREEMPT Wed Oct 6 16:42:49 BST 2021</span><br><span class="line"></span><br><span class="line">pi@raspberrypi:~ $ lsb_release -a</span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID: Debian</span><br><span class="line">Description:    Debian GNU/Linux 10 (buster)</span><br><span class="line">Release:        10</span><br><span class="line">Codename:       buster</span><br></pre></td></tr></table></figure><h3 id="重要部件信息"><a href="#重要部件信息" class="headerlink" title="重要部件信息"></a>重要部件信息</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pi@raspberrypi:~ $ lscpu</span><br><span class="line">Architecture:        aarch64</span><br><span class="line">Byte Order:          Little Endian</span><br><span class="line">CPU(s):              4</span><br><span class="line">On-line CPU(s) list: 0-3</span><br><span class="line">Thread(s) per core:  1</span><br><span class="line">Core(s) per socket:  4</span><br><span class="line">Socket(s):           1</span><br><span class="line">Vendor ID:           ARM</span><br><span class="line">Model:               3</span><br><span class="line">Model name:          Cortex-A72</span><br><span class="line">Stepping:            r0p3</span><br><span class="line">CPU max MHz:         1500.0000</span><br><span class="line">CPU min MHz:         600.0000</span><br><span class="line">BogoMIPS:            108.00</span><br><span class="line">Flags:               fp asimd evtstrm crc32 cpuid</span><br><span class="line"></span><br><span class="line">pi@raspberrypi:~ $ lsusb</span><br><span class="line">Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub</span><br><span class="line">Bus 001 Device 002: ID 2109:3431 VIA Labs, Inc. Hub</span><br><span class="line">Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub</span><br><span class="line"></span><br><span class="line">pi@raspberrypi:~ $ sudo ifconfig -a</span><br><span class="line">eth0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        ether e4:5f:01:64:3c:12  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 5  bytes 284 (284.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 5  bytes 284 (284.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">wlan0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.137.208  netmask 255.255.255.0  broadcast 192.168.137.255</span><br><span class="line">        inet6 fe80::9ac0:acda:640d:1cf0  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether e4:5f:01:64:3c:14  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 38498  bytes 48445286 (46.2 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 21303  bytes 3907714 (3.7 MiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> 教程 </tag>
            
            <tag> 配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker安装chevereto图床并解除上传图片大小限制、自定义图片上传用户和相册</title>
      <link href="/posts/36360.html"/>
      <url>/posts/36360.html</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>直接用官方的推荐安装方式，修改后的docker-compose.yaml如下</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mariadb</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">database:/var/lib/mysql:rw</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">private</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">xxx</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">chevereto</span></span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="string">jason</span></span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="string">xxx</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">chevereto:</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nmtan/chevereto</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">private</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">CHEVERETO_DB_HOST:</span> <span class="string">db</span></span><br><span class="line">      <span class="attr">CHEVERETO_DB_USERNAME:</span> <span class="string">jason</span></span><br><span class="line">      <span class="attr">CHEVERETO_DB_PASSWORD:</span> <span class="string">xxx</span></span><br><span class="line">      <span class="attr">CHEVERETO_DB_NAME:</span> <span class="string">chevereto</span></span><br><span class="line">      <span class="attr">CHEVERETO_DB_PREFIX:</span> <span class="string">chv_</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/home/Jason/chv_images:/var/www/html/images:rw</span>  <span class="comment">#将照片存放路径映射到了本地存储中</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span><span class="string">:80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">private:</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">database:</span></span><br><span class="line">  <span class="attr">chevereto_images:</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后<code>docker-compose up -d</code>就可以启动，通过8080端口访问chevereto。</p><h2 id="解除上传图片的大小限制"><a href="#解除上传图片的大小限制" class="headerlink" title="解除上传图片的大小限制"></a>解除上传图片的大小限制</h2><h3 id="复制到服务器本地路径下"><a href="#复制到服务器本地路径下" class="headerlink" title="复制到服务器本地路径下"></a>复制到服务器本地路径下</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">docker cp  containerID:<span class="regexp">/var/</span>www/html/.htaccess /volume1/docker/</span><br></pre></td></tr></table></figure><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /volume1/docker/.htaccess</span><br><span class="line"></span><br><span class="line"># Disable server signature</span><br><span class="line">ServerSignature Off</span><br><span class="line"></span><br><span class="line"># Disable directory listing (-indexes), Multiviews (-MultiViews) and enable Follow system links (+FollowSymLinks)</span><br><span class="line">Options -Indexes</span><br><span class="line">Options -MultiViews</span><br><span class="line"></span><br><span class="line">&lt;IfModule mod_rewrite.c&gt;</span><br><span class="line"></span><br><span class="line">    RewriteEngine On</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    RewriteRule . index.php [L]</span><br><span class="line">    #修改上传文件大小增加以下 配置  最大支持 32M 根据自己情况配置</span><br><span class="line">    php_value post_max_size 64M</span><br><span class="line">    php_value upload_max_filesize 32M</span><br><span class="line"></span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure><h3 id="复制到容器目录里面"><a href="#复制到容器目录里面" class="headerlink" title="复制到容器目录里面"></a>复制到容器目录里面</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">docker cp /volume1/docker/.htaccess containerID:<span class="regexp">/var/</span>www/html/</span><br></pre></td></tr></table></figure><h2 id="修改上传API"><a href="#修改上传API" class="headerlink" title="修改上传API"></a>修改上传API</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp containerID:/var/www/html/app/routes/route.api.php ./</span><br></pre></td></tr></table></figure><p>将PHP文件复制出来，相应位置增加如下代码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$version</span> = <span class="variable">$handler</span>-&gt;request[<span class="number">0</span>];</span><br><span class="line"><span class="variable">$action</span> = <span class="variable">$handler</span>-&gt;request[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增下面两行</span></span><br><span class="line"><span class="variable">$user</span> = <span class="variable">$_REQUEST</span>[<span class="string">&#x27;user&#x27;</span>];</span><br><span class="line"><span class="variable">$album</span> = <span class="variable">$_REQUEST</span>[<span class="string">&#x27;album&#x27;</span>];</span><br></pre></td></tr></table></figure><p>更改如下代码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将这行代码增加 user 和 album 两个参数</span></span><br><span class="line"><span class="variable">$uploaded_id</span> = CHV\Image::uploadToWebsite(<span class="variable">$source</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更改后的代码如下</span></span><br><span class="line"><span class="variable">$uploaded_id</span> = CHV\Image::uploadToWebsite(<span class="variable">$source</span>, <span class="variable">$user</span>, <span class="keyword">array</span>(<span class="string">&#x27;album_id&#x27;</span>=&gt;<span class="variable">$album</span>));</span><br></pre></td></tr></table></figure><p>将修改后的文件复制到容器中替换</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp ./route.api.php  containerID:/var/www/html/app/routes/route.api.php</span><br></pre></td></tr></table></figure><h2 id="配置Typora和PicGo"><a href="#配置Typora和PicGo" class="headerlink" title="配置Typora和PicGo"></a>配置Typora和PicGo</h2><p>在PicGo中下载插件web-uploader，填入如下配置</p><img src="https://images.961110.xyz/images/2021/10/20/image-20211020120134965.png" alt="image-20211020120134965" style="zoom: 50%;" /><ul><li>API地址：http或https(根据自身情况)://域名/api/1/upload</li><li>POST参数名：source</li><li>JSON路径：image.url</li><li>自定义Body：<code>&#123;&quot;key&quot;:&quot;your key&quot;, &quot;user&quot;:&quot;username&quot;, &quot;album&quot;:&quot;albumid&quot;&#125;</code></li></ul><p>key在用户名–&gt;仪表盘–&gt;设置–&gt;API可以找到</p><img src="https://images.961110.xyz/images/2021/10/20/image-20211020120705106.png" alt="image-20211020120705106" style="zoom:50%;" /><p>username就在chevereto网站右上角<img src="https://images.961110.xyz/images/2021/10/20/image-20211020120603290.png" alt="image-20211020120603290"></p><p>albumid在用户的相册详细信息中可以找到。</p><img src="https://images.961110.xyz/images/2021/10/20/image-20211020120843573.png" alt="image-20211020120843573" style="zoom: 50%;" /><p>配置完成后设置为默认图床，进行上传测试。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://blog.csdn.net/qq_25005601/article/details/110532477?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&spm=1001.2101.3001.4242">Typora + PicGo 自动上传图片到 Chevereto 图床_张大炮来巡山-CSDN博客</a></li><li><a href="https://blog.csdn.net/qq_19564393/article/details/108506062">修改Chevereto的API上传相册和用户_飞逝17的博客-CSDN博客</a></li><li><a href="https://blog.csdn.net/weixin_29343153/article/details/113534943">docker修改文件夹权限_群晖通过Docker安装图床工具Chevereto的步骤_藏美者阿远的博客-CSDN博客</a></li><li><a href="https://www.orcy.net.cn/775.html">Docker容器报错处理:AH00558: apache2: Could not reliably determine the server’s fully qualified domain name, using 172.17.0.5. Set the ‘ServerName’ directive globally to suppress this message – 下一朵云 (orcy.net.cn)</a></li><li><a href="https://cloud.tencent.com/developer/article/1645239">群晖Docker安装chevereto图床</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Docker </tag>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lambda表达式</title>
      <link href="/posts/40489.html"/>
      <url>/posts/40489.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h2><p>lambda 表达式有如下的一些优点：</p><ul><li>  声明式的编程风格：就地匿名定义目标函数或函数对象，不需要额外写一个命名函数或函数对象。</li><li>  简洁：避免了代码膨胀和功能分散，让开发更加高效。</li><li>  在需要的时间和地点实现功能闭包，使程序更加灵活。</li></ul><p>lambda 表达式定义了一个匿名函数，并且可以捕获一定范围内的变量。lambda 表达式的语法形式简单归纳如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[capture](params) opt -&gt; ret &#123;body;&#125;;</span><br></pre></td></tr></table></figure><p>其中 <code>capture</code> 是捕获列表，<code>params</code> 是参数列表，<code>opt</code> 是函数选项，<code>ret</code> 是返回值类型，<code>body</code> 是函数体。</p><ol><li>捕获列表 []: 捕获一定范围内的变量</li><li>参数列表 (): 和普通函数的参数列表一样，如果没有参数参数列表可以省略不写。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = []()&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;<span class="comment">// 没有参数, 参数列表为空</span></span><br><span class="line"><span class="keyword">auto</span> f = []&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;<span class="comment">// 没有参数, 参数列表省略不写</span></span><br></pre></td></tr></table></figure></li><li>opt 选项， <code>不需要可以省略</code><ul><li>  mutable: 可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）</li><li>exception: 指定函数抛出的异常，如抛出整数类型的异常，可以使用 throw ();</li></ul></li><li>返回值类型：在 C++11 中，lambda 表达式的返回值是通过返回值后置语法来定义的。</li><li>函数体：函数的实现，这部分不能省略，但函数体可以为空。</li></ol><h2 id="2-捕获列表"><a href="#2-捕获列表" class="headerlink" title="2. 捕获列表"></a>2. 捕获列表</h2><p>lambda 表达式的捕获列表可以捕获一定范围内的变量，具体使用方式如下：</p><ul><li>  <code>[]</code> - 不捕捉任何变量</li><li>  <code>[&amp;]</code> - 捕获外部作用域中所有变量，并作为引用在函数体内使用 (<code>按引用捕获</code>)</li><li><code>[=]</code> - 捕获外部作用域中所有变量，并作为副本在函数体内使用 (<code>按值捕获</code>)<ul><li>  <code>拷贝的副本在匿名函数体内部是只读的</code></li></ul></li><li>  <code>[=, &amp;foo]</code> - 按值捕获外部作用域中所有变量，并按照引用捕获外部变量 foo</li><li>  <code>[bar]</code> - 按值捕获 bar 变量，同时不捕获其他变量</li><li>  <code>[&amp;bar]</code> - 按引用捕获 bar 变量，同时不捕获其他变量</li><li><code>[this]</code> - 捕获当前类中的 this 指针<ul><li>  让 lambda 表达式拥有和当前类成员函数同样的访问权限</li><li>  <strong>如果已经使用了 &amp; 或者 =, 默认添加 this 指针</strong></li></ul></li></ul><p>下面通过一个例子，看一下初始化列表的具体用法：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> x1 = [] &#123;<span class="keyword">return</span> m_number; &#125;;                      <span class="comment">// error，没有捕获外部变量，不能使用类成员 m_number</span></span><br><span class="line">        <span class="keyword">auto</span> x2 = [=] &#123;<span class="keyword">return</span> m_number + x + y; &#125;;             <span class="comment">// ok，以值拷贝的方式捕获所有外部变量</span></span><br><span class="line">        <span class="keyword">auto</span> x3 = [&amp;] &#123;<span class="keyword">return</span> m_number + x + y; &#125;;             <span class="comment">// ok，以引用的方式捕获所有外部变量</span></span><br><span class="line">        <span class="keyword">auto</span> x4 = [<span class="keyword">this</span>] &#123;<span class="keyword">return</span> m_number; &#125;;                  <span class="comment">// ok，捕获 this 指针，可访问对象内部成员</span></span><br><span class="line">        <span class="keyword">auto</span> x5 = [<span class="keyword">this</span>] &#123;<span class="keyword">return</span> m_number + x + y; &#125;;          <span class="comment">// error，捕获 this 指针，可访问类内部成员，没有捕获到变量 x，y，因此不能访问。</span></span><br><span class="line">        <span class="keyword">auto</span> x6 = [<span class="keyword">this</span>, x, y] &#123;<span class="keyword">return</span> m_number + x + y; &#125;;    <span class="comment">// ok，捕获 this 指针，x，y</span></span><br><span class="line">        <span class="keyword">auto</span> x7 = [<span class="keyword">this</span>] &#123;<span class="keyword">return</span> m_number++; &#125;;                <span class="comment">// ok，捕获 this 指针，并且可以修改对象内部变量的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m_number = <span class="number">100</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>在匿名函数内部，需要通过 lambda 表达式的捕获列表控制如何捕获外部变量，以及访问哪些变量。默认状态下 lambda 表达式无法修改通过复制方式捕获外部变量，如果希望修改这些外部变量，需要通过引用的方式进行捕获。</p></blockquote><h2 id="3-返回值"><a href="#3-返回值" class="headerlink" title="3. 返回值"></a>3. 返回值</h2><p>一般情况下，不指定 lambda 表达式的返回值，编译器会根据 return 语句自动推导返回值的类型，但需要注意的是 <code>labmda表达式不能通过列表初始化自动推导出返回值类型。</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ok，可以自动推导出返回值类型</span></span><br><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">int</span> a) -&gt; <span class="keyword">int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+<span class="number">10</span>;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">int</span> a)&#123;</span><br><span class="line">    <span class="keyword">return</span> a+<span class="number">10</span>;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error，不能推导出返回值类型</span></span><br><span class="line"><span class="keyword">auto</span> f1 = []()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;<span class="comment">// 基于列表初始化推导返回值，错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-函数本质"><a href="#4-函数本质" class="headerlink" title="4. 函数本质"></a>4. 函数本质</h2><p>使用 lambda 表达式捕获列表捕获外部变量，如果希望去修改按值捕获的外部变量，那么应该如何处理呢？这就需要使用 mutable 选项，<code>被mutable修改是lambda表达式就算没有参数也要写明参数列表，并且可以去掉按值捕获的外部变量的只读（const）属性。</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f1 = [=] &#123;<span class="keyword">return</span> a++; &#125;;              <span class="comment">// error, 按值捕获外部变量, a是只读的</span></span><br><span class="line"><span class="keyword">auto</span> f2 = [=]()<span class="keyword">mutable</span> &#123;<span class="keyword">return</span> a++; &#125;;     <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>最后再剖析一下为什么通过值拷贝的方式捕获的外部变量是只读的:</p><ol><li> <code>lambda表达式的类型在C++11中会被看做是一个带operator()的类，即仿函数。</code></li><li> <code>按照C++标准，lambda表达式的operator()默认是const的，一个const成员函数是无法修改成员变量值的。</code></li></ol><p>mutable 选项的作用就在于取消 operator () 的 const 属性。</p><p>因为 lambda 表达式在 C++ 中会被看做是一个仿函数，因此<code>可以使用std::function和std::bind来存储和操作lambda表达式</code>：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 包装可调用函数</span></span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>)&gt; f1 = [](<span class="keyword">int</span> a) &#123;<span class="keyword">return</span> a; &#125;;</span><br><span class="line">    <span class="comment">// 绑定可调用函数</span></span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>)&gt; f2 = <span class="built_in">bind</span>([](<span class="keyword">int</span> a) &#123;<span class="keyword">return</span> a; &#125;, placeholders::_1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数调用</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">f1</span>(<span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">f2</span>(<span class="number">200</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于没有捕获任何变量的 lambda 表达式，还可以转换成一个普通的函数指针：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> func_ptr = <span class="built_in"><span class="keyword">int</span></span>(*)(<span class="keyword">int</span>);</span><br><span class="line"><span class="comment">// 没有捕获任何外部变量的匿名函数</span></span><br><span class="line">func_ptr f = [](<span class="keyword">int</span> a)&#123;</span><br><span class="line">    <span class="keyword">return</span> a;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 函数调用</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">1314</span>);</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://subingwen.cn/cpp/lambda/">Lambda表达式 | 爱编程的大丙 (subingwen.cn)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> C++ </tag>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux进程管理</title>
      <link href="/posts/25357.html"/>
      <url>/posts/25357.html</url>
      
        <content type="html"><![CDATA[<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h3><p><img src="https://images.961110.xyz/images/2021/10/20/Linux0.12.png" alt="Linux0.12创建进程的流程"></p><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p><img src="https://images.961110.xyz/images/2021/10/20/Linux0.1211029ed5dd197bbc.png" alt="Linux0.12进程调度流程图"></p><h3 id="退出进程"><a href="#退出进程" class="headerlink" title="退出进程"></a>退出进程</h3><p><img src="https://images.961110.xyz/images/2021/10/20/exit.c.png" alt="Linux0.12退出进程流程图"></p><p>退出进程</p><h2 id="进程0和进程1"><a href="#进程0和进程1" class="headerlink" title="进程0和进程1"></a>进程0和进程1</h2><h3 id="进程-0"><a href="#进程-0" class="headerlink" title="进程 0"></a>进程 0</h3><p> 首先，进程 0 也叫做空闲进程，是一个内核进程，它的主要作用是进入一个死循环，为了解决 cpu 空闲时刻的问题，所做的工作就是在 cpu 空闲时给 cpu 一个死循环从而使 cpu 工作。特殊性在于它是系统创建的第一个进程。</p><h3 id="进程-1"><a href="#进程-1" class="headerlink" title="进程 1"></a>进程 1</h3><p>进程 1 也叫做 init 进程，开始时它在内核态所做的工作就是挂载根文件系统，将根文件系统挂载上之后，进行一系列的环境配置，最后创建用户交互 shell环境</p><p> 进程 1 的最主要的作用就是对操作系统来说，其他所有的用户进程都是由进程 1 直接或间接创建的，也就是说所有的用户进程都是进程 1 的子孙进程。</p><h2 id="孤儿进程、孤儿进程组、僵尸进程"><a href="#孤儿进程、孤儿进程组、僵尸进程" class="headerlink" title="孤儿进程、孤儿进程组、僵尸进程"></a>孤儿进程、孤儿进程组、僵尸进程</h2><h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p>其父进程已经终止的进程。但是它会被 init 进程 “收养”，init 进程 ID 为 1，因此被收养的孤儿进程的父进程会更新为 1。</p><h3 id="孤儿进程组"><a href="#孤儿进程组" class="headerlink" title="孤儿进程组"></a>孤儿进程组</h3><p>一个进程组中的所有进程的父进程要么是该进程组的一个进程，要么不是该进程组所在的会话中的进程。 一个进程组不是孤儿进程组的条件是，该组中有一个进程其父进程在属于同一个会话的另一个组中。</p><p>一个进程组到其组外的父进程之间的联系依赖于该父进程和其子进程两者，所以会有两种产生孤儿进程组的情况：</p><ol><li>父进程终止</li><li>子进程终止</li></ol><p>在任何一种情況下，如果进程的终止导致进程组变成孤儿进程组，那么进程组中的所有进程就会与它们的作业控制 shell 断开联系，作业控制 shell 将不再具有该进程组存在的任何信息。而该进程组中处于停止状态的进程将会永远消失。为了解决这个问题，含有停止状态进程的新近产生的孤儿进程组就需要接收到一个SIGHIUP信号和一个SIGCONT信号，用于指示它们已经从它们的会话（session）中断开联系。SIGHUP信号将导致进程组中成员被终止，除非它们捕获或忽略了SIGHUP信号。而SIGCONT信号将使那些没有被SIGHUP信号终止的进程继续运行。但在大多数情況下，如果组中有一个进程处于停止状态，那么组中所有的进程可能都处于停止状态。</p><h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p>子进程先于父进程退出，而父进程并没有调用 wait 或 waitpid 获取子进程的状态信息并释放子进程资源，那么其的进程描述符仍然保存在系统中。</p><h2 id="进程、进程组、会话、前台进程组、后台进程组"><a href="#进程、进程组、会话、前台进程组、后台进程组" class="headerlink" title="进程、进程组、会话、前台进程组、后台进程组"></a>进程、进程组、会话、前台进程组、后台进程组</h2><h3 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h3><p>一个或者多个进程的集合。</p><p>每个进程组都有一个唯一的进程组标识号gid，一个称为组长的进程，gid等于组长进程的pid。</p><h3 id="会话（Session）"><a href="#会话（Session）" class="headerlink" title="会话（Session）"></a>会话（Session）</h3><p>一个或多个进程组的集合。</p><p>通常情况下，用户登录后所执行的所有程序都属于一个会话期，而其登录 shell 则是<strong>会话首进程</strong>，并且它所使用的终端就是会话期的控制终端，因此会话期首进程通常也被称为<strong>控制进程</strong>。当用户退出登录时，所有属于这个会话期的进程都将被终止。</p><h3 id="前台进程组"><a href="#前台进程组" class="headerlink" title="前台进程组"></a>前台进程组</h3><p>会话中拥有控制终端的一个进程组。</p><h3 id="后台进程组"><a href="#后台进程组" class="headerlink" title="后台进程组"></a>后台进程组</h3><p>会话期中除前台进程组外的其他进程组。</p><p><img src="https://images.961110.xyz/images/2021/10/20/Untitled.png" alt="进程、进程组和会话期之间的关系"></p><p>进程、进程组和会话期之间的关系</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 任务(进程)数据结构，或称为进程描述符 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line"><span class="comment">/* these are hardcoded - don&#x27;t touch */</span></span><br><span class="line"><span class="comment">/* 硬编码字段 */</span></span><br><span class="line"><span class="keyword">long</span> state;<span class="comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span></span><br><span class="line"><span class="comment">/* 任务运行状态 -1 不可运行，0 可运行(就绪)， &gt;0 已停止 */</span></span><br><span class="line"><span class="keyword">long</span> counter;<span class="comment">/* 任务运行时间计数(递减)(滴答数)，运行时间片 */</span></span><br><span class="line"><span class="keyword">long</span> priority;<span class="comment">/* 优先级 */</span></span><br><span class="line"><span class="keyword">long</span> signal;<span class="comment">/* 信号位图 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sigaction</span>[32];</span><span class="comment">/* 信号执行属性结构,对应信号将要执行的操作和标志信息 */</span></span><br><span class="line"><span class="keyword">long</span> blocked;<span class="comment">/* 进程信号屏蔽码(对应信号位图) */</span> <span class="comment">/* bitmap of masked signals */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* various fields */</span></span><br><span class="line"><span class="comment">/* 可变字段 */</span></span><br><span class="line"><span class="keyword">int</span> exit_code;<span class="comment">/* 退出码 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> start_code;<span class="comment">/* 代码段地址 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> end_code;<span class="comment">/* 代码段长度（字节数） */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> end_data;<span class="comment">/* 代码段加数据段的长度 （字节数）*/</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> brk;<span class="comment">/* 总长度(字节数) */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> start_stack;<span class="comment">/* 堆栈段地址 */</span></span><br><span class="line"><span class="keyword">long</span> pid;<span class="comment">/* 进程标识号(进程号) */</span></span><br><span class="line"><span class="keyword">long</span> pgrp;<span class="comment">/* 进程组号 */</span></span><br><span class="line"><span class="keyword">long</span> session;<span class="comment">/* 会话号 */</span></span><br><span class="line"><span class="keyword">long</span> leader;<span class="comment">/* 会话首领 */</span></span><br><span class="line"><span class="keyword">int</span>groups[NGROUPS];<span class="comment">/* 进程所属组号（一个进程可属于多个组） */</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * pointers to parent process, youngest child, younger sibling,</span></span><br><span class="line"><span class="comment"> * older sibling, respectively.  (p-&gt;father can be replaced with </span></span><br><span class="line"><span class="comment"> * p-&gt;p_pptr-&gt;pid)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p_pptr</span>;</span><span class="comment">/* 指向父进程的指针 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p_cptr</span>;</span><span class="comment">/* 指向最新子进程的指针 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p_ysptr</span>;</span><span class="comment">/* 指向比自己后创建的相邻进程的指针 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p_osptr</span>;</span><span class="comment">/* 指向比自己早创建的相邻进程的指针 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> uid;<span class="comment">/* 用户id */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> euid;<span class="comment">/* 有效用户id */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> suid;<span class="comment">/* 保存的设置用户id */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> gid;<span class="comment">/* 组id */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> egid;<span class="comment">/* 有效组id */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> sgid;<span class="comment">/* 保存的设置组id */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> timeout;<span class="comment">/* 内核定时超时值 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> alarm;<span class="comment">/* 报警定时值(滴答数) */</span></span><br><span class="line"><span class="keyword">long</span> utime;<span class="comment">/* 用户态运行时间(滴答数) */</span></span><br><span class="line"><span class="keyword">long</span> stime;<span class="comment">/* 内核态运行时间(滴答数) */</span></span><br><span class="line"><span class="keyword">long</span> cutime;<span class="comment">/* 子进程用户态运行时间 */</span></span><br><span class="line"><span class="keyword">long</span> cstime;<span class="comment">/* 子进程内核态运行时间 */</span></span><br><span class="line"><span class="keyword">long</span> start_time;<span class="comment">/* 进程开始运行时刻 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rlim</span>[<span class="title">RLIM_NLIMITS</span>];</span><span class="comment">/* 进程资源使用统计数组 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> flags;<span class="comment">/* 各进程的标志，还未使用*/</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> used_math;<span class="comment">/* 是否使用了协处理器的标志 */</span></span><br><span class="line"><span class="comment">/* file system info */</span></span><br><span class="line"><span class="keyword">int</span> tty;<span class="comment">/* -1 if no tty, so it must be signed */</span></span><br><span class="line"><span class="comment">/* 进程使用tty终端的子设备号。-1表示没有使用 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> umask;<span class="comment">/* 文件创建属性屏蔽位 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">pwd</span>;</span><span class="comment">/* 当前工作目录i节点结构指针 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">root</span>;</span><span class="comment">/* 根目录i节点结构指针 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">executable</span>;</span><span class="comment">/* 执行文件i节点结构指针 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">library</span>;</span><span class="comment">/* 被加载库文件i节点结构指针 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> close_on_exec;<span class="comment">/* 执行时关闭文件句柄位图标志 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">filp</span>[<span class="title">NR_OPEN</span>];</span><span class="comment">/* 文件结构指针表，最多32项。表项号即是文件描述符的值 */</span></span><br><span class="line"><span class="comment">/* ldt for this task 0 - zero 1 - cs 2 - ds&amp;ss */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> <span class="title">ldt</span>[3];</span><span class="comment">/* 局部描述符表, 0 - 空，1 - 代码段cs，2 - 数据和堆栈段ds&amp;ss */</span></span><br><span class="line"><span class="comment">/* tss for this task */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tss_struct</span> <span class="title">tss</span>;</span><span class="comment">/* 进程的任务状态段信息结构 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">任务状态</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_RUNNING0<span class="comment">/* 任务正在运行或已准备就绪 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_INTERRUPTIBLE1<span class="comment">/* 任务处于可中断等待状态 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_UNINTERRUPTIBLE2<span class="comment">/* 任务处于不可中断等待状态 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_ZOMBIE3<span class="comment">/* 任务处于僵死状态，已经停止，但父进程还没发出信号 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_STOPPED4<span class="comment">/* 任务已停止 */</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGHUP 1<span class="comment">/* Hang Up-- 挂起控制终端或进程 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGINT 2<span class="comment">/* Interrupt -- 来自键盘的中断 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGQUIT 3<span class="comment">/* Quit-- 来自键盘的退出 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGILL 4<span class="comment">/* Illeagle-- 非法指令 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGTRAP 5<span class="comment">/* Trap -- 跟踪断点 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGABRT 6<span class="comment">/* Abort-- 异常结束 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGIOT 6<span class="comment">/* IO Trap-- 同上 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGUNUSED 7<span class="comment">/* Unused-- 没有使用 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGFPE 8<span class="comment">/* FPE-- 协处理器出错 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGKILL 9<span class="comment">/* Kill-- 强迫进程终止 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGUSR110<span class="comment">/* User1-- 用户信号 1，进程可使用 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGSEGV11<span class="comment">/* Segment Violation -- 无效内存引用 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGUSR212<span class="comment">/* User2    -- 用户信号 2，进程可使用 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGPIPE13<span class="comment">/* Pipe-- 管道写出错，无读者 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGALRM14<span class="comment">/* Alarm-- 实时定时器报警 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGTERM15<span class="comment">/* Terminate -- 进程终止 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGSTKFLT16<span class="comment">/* Stack Fault -- 栈出错（协处理器） */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGCHLD17<span class="comment">/* Child-- 子进程停止或被终止 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGCONT18<span class="comment">/* Continue-- 恢复进程继续执行 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGSTOP19<span class="comment">/* Stop-- 停止进程的执行 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGTSTP20<span class="comment">/* TTY Stop-- tty 发出停止进程，可忽略 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGTTIN21<span class="comment">/* TTY In-- 后台进程请求输入 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGTTOU22<span class="comment">/* TTY Out-- 后台进程请求输出 */</span></span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://blog.csdn.net/qq_29503203/article/details/54618275">https://blog.csdn.net/qq_29503203/article/details/54618275</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 进程管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《智能网联汽车技术》读书笔记</title>
      <link href="/posts/29265.html"/>
      <url>/posts/29265.html</url>
      
        <content type="html"><![CDATA[<h3 id="第一章-智能网联汽车概述"><a href="#第一章-智能网联汽车概述" class="headerlink" title="第一章 智能网联汽车概述"></a>第一章 智能网联汽车概述</h3><p>这一章主要讲了智能网联汽车的一些基本概念、分级以及分阶段的发展目标。</p><h3 id="第二章-中国智能网联汽车发展及标准法规演变趋势"><a href="#第二章-中国智能网联汽车发展及标准法规演变趋势" class="headerlink" title="第二章 中国智能网联汽车发展及标准法规演变趋势"></a>第二章 中国智能网联汽车发展及标准法规演变趋势</h3><p>这一章主要介绍了智能网联汽车的发展路线，产业生态、主机厂、用户接受度的发展趋势，各企业的布局，国内外的系列政策。</p><h3 id="第三章-智能网联汽车产业链及商业模式"><a href="#第三章-智能网联汽车产业链及商业模式" class="headerlink" title="第三章 智能网联汽车产业链及商业模式"></a>第三章 智能网联汽车产业链及商业模式</h3><p>这一章主要介绍了智能网联汽车产业链、价值链、商业化技术服务和商业模式。</p><h3 id="第四章-驾驶场景数据技术"><a href="#第四章-驾驶场景数据技术" class="headerlink" title="第四章 驾驶场景数据技术"></a>第四章 驾驶场景数据技术</h3><p>这一张主要介绍了驾驶场景数据的采集、分类、处理、存储和应用的一系列流程，以及所用到的硬件设备的标定方法。</p><h3 id="第五章-驾驶场景虚拟仿真技术"><a href="#第五章-驾驶场景虚拟仿真技术" class="headerlink" title="第五章 驾驶场景虚拟仿真技术"></a>第五章 驾驶场景虚拟仿真技术</h3><p>这一章主要介绍了仿真测试系统、仿真平台、仿真数据体系、虚拟试验场建设、仿真测试工具和仿真验证与评价。</p><h3 id="第六章-自动驾驶感知融合算法实现与应用"><a href="#第六章-自动驾驶感知融合算法实现与应用" class="headerlink" title="第六章 自动驾驶感知融合算法实现与应用"></a>第六章 自动驾驶感知融合算法实现与应用</h3><p>这一章主要介绍了自动驾驶的相关算法，包括感知、融合、算法验证等，以及会用到的硬件设备，比如激光雷达、毫米波雷达、超声波雷达、摄像头等。</p><h3 id="第七章-自动驾驶工程技术验证与实现"><a href="#第七章-自动驾驶工程技术验证与实现" class="headerlink" title="第七章 自动驾驶工程技术验证与实现"></a>第七章 自动驾驶工程技术验证与实现</h3><p>这一章主要介绍了工程验证的关键技术包括环境感知、决策规划的相关技术，以及车辆改装、功能实现方法和软硬件发展思路。</p><p><img src="https://images.961110.xyz/images/2021/10/20/6a4a580a242f4d97ebe64463412dc677.png" alt="《智能网联汽车技术》关键技术点"></p><p>《智能网联汽车技术》关键技术点</p>]]></content>
      
      
      <categories>
          
          <category> 智能网联汽车 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 智能网联汽车 </tag>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核模块</title>
      <link href="/posts/62642.html"/>
      <url>/posts/62642.html</url>
      
        <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>Linux的内核模块机制允许开发者动态的向内核添加功能，常见的文件系统、驱动程序等都可以通过模块的方式添加到内核而无需对内核重新编译，这在很大程度上减少了操作的复杂度。</p><p>模块机制使内核预编译时不必包含很多无关功能，把内核做到最精简，后期可以根据需要进行添加。针对驱动程序，因为涉及到具体的硬件，很难使通用的，且其中可能包含了各个厂商的私密接口，厂商几乎不会允许开发者把源代码公开，模块机制很好的解决了这个冲突。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>使用模块的优点：</p><ol><li>使得内核更加紧凑和灵活</li><li>修改内核时，不必全部重新编译整个内核，可节省不少时间，避免人工操作的错误。系统中如果需要使用新模块，只要编译相应的模块然后使用特定用户空间的程序将模块插入即可。</li><li>模块可以不依赖于某个固定的硬件平台。</li><li>模块的目标代码一旦被链接到内核，它的作用和静态链接的内核目标代码完全等价。 所以，当调用模块的函数时，无须显式的消息传递。</li></ol><p>缺点：</p><ol><li>由于模块所占用的内存是不会被换出的，所以链接进内核的模块会给整个系统带来一定的性能和内存利用方面的损失。</li><li>装入内核的模块就成为内核的一部分，可以修改内核中的其他部分，因此，模块的使用不当会导致系统崩溃。</li><li>为了让内核模块能访问所有内核资源，内核必须维护符号表，并在装入和卸载模块时修改符号表。</li><li>模块会要求利用其它模块的功能，所以，内核要维护模块之间的依赖性。</li></ol><h3 id="内核符号表"><a href="#内核符号表" class="headerlink" title="内核符号表"></a>内核符号表</h3><p>内核符号表是一个用来存放所有模块可以访问的那些符号以及相应地址的特殊的表。模块的连接就是将模块插入到内核的过程。模块所声明的任何全局符号都成为内核符号表的一部分。内核模块根据系统符号表从内核空间中获取符号的地址，从而确保在内核空间中正确地运行。存放路径：<code>/proc/kallsyms</code></p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h3><ol><li><p>模块装载到内核中，首先调用初始化函数<code>proc_module_init()</code><br>打印初始化提示信息；</p></li><li><p>在查看<code>proc_info</code>文件之前，如右图可见文件是空的，说明代码里的<code>proc_info_show()</code>是在文件被查看时调用的；</p></li><li><p><code>proc_info_show()</code>在执行时首先打印提示信息，然后通过<code>seq_printf()</code>函数分别写入内核版本号和进程数；</p><p>内核版本号保存在结构体ustname中，可以直接调用，proc下verison也是</p></li><li><p>模块卸载的时候，调用出口函数<code>proc_module_exit()</code>，打印退出提示信息。</p></li></ol><p><img src="https://images.961110.xyz/images/2021/10/20/proc_info.png" alt="proc_info文件内容为空"></p><p><img src="https://images.961110.xyz/images/2021/10/20/proc_info69158ed329c16d70.png" alt="proc_info文件里的内容"></p><h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><p><code>create_proc_entry()</code>这个函数在3.x或4.x的时候已经被弃用，用<code>proc_create()</code>代替即可。</p><p><img src="https://images.961110.xyz/images/2021/10/20/my_module.png" alt="my_module模块编译出错"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">proc_dir = proc_mkdir(<span class="string">&quot;my_proc&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">proc_info = proc_create(<span class="string">&quot;proc_info&quot;</span>, <span class="number">0644</span>, proc_dir, &amp;proc_module_fops);</span><br></pre></td></tr></table></figure><h2 id="size-t"><a href="#size-t" class="headerlink" title="size_t"></a>size_t</h2><p>size_t的提出主要是为了解决可移植性问题，方便在处理器位数不同的平台使用。</p><p>size_t一般用来计数，代表C中任何对象所能达到的最大长度，比如：</p><ol><li><code>void *malloc(size_t n);</code> </li><li><code>void *memcpy(void *s1, void const *s2, size_t n);</code></li><li><code>size_t strlen(char const *s);</code></li></ol><p>习惯性地用<code>int</code>类型肯定是有问题的，因为<code>int</code>是带符号的，而且并不一定能覆盖到对象的最大长度。</p><p>int类型对应平台的大小是这样的：</p><ul><li>16位系统中，int型为16位大小，2字节</li><li>32位系统中，int型为32位大小，4字节</li><li>64位系统中，int型为32位大小，4字节</li></ul><p>long类型对应平台的大小是这样的：</p><ul><li>16位系统中，long型为32位大小，4字节</li><li>32位系统中，long型为32位大小，4字节</li><li>64位系统中，long型为64位大小，8字节</li></ul><p>因此猜想size_t在16位架构上应该是2字节，32位架构上是4字节，在64位架构上是8字节。</p><p>size_t在32位架构中被定义为<code>typedef unsigned int size_t;</code>而在64位架构中被定义为<code>typedef unsigned long size_t;</code>符合猜想，16位架构中的定义可能也是<code>typedef unsigned int size_t;</code></p><h2 id="seq-file-操作函数"><a href="#seq-file-操作函数" class="headerlink" title="seq_file 操作函数"></a>seq_file 操作函数</h2><p><code>seq_file</code> 系列函数是为了方便内核导出信息到 sysfs、debugfs、procfs 实现的。简化了文件操作的实现，内部维护缓冲区，内部的当前位置，不用驱动开发者自己实现缓冲区操作，对于驱动开发人员只需要实现相关的数据操作函数回调即可。<br>它包含了如下一些接口：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seq_open</span><span class="params">(struct file *file, <span class="keyword">const</span> struct seq_operations *op)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seq_release</span><span class="params">(struct inode *inode, struct file *file)</span></span>;</span><br><span class="line"><span class="comment">//seq_read 操作是系列函数中最为重要的一个函数，它负责从内部buffer缓冲区中读取数据并 copy_to_user 返回给应用层</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">seq_read</span><span class="params">(struct file *file, <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> size, <span class="keyword">loff_t</span> *ppos)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seq_write</span><span class="params">(struct seq_file *seq, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">loff_t</span> <span class="title">seq_lseek</span><span class="params">(struct file *file, <span class="keyword">loff_t</span> offset, <span class="keyword">int</span> whence)</span>；</span></span><br></pre></td></tr></table></figure><p>在实验过程中就是通过封装好的函数，把内核版本号和进程数写到proc文件里的。</p><h2 id="Linux内核模块参数传递及函数调用"><a href="#Linux内核模块参数传递及函数调用" class="headerlink" title="Linux内核模块参数传递及函数调用"></a>Linux内核模块参数传递及函数调用</h2><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>模块的参数传递也是一个宏，定义在<code>linux/moduleparam.h</code>中，type支持<code>byte, short, ushort,int, uint, long, ulong, bool</code></p><ul><li><p>单个参数传递<code>moudle_param(name,type,perm)</code></p></li><li><p>参数组传递<code>module_param_array(name, type, nump, perm)</code></p><p><strong><code>name</code>数组必须静态分配</strong></p></li><li><p>源文件内外参数名可以不同：<br><code>module_param_named(name, variable, type, perm)</code></p><p>  其中<code>name</code>是外部可见的参数名，<code>variable</code>是源文件内部的全局变量名</p></li><li><p>另一种字符串传递方法<code>module_param_string(name, string, len, perm)</code><br>name是外部的参数名，string是内部的变量名，len是以string命名的buffer大小（可以小于buffer的大小，但是没有意义）。</p></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *msg;</span><br><span class="line">module_param(msg, charp, <span class="number">0644</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> para[<span class="number">8</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> n_para = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> species[BUF_LEN]；</span><br><span class="line">module_param_string(specifies, species, BUF_LEN, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">module_param_array(para , <span class="keyword">int</span> , &amp;n_para , S_IRUGO);</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">module_init</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">module_exit</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在装载模块时指定参数即可</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sudo insmod <span class="keyword">module</span>.ko msg=<span class="string">&quot;test&quot;</span> para=<span class="number">4</span>，<span class="number">5</span>，<span class="number">6</span>，<span class="number">1</span>，<span class="number">8</span> specifies=<span class="string">&quot;test_string&quot;</span></span><br></pre></td></tr></table></figure><h3 id="模块间函数调用"><a href="#模块间函数调用" class="headerlink" title="模块间函数调用"></a>模块间函数调用</h3><p>模块的函数导出到符号表才可以供其他函数使用，需要用到宏：<code>EXPORT_SYMBOL(sym)</code>，该宏在<code>linux/export.h</code>里面。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fun1.c</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;fun() is called\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">EXPORT_SYMBOL(fun);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fun2.c</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;fun_1.h&quot;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mod_init</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;mod_init() start\n&quot;</span>);</span><br><span class="line">    fun();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fun_1.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> KERNEL_FUN_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNEL_FUN_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><img src="https://images.961110.xyz/images/2021/10/20/45bb76418d7ff50f34511fb7e26d23a3.png" alt="实验结果"></p><p>根据日志可以看出，被调用的函数已经打印出了提示信息。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><p>两个不同的模块不能导出相同的的函数，否则会在装载模块的时候报错。</p><p>在<code>/proc/kallsyms</code> 文件中保存对应着内核符号表，它记录了符号以及符号所在的内存地址，所以不能导出相同的函数。</p></li></ol><p><img src="https://images.961110.xyz/images/2021/10/20/79d0e8fb90a66cdebe819d07db6b492a.png" alt="导出相同函数报错"></p><p>导出相同函数报错</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核裁剪</title>
      <link href="/posts/2771.html"/>
      <url>/posts/2771.html</url>
      
        <content type="html"><![CDATA[<h3 id="Kconfig和menuconfig文件"><a href="#Kconfig和menuconfig文件" class="headerlink" title="Kconfig和menuconfig文件"></a>Kconfig和menuconfig文件</h3><p>内核源码的每一级目录下都会有 <strong>Kconfig</strong> 文件，文件里的<code>menu</code>对应<code>make menuconfig</code>中的菜单项，菜单中包含若干子选项，由 <code>source</code>引入各级子目录下的 <code>Kconfig</code>文件，由此构成了<code>menuconfig</code>。</p><p><img src="https://images.961110.xyz/images/2021/10/20/Kconfigmenuconfig.png" alt="Kconfig和menuconfig文件.png"></p><p>每一个子选项在代码中对应的是一个个的<code>config</code></p><p>其中选项中<code>bool</code>代表二选一(编译、不编译)</p><p><code>trastate</code>代表三选一(编译、不编译、编译成模块)</p><p><code>depends on</code>代表其依赖的配置。</p><p><img src="https://images.961110.xyz/images/2021/10/20/config.png" alt="config的构成.png"></p><h3 id="config文件"><a href="#config文件" class="headerlink" title=".config文件"></a>.config文件</h3><p><code>menuconfig</code>又会生成源码根目录下的<code>.config</code>文件，由各个<code>Kconfig</code>中的<code>config</code>宏定义构成。</p><h3 id="makefile文件"><a href="#makefile文件" class="headerlink" title="makefile文件"></a>makefile文件</h3><p>编译内核依赖的makefile文件会根据<code>.config</code>文件来决定是否将对应部分编译进内核。</p><h3 id="四者的关系图如下"><a href="#四者的关系图如下" class="headerlink" title="四者的关系图如下"></a>四者的关系图如下</h3><p><img src="https://images.961110.xyz/images/2021/10/20/menuconfig-Kconfig-.config-makefile.png" alt="menuconfig相关文件的关系"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 内核裁剪 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM目标代码优化</title>
      <link href="/posts/64925.html"/>
      <url>/posts/64925.html</url>
      
        <content type="html"><![CDATA[<h2 id="速度优化"><a href="#速度优化" class="headerlink" title="速度优化"></a>速度优化</h2><h3 id="通用优化方法"><a href="#通用优化方法" class="headerlink" title="通用优化方法"></a>通用优化方法</h3><p><strong>减少计算强度</strong></p><ol><li>左右位移代替乘除2运算: <code>i = i * 5 = (i &lt;&lt; 2) + 1</code> ，位移有桶形位移器，执行比乘除快。</li><li>乘法代替乘方运算: <code>i = pow(i, 3) = i * i * i</code>，ARM中有乘法器，所以比调用函数更快。</li><li>与运算代替求余运算: <code>i = i % 8 = i &amp; 0x07</code>，ARM中没有求余指令，但是有与指令。</li></ol><p><strong>优化循环终止条件</strong></p><p>使用减计数代替惯用的加计数，使用<code>i != 0</code>作循环终止条件。加法计数在循环判断的时候是用CMP和BLE实现的，而用<code>i != 0</code>可以用BNE一条指令代替。</p><p><strong>使用<code>inline</code>函数</strong></p><p><code>inline</code>函数主要节省了调用函数所占用的时间。缺点就是被频繁调用时，代码量将增大，以空间换时间。</p><p><strong>利用已有结果</strong></p><p><code>tmp = a * b;</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i = a * b + c;</span><br><span class="line">j = a * b * d;</span><br></pre></td></tr></table></figure><p><strong>避免循环</strong></p><p>拆开小循环</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">x[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">x[<span class="number">0</span>] = <span class="number">0</span>; x[<span class="number">1</span>] = <span class="number">1</span>; x[<span class="number">2</span>] = <span class="number">2</span>;...;x[<span class="number">9</span>] = <span class="number">9</span>;</span><br></pre></td></tr></table></figure><h3 id="处理器相关的优化方法"><a href="#处理器相关的优化方法" class="headerlink" title="处理器相关的优化方法"></a>处理器相关的优化方法</h3><p><strong>保持流水线畅通</strong></p><p>将循环拆解来<strong>减小跳转指令在循环指令中所占的比重。</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memcopy</span><span class="params">(<span class="keyword">char</span> *to, <span class="keyword">char</span> *from, <span class="keyword">unsigned</span> <span class="keyword">int</span> nbytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p_to = (<span class="keyword">int</span> *)to;</span><br><span class="line"><span class="keyword">int</span> *p_from = (<span class="keyword">int</span> *)from;</span><br><span class="line"><span class="keyword">while</span>(nbytes) &#123;</span><br><span class="line">*p_to++ = *p_from++;</span><br><span class="line">*p_to++ = *p_from++;</span><br><span class="line">*p_to++ = *p_from++;</span><br><span class="line">*p_to++ = *p_from++;</span><br><span class="line">nbytes - = <span class="number">16</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过优化后，一次循环可以处理16 个字节。</p><p><strong>使用寄存器变量</strong></p><p>整型、指针、浮点等类型的变量都可以分配寄存器；一个结构的部分或者全部也可以分配寄存器。给循环体中需要频繁访问的变量分配寄存器也能在一定程度上提高程序效率。</p><h3 id="指令集相关的优化方法"><a href="#指令集相关的优化方法" class="headerlink" title="指令集相关的优化方法"></a>指令集相关的优化方法</h3><p><strong>避免除法</strong></p><p>ARM7 指令集中没有除法指令，其除法是通过调用 C 库函数实现的。一个32 位的除法通常需要20~140 个时钟周期。</p><ul><li>例如<code>if((x/y) &gt; z)</code>可变通为<code>if(x &gt; (y × z))</code></li><li>在能满足精度，且存储器空间冗余的情况下， 也可考虑使用查表法代替除法。</li><li>当除数为2 的幂次方时， 应用移位操作代替除法。</li></ul><p><strong>在后来支持硬件除法的芯片（Cortex-M3）中，用<code>SDIV</code>指令代替了库函数的调用。</strong></p><p><strong>利用条件执行</strong></p><p>ARM 指令集的一个重要特征就是<strong>所有的指令均可包含一个可选的条件码</strong>。当程序状态寄存器(PSR)中的条件码标志满足指定条件时，指令才能执行，因此可以省去单独的判断指令。</p><p><strong>使用合适的变量类型</strong></p><p>在操作char、short型的ARM局部变量，往往比操作32 位变量需要更多指令，所以应该尽可能地避免使用。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wordinc</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">ADD a1,a1,#<span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> a + <span class="number">1</span>; MOV pc,lr</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">short</span> <span class="title">shortinc</span><span class="params">(<span class="keyword">short</span> a)</span> </span>&#123;</span><br><span class="line">ADD a1,a1,#<span class="number">1</span></span><br><span class="line">MOV a1,a1,LSL #<span class="number">16</span></span><br><span class="line"><span class="keyword">return</span> a + <span class="number">1</span>; MOV a1,a1,ASR #<span class="number">16</span>ARM</span><br><span class="line">&#125; MOV pc,<span class="function">lr</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">charinc</span><span class="params">(<span class="keyword">char</span> a)</span></span>&#123;</span><br><span class="line">ADD a1,a1,#<span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> a + <span class="number">1</span>; </span><br><span class="line">AND a1,a1,#&amp;ff</span><br><span class="line">&#125; MOV pc,lr</span><br></pre></td></tr></table></figure><h3 id="存储器相关的优化方法"><a href="#存储器相关的优化方法" class="headerlink" title="存储器相关的优化方法"></a>存储器相关的优化方法</h3><p><strong>用查表代替计算</strong></p><p>用空间换速度：例如需要频繁计算正弦或余弦函数值时，可预先将函数值计算出来置于内存中供以后ARM查找。</p><p><strong>充分利用片内RAM</strong></p><p>一些厂商出产的ARM 芯片内集成有一定容量的RAM，处理器对片内RAM 的访问速度要快于对外部RAM 的访问。</p><h3 id="编译器相关的优化方法"><a href="#编译器相关的优化方法" class="headerlink" title="编译器相关的优化方法"></a>编译器相关的优化方法</h3><p>根据编译器提供的优化选项进行设置。多数编译器都支持对程序速度和程序大小的优化，有些编译器还允许用户选择可供优化的内容及优化的程度。</p><h2 id="尺寸优化"><a href="#尺寸优化" class="headerlink" title="尺寸优化"></a>尺寸优化</h2><h3 id="使用多寄存器操作指令"><a href="#使用多寄存器操作指令" class="headerlink" title="使用多寄存器操作指令"></a>使用多寄存器操作指令</h3><p>ARM 指令集中的多寄存器操作指令LDM/STM 可以加载/ 存储多个寄存器，这在保存/ 恢复寄存器组的状态及进行大块数据复制时非常有效。例如要将寄存器R4~R12 及R14 的内容保存到堆栈中，若用<code>STR</code> 指令共需要10 条，而一条<code>STMEA R13!, &#123;R4 ?? R12, R14&#125;</code> 指令就能达到相同的目的，虽然在执行速度上不一定有提高。</p><h3 id="合理安排变量顺序"><a href="#合理安排变量顺序" class="headerlink" title="合理安排变量顺序"></a>合理安排变量顺序</h3><p>ARM程序中的32 位/16 位变量必须按字/ 半字对齐</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>  i1 ~ i4;</span><br><span class="line"><span class="keyword">char</span> c1 ~ c4;</span><br><span class="line"></span><br><span class="line">按照i1、c1、i2、c2、i3、c3、i4、c4的顺序排列的话，<span class="number">8</span>位的<span class="keyword">char</span>型变量实际上占用的是一个<span class="number">32</span>位寄存器，空间浪费</span><br><span class="line">所以应将 <span class="keyword">int</span> 型变量和 <span class="keyword">char</span> 型变量按类似i1、i2、i3、i4、c1、c2、c3、c4 的顺序连续存放。</span><br></pre></td></tr></table></figure><h3 id="使用Thumb指令"><a href="#使用Thumb指令" class="headerlink" title="使用Thumb指令"></a>使用Thumb指令</h3><p>16 位的 Thumb 指令是ARM 体系结构的扩充。Thumb 指令集是大多数常用32 位ARM 指令压缩成16 位宽指令的集合。</p>]]></content>
      
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> ARM </tag>
            
            <tag> 代码优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>租房注意事项</title>
      <link href="/posts/40489.html"/>
      <url>/posts/40489.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、重中之重"><a href="#一、重中之重" class="headerlink" title="一、重中之重"></a>一、重中之重</h2><ol><li>租 转租房一定要三方（你、转租人、房东）都在场，最好直接跟房东签协议。</li><li>房东、二房东的身份证复印件和房本要留底，可以写仅供租房使用。</li><li>不租隔断间，敲墙听音；</li><li>下面所有细节都要在合同上落实好</li><li>仔细看合同！！！！！</li><li>别轻易交定金。</li><li>核对电子版跟签的纸质版是否有细节上的变动。</li></ol><h2 id="二、细节"><a href="#二、细节" class="headerlink" title="二、细节"></a>二、细节</h2><h3 id="筛选小区"><a href="#筛选小区" class="headerlink" title="筛选小区"></a>筛选小区</h3><h4 id="便利性"><a href="#便利性" class="headerlink" title="便利性"></a>便利性</h4><ol><li>有无商场</li><li>有无超市、菜市场</li><li>周围外卖情况（直接在外卖软件上看）</li><li>周围打车情况（直接在打车软件上看）</li><li>有无社区医院、药店</li></ol><h4 id="整体环境"><a href="#整体环境" class="headerlink" title="整体环境"></a>整体环境</h4><ol><li>小区封闭或开放</li><li>有无保安</li><li>进出小区是否刷卡</li><li>绿化情况</li><li>一梯几户： 户数多，层数高，电梯排队时间长</li><li>老人多还是年轻人多</li></ol><h4 id="房屋性质"><a href="#房屋性质" class="headerlink" title="房屋性质"></a>房屋性质</h4><ol><li>城中村</li><li>回迁房</li><li>商住两用： 燃气一般不通、商水商电、物业参差不齐</li></ol><h4 id="预备资金"><a href="#预备资金" class="headerlink" title="预备资金"></a>预备资金</h4><p>押一付三+中介费=五个月的房租</p><h3 id="筛选房子"><a href="#筛选房子" class="headerlink" title="筛选房子"></a>筛选房子</h3><h4 id="楼层及位置"><a href="#楼层及位置" class="headerlink" title="楼层及位置"></a>楼层及位置</h4><ul><li>一楼  不安全</li><li>顶楼  电梯不方便、可能房顶漏水</li><li>楼下别有KTV、Club</li></ul><h4 id="季节性因素"><a href="#季节性因素" class="headerlink" title="季节性因素"></a>季节性因素</h4><ul><li>夏季<ol><li>房顶漏不漏水</li><li>潮不潮</li></ol></li><li>冬季<ol><li>屋内温度</li></ol></li></ul><h4 id="杂费缴纳"><a href="#杂费缴纳" class="headerlink" title="杂费缴纳"></a>杂费缴纳</h4><ol><li>物业费</li><li>取暖费</li><li>卫生费</li><li>水、电、网、燃气费</li></ol><h4 id="网络需求"><a href="#网络需求" class="headerlink" title="网络需求"></a>网络需求</h4><p>通哪些运营商的网络</p><ol><li>移动</li><li>电信</li><li>联通</li></ol><p>手机信号如何</p><h4 id="水、电、燃气、物业费等交割"><a href="#水、电、燃气、物业费等交割" class="headerlink" title="水、电、燃气、物业费等交割"></a>水、电、燃气、物业费等交割</h4><ol><li>签合同之前确定水、电、燃气表的读数</li><li>有无拖欠物业费等</li></ol><h4 id="问题家电"><a href="#问题家电" class="headerlink" title="问题家电"></a>问题家电</h4><ol><li>所有家电、家具都试用一遍，确定状态 有问题的家电可以要求房东更换：<ul><li>给换，Yeah！</li><li>不给换，说自己买：<ul><li>旧家电房东搬走，OK！</li><li>不搬走？不租！房东肯定事儿多！</li></ul></li></ul></li></ol><h4 id="证据留存"><a href="#证据留存" class="headerlink" title="证据留存"></a>证据留存</h4><ol><li>房子的状态、家具、家电都拍照或者录视频记录，退房时候以免万一</li></ol><h4 id="房屋朝向"><a href="#房屋朝向" class="headerlink" title="房屋朝向"></a>房屋朝向</h4><p>一定坐北朝南！</p><h4 id="卫生问题"><a href="#卫生问题" class="headerlink" title="卫生问题"></a>卫生问题</h4><ol><li>有无蟑螂、老鼠</li><li>通风好不好</li><li>下水道有没有反味、通不通畅</li><li>噪音</li></ol><h4 id="换锁芯"><a href="#换锁芯" class="headerlink" title="换锁芯"></a>换锁芯</h4><p>交房之后换锁芯，旧锁芯保留，退房的时候换上</p><h4 id="押金"><a href="#押金" class="headerlink" title="押金"></a>押金</h4><p>抱着不要的心态，调整好心态，但是要争取挽回可能的损失。</p><h2 id="小注意事项"><a href="#小注意事项" class="headerlink" title="小注意事项"></a>小注意事项</h2><ol><li>哥哥、姐姐叫起来，大家都出来混的，强龙不压地头蛇。</li><li>记得砍价，也许房租可以便宜一二百；中介费也是可谈的。 中介说走过路过不要错过的时候，记得还价！记住TA是要赚你的钱的，主动权应该在你手上，你可以说不是非这个房子不可，又不是赶着住，希望TA能再压低价格，如果可以了明天就可以签。</li><li>锁定一个心意的房子之后，中介说已经租出去了，要带着去看其他的房子。直接Say NO！</li><li>多花一点钱，比平时上下班多花一个小时更舒服。</li><li>合租可以看TA的工作是否规律、有无不良习惯、房子是否整洁、厕所是否干净</li><li>先看实拍图，再实地看房。</li><li>要看房本、身份证。</li><li>合同详细内容可以百度做功课。</li><li>给中介转中介费的时候要有第三方在，或者全程录音，而且转账账号要念出来让他确认。</li><li>从中介或者二房东租房要看其委托书或合同的委托或租赁时长，以免中途被赶出去。</li><li>不用租房贷。</li><li>到地铁口、超市等距离要看地图实际距离；</li><li>58同城上可以在线签合同，应该是没有什么问题的</li><li>租好房之后如果房子比较脏，可以在58或者其他平台上找找保洁，价格可以接受的话请保洁还是很划算的。</li></ol><h2 id="法律小知识"><a href="#法律小知识" class="headerlink" title="法律小知识"></a>法律小知识</h2><ol><li>业主负责维修 家电、家具合理的老化磨损应由业主负责，而非租客赔偿</li><li>买卖不破租赁 房子换了房东，我们依然有权依照合同约定期限继续居住</li><li>出现纠纷需要仲裁，仲裁费用由对方出</li><li>转租需征得业主同意</li><li>装修需经业主同意</li><li>甲醛超标可要求赔偿</li><li>不付租金房东有权赶走租客</li><li>续租需补签续租合同</li></ol><h2 id="合同相关"><a href="#合同相关" class="headerlink" title="合同相关"></a>合同相关</h2><ol><li>房主违约赔偿规则</li><li>租户违约赔偿规则</li><li>是否可以转租、装修、养宠物</li><li>物业费 如果包括，要清楚的写到合同上—房租 xx 元/月（含物业费）<br> 如果不包括，一定要问清楚物业费是怎么算的，具体到一平米多少钱还要写清楚你交的物业是你房间的平方米数，还是包括公摊面积（比如客厅，厕所）</li><li>电费<ul><li>你们租户自己交电费（支付宝就能交，房东有水电卡）</li><li>房东交按收据收钱</li><li>看总电表，按 x 毛度算钱</li></ul></li></ol><figure class="half">    <img src="https://images.961110.xyz/images/2021/10/20/98745486c5106dcec004682626f2af82.jpg">    <img src="https://images.961110.xyz/images/2021/10/20/26b7a5b950bfb95c45a6164ec43549ae.jpg"></figure><h2 id="六、参考链接"><a href="#六、参考链接" class="headerlink" title="六、参考链接"></a>六、参考链接</h2><ol><li><a href="https://b23.tv/hfMNvq">https://b23.tv/hfMNvq</a></li><li><a href="https://b23.tv/1sNxTj">https://b23.tv/1sNxTj</a></li><li><a href="https://b23.tv/koKZX7">https://b23.tv/koKZX7</a></li><li><a href="https://b23.tv/ug2GjJ">https://b23.tv/ug2GjJ</a></li><li><a href="https://www.zhihu.com/question/375266600">https://www.zhihu.com/question/375266600</a></li><li><a href="https://zhuanlan.zhihu.com/p/112314408">https://zhuanlan.zhihu.com/p/112314408</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 生活 </tag>
            
            <tag> 租房 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MAC使用VNC连接Centos7服务器</title>
      <link href="/posts/44617.html"/>
      <url>/posts/44617.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在windows 中，很多人选择安装xmanager+xshell，然后远程连接linux，就能直接调用软件的GUI界面。于是也在Mac上尝试远程调用Centos7的界面，但是使用XQuartz软件+ssh -X命令的方式(教程网址在最后引用里有)并不管用，百度了半天才发现可以使用VNC连接Centos7，故进行了总结。</p><h2 id="安装（Centos7）"><a href="#安装（Centos7）" class="headerlink" title="安装（Centos7）"></a>安装（Centos7）</h2><h3 id="安装x-window（已有图形界面则跳过此步骤）"><a href="#安装x-window（已有图形界面则跳过此步骤）" class="headerlink" title="安装x-window（已有图形界面则跳过此步骤）"></a>安装x-window（已有图形界面则跳过此步骤）</h3><p>以root用户输入以下命令安装x-window</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">yum check-update</span><br><span class="line">yum groupinstall <span class="string">&quot;X Window System&quot;</span></span><br><span class="line">yum install gnome-classic-session gnome-terminalnautilus-open-terminal control-center liberation-mono-fonts</span><br><span class="line"></span><br><span class="line">### 设置默认启动图形界面</span><br><span class="line">unlink /etc/systemd/system/<span class="keyword">default</span>.target</span><br><span class="line">ln -sf /lib/systemd/system/graphical.target/etc/systemd/system/<span class="keyword">default</span>.target</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><p>重启完成后，Centos7就会有图形化界面了。</p><h3 id="安装VNC-Server"><a href="#安装VNC-Server" class="headerlink" title="安装VNC Server"></a>安装VNC Server</h3><p>输入以下命令检查vnc server是否安装</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">yum info tigervnc-server</span><br></pre></td></tr></table></figure><p>已经安装好会有以下vnc server的信息</p><img src="https://images.961110.xyz/images/2021/10/20/tigervnc-server.png" alt="tigervnc-server安装" style="zoom: 67%;" /><p>没有安装好则以root用户运行以下命令来安装vncserver</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">yum install tigervnc-server</span><br></pre></td></tr></table></figure><h3 id="配置相关文件"><a href="#配置相关文件" class="headerlink" title="配置相关文件"></a>配置相关文件</h3><p>需要在 /etc/systemd/system/ 目录里创建一个配置文件，可以将 /lib/systemd/sytem/vncserver@.service 拷贝一份配置文件范例过来。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cp /lib/systemd/system/vncserver@.service  /etc/systemd/system/vncserver@:<span class="number">1.</span>service</span><br></pre></td></tr></table></figure><p>编辑/etc/systemd/system/vncserver@:1.service,替换成自己的用户名。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#普通用户用下面两句</span><br><span class="line">ExecStart=/sbin/runuser -l &lt;user_name&gt; -c<span class="string">&quot;/usr/bin/vncserver %i&quot;</span></span><br><span class="line">PIDFile=/home/&lt;user_name&gt;/.vnc/%H%i.pid</span><br><span class="line"></span><br><span class="line"><span class="meta">#root用户用下面两句</span></span><br><span class="line">ExecStart=/sbin/runuser -l root -c <span class="string">&quot;/usr/bin/vncserver %i&quot;</span></span><br><span class="line">PIDFile=/root/.vnc/%H%i.pid</span><br></pre></td></tr></table></figure><p>修改完的文件内容如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Remote desktop service (VNC)</span><br><span class="line">After=syslog.target network.target</span><br><span class="line"></span><br><span class="line">Type=forking</span><br><span class="line"></span><br><span class="line"># Clean any existing files in /tmp/.X11-unix environment</span><br><span class="line"></span><br><span class="line">ExecStartPre=/bin/sh -c <span class="string">&#x27;/usr/bin/vncserver -kill %i &gt; /dev/null 2&gt;&amp;1 || :&#x27;</span></span><br><span class="line"></span><br><span class="line">ExecStart=/sbin/runuser -l root -c <span class="string">&quot;/usr/bin/vncserver %i -geometry 800x600&quot;</span></span><br><span class="line"></span><br><span class="line">PIDFile=/root/.vnc/%H%i.pid</span><br><span class="line"></span><br><span class="line">ExecStop=/bin/sh -c <span class="string">&#x27;/usr/bin/vncserver -kill %i &gt; /dev/null 2&gt;&amp;1 || :&#x27;</span></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>更新systemctl以使其生效</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>最后还要设置一下用户的 VNC 密码。要设置某个用户的密码，必须要有能通过 sudo 切换到用户的权限。PS：密码要≥六位</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">su user_name</span><br><span class="line">vncpasswd</span><br></pre></td></tr></table></figure><p>执行如下语句，让防火墙放行vnc服务</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --add-service vnc-server</span><br><span class="line"></span><br><span class="line">systemctl restart firewalld.service</span><br></pre></td></tr></table></figure><p>或者设置防火墙放行对应端口</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --zone=<span class="keyword">public</span> --add-port=<span class="number">5901</span>/tcp</span><br><span class="line"></span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>如果命令报错，可能是由于安装了python3的解释器，python是指向python3的，而原来的系统firewall-cmd 是命令脚本是使用python2的，而python3没有对应包，所以需要修改firewall-cmd命令脚本，让它依旧使用python2，这样就不会有问题了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sudo vim /usr/bin/firewall-cmd</span><br></pre></td></tr></table></figure><p>第一行python改为python2</p><p><img src="https://images.961110.xyz/images/2021/10/20/python.png" alt="更改python解释器"></p><p>接着把vnc添加到开机自启动</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">systemctl enable vncserver@:<span class="number">1.</span>service</span><br></pre></td></tr></table></figure><p>最后启动服务</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">systemctl start vncserver@:<span class="number">1.</span>service</span><br></pre></td></tr></table></figure><p>启动时可能会报如下错误</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">job <span class="keyword">for</span> vncserver@:<span class="number">1.</span>service failed because a configured resourcelimit was exceeded.</span><br></pre></td></tr></table></figure><p>执行# systemctl status vncserver@:1.service，发现一条信息：</p><p>localhost.localdomain systemd[1]: PID file /root/.vnc/localhost.localdomain:1.pid not readable (yet?) after start.</p><p>检查 /root/.vnc/，发现没有localhost.localdomain:1.pid</p><p>解决方法：</p><p>原来目录/tmp/下有一个/.X11-unix目录会占用这个pid序号资源。<br>把这个目录改名/.X11-unix.bak后，再次尝试启动后成功。</p><p>执行的代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mv /tmp/.X11-unix /tmp/.X11-unix.bak</span><br><span class="line"></span><br><span class="line">systemctl start vncserver@\:<span class="number">1.</span>service</span><br></pre></td></tr></table></figure><p>如果提示Too many open files 且启动不成功，重启一下机器即可</p><p>注意：非正常关机启动后，会报</p><p>PID 4286 read from file /root/.vnc/localhost.localdomain:1.pid does not exist or is a zombie</p><p>或者 PID file /root/.vnc/localhost.localdomain:2.pid not readable (yet?) after start.</p><p>解决方法：cd /tmp/.X11-unix</p><p>Rm -rf *</p><h3 id="多用户连接"><a href="#多用户连接" class="headerlink" title="多用户连接"></a>多用户连接</h3><p>如果需要更多的用户连接，需要创建配置文件和端口，添加一个新的用户和端口。创建/etc/systemd/system/vncserver@:*.service，替换配置文件里的用户名和之后步骤里相应的文件名、端口号。</p><p>VNC 服务本身使用的是 5900 端口。鉴于有不同的用户使用 VNC ，每个人的连接都会获得不同的端口。第一个 VNC 服务会运行在 5901（5900 + 1）端口上，之后的依次增加，运行在 5900 + x 号端口上。其中 x 是指之后用户的配置文件名 vncserver@:x.service 里面的 x 。</p><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><p>关闭 VNC 服务</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">systemctl stop vncserver@:<span class="number">1.</span>service</span><br></pre></td></tr></table></figure><p>禁止 VNC 服务开机启动</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">systemctl disable vncserver@:<span class="number">1.</span>service</span><br></pre></td></tr></table></figure><p>关闭防火墙</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br></pre></td></tr></table></figure><h2 id="安装（MAC）"><a href="#安装（MAC）" class="headerlink" title="安装（MAC）"></a>安装（MAC）</h2><h3 id="安装VNC-Viewer"><a href="#安装VNC-Viewer" class="headerlink" title="安装VNC Viewer"></a>安装VNC Viewer</h3><p>链接：<a href="https://www.realvnc.com/download/file/viewer.files/VNC-Viewer-6.19.923-MacOSX-x86_64.dmg">https://www.realvnc.com/download/file/viewer.files/VNC-Viewer-6.19.923-MacOSX-x86_64.dmg</a></p><p>启动输入IP:Port进行连接</p><img src="https://images.961110.xyz/images/2021/10/20/VNCViewer.png" alt="VNCViewer" style="zoom:67%;" /><p>输入之前设置的密码即可</p><p><img src="https://images.961110.xyz/images/2021/10/20/VNC.png" alt="VNC连接"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://blog.csdn.net/dobell/article/details/55047811">https://blog.csdn.net/dobell/article/details/55047811</a>（mac如何ssh连接linux(ubuntu) GUI图形界面）</li><li><a href="https://blog.csdn.net/weixin_38280090/article/details/84259489">https://blog.csdn.net/weixin_38280090/article/details/84259489</a>（Linux VNC server 安装配置）</li><li><a href="https://blog.csdn.net/smile_caijx/article/details/78797234">https://blog.csdn.net/smile_caijx/article/details/78797234</a>（在Linux中如何开启VNC服务）</li><li><a href="https://linux.cn/article-5335-1.html">https://linux.cn/article-5335-1.html</a>（怎样在 CentOS 7.0 上安装和配置 VNC 服务器）</li><li><a href="https://blog.csdn.net/qq_42999398/article/details/88750280">https://blog.csdn.net/qq_42999398/article/details/88750280</a>（centos7 firewall-cmd 命令报错）</li><li><a href="https://blog.csdn.net/liliangkuba/article/details/99684420">https://blog.csdn.net/liliangkuba/article/details/99684420</a>（解决vncserver报错：PID file /root/.vnc/localhost.localdomain:1.pid not readable）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Linux </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
