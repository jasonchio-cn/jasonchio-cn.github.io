<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>zsh终端配置</title>
      <link href="/posts/3295.html"/>
      <url>/posts/3295.html</url>
      
        <content type="html"><![CDATA[<h2 id="安装zsh"><a href="#安装zsh" class="headerlink" title="安装zsh"></a>安装zsh</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get update #更新软件源索引</span><br><span class="line">sudo apt-get install zsh #安装zsh</span><br></pre></td></tr></table></figure><p>zsh安装完成后，执行:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/shell</span><br></pre></td></tr></table></figure><p>不出意外的话，终端应该会返回包含<code>/bin/zsh</code>或<code>/usr/bin/zsh</code>字样的结果了。</p><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><p>使用oh-my-zsh来配置zsh，oh-my-zsh是一个快速&amp;自动化配置zsh的项目，项目地址:<a href="https://github.com/robbyrussell/oh-my-zsh">https://github.com/robbyrussell/oh-my-zsh</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh #下载并执行oh-my-zsh自动配置脚本</span><br></pre></td></tr></table></figure><p>执行此命令后，脚本将会下载zsh所需的资源和配置文件至<code>~/oh-my-zsh/</code>目录，并将根据你的系统环境变量完成对zsh的配置。</p><p>接着，我们可以执行以下命令将zsh切换为此用户的默认Shell(可能需要用户的密码):</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chsh -s /bin/zsh #无需加sudo</span><br></pre></td></tr></table></figure><p>退出终端并再次登录终端，这时命令指示符应该有变化了，说明zsh的基础配置完成。</p><h2 id="进阶配置"><a href="#进阶配置" class="headerlink" title="进阶配置"></a>进阶配置</h2><p>通过更改<code>~/.zshrc</code>文件来对zsh进行进一步的配置:</p><h3 id="更改主题"><a href="#更改主题" class="headerlink" title="更改主题"></a>更改主题</h3><p>对应的主题应该都有介绍，链接：<a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Themes">https://github.com/ohmyzsh/ohmyzsh/wiki/Themes</a></p><p>我这里安装的是powerlevel10k，安装步骤如下：</p><p>项目链接：<a href="https://github.com/romkatv/powerlevel10k">https://github.com/romkatv/powerlevel10k</a></p><img src="https://images.961110.xyz/images/2021/10/22/powerlevel10k.png" alt="image-20211022132355307" style="zoom:50%;" /><p>根据官方教程即可进行相应配置，或者输入<code>p10k configure</code>进行配置。</p><img src="https://images.961110.xyz/images/2021/10/22/p10k-configure.png" alt="image-20211022132701167" style="zoom:50%;" /><p>根据提示输入选项即可。</p><p>zsh配置文件中主题相关的配置如下图</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ZSH_THEME=&quot;powerlevel10k/powerlevel10k&quot;    #将zsh的主题更改为powerlevel10k</span><br></pre></td></tr></table></figure><h3 id="自动纠错"><a href="#自动纠错" class="headerlink" title="自动纠错"></a>自动纠错</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENABLE_CORRECTION=&quot;true&quot;    #(去掉ENABLE前的&quot;#&quot;)打开zsh的自动纠错功能</span><br></pre></td></tr></table></figure><p>当纠错功能开启后，当你键入的命令被zsh判定为”可能错误的命令”时，将会提示你是否将此命令重定向为”zsh认为可能正确的命令”，比如键入<code>iconfig</code>命令时，zsh将会返回以下提示:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zsh: correct &#x27;iconfig&#x27; to &#x27;ifconfig&#x27; [nyae]?</span><br></pre></td></tr></table></figure><p>键入 y 即可将刚刚输入的iconfig命令重定向到ifconfig命令</p><h3 id="命令别名"><a href="#命令别名" class="headerlink" title="命令别名"></a>命令别名</h3><p>将以下内容添加到文件的末尾以重定向默认命令或添加自定义命令:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Alias Settings</span><br><span class="line">alias ll=&#x27;ls -all&#x27;</span><br><span class="line">alias vi=&#x27;vim&#x27;</span><br><span class="line">alias ps=&#x27;ps -A&#x27;</span><br><span class="line">alias ifconfig=&#x27;sudo ifconfig&#x27;</span><br></pre></td></tr></table></figure><p>其中，<code>alias ifconfig=&#39;sudo ifconfig&#39;</code>这一句比较重要，如果不加此内容，在当前用户下可能会出现无法执行ifconfig命令的情况。</p><p>如在终端中执行<code>ll</code>命令，相当于执行<code>ls -all</code>文件，执行<code>ps</code>命令则相当于执行<code>ps -A</code>命令:</p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>安装插件时可能因为网络问题无法连接到github仓库，可以到gitee上看看有没有对应的克隆库，替换一下即可。</p><h4 id="Autojump"><a href="#Autojump" class="headerlink" title="Autojump"></a>Autojump</h4><p>我们还可以安装Autojump插件，以实现快捷定位常用目录(需要在安装之前配置Python环境):</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">git clone git://github.com/joelthelion/autojump.git #从Github克隆Autojump项目</span><br><span class="line"></span><br><span class="line">cd autojump</span><br><span class="line">sudo chmod 755 install.py</span><br><span class="line"></span><br><span class="line">./install.py #执行安装脚本，安装Autojump</span><br></pre></td></tr></table></figure><p>在脚本执行结果的末尾，你将会看到类似这样的内容(实际内容可能不一样):</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[[ -s /home/pi/.autojump/etc/profile.d/autojump.sh ]] &amp;&amp; source /home/pi/.autojump/etc/profile.d/autojump.sh</span><br><span class="line">autoload -U compinit &amp;&amp; compinit -u</span><br></pre></td></tr></table></figure><p>复制终端中这段内容，添加到<code>~/.zshrc</code>文件末尾即可启用Autojump。接着，我们可以执行以下命令重载<code>.zshrc</code>文件以更新zsh配置:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source .zshrc #重载zsh配置文件</span><br></pre></td></tr></table></figure><p>启用Autojump插件后，插件将记录你经常定位的目录，存储到数据库中，当之后想要访问此目录时，只需要键入:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">j &lt;目录简称&gt;</span><br></pre></td></tr></table></figure><p>即可快速定位。比如<code>/var/www/html</code>是我经常定位的目录。如果我想快捷访问此目录，只需要键入:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">j html</span><br></pre></td></tr></table></figure><p>即可快速定位。</p><h4 id="sudo插件"><a href="#sudo插件" class="headerlink" title="sudo插件"></a>sudo插件</h4><p>开启sudo插件后，如果遇到上一条命令因为未在命令头部添加sudo命令而保存的情况时，只需要双击”Esc”键，即可自动为刚才键入的最后一条命令补全sudo。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plugins=(git sudo)    #为zsh添加git和sudo插件</span><br></pre></td></tr></table></figure><h4 id="highlighting插件"><a href="#highlighting插件" class="headerlink" title="highlighting插件"></a>highlighting插件</h4><p>命令高亮插件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://gitee.com/unrogue007/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure><p>在<code>.zshrc</code>配置文件的插件配置项增加高亮插件即可。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plugins=(git sudo zsh-syntax-highlighting )</span><br></pre></td></tr></table></figure><h4 id="autosuggestions插件"><a href="#autosuggestions插件" class="headerlink" title="autosuggestions插件"></a>autosuggestions插件</h4><p>命令提示插件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure><p>在<code>.zshrc</code>配置文件的插件配置项增加高亮插件即可。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plugins=(git sudo zsh-syntax-highlighting zsh-autosuggestions)</span><br></pre></td></tr></table></figure><p><strong>别忘了<code>source .zshrc</code> 重载zsh配置文件</strong></p><h3 id="隐藏用户名或者主机名"><a href="#隐藏用户名或者主机名" class="headerlink" title="隐藏用户名或者主机名"></a>隐藏用户名或者主机名</h3><p>修改<code>vim ~/.zshrc</code>文件,在文件底部增加</p><ul><li><p>隐藏用户名和主机名</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">prompt_context() &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>只保留用户名，隐藏主机名</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">prompt_context() &#123;</span><br><span class="line">  if [[ &quot;$USER&quot; != &quot;$DEFAULT_USER&quot; || -n &quot;$SSH_CLIENT&quot; ]]; then</span><br><span class="line">    prompt_segment black default &quot;%(!.%&#123;%F&#123;yellow&#125;%&#125;.)$USER&quot;</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>只保留主机名，隐藏用户名</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">prompt_context() &#123;</span><br><span class="line">  if [[ &quot;$USER&quot; != &quot;$DEFAULT_USER&quot; || -n &quot;$SSH_CLIENT&quot; ]]; then</span><br><span class="line">    prompt_segment black default &quot;%(!.%&#123;%F&#123;yellow&#125;%&#125;.)$HOST&quot;</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>修改后记得执行 <code>source ~/.zshrc</code></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://mlapp.cn/310.html">树莓派折腾记:安装并配置zsh | 美丽应用 (mlapp.cn)</a></li><li><a href="https://www.jianshu.com/p/3158a2116fdf">ZSH的配置 - 简书 (jianshu.com)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 树莓派 </tag>
            
            <tag> zsh </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派安装Clash代理</title>
      <link href="/posts/60310.html"/>
      <url>/posts/60310.html</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>到<a href="https://github.com/Dreamacro/clash/releases">官方Releases页面</a>下，选择合适的版本下载。</p><p>我这里下载的是<a href="https://github.com/Dreamacro/clash/releases/download/v1.7.1/clash-linux-armv8-v1.7.1.gz">clash-linux-armv8-v1.7.1.gz</a></p><h3 id="解压并安装"><a href="#解压并安装" class="headerlink" title="解压并安装"></a>解压并安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gzip -dv clash-linux-armv8-v1.7.1.gz</span><br><span class="line"></span><br><span class="line">sudo mkdri /usr/local/bin/clash</span><br><span class="line"></span><br><span class="line">mv clash-linux-armv8-v1.7.1 /usr/local/bin/clash</span><br><span class="line"></span><br><span class="line">sudo chmod a+x /usr/local/bin/clash</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 首次运行，初始化一下config目录</span></span><br><span class="line">clash</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载配置文件（如果是root用户安装clash的那么配置文件应放在/root/.config/clash目录下）</span></span><br><span class="line">sudo wget -O /home/pi/.config/clash/config.yaml https://xxxx.xx/xxx</span><br></pre></td></tr></table></figure><p>配置文件可以在购买渠道获得，我电脑上也在用，所以直接复制过来了，就是URL下对应的链接。</p><img src="https://images.961110.xyz/images/2021/10/22/clash.png" alt="image-20211022172216860" style="zoom:50%;" /><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">port: 7890</span><br><span class="line">socks-port: 7891</span><br><span class="line">allow-lan: false</span><br><span class="line">mode: Rule</span><br><span class="line">log-level: info</span><br><span class="line">external-controller: 0.0.0.0:9091</span><br></pre></td></tr></table></figure><p>port为代理的端口<br>allow-lan为是否开启局域网访问<br>external-controller为Clash控制端口与允许访问该端口的设备</p><p><strong>这里mode先设置为Global，方便之后测试。</strong></p><h3 id="配置开机启动"><a href="#配置开机启动" class="headerlink" title="配置开机启动"></a>配置开机启动</h3><p>官方教程：<a href="https://github.com/Dreamacro/clash/wiki/clash-as-a-daemon#systemd">https://github.com/Dreamacro/clash/wiki/clash-as-a-daemon#systemd</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将配置文件复制到/etc/clash文件夹中</span></span><br><span class="line">sudo mkdir /etc/clash</span><br><span class="line"></span><br><span class="line">cp /home/pi/.config/clash/config.yaml /etc/clash/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 虽然前面的步骤中没见过这个文件，但是它是自动生成的</span></span><br><span class="line">cp /home/pi/.config/clash/Country.mmdb /etc/clash/</span><br></pre></td></tr></table></figure><p>在systemd配置目录中新建配置文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/systemd/system/clash.service</span><br></pre></td></tr></table></figure><p>输入一下内容</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Clash daemon, A rule-based proxy in Go.</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">Restart=always</span><br><span class="line">ExecStart=/usr/local/bin/clash -d /etc/clash</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>启动开机自启</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable clash</span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> systemctl start clash</span></span><br></pre></td></tr></table></figure><p>检查状态</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl status clash</span><br></pre></td></tr></table></figure><p>开启代理</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export http_proxy=127.0.0.1:7890</span><br><span class="line">export https_proxy=127.0.0.1:7890</span><br></pre></td></tr></table></figure><p>取消代理</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unset http_proxy</span><br><span class="line">unset https_proxy</span><br></pre></td></tr></table></figure><p>验证代理是否成功</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl cip.cc</span><br></pre></td></tr></table></figure><p><img src="https://images.961110.xyz/images/2021/10/22/30f1e33fa6233494f9b97eb22427568e.png" alt="image-20211022174912273" style="zoom:50%;" /><img src="https://images.961110.xyz/images/2021/10/22/115f7af8cbbf091d4478c60fb8631461.png" alt="image-20211022174955495" style="zoom: 50%;" /></p><p>如果提示未安装curl，输入以下命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt install curl</span><br></pre></td></tr></table></figure><p>如果代理成功，则会显示代理的IP及地址。</p><p>代理成功，可以把代理模式改回 Rule 模式</p><h3 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h3><p>通过一下网站可以管理Clash</p><p><a href="http://clash.razord.top/#/settings">http://clash.razord.top/#/settings</a></p><img src="https://images.961110.xyz/images/2021/10/22/clashe8aa2ec8d51bee0e.png" alt="image-20211022174624218" style="zoom:50%;" /><p>Host填写树莓派的IP，端口填写clash配置文件中<code>external-controller</code>填写的端口。</p><img src="https://images.961110.xyz/images/2021/10/22/clash49c32381cceff753.png" alt="image-20211022174803075" style="zoom:50%;" /><p>在设置页面也可以控制全局代理还是规则代理还是直连。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="http://events.jianshu.io/p/f0daa2d9eae6">树莓派4B 通过Clash实现代理 - 简书 (jianshu.io)</a></li><li><a href="https://www.cnblogs.com/rogunt/p/15127947.html">在Linux终端中使用Clash（clash for linux) - Rogunt - 博客园 (cnblogs.com)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 树莓派 </tag>
            
            <tag> 代理 </tag>
            
            <tag> 科学上网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux通过dd命令备份及还原SD卡</title>
      <link href="/posts/2965.html"/>
      <url>/posts/2965.html</url>
      
        <content type="html"><![CDATA[<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>dd：用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换。</p><p>参数：</p><ol><li>if=文件名：输入文件名，缺省为标准输入。即指定源文件。&lt; if=input file &gt;</li><li>of=文件名：输出文件名，缺省为标准输出。即指定目的文件。&lt; of=output file &gt;</li></ol><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li><p>将读卡器连接到Linux虚拟机中；</p></li><li><p>使用<code>sudo fdisk -l</code>命令列出所有存储设备，找到SD对应的盘符，/dev/sdb</p><img src="https://images.961110.xyz/images/2021/10/21/fdisk--l.png" alt="image-20211021164046598" style="zoom:50%;" /></li><li><p>输入<code>sudo dd if=/dev/sdb status=progress | gzip &gt; /path2backup/backup.gz</code>将镜像备份到指定目录，并用gzip压缩</p></li><li><p>要恢复的话，输入<code>gzip -dc /path2backup/backup.gz | dd of=/dev/sdb</code></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Linux </tag>
            
            <tag> 树莓派 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派4B启动配置</title>
      <link href="/posts/59454.html"/>
      <url>/posts/59454.html</url>
      
        <content type="html"><![CDATA[<h2 id="镜像及工具"><a href="#镜像及工具" class="headerlink" title="镜像及工具"></a>镜像及工具</h2><h3 id="系统镜像"><a href="#系统镜像" class="headerlink" title="系统镜像"></a>系统镜像</h3><h4 id="Raspberry-Pi-OS"><a href="#Raspberry-Pi-OS" class="headerlink" title="Raspberry Pi OS"></a>Raspberry Pi OS</h4><p>官方镜像，基于Debian的一个发行版，针对树莓派做了优化。</p><p>一共提供了三个版本，镜像大小逐个递减。</p><ol><li>Raspberry Pi OS with desktop and recommended software：有图形界面，内置各种软件，比如博主的世界、Python、游戏等；</li><li>Raspberry Pi OS with desktop：有图形界面、浏览器，没有一些乱七八糟的软件；</li><li>Raspberry Pi OS Lite：无图形界面，有核心依赖，比如Python等。</li></ol><p>需要图形化界面的更推荐Raspberry Pi OS with desktop这个版本，不大不小。不过<strong>官网默认提供的是32bit的版本</strong>，树莓派RaspBerry4B的CPU是博通的BCM2711，一颗ARM Cortex-A72架构的64位处理器，所以使用64位系统才能更好释放性能。</p><blockquote><p><a href="https://downloads.raspberrypi.org/raspios_armhf/images/">32bit镜像官网链接</a></p><p><a href="https://downloads.raspberrypi.org/raspios_arm64/images">64bit镜像官网链接</a></p><p><a href="https://www.raspberrypi.com/software/operating-systems/">镜像的官方介绍及各个版本</a></p></blockquote><h3 id="SD卡格式化工具"><a href="#SD卡格式化工具" class="headerlink" title="SD卡格式化工具"></a>SD卡格式化工具</h3><p>SD Card Formatter</p><p><a href="https://www.sdcard.org/downloads/formatter/sd-memory-card-formatter-for-windows-download/">官网下载链接</a></p><h3 id="写镜像工具"><a href="#写镜像工具" class="headerlink" title="写镜像工具"></a>写镜像工具</h3><p>Win32DiskImager</p><p><a href="https://sourceforge.net/projects/win32diskimager/files/latest/download">官方下载链接</a></p><h3 id="远程桌面工具"><a href="#远程桌面工具" class="headerlink" title="远程桌面工具"></a>远程桌面工具</h3><h5 id="VNC-Viewer"><a href="#VNC-Viewer" class="headerlink" title="VNC Viewer"></a>VNC Viewer</h5><p><a href="https://www.realvnc.com/en/connect/download/viewer/">官方下载链接</a></p><h2 id="刷写系统"><a href="#刷写系统" class="headerlink" title="刷写系统"></a>刷写系统</h2><h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><p>此处博主下载的是64位的最新镜像，官方文件名为：2021-05-07-raspios-buster-arm64</p><p>下载之后可以Windows 10终端里输入下面命令来计算SHA256进行完整性校验。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">certutil -hashfile 镜像存放路径\2021-05-07-raspios-buster-arm64.zip SHA256</span><br></pre></td></tr></table></figure><p>BTW，可选哈希算法参数有MD2 MD4 MD5 SHA1 SHA256 SHA384 SHA512</p><p><img src="https://images.961110.xyz/images/2021/10/19/Raspberry-Pi-OS-with-desktop-.png" alt="image-20211016201407578" style="zoom:50%;" /><img src="https://images.961110.xyz/images/2021/10/19/Raspberry-Pi-OS-with-desktop-dc4e0e6197208ff1.png" alt="image-20211016201252081" style="zoom:50%;" /></p><p>两个不同的下载通道都可以看到SHA256的值，最好校验一下。</p><p>校验无误后，解压得到<code>.img</code>镜像文件，待会写到SD卡中。</p><h3 id="格式化SD卡"><a href="#格式化SD卡" class="headerlink" title="格式化SD卡"></a>格式化SD卡</h3><p>选择好SD卡对应的盘符，选择Quick format，点击右下角Format，稍等片刻即可。<strong>注意不要选择错了盘符，否则后果不堪设想。</strong></p><p><img src="https://images.961110.xyz/images/2021/10/19/SD-Card-Formatter.png" alt="image-20211016201935243" style="zoom: 67%;" /><img src="https://images.961110.xyz/images/2021/10/19/SD.png" alt="image-20211016202211668" style="zoom:67%;" /></p><h3 id="刷写镜像"><a href="#刷写镜像" class="headerlink" title="刷写镜像"></a>刷写镜像</h3><p>选择刚刚解压出来的镜像文件，选择好盘符，然后点击写入即可，完成速度取决于SD卡及读卡器的速度。</p><p><img src="https://images.961110.xyz/images/2021/10/19/f28e57496b9b60234c05963587aebae3.png" alt="image-20211016202444369" style="zoom:67%;" /><img src="https://images.961110.xyz/images/2021/10/19/1163840ac01b2da689eb0dc2686f4eb3.png" alt="image-20211016203816344" style="zoom:67%;" /></p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="开启ssh"><a href="#开启ssh" class="headerlink" title="开启ssh"></a>开启ssh</h4><p>写入镜像后，会有一个boot分区，在boot分区下新建一个<strong>删掉格式后缀</strong>的名为ssh的<strong>文件</strong>，以便启动后使用ssh连接树莓派。</p><h4 id="通过网线共享电脑的网络"><a href="#通过网线共享电脑的网络" class="headerlink" title="通过网线共享电脑的网络"></a>通过网线共享电脑的网络</h4><blockquote><p>设置–&gt;状态–&gt;高级网络设置：更改适配器选项–&gt;选择电脑联网的适配器–&gt;右键选择属性，点击共享–&gt;打开下图中的选项–&gt;选择树莓派要连接的适配器–&gt;确定</p></blockquote><img src="https://images.961110.xyz/images/2021/10/19/2d3ddc0a200c6e2f6386bbfe718cb969.png" alt="image-20211017133126324" style="zoom:50%;" /><p>此种方式的默认的网关IP是192.168.137.1，所以分配给树莓派的IP是192.168.137.XXX，具体查看方式见下文。</p><h4 id="通过配置WiFi上网"><a href="#通过配置WiFi上网" class="headerlink" title="通过配置WiFi上网"></a>通过配置WiFi上网</h4><p>在boot分区新建一个wpa_supplicant.conf文件，内容如下:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">country=CN</span><br><span class="line">ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev</span><br><span class="line">update_config=1</span><br><span class="line"></span><br><span class="line">network=&#123;</span><br><span class="line">       ssid=&quot;XXXXXXX&quot;</span><br><span class="line">       psk=&quot;password&quot;</span><br><span class="line">       key_mgmt=WPA-PSK</span><br><span class="line">       priority=1</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>ssid</code>就是WIFI名，<code>psk</code>就是WiFi密码，<code>key_mgmt</code>就是WiFi的加密方式，一般在路由器管理界面的WiFi设置中可以看到。</p><p>和一般的不同，这里**<code>priority</code>值越大，优先级越大**。</p><h4 id="连接风扇"><a href="#连接风扇" class="headerlink" title="连接风扇"></a>连接风扇</h4><img src="https://images.961110.xyz/images/2021/10/19/4B-.jpg" alt="树莓派4B 连接风扇" style="zoom:50%;" /><p>树莓派4B的GPIO口外侧是偶数口，内侧是奇数口，如图示从左到右需要依次增大。风扇需要连接在第4和6号引脚上，正极（红线）连接在4号引脚，负极（黑线）连接在6号引脚。</p><h3 id="通电"><a href="#通电" class="headerlink" title="通电"></a>通电</h3><h4 id="状态检查"><a href="#状态检查" class="headerlink" title="状态检查"></a>状态检查</h4><p>插入SD卡，插入网线，连接电源自动开机：</p><ul><li>红灯常亮：未能检测到TF卡；</li><li>双灯常亮：未能检测到系统；</li><li>绿灯闪烁：系统运行正常。、</li></ul><p>等个几十秒进行下一步</p><h4 id="通过网线联网，查看树莓派Raspberry-4B的IP"><a href="#通过网线联网，查看树莓派Raspberry-4B的IP" class="headerlink" title="通过网线联网，查看树莓派Raspberry 4B的IP"></a>通过网线联网，查看树莓派Raspberry 4B的IP</h4><p>打开cmd或其他shell工具，通过<code>arp -a</code>查看本机的arp表，找到接口为192.168.137.1下的内容</p><p>可以看到树莓派Raspberry 4B获得的IP: 192.168.137.XXX</p><h4 id="通过配置WiFi上网，查看树莓派Raspberry-4B的IP"><a href="#通过配置WiFi上网，查看树莓派Raspberry-4B的IP" class="headerlink" title="通过配置WiFi上网，查看树莓派Raspberry 4B的IP"></a>通过配置WiFi上网，查看树莓派Raspberry 4B的IP</h4><p>进入路由器后台，查看接入网络的设备列表，记录其IP即可。</p><p>此处博主通过Windows 10开启移动热点，树莓派连接上WIFI之后可以直接看到IP地址</p><img src="https://images.961110.xyz/images/2021/10/21/Windows104a0509f4c0915e31.png" alt="image-20211021162133259" style="zoom:50%;" /><img src="https://images.961110.xyz/images/2021/10/21/Windows10851671f235bebad9.png" alt="image-20211021162217862" style="zoom:50%;" /><h3 id="ssh连接"><a href="#ssh连接" class="headerlink" title="ssh连接"></a>ssh连接</h3><p>获取IP后，直接 <code>ssh pi@IP</code> 即</p><p>密码是 raspberry</p><h3 id="VNC连接"><a href="#VNC连接" class="headerlink" title="VNC连接"></a>VNC连接</h3><h4 id="开启VNC"><a href="#开启VNC" class="headerlink" title="开启VNC"></a>开启VNC</h4><p>使用ssh登录之后，输入<code>sudo raspi-config</code>进行配置</p><p><img src="https://images.961110.xyz/images/2021/10/21/config.png" alt="image-20211021162433139" style="zoom: 40%;" /><img src="https://images.961110.xyz/images/2021/10/21/VNC.png" alt="image-20211021161625685" style="zoom:45%;" /></p><p>此种方式是<strong>开机自动开启</strong>VNC服务的。</p><p>在终端输入<code>vncserver</code>开启NVC服务的方式，每次启动必须手动执行才可以。</p><h4 id="使用VNC连接"><a href="#使用VNC连接" class="headerlink" title="使用VNC连接"></a>使用VNC连接</h4><img src="https://images.961110.xyz/images/2021/10/21/VNC7439f5bdc8e20c2c.png" alt="image-20211021162832932" style="zoom: 50%;" /><p>直接输入树莓派的IP地址即可。</p><h3 id="使用微软远程桌面连接"><a href="#使用微软远程桌面连接" class="headerlink" title="使用微软远程桌面连接"></a>使用微软远程桌面连接</h3><h4 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装 xrdp</span></span><br><span class="line">sudo apt-get install xrdp</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动xrdp</span></span><br><span class="line">sudo /etc/init.d/xrdp start</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将Xrdp服务添加到系统默认启动服务中</span></span><br><span class="line">sudo update-rc.d xrdp defaults</span><br></pre></td></tr></table></figure><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>打开Windows远程桌面，输入树莓派4B的IP，连接即可。默认用户名：pi，默认密码：raspberry。</p><h2 id="更换软件源"><a href="#更换软件源" class="headerlink" title="更换软件源"></a>更换软件源</h2><h3 id="Debian系统源"><a href="#Debian系统源" class="headerlink" title="Debian系统源"></a>Debian系统源</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure><p>清空原文件中的内容，填入清华大学的源</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster main contrib non-free</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster main contrib non-free</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-updates main contrib non-free</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-updates main contrib non-free</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-backports main contrib non-free</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-backports main contrib non-free</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian-security buster/updates main contrib non-free</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/debian-security buster/updates main contrib non-free</span><br></pre></td></tr></table></figure><h3 id="树莓派软件源"><a href="#树莓派软件源" class="headerlink" title="树莓派软件源"></a>树莓派软件源</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /etc/apt/sources.list.d/raspi.list /etc/apt/sources.list.d/raspi.list.bak</span><br></pre></td></tr></table></figure><p>清空原文件中的内容，填入清华大学的源</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui</span><br></pre></td></tr></table></figure><h3 id="刷新软件包信息"><a href="#刷新软件包信息" class="headerlink" title="刷新软件包信息"></a>刷新软件包信息</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><h3 id="版本信息"><a href="#版本信息" class="headerlink" title="版本信息"></a>版本信息</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pi@raspberrypi:~ $ uname -a</span><br><span class="line">Linux raspberrypi 5.10.63-v8+ #1459 SMP PREEMPT Wed Oct 6 16:42:49 BST 2021 aarch64 GNU/Linux</span><br><span class="line"></span><br><span class="line">pi@raspberrypi:~ $ cat /proc/version</span><br><span class="line">Linux version 5.10.63-v8+ (dom@buildbot) (aarch64-linux-gnu-gcc-8 (Ubuntu/Linaro 8.4.0-3ubuntu1) 8.4.0, GNU ld (GNU Binutils for Ubuntu) 2.34) #1459 SMP PREEMPT Wed Oct 6 16:42:49 BST 2021</span><br><span class="line"></span><br><span class="line">pi@raspberrypi:~ $ lsb_release -a</span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID: Debian</span><br><span class="line">Description:    Debian GNU/Linux 10 (buster)</span><br><span class="line">Release:        10</span><br><span class="line">Codename:       buster</span><br></pre></td></tr></table></figure><h3 id="重要部件信息"><a href="#重要部件信息" class="headerlink" title="重要部件信息"></a>重要部件信息</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pi@raspberrypi:~ $ lscpu</span><br><span class="line">Architecture:        aarch64</span><br><span class="line">Byte Order:          Little Endian</span><br><span class="line">CPU(s):              4</span><br><span class="line">On-line CPU(s) list: 0-3</span><br><span class="line">Thread(s) per core:  1</span><br><span class="line">Core(s) per socket:  4</span><br><span class="line">Socket(s):           1</span><br><span class="line">Vendor ID:           ARM</span><br><span class="line">Model:               3</span><br><span class="line">Model name:          Cortex-A72</span><br><span class="line">Stepping:            r0p3</span><br><span class="line">CPU max MHz:         1500.0000</span><br><span class="line">CPU min MHz:         600.0000</span><br><span class="line">BogoMIPS:            108.00</span><br><span class="line">Flags:               fp asimd evtstrm crc32 cpuid</span><br><span class="line"></span><br><span class="line">pi@raspberrypi:~ $ lsusb</span><br><span class="line">Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub</span><br><span class="line">Bus 001 Device 002: ID 2109:3431 VIA Labs, Inc. Hub</span><br><span class="line">Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub</span><br><span class="line"></span><br><span class="line">pi@raspberrypi:~ $ sudo ifconfig -a</span><br><span class="line">eth0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        ether e4:5f:01:64:3c:12  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 5  bytes 284 (284.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 5  bytes 284 (284.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">wlan0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.137.208  netmask 255.255.255.0  broadcast 192.168.137.255</span><br><span class="line">        inet6 fe80::9ac0:acda:640d:1cf0  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether e4:5f:01:64:3c:14  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 38498  bytes 48445286 (46.2 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 21303  bytes 3907714 (3.7 MiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 树莓派 </tag>
            
            <tag> 配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker安装chevereto图床并解除上传图片大小限制、自定义图片上传用户和相册</title>
      <link href="/posts/36360.html"/>
      <url>/posts/36360.html</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>直接用官方的推荐安装方式，修改后的docker-compose.yaml如下</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mariadb</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">database:/var/lib/mysql:rw</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">private</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">xxx</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">chevereto</span></span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="string">jason</span></span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="string">xxx</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">chevereto:</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nmtan/chevereto</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">private</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">CHEVERETO_DB_HOST:</span> <span class="string">db</span></span><br><span class="line">      <span class="attr">CHEVERETO_DB_USERNAME:</span> <span class="string">jason</span></span><br><span class="line">      <span class="attr">CHEVERETO_DB_PASSWORD:</span> <span class="string">xxx</span></span><br><span class="line">      <span class="attr">CHEVERETO_DB_NAME:</span> <span class="string">chevereto</span></span><br><span class="line">      <span class="attr">CHEVERETO_DB_PREFIX:</span> <span class="string">chv_</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/home/Jason/chv_images:/var/www/html/images:rw</span>  <span class="comment">#将照片存放路径映射到了本地存储中</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span><span class="string">:80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">private:</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">database:</span></span><br><span class="line">  <span class="attr">chevereto_images:</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后<code>docker-compose up -d</code>就可以启动，通过8080端口访问chevereto。</p><h2 id="解除上传图片的大小限制"><a href="#解除上传图片的大小限制" class="headerlink" title="解除上传图片的大小限制"></a>解除上传图片的大小限制</h2><h3 id="复制到服务器本地路径下"><a href="#复制到服务器本地路径下" class="headerlink" title="复制到服务器本地路径下"></a>复制到服务器本地路径下</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">docker cp  containerID:<span class="regexp">/var/</span>www/html/.htaccess /volume1/docker/</span><br></pre></td></tr></table></figure><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /volume1/docker/.htaccess</span><br><span class="line"></span><br><span class="line"># Disable server signature</span><br><span class="line">ServerSignature Off</span><br><span class="line"></span><br><span class="line"># Disable directory listing (-indexes), Multiviews (-MultiViews) and enable Follow system links (+FollowSymLinks)</span><br><span class="line">Options -Indexes</span><br><span class="line">Options -MultiViews</span><br><span class="line"></span><br><span class="line">&lt;IfModule mod_rewrite.c&gt;</span><br><span class="line"></span><br><span class="line">    RewriteEngine On</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    RewriteRule . index.php [L]</span><br><span class="line">    #修改上传文件大小增加以下 配置  最大支持 32M 根据自己情况配置</span><br><span class="line">    php_value post_max_size 64M</span><br><span class="line">    php_value upload_max_filesize 32M</span><br><span class="line"></span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure><h3 id="复制到容器目录里面"><a href="#复制到容器目录里面" class="headerlink" title="复制到容器目录里面"></a>复制到容器目录里面</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">docker cp /volume1/docker/.htaccess containerID:<span class="regexp">/var/</span>www/html/</span><br></pre></td></tr></table></figure><h2 id="修改上传API"><a href="#修改上传API" class="headerlink" title="修改上传API"></a>修改上传API</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp containerID:/var/www/html/app/routes/route.api.php ./</span><br></pre></td></tr></table></figure><p>将PHP文件复制出来，相应位置增加如下代码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$version</span> = <span class="variable">$handler</span>-&gt;request[<span class="number">0</span>];</span><br><span class="line"><span class="variable">$action</span> = <span class="variable">$handler</span>-&gt;request[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增下面两行</span></span><br><span class="line"><span class="variable">$user</span> = <span class="variable">$_REQUEST</span>[<span class="string">&#x27;user&#x27;</span>];</span><br><span class="line"><span class="variable">$album</span> = <span class="variable">$_REQUEST</span>[<span class="string">&#x27;album&#x27;</span>];</span><br></pre></td></tr></table></figure><p>更改如下代码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将这行代码增加 user 和 album 两个参数</span></span><br><span class="line"><span class="variable">$uploaded_id</span> = CHV\Image::uploadToWebsite(<span class="variable">$source</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更改后的代码如下</span></span><br><span class="line"><span class="variable">$uploaded_id</span> = CHV\Image::uploadToWebsite(<span class="variable">$source</span>, <span class="variable">$user</span>, <span class="keyword">array</span>(<span class="string">&#x27;album_id&#x27;</span>=&gt;<span class="variable">$album</span>));</span><br></pre></td></tr></table></figure><p>将修改后的文件复制到容器中替换</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp ./route.api.php  containerID:/var/www/html/app/routes/route.api.php</span><br></pre></td></tr></table></figure><h2 id="配置Typora和PicGo"><a href="#配置Typora和PicGo" class="headerlink" title="配置Typora和PicGo"></a>配置Typora和PicGo</h2><p>在PicGo中下载插件web-uploader，填入如下配置</p><img src="https://images.961110.xyz/images/2021/10/20/image-20211020120134965.png" alt="image-20211020120134965" style="zoom: 50%;" /><ul><li>API地址：http或https(根据自身情况)://域名/api/1/upload</li><li>POST参数名：source</li><li>JSON路径：image.url</li><li>自定义Body：<code>&#123;&quot;key&quot;:&quot;your key&quot;, &quot;user&quot;:&quot;username&quot;, &quot;album&quot;:&quot;albumid&quot;&#125;</code></li></ul><p>key在用户名–&gt;仪表盘–&gt;设置–&gt;API可以找到</p><img src="https://images.961110.xyz/images/2021/10/20/image-20211020120705106.png" alt="image-20211020120705106" style="zoom:50%;" /><p>username就在chevereto网站右上角<img src="https://images.961110.xyz/images/2021/10/20/image-20211020120603290.png" alt="image-20211020120603290"></p><p>albumid在用户的相册详细信息中可以找到。</p><img src="https://images.961110.xyz/images/2021/10/20/image-20211020120843573.png" alt="image-20211020120843573" style="zoom: 50%;" /><p>配置完成后设置为默认图床，进行上传测试。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://blog.csdn.net/qq_25005601/article/details/110532477?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&spm=1001.2101.3001.4242">Typora + PicGo 自动上传图片到 Chevereto 图床_张大炮来巡山-CSDN博客</a></li><li><a href="https://blog.csdn.net/qq_19564393/article/details/108506062">修改Chevereto的API上传相册和用户_飞逝17的博客-CSDN博客</a></li><li><a href="https://blog.csdn.net/weixin_29343153/article/details/113534943">docker修改文件夹权限_群晖通过Docker安装图床工具Chevereto的步骤_藏美者阿远的博客-CSDN博客</a></li><li><a href="https://www.orcy.net.cn/775.html">Docker容器报错处理:AH00558: apache2: Could not reliably determine the server’s fully qualified domain name, using 172.17.0.5. Set the ‘ServerName’ directive globally to suppress this message – 下一朵云 (orcy.net.cn)</a></li><li><a href="https://cloud.tencent.com/developer/article/1645239">群晖Docker安装chevereto图床</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 图床 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lambda表达式</title>
      <link href="/posts/40489.html"/>
      <url>/posts/40489.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h2><p>lambda 表达式有如下的一些优点：</p><ul><li>  声明式的编程风格：就地匿名定义目标函数或函数对象，不需要额外写一个命名函数或函数对象。</li><li>  简洁：避免了代码膨胀和功能分散，让开发更加高效。</li><li>  在需要的时间和地点实现功能闭包，使程序更加灵活。</li></ul><p>lambda 表达式定义了一个匿名函数，并且可以捕获一定范围内的变量。lambda 表达式的语法形式简单归纳如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[capture](params) opt -&gt; ret &#123;body;&#125;;</span><br></pre></td></tr></table></figure><p>其中 <code>capture</code> 是捕获列表，<code>params</code> 是参数列表，<code>opt</code> 是函数选项，<code>ret</code> 是返回值类型，<code>body</code> 是函数体。</p><ol><li>捕获列表 []: 捕获一定范围内的变量</li><li>参数列表 (): 和普通函数的参数列表一样，如果没有参数参数列表可以省略不写。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = []()&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;<span class="comment">// 没有参数, 参数列表为空</span></span><br><span class="line"><span class="keyword">auto</span> f = []&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;<span class="comment">// 没有参数, 参数列表省略不写</span></span><br></pre></td></tr></table></figure></li><li>opt 选项， <code>不需要可以省略</code><ul><li>  mutable: 可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）</li><li>exception: 指定函数抛出的异常，如抛出整数类型的异常，可以使用 throw ();</li></ul></li><li>返回值类型：在 C++11 中，lambda 表达式的返回值是通过返回值后置语法来定义的。</li><li>函数体：函数的实现，这部分不能省略，但函数体可以为空。</li></ol><h2 id="2-捕获列表"><a href="#2-捕获列表" class="headerlink" title="2. 捕获列表"></a>2. 捕获列表</h2><p>lambda 表达式的捕获列表可以捕获一定范围内的变量，具体使用方式如下：</p><ul><li>  <code>[]</code> - 不捕捉任何变量</li><li>  <code>[&amp;]</code> - 捕获外部作用域中所有变量，并作为引用在函数体内使用 (<code>按引用捕获</code>)</li><li><code>[=]</code> - 捕获外部作用域中所有变量，并作为副本在函数体内使用 (<code>按值捕获</code>)<ul><li>  <code>拷贝的副本在匿名函数体内部是只读的</code></li></ul></li><li>  <code>[=, &amp;foo]</code> - 按值捕获外部作用域中所有变量，并按照引用捕获外部变量 foo</li><li>  <code>[bar]</code> - 按值捕获 bar 变量，同时不捕获其他变量</li><li>  <code>[&amp;bar]</code> - 按引用捕获 bar 变量，同时不捕获其他变量</li><li><code>[this]</code> - 捕获当前类中的 this 指针<ul><li>  让 lambda 表达式拥有和当前类成员函数同样的访问权限</li><li>  <strong>如果已经使用了 &amp; 或者 =, 默认添加 this 指针</strong></li></ul></li></ul><p>下面通过一个例子，看一下初始化列表的具体用法：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> x1 = [] &#123;<span class="keyword">return</span> m_number; &#125;;                      <span class="comment">// error，没有捕获外部变量，不能使用类成员 m_number</span></span><br><span class="line">        <span class="keyword">auto</span> x2 = [=] &#123;<span class="keyword">return</span> m_number + x + y; &#125;;             <span class="comment">// ok，以值拷贝的方式捕获所有外部变量</span></span><br><span class="line">        <span class="keyword">auto</span> x3 = [&amp;] &#123;<span class="keyword">return</span> m_number + x + y; &#125;;             <span class="comment">// ok，以引用的方式捕获所有外部变量</span></span><br><span class="line">        <span class="keyword">auto</span> x4 = [<span class="keyword">this</span>] &#123;<span class="keyword">return</span> m_number; &#125;;                  <span class="comment">// ok，捕获 this 指针，可访问对象内部成员</span></span><br><span class="line">        <span class="keyword">auto</span> x5 = [<span class="keyword">this</span>] &#123;<span class="keyword">return</span> m_number + x + y; &#125;;          <span class="comment">// error，捕获 this 指针，可访问类内部成员，没有捕获到变量 x，y，因此不能访问。</span></span><br><span class="line">        <span class="keyword">auto</span> x6 = [<span class="keyword">this</span>, x, y] &#123;<span class="keyword">return</span> m_number + x + y; &#125;;    <span class="comment">// ok，捕获 this 指针，x，y</span></span><br><span class="line">        <span class="keyword">auto</span> x7 = [<span class="keyword">this</span>] &#123;<span class="keyword">return</span> m_number++; &#125;;                <span class="comment">// ok，捕获 this 指针，并且可以修改对象内部变量的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m_number = <span class="number">100</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>在匿名函数内部，需要通过 lambda 表达式的捕获列表控制如何捕获外部变量，以及访问哪些变量。默认状态下 lambda 表达式无法修改通过复制方式捕获外部变量，如果希望修改这些外部变量，需要通过引用的方式进行捕获。</p></blockquote><h2 id="3-返回值"><a href="#3-返回值" class="headerlink" title="3. 返回值"></a>3. 返回值</h2><p>一般情况下，不指定 lambda 表达式的返回值，编译器会根据 return 语句自动推导返回值的类型，但需要注意的是 <code>labmda表达式不能通过列表初始化自动推导出返回值类型。</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ok，可以自动推导出返回值类型</span></span><br><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">int</span> a) -&gt; <span class="keyword">int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+<span class="number">10</span>;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">int</span> a)&#123;</span><br><span class="line">    <span class="keyword">return</span> a+<span class="number">10</span>;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error，不能推导出返回值类型</span></span><br><span class="line"><span class="keyword">auto</span> f1 = []()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;<span class="comment">// 基于列表初始化推导返回值，错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-函数本质"><a href="#4-函数本质" class="headerlink" title="4. 函数本质"></a>4. 函数本质</h2><p>使用 lambda 表达式捕获列表捕获外部变量，如果希望去修改按值捕获的外部变量，那么应该如何处理呢？这就需要使用 mutable 选项，<code>被mutable修改是lambda表达式就算没有参数也要写明参数列表，并且可以去掉按值捕获的外部变量的只读（const）属性。</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f1 = [=] &#123;<span class="keyword">return</span> a++; &#125;;              <span class="comment">// error, 按值捕获外部变量, a是只读的</span></span><br><span class="line"><span class="keyword">auto</span> f2 = [=]()<span class="keyword">mutable</span> &#123;<span class="keyword">return</span> a++; &#125;;     <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>最后再剖析一下为什么通过值拷贝的方式捕获的外部变量是只读的:</p><ol><li> <code>lambda表达式的类型在C++11中会被看做是一个带operator()的类，即仿函数。</code></li><li> <code>按照C++标准，lambda表达式的operator()默认是const的，一个const成员函数是无法修改成员变量值的。</code></li></ol><p>mutable 选项的作用就在于取消 operator () 的 const 属性。</p><p>因为 lambda 表达式在 C++ 中会被看做是一个仿函数，因此<code>可以使用std::function和std::bind来存储和操作lambda表达式</code>：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 包装可调用函数</span></span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>)&gt; f1 = [](<span class="keyword">int</span> a) &#123;<span class="keyword">return</span> a; &#125;;</span><br><span class="line">    <span class="comment">// 绑定可调用函数</span></span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>)&gt; f2 = <span class="built_in">bind</span>([](<span class="keyword">int</span> a) &#123;<span class="keyword">return</span> a; &#125;, placeholders::_1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数调用</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">f1</span>(<span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">f2</span>(<span class="number">200</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于没有捕获任何变量的 lambda 表达式，还可以转换成一个普通的函数指针：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> func_ptr = <span class="built_in"><span class="keyword">int</span></span>(*)(<span class="keyword">int</span>);</span><br><span class="line"><span class="comment">// 没有捕获任何外部变量的匿名函数</span></span><br><span class="line">func_ptr f = [](<span class="keyword">int</span> a)&#123;</span><br><span class="line">    <span class="keyword">return</span> a;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 函数调用</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">1314</span>);</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://subingwen.cn/cpp/lambda/">Lambda表达式 | 爱编程的大丙 (subingwen.cn)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> C++ </tag>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux进程管理</title>
      <link href="/posts/25357.html"/>
      <url>/posts/25357.html</url>
      
        <content type="html"><![CDATA[<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h3><p><img src="https://images.961110.xyz/images/2021/10/20/Linux0.12.png" alt="Linux0.12创建进程的流程"></p><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p><img src="https://images.961110.xyz/images/2021/10/20/Linux0.1211029ed5dd197bbc.png" alt="Linux0.12进程调度流程图"></p><h3 id="退出进程"><a href="#退出进程" class="headerlink" title="退出进程"></a>退出进程</h3><p><img src="https://images.961110.xyz/images/2021/10/20/exit.c.png" alt="Linux0.12退出进程流程图"></p><p>退出进程</p><h2 id="进程0和进程1"><a href="#进程0和进程1" class="headerlink" title="进程0和进程1"></a>进程0和进程1</h2><h3 id="进程-0"><a href="#进程-0" class="headerlink" title="进程 0"></a>进程 0</h3><p> 首先，进程 0 也叫做空闲进程，是一个内核进程，它的主要作用是进入一个死循环，为了解决 cpu 空闲时刻的问题，所做的工作就是在 cpu 空闲时给 cpu 一个死循环从而使 cpu 工作。特殊性在于它是系统创建的第一个进程。</p><h3 id="进程-1"><a href="#进程-1" class="headerlink" title="进程 1"></a>进程 1</h3><p>进程 1 也叫做 init 进程，开始时它在内核态所做的工作就是挂载根文件系统，将根文件系统挂载上之后，进行一系列的环境配置，最后创建用户交互 shell环境</p><p> 进程 1 的最主要的作用就是对操作系统来说，其他所有的用户进程都是由进程 1 直接或间接创建的，也就是说所有的用户进程都是进程 1 的子孙进程。</p><h2 id="孤儿进程、孤儿进程组、僵尸进程"><a href="#孤儿进程、孤儿进程组、僵尸进程" class="headerlink" title="孤儿进程、孤儿进程组、僵尸进程"></a>孤儿进程、孤儿进程组、僵尸进程</h2><h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p>其父进程已经终止的进程。但是它会被 init 进程 “收养”，init 进程 ID 为 1，因此被收养的孤儿进程的父进程会更新为 1。</p><h3 id="孤儿进程组"><a href="#孤儿进程组" class="headerlink" title="孤儿进程组"></a>孤儿进程组</h3><p>一个进程组中的所有进程的父进程要么是该进程组的一个进程，要么不是该进程组所在的会话中的进程。 一个进程组不是孤儿进程组的条件是，该组中有一个进程其父进程在属于同一个会话的另一个组中。</p><p>一个进程组到其组外的父进程之间的联系依赖于该父进程和其子进程两者，所以会有两种产生孤儿进程组的情况：</p><ol><li>父进程终止</li><li>子进程终止</li></ol><p>在任何一种情況下，如果进程的终止导致进程组变成孤儿进程组，那么进程组中的所有进程就会与它们的作业控制 shell 断开联系，作业控制 shell 将不再具有该进程组存在的任何信息。而该进程组中处于停止状态的进程将会永远消失。为了解决这个问题，含有停止状态进程的新近产生的孤儿进程组就需要接收到一个SIGHIUP信号和一个SIGCONT信号，用于指示它们已经从它们的会话（session）中断开联系。SIGHUP信号将导致进程组中成员被终止，除非它们捕获或忽略了SIGHUP信号。而SIGCONT信号将使那些没有被SIGHUP信号终止的进程继续运行。但在大多数情況下，如果组中有一个进程处于停止状态，那么组中所有的进程可能都处于停止状态。</p><h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p>子进程先于父进程退出，而父进程并没有调用 wait 或 waitpid 获取子进程的状态信息并释放子进程资源，那么其的进程描述符仍然保存在系统中。</p><h2 id="进程、进程组、会话、前台进程组、后台进程组"><a href="#进程、进程组、会话、前台进程组、后台进程组" class="headerlink" title="进程、进程组、会话、前台进程组、后台进程组"></a>进程、进程组、会话、前台进程组、后台进程组</h2><h3 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h3><p>一个或者多个进程的集合。</p><p>每个进程组都有一个唯一的进程组标识号gid，一个称为组长的进程，gid等于组长进程的pid。</p><h3 id="会话（Session）"><a href="#会话（Session）" class="headerlink" title="会话（Session）"></a>会话（Session）</h3><p>一个或多个进程组的集合。</p><p>通常情况下，用户登录后所执行的所有程序都属于一个会话期，而其登录 shell 则是<strong>会话首进程</strong>，并且它所使用的终端就是会话期的控制终端，因此会话期首进程通常也被称为<strong>控制进程</strong>。当用户退出登录时，所有属于这个会话期的进程都将被终止。</p><h3 id="前台进程组"><a href="#前台进程组" class="headerlink" title="前台进程组"></a>前台进程组</h3><p>会话中拥有控制终端的一个进程组。</p><h3 id="后台进程组"><a href="#后台进程组" class="headerlink" title="后台进程组"></a>后台进程组</h3><p>会话期中除前台进程组外的其他进程组。</p><p><img src="https://images.961110.xyz/images/2021/10/20/Untitled.png" alt="进程、进程组和会话期之间的关系"></p><p>进程、进程组和会话期之间的关系</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 任务(进程)数据结构，或称为进程描述符 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line"><span class="comment">/* these are hardcoded - don&#x27;t touch */</span></span><br><span class="line"><span class="comment">/* 硬编码字段 */</span></span><br><span class="line"><span class="keyword">long</span> state;<span class="comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span></span><br><span class="line"><span class="comment">/* 任务运行状态 -1 不可运行，0 可运行(就绪)， &gt;0 已停止 */</span></span><br><span class="line"><span class="keyword">long</span> counter;<span class="comment">/* 任务运行时间计数(递减)(滴答数)，运行时间片 */</span></span><br><span class="line"><span class="keyword">long</span> priority;<span class="comment">/* 优先级 */</span></span><br><span class="line"><span class="keyword">long</span> signal;<span class="comment">/* 信号位图 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sigaction</span>[32];</span><span class="comment">/* 信号执行属性结构,对应信号将要执行的操作和标志信息 */</span></span><br><span class="line"><span class="keyword">long</span> blocked;<span class="comment">/* 进程信号屏蔽码(对应信号位图) */</span> <span class="comment">/* bitmap of masked signals */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* various fields */</span></span><br><span class="line"><span class="comment">/* 可变字段 */</span></span><br><span class="line"><span class="keyword">int</span> exit_code;<span class="comment">/* 退出码 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> start_code;<span class="comment">/* 代码段地址 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> end_code;<span class="comment">/* 代码段长度（字节数） */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> end_data;<span class="comment">/* 代码段加数据段的长度 （字节数）*/</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> brk;<span class="comment">/* 总长度(字节数) */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> start_stack;<span class="comment">/* 堆栈段地址 */</span></span><br><span class="line"><span class="keyword">long</span> pid;<span class="comment">/* 进程标识号(进程号) */</span></span><br><span class="line"><span class="keyword">long</span> pgrp;<span class="comment">/* 进程组号 */</span></span><br><span class="line"><span class="keyword">long</span> session;<span class="comment">/* 会话号 */</span></span><br><span class="line"><span class="keyword">long</span> leader;<span class="comment">/* 会话首领 */</span></span><br><span class="line"><span class="keyword">int</span>groups[NGROUPS];<span class="comment">/* 进程所属组号（一个进程可属于多个组） */</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * pointers to parent process, youngest child, younger sibling,</span></span><br><span class="line"><span class="comment"> * older sibling, respectively.  (p-&gt;father can be replaced with </span></span><br><span class="line"><span class="comment"> * p-&gt;p_pptr-&gt;pid)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p_pptr</span>;</span><span class="comment">/* 指向父进程的指针 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p_cptr</span>;</span><span class="comment">/* 指向最新子进程的指针 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p_ysptr</span>;</span><span class="comment">/* 指向比自己后创建的相邻进程的指针 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p_osptr</span>;</span><span class="comment">/* 指向比自己早创建的相邻进程的指针 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> uid;<span class="comment">/* 用户id */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> euid;<span class="comment">/* 有效用户id */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> suid;<span class="comment">/* 保存的设置用户id */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> gid;<span class="comment">/* 组id */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> egid;<span class="comment">/* 有效组id */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> sgid;<span class="comment">/* 保存的设置组id */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> timeout;<span class="comment">/* 内核定时超时值 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> alarm;<span class="comment">/* 报警定时值(滴答数) */</span></span><br><span class="line"><span class="keyword">long</span> utime;<span class="comment">/* 用户态运行时间(滴答数) */</span></span><br><span class="line"><span class="keyword">long</span> stime;<span class="comment">/* 内核态运行时间(滴答数) */</span></span><br><span class="line"><span class="keyword">long</span> cutime;<span class="comment">/* 子进程用户态运行时间 */</span></span><br><span class="line"><span class="keyword">long</span> cstime;<span class="comment">/* 子进程内核态运行时间 */</span></span><br><span class="line"><span class="keyword">long</span> start_time;<span class="comment">/* 进程开始运行时刻 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rlim</span>[<span class="title">RLIM_NLIMITS</span>];</span><span class="comment">/* 进程资源使用统计数组 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> flags;<span class="comment">/* 各进程的标志，还未使用*/</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> used_math;<span class="comment">/* 是否使用了协处理器的标志 */</span></span><br><span class="line"><span class="comment">/* file system info */</span></span><br><span class="line"><span class="keyword">int</span> tty;<span class="comment">/* -1 if no tty, so it must be signed */</span></span><br><span class="line"><span class="comment">/* 进程使用tty终端的子设备号。-1表示没有使用 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> umask;<span class="comment">/* 文件创建属性屏蔽位 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">pwd</span>;</span><span class="comment">/* 当前工作目录i节点结构指针 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">root</span>;</span><span class="comment">/* 根目录i节点结构指针 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">executable</span>;</span><span class="comment">/* 执行文件i节点结构指针 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">library</span>;</span><span class="comment">/* 被加载库文件i节点结构指针 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> close_on_exec;<span class="comment">/* 执行时关闭文件句柄位图标志 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">filp</span>[<span class="title">NR_OPEN</span>];</span><span class="comment">/* 文件结构指针表，最多32项。表项号即是文件描述符的值 */</span></span><br><span class="line"><span class="comment">/* ldt for this task 0 - zero 1 - cs 2 - ds&amp;ss */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> <span class="title">ldt</span>[3];</span><span class="comment">/* 局部描述符表, 0 - 空，1 - 代码段cs，2 - 数据和堆栈段ds&amp;ss */</span></span><br><span class="line"><span class="comment">/* tss for this task */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tss_struct</span> <span class="title">tss</span>;</span><span class="comment">/* 进程的任务状态段信息结构 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">任务状态</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_RUNNING0<span class="comment">/* 任务正在运行或已准备就绪 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_INTERRUPTIBLE1<span class="comment">/* 任务处于可中断等待状态 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_UNINTERRUPTIBLE2<span class="comment">/* 任务处于不可中断等待状态 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_ZOMBIE3<span class="comment">/* 任务处于僵死状态，已经停止，但父进程还没发出信号 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_STOPPED4<span class="comment">/* 任务已停止 */</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGHUP 1<span class="comment">/* Hang Up-- 挂起控制终端或进程 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGINT 2<span class="comment">/* Interrupt -- 来自键盘的中断 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGQUIT 3<span class="comment">/* Quit-- 来自键盘的退出 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGILL 4<span class="comment">/* Illeagle-- 非法指令 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGTRAP 5<span class="comment">/* Trap -- 跟踪断点 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGABRT 6<span class="comment">/* Abort-- 异常结束 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGIOT 6<span class="comment">/* IO Trap-- 同上 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGUNUSED 7<span class="comment">/* Unused-- 没有使用 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGFPE 8<span class="comment">/* FPE-- 协处理器出错 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGKILL 9<span class="comment">/* Kill-- 强迫进程终止 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGUSR110<span class="comment">/* User1-- 用户信号 1，进程可使用 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGSEGV11<span class="comment">/* Segment Violation -- 无效内存引用 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGUSR212<span class="comment">/* User2    -- 用户信号 2，进程可使用 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGPIPE13<span class="comment">/* Pipe-- 管道写出错，无读者 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGALRM14<span class="comment">/* Alarm-- 实时定时器报警 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGTERM15<span class="comment">/* Terminate -- 进程终止 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGSTKFLT16<span class="comment">/* Stack Fault -- 栈出错（协处理器） */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGCHLD17<span class="comment">/* Child-- 子进程停止或被终止 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGCONT18<span class="comment">/* Continue-- 恢复进程继续执行 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGSTOP19<span class="comment">/* Stop-- 停止进程的执行 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGTSTP20<span class="comment">/* TTY Stop-- tty 发出停止进程，可忽略 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGTTIN21<span class="comment">/* TTY In-- 后台进程请求输入 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGTTOU22<span class="comment">/* TTY Out-- 后台进程请求输出 */</span></span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://blog.csdn.net/qq_29503203/article/details/54618275">https://blog.csdn.net/qq_29503203/article/details/54618275</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 进程管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《智能网联汽车技术》读书笔记</title>
      <link href="/posts/29265.html"/>
      <url>/posts/29265.html</url>
      
        <content type="html"><![CDATA[<h3 id="第一章-智能网联汽车概述"><a href="#第一章-智能网联汽车概述" class="headerlink" title="第一章 智能网联汽车概述"></a>第一章 智能网联汽车概述</h3><p>这一章主要讲了智能网联汽车的一些基本概念、分级以及分阶段的发展目标。</p><h3 id="第二章-中国智能网联汽车发展及标准法规演变趋势"><a href="#第二章-中国智能网联汽车发展及标准法规演变趋势" class="headerlink" title="第二章 中国智能网联汽车发展及标准法规演变趋势"></a>第二章 中国智能网联汽车发展及标准法规演变趋势</h3><p>这一章主要介绍了智能网联汽车的发展路线，产业生态、主机厂、用户接受度的发展趋势，各企业的布局，国内外的系列政策。</p><h3 id="第三章-智能网联汽车产业链及商业模式"><a href="#第三章-智能网联汽车产业链及商业模式" class="headerlink" title="第三章 智能网联汽车产业链及商业模式"></a>第三章 智能网联汽车产业链及商业模式</h3><p>这一章主要介绍了智能网联汽车产业链、价值链、商业化技术服务和商业模式。</p><h3 id="第四章-驾驶场景数据技术"><a href="#第四章-驾驶场景数据技术" class="headerlink" title="第四章 驾驶场景数据技术"></a>第四章 驾驶场景数据技术</h3><p>这一张主要介绍了驾驶场景数据的采集、分类、处理、存储和应用的一系列流程，以及所用到的硬件设备的标定方法。</p><h3 id="第五章-驾驶场景虚拟仿真技术"><a href="#第五章-驾驶场景虚拟仿真技术" class="headerlink" title="第五章 驾驶场景虚拟仿真技术"></a>第五章 驾驶场景虚拟仿真技术</h3><p>这一章主要介绍了仿真测试系统、仿真平台、仿真数据体系、虚拟试验场建设、仿真测试工具和仿真验证与评价。</p><h3 id="第六章-自动驾驶感知融合算法实现与应用"><a href="#第六章-自动驾驶感知融合算法实现与应用" class="headerlink" title="第六章 自动驾驶感知融合算法实现与应用"></a>第六章 自动驾驶感知融合算法实现与应用</h3><p>这一章主要介绍了自动驾驶的相关算法，包括感知、融合、算法验证等，以及会用到的硬件设备，比如激光雷达、毫米波雷达、超声波雷达、摄像头等。</p><h3 id="第七章-自动驾驶工程技术验证与实现"><a href="#第七章-自动驾驶工程技术验证与实现" class="headerlink" title="第七章 自动驾驶工程技术验证与实现"></a>第七章 自动驾驶工程技术验证与实现</h3><p>这一章主要介绍了工程验证的关键技术包括环境感知、决策规划的相关技术，以及车辆改装、功能实现方法和软硬件发展思路。</p><p><img src="https://images.961110.xyz/images/2021/10/20/6a4a580a242f4d97ebe64463412dc677.png" alt="《智能网联汽车技术》关键技术点"></p><p>《智能网联汽车技术》关键技术点</p>]]></content>
      
      
      <categories>
          
          <category> 智能网联汽车 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 智能网联汽车 </tag>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核模块</title>
      <link href="/posts/62642.html"/>
      <url>/posts/62642.html</url>
      
        <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>Linux的内核模块机制允许开发者动态的向内核添加功能，常见的文件系统、驱动程序等都可以通过模块的方式添加到内核而无需对内核重新编译，这在很大程度上减少了操作的复杂度。</p><p>模块机制使内核预编译时不必包含很多无关功能，把内核做到最精简，后期可以根据需要进行添加。针对驱动程序，因为涉及到具体的硬件，很难使通用的，且其中可能包含了各个厂商的私密接口，厂商几乎不会允许开发者把源代码公开，模块机制很好的解决了这个冲突。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>使用模块的优点：</p><ol><li>使得内核更加紧凑和灵活</li><li>修改内核时，不必全部重新编译整个内核，可节省不少时间，避免人工操作的错误。系统中如果需要使用新模块，只要编译相应的模块然后使用特定用户空间的程序将模块插入即可。</li><li>模块可以不依赖于某个固定的硬件平台。</li><li>模块的目标代码一旦被链接到内核，它的作用和静态链接的内核目标代码完全等价。 所以，当调用模块的函数时，无须显式的消息传递。</li></ol><p>缺点：</p><ol><li>由于模块所占用的内存是不会被换出的，所以链接进内核的模块会给整个系统带来一定的性能和内存利用方面的损失。</li><li>装入内核的模块就成为内核的一部分，可以修改内核中的其他部分，因此，模块的使用不当会导致系统崩溃。</li><li>为了让内核模块能访问所有内核资源，内核必须维护符号表，并在装入和卸载模块时修改符号表。</li><li>模块会要求利用其它模块的功能，所以，内核要维护模块之间的依赖性。</li></ol><h3 id="内核符号表"><a href="#内核符号表" class="headerlink" title="内核符号表"></a>内核符号表</h3><p>内核符号表是一个用来存放所有模块可以访问的那些符号以及相应地址的特殊的表。模块的连接就是将模块插入到内核的过程。模块所声明的任何全局符号都成为内核符号表的一部分。内核模块根据系统符号表从内核空间中获取符号的地址，从而确保在内核空间中正确地运行。存放路径：<code>/proc/kallsyms</code></p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h3><ol><li><p>模块装载到内核中，首先调用初始化函数<code>proc_module_init()</code><br>打印初始化提示信息；</p></li><li><p>在查看<code>proc_info</code>文件之前，如右图可见文件是空的，说明代码里的<code>proc_info_show()</code>是在文件被查看时调用的；</p></li><li><p><code>proc_info_show()</code>在执行时首先打印提示信息，然后通过<code>seq_printf()</code>函数分别写入内核版本号和进程数；</p><p>内核版本号保存在结构体ustname中，可以直接调用，proc下verison也是</p></li><li><p>模块卸载的时候，调用出口函数<code>proc_module_exit()</code>，打印退出提示信息。</p></li></ol><p><img src="https://images.961110.xyz/images/2021/10/20/proc_info.png" alt="proc_info文件内容为空"></p><p><img src="https://images.961110.xyz/images/2021/10/20/proc_info69158ed329c16d70.png" alt="proc_info文件里的内容"></p><h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><p><code>create_proc_entry()</code>这个函数在3.x或4.x的时候已经被弃用，用<code>proc_create()</code>代替即可。</p><p><img src="https://images.961110.xyz/images/2021/10/20/my_module.png" alt="my_module模块编译出错"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">proc_dir = proc_mkdir(<span class="string">&quot;my_proc&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">proc_info = proc_create(<span class="string">&quot;proc_info&quot;</span>, <span class="number">0644</span>, proc_dir, &amp;proc_module_fops);</span><br></pre></td></tr></table></figure><h2 id="size-t"><a href="#size-t" class="headerlink" title="size_t"></a>size_t</h2><p>size_t的提出主要是为了解决可移植性问题，方便在处理器位数不同的平台使用。</p><p>size_t一般用来计数，代表C中任何对象所能达到的最大长度，比如：</p><ol><li><code>void *malloc(size_t n);</code> </li><li><code>void *memcpy(void *s1, void const *s2, size_t n);</code></li><li><code>size_t strlen(char const *s);</code></li></ol><p>习惯性地用<code>int</code>类型肯定是有问题的，因为<code>int</code>是带符号的，而且并不一定能覆盖到对象的最大长度。</p><p>int类型对应平台的大小是这样的：</p><ul><li>16位系统中，int型为16位大小，2字节</li><li>32位系统中，int型为32位大小，4字节</li><li>64位系统中，int型为32位大小，4字节</li></ul><p>long类型对应平台的大小是这样的：</p><ul><li>16位系统中，long型为32位大小，4字节</li><li>32位系统中，long型为32位大小，4字节</li><li>64位系统中，long型为64位大小，8字节</li></ul><p>因此猜想size_t在16位架构上应该是2字节，32位架构上是4字节，在64位架构上是8字节。</p><p>size_t在32位架构中被定义为<code>typedef unsigned int size_t;</code>而在64位架构中被定义为<code>typedef unsigned long size_t;</code>符合猜想，16位架构中的定义可能也是<code>typedef unsigned int size_t;</code></p><h2 id="seq-file-操作函数"><a href="#seq-file-操作函数" class="headerlink" title="seq_file 操作函数"></a>seq_file 操作函数</h2><p><code>seq_file</code> 系列函数是为了方便内核导出信息到 sysfs、debugfs、procfs 实现的。简化了文件操作的实现，内部维护缓冲区，内部的当前位置，不用驱动开发者自己实现缓冲区操作，对于驱动开发人员只需要实现相关的数据操作函数回调即可。<br>它包含了如下一些接口：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seq_open</span><span class="params">(struct file *file, <span class="keyword">const</span> struct seq_operations *op)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seq_release</span><span class="params">(struct inode *inode, struct file *file)</span></span>;</span><br><span class="line"><span class="comment">//seq_read 操作是系列函数中最为重要的一个函数，它负责从内部buffer缓冲区中读取数据并 copy_to_user 返回给应用层</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">seq_read</span><span class="params">(struct file *file, <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> size, <span class="keyword">loff_t</span> *ppos)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seq_write</span><span class="params">(struct seq_file *seq, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">loff_t</span> <span class="title">seq_lseek</span><span class="params">(struct file *file, <span class="keyword">loff_t</span> offset, <span class="keyword">int</span> whence)</span>；</span></span><br></pre></td></tr></table></figure><p>在实验过程中就是通过封装好的函数，把内核版本号和进程数写到proc文件里的。</p><h2 id="Linux内核模块参数传递及函数调用"><a href="#Linux内核模块参数传递及函数调用" class="headerlink" title="Linux内核模块参数传递及函数调用"></a>Linux内核模块参数传递及函数调用</h2><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>模块的参数传递也是一个宏，定义在<code>linux/moduleparam.h</code>中，type支持<code>byte, short, ushort,int, uint, long, ulong, bool</code></p><ul><li><p>单个参数传递<code>moudle_param(name,type,perm)</code></p></li><li><p>参数组传递<code>module_param_array(name, type, nump, perm)</code></p><p><strong><code>name</code>数组必须静态分配</strong></p></li><li><p>源文件内外参数名可以不同：<br><code>module_param_named(name, variable, type, perm)</code></p><p>  其中<code>name</code>是外部可见的参数名，<code>variable</code>是源文件内部的全局变量名</p></li><li><p>另一种字符串传递方法<code>module_param_string(name, string, len, perm)</code><br>name是外部的参数名，string是内部的变量名，len是以string命名的buffer大小（可以小于buffer的大小，但是没有意义）。</p></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *msg;</span><br><span class="line">module_param(msg, charp, <span class="number">0644</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> para[<span class="number">8</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> n_para = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> species[BUF_LEN]；</span><br><span class="line">module_param_string(specifies, species, BUF_LEN, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">module_param_array(para , <span class="keyword">int</span> , &amp;n_para , S_IRUGO);</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">module_init</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">module_exit</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在装载模块时指定参数即可</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sudo insmod <span class="keyword">module</span>.ko msg=<span class="string">&quot;test&quot;</span> para=<span class="number">4</span>，<span class="number">5</span>，<span class="number">6</span>，<span class="number">1</span>，<span class="number">8</span> specifies=<span class="string">&quot;test_string&quot;</span></span><br></pre></td></tr></table></figure><h3 id="模块间函数调用"><a href="#模块间函数调用" class="headerlink" title="模块间函数调用"></a>模块间函数调用</h3><p>模块的函数导出到符号表才可以供其他函数使用，需要用到宏：<code>EXPORT_SYMBOL(sym)</code>，该宏在<code>linux/export.h</code>里面。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fun1.c</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;fun() is called\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">EXPORT_SYMBOL(fun);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fun2.c</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;fun_1.h&quot;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mod_init</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;mod_init() start\n&quot;</span>);</span><br><span class="line">    fun();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fun_1.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> KERNEL_FUN_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNEL_FUN_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><img src="https://images.961110.xyz/images/2021/10/20/45bb76418d7ff50f34511fb7e26d23a3.png" alt="实验结果"></p><p>根据日志可以看出，被调用的函数已经打印出了提示信息。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><p>两个不同的模块不能导出相同的的函数，否则会在装载模块的时候报错。</p><p>在<code>/proc/kallsyms</code> 文件中保存对应着内核符号表，它记录了符号以及符号所在的内存地址，所以不能导出相同的函数。</p></li></ol><p><img src="https://images.961110.xyz/images/2021/10/20/79d0e8fb90a66cdebe819d07db6b492a.png" alt="导出相同函数报错"></p><p>导出相同函数报错</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核裁剪</title>
      <link href="/posts/2771.html"/>
      <url>/posts/2771.html</url>
      
        <content type="html"><![CDATA[<h3 id="Kconfig和menuconfig文件"><a href="#Kconfig和menuconfig文件" class="headerlink" title="Kconfig和menuconfig文件"></a>Kconfig和menuconfig文件</h3><p>内核源码的每一级目录下都会有 <strong>Kconfig</strong> 文件，文件里的<code>menu</code>对应<code>make menuconfig</code>中的菜单项，菜单中包含若干子选项，由 <code>source</code>引入各级子目录下的 <code>Kconfig</code>文件，由此构成了<code>menuconfig</code>。</p><p><img src="https://images.961110.xyz/images/2021/10/20/Kconfigmenuconfig.png" alt="Kconfig和menuconfig文件.png"></p><p>每一个子选项在代码中对应的是一个个的<code>config</code></p><p>其中选项中<code>bool</code>代表二选一(编译、不编译)</p><p><code>trastate</code>代表三选一(编译、不编译、编译成模块)</p><p><code>depends on</code>代表其依赖的配置。</p><p><img src="https://images.961110.xyz/images/2021/10/20/config.png" alt="config的构成.png"></p><h3 id="config文件"><a href="#config文件" class="headerlink" title=".config文件"></a>.config文件</h3><p><code>menuconfig</code>又会生成源码根目录下的<code>.config</code>文件，由各个<code>Kconfig</code>中的<code>config</code>宏定义构成。</p><h3 id="makefile文件"><a href="#makefile文件" class="headerlink" title="makefile文件"></a>makefile文件</h3><p>编译内核依赖的makefile文件会根据<code>.config</code>文件来决定是否将对应部分编译进内核。</p><h3 id="四者的关系图如下"><a href="#四者的关系图如下" class="headerlink" title="四者的关系图如下"></a>四者的关系图如下</h3><p><img src="https://images.961110.xyz/images/2021/10/20/menuconfig-Kconfig-.config-makefile.png" alt="menuconfig相关文件的关系"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 内核裁剪 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM目标代码优化</title>
      <link href="/posts/64925.html"/>
      <url>/posts/64925.html</url>
      
        <content type="html"><![CDATA[<h2 id="速度优化"><a href="#速度优化" class="headerlink" title="速度优化"></a>速度优化</h2><h3 id="通用优化方法"><a href="#通用优化方法" class="headerlink" title="通用优化方法"></a>通用优化方法</h3><p><strong>减少计算强度</strong></p><ol><li>左右位移代替乘除2运算: <code>i = i * 5 = (i &lt;&lt; 2) + 1</code> ，位移有桶形位移器，执行比乘除快。</li><li>乘法代替乘方运算: <code>i = pow(i, 3) = i * i * i</code>，ARM中有乘法器，所以比调用函数更快。</li><li>与运算代替求余运算: <code>i = i % 8 = i &amp; 0x07</code>，ARM中没有求余指令，但是有与指令。</li></ol><p><strong>优化循环终止条件</strong></p><p>使用减计数代替惯用的加计数，使用<code>i != 0</code>作循环终止条件。加法计数在循环判断的时候是用CMP和BLE实现的，而用<code>i != 0</code>可以用BNE一条指令代替。</p><p><strong>使用<code>inline</code>函数</strong></p><p><code>inline</code>函数主要节省了调用函数所占用的时间。缺点就是被频繁调用时，代码量将增大，以空间换时间。</p><p><strong>利用已有结果</strong></p><p><code>tmp = a * b;</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i = a * b + c;</span><br><span class="line">j = a * b * d;</span><br></pre></td></tr></table></figure><p><strong>避免循环</strong></p><p>拆开小循环</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">x[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">x[<span class="number">0</span>] = <span class="number">0</span>; x[<span class="number">1</span>] = <span class="number">1</span>; x[<span class="number">2</span>] = <span class="number">2</span>;...;x[<span class="number">9</span>] = <span class="number">9</span>;</span><br></pre></td></tr></table></figure><h3 id="处理器相关的优化方法"><a href="#处理器相关的优化方法" class="headerlink" title="处理器相关的优化方法"></a>处理器相关的优化方法</h3><p><strong>保持流水线畅通</strong></p><p>将循环拆解来<strong>减小跳转指令在循环指令中所占的比重。</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memcopy</span><span class="params">(<span class="keyword">char</span> *to, <span class="keyword">char</span> *from, <span class="keyword">unsigned</span> <span class="keyword">int</span> nbytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p_to = (<span class="keyword">int</span> *)to;</span><br><span class="line"><span class="keyword">int</span> *p_from = (<span class="keyword">int</span> *)from;</span><br><span class="line"><span class="keyword">while</span>(nbytes) &#123;</span><br><span class="line">*p_to++ = *p_from++;</span><br><span class="line">*p_to++ = *p_from++;</span><br><span class="line">*p_to++ = *p_from++;</span><br><span class="line">*p_to++ = *p_from++;</span><br><span class="line">nbytes - = <span class="number">16</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过优化后，一次循环可以处理16 个字节。</p><p><strong>使用寄存器变量</strong></p><p>整型、指针、浮点等类型的变量都可以分配寄存器；一个结构的部分或者全部也可以分配寄存器。给循环体中需要频繁访问的变量分配寄存器也能在一定程度上提高程序效率。</p><h3 id="指令集相关的优化方法"><a href="#指令集相关的优化方法" class="headerlink" title="指令集相关的优化方法"></a>指令集相关的优化方法</h3><p><strong>避免除法</strong></p><p>ARM7 指令集中没有除法指令，其除法是通过调用 C 库函数实现的。一个32 位的除法通常需要20~140 个时钟周期。</p><ul><li>例如<code>if((x/y) &gt; z)</code>可变通为<code>if(x &gt; (y × z))</code></li><li>在能满足精度，且存储器空间冗余的情况下， 也可考虑使用查表法代替除法。</li><li>当除数为2 的幂次方时， 应用移位操作代替除法。</li></ul><p><strong>在后来支持硬件除法的芯片（Cortex-M3）中，用<code>SDIV</code>指令代替了库函数的调用。</strong></p><p><strong>利用条件执行</strong></p><p>ARM 指令集的一个重要特征就是<strong>所有的指令均可包含一个可选的条件码</strong>。当程序状态寄存器(PSR)中的条件码标志满足指定条件时，指令才能执行，因此可以省去单独的判断指令。</p><p><strong>使用合适的变量类型</strong></p><p>在操作char、short型的ARM局部变量，往往比操作32 位变量需要更多指令，所以应该尽可能地避免使用。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wordinc</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">ADD a1,a1,#<span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> a + <span class="number">1</span>; MOV pc,lr</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">short</span> <span class="title">shortinc</span><span class="params">(<span class="keyword">short</span> a)</span> </span>&#123;</span><br><span class="line">ADD a1,a1,#<span class="number">1</span></span><br><span class="line">MOV a1,a1,LSL #<span class="number">16</span></span><br><span class="line"><span class="keyword">return</span> a + <span class="number">1</span>; MOV a1,a1,ASR #<span class="number">16</span>ARM</span><br><span class="line">&#125; MOV pc,<span class="function">lr</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">charinc</span><span class="params">(<span class="keyword">char</span> a)</span></span>&#123;</span><br><span class="line">ADD a1,a1,#<span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> a + <span class="number">1</span>; </span><br><span class="line">AND a1,a1,#&amp;ff</span><br><span class="line">&#125; MOV pc,lr</span><br></pre></td></tr></table></figure><h3 id="存储器相关的优化方法"><a href="#存储器相关的优化方法" class="headerlink" title="存储器相关的优化方法"></a>存储器相关的优化方法</h3><p><strong>用查表代替计算</strong></p><p>用空间换速度：例如需要频繁计算正弦或余弦函数值时，可预先将函数值计算出来置于内存中供以后ARM查找。</p><p><strong>充分利用片内RAM</strong></p><p>一些厂商出产的ARM 芯片内集成有一定容量的RAM，处理器对片内RAM 的访问速度要快于对外部RAM 的访问。</p><h3 id="编译器相关的优化方法"><a href="#编译器相关的优化方法" class="headerlink" title="编译器相关的优化方法"></a>编译器相关的优化方法</h3><p>根据编译器提供的优化选项进行设置。多数编译器都支持对程序速度和程序大小的优化，有些编译器还允许用户选择可供优化的内容及优化的程度。</p><h2 id="尺寸优化"><a href="#尺寸优化" class="headerlink" title="尺寸优化"></a>尺寸优化</h2><h3 id="使用多寄存器操作指令"><a href="#使用多寄存器操作指令" class="headerlink" title="使用多寄存器操作指令"></a>使用多寄存器操作指令</h3><p>ARM 指令集中的多寄存器操作指令LDM/STM 可以加载/ 存储多个寄存器，这在保存/ 恢复寄存器组的状态及进行大块数据复制时非常有效。例如要将寄存器R4~R12 及R14 的内容保存到堆栈中，若用<code>STR</code> 指令共需要10 条，而一条<code>STMEA R13!, &#123;R4 ?? R12, R14&#125;</code> 指令就能达到相同的目的，虽然在执行速度上不一定有提高。</p><h3 id="合理安排变量顺序"><a href="#合理安排变量顺序" class="headerlink" title="合理安排变量顺序"></a>合理安排变量顺序</h3><p>ARM程序中的32 位/16 位变量必须按字/ 半字对齐</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>  i1 ~ i4;</span><br><span class="line"><span class="keyword">char</span> c1 ~ c4;</span><br><span class="line"></span><br><span class="line">按照i1、c1、i2、c2、i3、c3、i4、c4的顺序排列的话，<span class="number">8</span>位的<span class="keyword">char</span>型变量实际上占用的是一个<span class="number">32</span>位寄存器，空间浪费</span><br><span class="line">所以应将 <span class="keyword">int</span> 型变量和 <span class="keyword">char</span> 型变量按类似i1、i2、i3、i4、c1、c2、c3、c4 的顺序连续存放。</span><br></pre></td></tr></table></figure><h3 id="使用Thumb指令"><a href="#使用Thumb指令" class="headerlink" title="使用Thumb指令"></a>使用Thumb指令</h3><p>16 位的 Thumb 指令是ARM 体系结构的扩充。Thumb 指令集是大多数常用32 位ARM 指令压缩成16 位宽指令的集合。</p>]]></content>
      
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> ARM </tag>
            
            <tag> 代码优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>租房注意事项</title>
      <link href="/posts/40489.html"/>
      <url>/posts/40489.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、重中之重"><a href="#一、重中之重" class="headerlink" title="一、重中之重"></a>一、重中之重</h2><ol><li>租 转租房一定要三方（你、转租人、房东）都在场，最好直接跟房东签协议。</li><li>房东、二房东的身份证复印件和房本要留底，可以写仅供租房使用。</li><li>不租隔断间，敲墙听音；</li><li>下面所有细节都要在合同上落实好</li><li>仔细看合同！！！！！</li><li>别轻易交定金。</li><li>核对电子版跟签的纸质版是否有细节上的变动。</li></ol><h2 id="二、细节"><a href="#二、细节" class="headerlink" title="二、细节"></a>二、细节</h2><h3 id="筛选小区"><a href="#筛选小区" class="headerlink" title="筛选小区"></a>筛选小区</h3><h4 id="便利性"><a href="#便利性" class="headerlink" title="便利性"></a>便利性</h4><ol><li>有无商场</li><li>有无超市、菜市场</li><li>周围外卖情况（直接在外卖软件上看）</li><li>周围打车情况（直接在打车软件上看）</li><li>有无社区医院、药店</li></ol><h4 id="整体环境"><a href="#整体环境" class="headerlink" title="整体环境"></a>整体环境</h4><ol><li>小区封闭或开放</li><li>有无保安</li><li>进出小区是否刷卡</li><li>绿化情况</li><li>一梯几户： 户数多，层数高，电梯排队时间长</li><li>老人多还是年轻人多</li></ol><h4 id="房屋性质"><a href="#房屋性质" class="headerlink" title="房屋性质"></a>房屋性质</h4><ol><li>城中村</li><li>回迁房</li><li>商住两用： 燃气一般不通、商水商电、物业参差不齐</li></ol><h4 id="预备资金"><a href="#预备资金" class="headerlink" title="预备资金"></a>预备资金</h4><p>押一付三+中介费=五个月的房租</p><h3 id="筛选房子"><a href="#筛选房子" class="headerlink" title="筛选房子"></a>筛选房子</h3><h4 id="楼层及位置"><a href="#楼层及位置" class="headerlink" title="楼层及位置"></a>楼层及位置</h4><ul><li>一楼  不安全</li><li>顶楼  电梯不方便、可能房顶漏水</li><li>楼下别有KTV、Club</li></ul><h4 id="季节性因素"><a href="#季节性因素" class="headerlink" title="季节性因素"></a>季节性因素</h4><ul><li>夏季<ol><li>房顶漏不漏水</li><li>潮不潮</li></ol></li><li>冬季<ol><li>屋内温度</li></ol></li></ul><h4 id="杂费缴纳"><a href="#杂费缴纳" class="headerlink" title="杂费缴纳"></a>杂费缴纳</h4><ol><li>物业费</li><li>取暖费</li><li>卫生费</li><li>水、电、网、燃气费</li></ol><h4 id="网络需求"><a href="#网络需求" class="headerlink" title="网络需求"></a>网络需求</h4><p>通哪些运营商的网络</p><ol><li>移动</li><li>电信</li><li>联通</li></ol><p>手机信号如何</p><h4 id="水、电、燃气、物业费等交割"><a href="#水、电、燃气、物业费等交割" class="headerlink" title="水、电、燃气、物业费等交割"></a>水、电、燃气、物业费等交割</h4><ol><li>签合同之前确定水、电、燃气表的读数</li><li>有无拖欠物业费等</li></ol><h4 id="问题家电"><a href="#问题家电" class="headerlink" title="问题家电"></a>问题家电</h4><ol><li>所有家电、家具都试用一遍，确定状态 有问题的家电可以要求房东更换：<ul><li>给换，Yeah！</li><li>不给换，说自己买：<ul><li>旧家电房东搬走，OK！</li><li>不搬走？不租！房东肯定事儿多！</li></ul></li></ul></li></ol><h4 id="证据留存"><a href="#证据留存" class="headerlink" title="证据留存"></a>证据留存</h4><ol><li>房子的状态、家具、家电都拍照或者录视频记录，退房时候以免万一</li></ol><h4 id="房屋朝向"><a href="#房屋朝向" class="headerlink" title="房屋朝向"></a>房屋朝向</h4><p>一定坐北朝南！</p><h4 id="卫生问题"><a href="#卫生问题" class="headerlink" title="卫生问题"></a>卫生问题</h4><ol><li>有无蟑螂、老鼠</li><li>通风好不好</li><li>下水道有没有反味、通不通畅</li><li>噪音</li></ol><h4 id="换锁芯"><a href="#换锁芯" class="headerlink" title="换锁芯"></a>换锁芯</h4><p>交房之后换锁芯，旧锁芯保留，退房的时候换上</p><h4 id="押金"><a href="#押金" class="headerlink" title="押金"></a>押金</h4><p>抱着不要的心态，调整好心态，但是要争取挽回可能的损失。</p><h2 id="小注意事项"><a href="#小注意事项" class="headerlink" title="小注意事项"></a>小注意事项</h2><ol><li>哥哥、姐姐叫起来，大家都出来混的，强龙不压地头蛇。</li><li>记得砍价，也许房租可以便宜一二百；中介费也是可谈的。 中介说走过路过不要错过的时候，记得还价！记住TA是要赚你的钱的，主动权应该在你手上，你可以说不是非这个房子不可，又不是赶着住，希望TA能再压低价格，如果可以了明天就可以签。</li><li>锁定一个心意的房子之后，中介说已经租出去了，要带着去看其他的房子。直接Say NO！</li><li>多花一点钱，比平时上下班多花一个小时更舒服。</li><li>合租可以看TA的工作是否规律、有无不良习惯、房子是否整洁、厕所是否干净</li><li>先看实拍图，再实地看房。</li><li>要看房本、身份证。</li><li>合同详细内容可以百度做功课。</li><li>给中介转中介费的时候要有第三方在，或者全程录音，而且转账账号要念出来让他确认。</li><li>从中介或者二房东租房要看其委托书或合同的委托或租赁时长，以免中途被赶出去。</li><li>不用租房贷。</li><li>到地铁口、超市等距离要看地图实际距离；</li><li>58同城上可以在线签合同，应该是没有什么问题的</li><li>租好房之后如果房子比较脏，可以在58或者其他平台上找找保洁，价格可以接受的话请保洁还是很划算的。</li></ol><h2 id="法律小知识"><a href="#法律小知识" class="headerlink" title="法律小知识"></a>法律小知识</h2><ol><li>业主负责维修 家电、家具合理的老化磨损应由业主负责，而非租客赔偿</li><li>买卖不破租赁 房子换了房东，我们依然有权依照合同约定期限继续居住</li><li>出现纠纷需要仲裁，仲裁费用由对方出</li><li>转租需征得业主同意</li><li>装修需经业主同意</li><li>甲醛超标可要求赔偿</li><li>不付租金房东有权赶走租客</li><li>续租需补签续租合同</li></ol><h2 id="合同相关"><a href="#合同相关" class="headerlink" title="合同相关"></a>合同相关</h2><ol><li>房主违约赔偿规则</li><li>租户违约赔偿规则</li><li>是否可以转租、装修、养宠物</li><li>物业费 如果包括，要清楚的写到合同上—房租 xx 元/月（含物业费）<br> 如果不包括，一定要问清楚物业费是怎么算的，具体到一平米多少钱还要写清楚你交的物业是你房间的平方米数，还是包括公摊面积（比如客厅，厕所）</li><li>电费<ul><li>你们租户自己交电费（支付宝就能交，房东有水电卡）</li><li>房东交按收据收钱</li><li>看总电表，按 x 毛度算钱</li></ul></li></ol><figure class="half">    <img src="https://images.961110.xyz/images/2021/10/20/98745486c5106dcec004682626f2af82.jpg">    <img src="https://images.961110.xyz/images/2021/10/20/26b7a5b950bfb95c45a6164ec43549ae.jpg"></figure><h2 id="六、参考链接"><a href="#六、参考链接" class="headerlink" title="六、参考链接"></a>六、参考链接</h2><ol><li><a href="https://b23.tv/hfMNvq">https://b23.tv/hfMNvq</a></li><li><a href="https://b23.tv/1sNxTj">https://b23.tv/1sNxTj</a></li><li><a href="https://b23.tv/koKZX7">https://b23.tv/koKZX7</a></li><li><a href="https://b23.tv/ug2GjJ">https://b23.tv/ug2GjJ</a></li><li><a href="https://www.zhihu.com/question/375266600">https://www.zhihu.com/question/375266600</a></li><li><a href="https://zhuanlan.zhihu.com/p/112314408">https://zhuanlan.zhihu.com/p/112314408</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 生活 </tag>
            
            <tag> 租房 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MAC使用VNC连接Centos7服务器</title>
      <link href="/posts/44617.html"/>
      <url>/posts/44617.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在windows 中，很多人选择安装xmanager+xshell，然后远程连接linux，就能直接调用软件的GUI界面。于是也在Mac上尝试远程调用Centos7的界面，但是使用XQuartz软件+ssh -X命令的方式(教程网址在最后引用里有)并不管用，百度了半天才发现可以使用VNC连接Centos7，故进行了总结。</p><h2 id="安装（Centos7）"><a href="#安装（Centos7）" class="headerlink" title="安装（Centos7）"></a>安装（Centos7）</h2><h3 id="安装x-window（已有图形界面则跳过此步骤）"><a href="#安装x-window（已有图形界面则跳过此步骤）" class="headerlink" title="安装x-window（已有图形界面则跳过此步骤）"></a>安装x-window（已有图形界面则跳过此步骤）</h3><p>以root用户输入以下命令安装x-window</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">yum check-update</span><br><span class="line">yum groupinstall <span class="string">&quot;X Window System&quot;</span></span><br><span class="line">yum install gnome-classic-session gnome-terminalnautilus-open-terminal control-center liberation-mono-fonts</span><br><span class="line"></span><br><span class="line">### 设置默认启动图形界面</span><br><span class="line">unlink /etc/systemd/system/<span class="keyword">default</span>.target</span><br><span class="line">ln -sf /lib/systemd/system/graphical.target/etc/systemd/system/<span class="keyword">default</span>.target</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><p>重启完成后，Centos7就会有图形化界面了。</p><h3 id="安装VNC-Server"><a href="#安装VNC-Server" class="headerlink" title="安装VNC Server"></a>安装VNC Server</h3><p>输入以下命令检查vnc server是否安装</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">yum info tigervnc-server</span><br></pre></td></tr></table></figure><p>已经安装好会有以下vnc server的信息</p><img src="https://images.961110.xyz/images/2021/10/20/tigervnc-server.png" alt="tigervnc-server安装" style="zoom: 67%;" /><p>没有安装好则以root用户运行以下命令来安装vncserver</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">yum install tigervnc-server</span><br></pre></td></tr></table></figure><h3 id="配置相关文件"><a href="#配置相关文件" class="headerlink" title="配置相关文件"></a>配置相关文件</h3><p>需要在 /etc/systemd/system/ 目录里创建一个配置文件，可以将 /lib/systemd/sytem/vncserver@.service 拷贝一份配置文件范例过来。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cp /lib/systemd/system/vncserver@.service  /etc/systemd/system/vncserver@:<span class="number">1.</span>service</span><br></pre></td></tr></table></figure><p>编辑/etc/systemd/system/vncserver@:1.service,替换成自己的用户名。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#普通用户用下面两句</span><br><span class="line">ExecStart=/sbin/runuser -l &lt;user_name&gt; -c<span class="string">&quot;/usr/bin/vncserver %i&quot;</span></span><br><span class="line">PIDFile=/home/&lt;user_name&gt;/.vnc/%H%i.pid</span><br><span class="line"></span><br><span class="line"><span class="meta">#root用户用下面两句</span></span><br><span class="line">ExecStart=/sbin/runuser -l root -c <span class="string">&quot;/usr/bin/vncserver %i&quot;</span></span><br><span class="line">PIDFile=/root/.vnc/%H%i.pid</span><br></pre></td></tr></table></figure><p>修改完的文件内容如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Remote desktop service (VNC)</span><br><span class="line">After=syslog.target network.target</span><br><span class="line"></span><br><span class="line">Type=forking</span><br><span class="line"></span><br><span class="line"># Clean any existing files in /tmp/.X11-unix environment</span><br><span class="line"></span><br><span class="line">ExecStartPre=/bin/sh -c <span class="string">&#x27;/usr/bin/vncserver -kill %i &gt; /dev/null 2&gt;&amp;1 || :&#x27;</span></span><br><span class="line"></span><br><span class="line">ExecStart=/sbin/runuser -l root -c <span class="string">&quot;/usr/bin/vncserver %i -geometry 800x600&quot;</span></span><br><span class="line"></span><br><span class="line">PIDFile=/root/.vnc/%H%i.pid</span><br><span class="line"></span><br><span class="line">ExecStop=/bin/sh -c <span class="string">&#x27;/usr/bin/vncserver -kill %i &gt; /dev/null 2&gt;&amp;1 || :&#x27;</span></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>更新systemctl以使其生效</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>最后还要设置一下用户的 VNC 密码。要设置某个用户的密码，必须要有能通过 sudo 切换到用户的权限。PS：密码要≥六位</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">su user_name</span><br><span class="line">vncpasswd</span><br></pre></td></tr></table></figure><p>执行如下语句，让防火墙放行vnc服务</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --add-service vnc-server</span><br><span class="line"></span><br><span class="line">systemctl restart firewalld.service</span><br></pre></td></tr></table></figure><p>或者设置防火墙放行对应端口</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --zone=<span class="keyword">public</span> --add-port=<span class="number">5901</span>/tcp</span><br><span class="line"></span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>如果命令报错，可能是由于安装了python3的解释器，python是指向python3的，而原来的系统firewall-cmd 是命令脚本是使用python2的，而python3没有对应包，所以需要修改firewall-cmd命令脚本，让它依旧使用python2，这样就不会有问题了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sudo vim /usr/bin/firewall-cmd</span><br></pre></td></tr></table></figure><p>第一行python改为python2</p><p><img src="https://images.961110.xyz/images/2021/10/20/python.png" alt="更改python解释器"></p><p>接着把vnc添加到开机自启动</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">systemctl enable vncserver@:<span class="number">1.</span>service</span><br></pre></td></tr></table></figure><p>最后启动服务</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">systemctl start vncserver@:<span class="number">1.</span>service</span><br></pre></td></tr></table></figure><p>启动时可能会报如下错误</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">job <span class="keyword">for</span> vncserver@:<span class="number">1.</span>service failed because a configured resourcelimit was exceeded.</span><br></pre></td></tr></table></figure><p>执行# systemctl status vncserver@:1.service，发现一条信息：</p><p>localhost.localdomain systemd[1]: PID file /root/.vnc/localhost.localdomain:1.pid not readable (yet?) after start.</p><p>检查 /root/.vnc/，发现没有localhost.localdomain:1.pid</p><p>解决方法：</p><p>原来目录/tmp/下有一个/.X11-unix目录会占用这个pid序号资源。<br>把这个目录改名/.X11-unix.bak后，再次尝试启动后成功。</p><p>执行的代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mv /tmp/.X11-unix /tmp/.X11-unix.bak</span><br><span class="line"></span><br><span class="line">systemctl start vncserver@\:<span class="number">1.</span>service</span><br></pre></td></tr></table></figure><p>如果提示Too many open files 且启动不成功，重启一下机器即可</p><p>注意：非正常关机启动后，会报</p><p>PID 4286 read from file /root/.vnc/localhost.localdomain:1.pid does not exist or is a zombie</p><p>或者 PID file /root/.vnc/localhost.localdomain:2.pid not readable (yet?) after start.</p><p>解决方法：cd /tmp/.X11-unix</p><p>Rm -rf *</p><h3 id="多用户连接"><a href="#多用户连接" class="headerlink" title="多用户连接"></a>多用户连接</h3><p>如果需要更多的用户连接，需要创建配置文件和端口，添加一个新的用户和端口。创建/etc/systemd/system/vncserver@:*.service，替换配置文件里的用户名和之后步骤里相应的文件名、端口号。</p><p>VNC 服务本身使用的是 5900 端口。鉴于有不同的用户使用 VNC ，每个人的连接都会获得不同的端口。第一个 VNC 服务会运行在 5901（5900 + 1）端口上，之后的依次增加，运行在 5900 + x 号端口上。其中 x 是指之后用户的配置文件名 vncserver@:x.service 里面的 x 。</p><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><p>关闭 VNC 服务</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">systemctl stop vncserver@:<span class="number">1.</span>service</span><br></pre></td></tr></table></figure><p>禁止 VNC 服务开机启动</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">systemctl disable vncserver@:<span class="number">1.</span>service</span><br></pre></td></tr></table></figure><p>关闭防火墙</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br></pre></td></tr></table></figure><h2 id="安装（MAC）"><a href="#安装（MAC）" class="headerlink" title="安装（MAC）"></a>安装（MAC）</h2><h3 id="安装VNC-Viewer"><a href="#安装VNC-Viewer" class="headerlink" title="安装VNC Viewer"></a>安装VNC Viewer</h3><p>链接：<a href="https://www.realvnc.com/download/file/viewer.files/VNC-Viewer-6.19.923-MacOSX-x86_64.dmg">https://www.realvnc.com/download/file/viewer.files/VNC-Viewer-6.19.923-MacOSX-x86_64.dmg</a></p><p>启动输入IP:Port进行连接</p><img src="https://images.961110.xyz/images/2021/10/20/VNCViewer.png" alt="VNCViewer" style="zoom:67%;" /><p>输入之前设置的密码即可</p><p><img src="https://images.961110.xyz/images/2021/10/20/VNC.png" alt="VNC连接"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://blog.csdn.net/dobell/article/details/55047811">https://blog.csdn.net/dobell/article/details/55047811</a>（mac如何ssh连接linux(ubuntu) GUI图形界面）</li><li><a href="https://blog.csdn.net/weixin_38280090/article/details/84259489">https://blog.csdn.net/weixin_38280090/article/details/84259489</a>（Linux VNC server 安装配置）</li><li><a href="https://blog.csdn.net/smile_caijx/article/details/78797234">https://blog.csdn.net/smile_caijx/article/details/78797234</a>（在Linux中如何开启VNC服务）</li><li><a href="https://linux.cn/article-5335-1.html">https://linux.cn/article-5335-1.html</a>（怎样在 CentOS 7.0 上安装和配置 VNC 服务器）</li><li><a href="https://blog.csdn.net/qq_42999398/article/details/88750280">https://blog.csdn.net/qq_42999398/article/details/88750280</a>（centos7 firewall-cmd 命令报错）</li><li><a href="https://blog.csdn.net/liliangkuba/article/details/99684420">https://blog.csdn.net/liliangkuba/article/details/99684420</a>（解决vncserver报错：PID file /root/.vnc/localhost.localdomain:1.pid not readable）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Linux </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
