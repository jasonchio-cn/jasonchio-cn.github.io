<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Docker源码分析（五）—— 命令 docker inspect 的执行</title>
      <link href="/posts/21441.html"/>
      <url>/posts/21441.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>想要获取 container 的相关信息，看到有 <code>docker inspect containerID</code> 这个命令而且返回了较为完备的 container 底层信息，所以对其进行简单的追踪。这个命令是 Docker Client 的命令，所以从 Docker Client 开始分析。</p><h2 id="Docker-Client"><a href="#Docker-Client" class="headerlink" title="Docker Client"></a>Docker Client</h2><p>调用链路是 <code>main()--&gt;runDocker()--&gt;newDockerCommand()--&gt;AddCommands()--&gt;cmd.AddCommand()--&gt;container.NewContainerCommand()--&gt;cmd.AddCommand()--&gt;newInspectCommand()</code></p><p>从<code>newInspectCommand()</code>开始进行分析。</p><h3 id="newInspectCommand-dockerCli"><a href="#newInspectCommand-dockerCli" class="headerlink" title="newInspectCommand(dockerCli)"></a>newInspectCommand(dockerCli)</h3><p>cli/command/container/inspect.go: 19</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newInspectCommand</span><span class="params">(dockerCli command.Cli)</span> *<span class="title">cobra</span>.<span class="title">Command</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> opts inspectOptions</span><br><span class="line"></span><br><span class="line">cmd := &amp;cobra.Command&#123;</span><br><span class="line">Use:   <span class="string">&quot;inspect [OPTIONS] CONTAINER [CONTAINER...]&quot;</span>,</span><br><span class="line">Short: <span class="string">&quot;Display detailed information on one or more containers&quot;</span>,</span><br><span class="line">Args:  cli.RequiresMinArgs(<span class="number">1</span>),</span><br><span class="line">RunE: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">opts.refs = args</span><br><span class="line"><span class="keyword">return</span> runInspect(dockerCli, opts)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flags := cmd.Flags()</span><br><span class="line">flags.StringVarP(&amp;opts.format, <span class="string">&quot;format&quot;</span>, <span class="string">&quot;f&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Format the output using the given Go template&quot;</span>)</span><br><span class="line">flags.BoolVarP(&amp;opts.size, <span class="string">&quot;size&quot;</span>, <span class="string">&quot;s&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;Display total file sizes&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> cmd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的主要作用是新增 <code>docker inspect</code> 这个命令，相关的可视化效果可以在下图看到。</p><img src="https://images.961110.xyz/images/2021/11/28/docker-inspect--help.png" alt="image-20211128171139806" style="zoom:50%;" /><h3 id="runInspect-dockerCli-opts"><a href="#runInspect-dockerCli-opts" class="headerlink" title="runInspect(dockerCli, opts)"></a>runInspect(dockerCli, opts)</h3><p>cli/command/container/inspect.go: 39</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runInspect</span><span class="params">(dockerCli command.Cli, opts inspectOptions)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">client := dockerCli.Client()</span><br><span class="line">ctx := context.Background()</span><br><span class="line"></span><br><span class="line">getRefFunc := <span class="function"><span class="keyword">func</span><span class="params">(ref <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, []<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> client.ContainerInspectWithRaw(ctx, ref, opts.size)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> inspect.Inspect(dockerCli.Out(), opts.refs, opts.format, getRefFunc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>dockerCli</code>是 Docker 命令行的对象；</li><li><code>dockerCli.Client()</code>是与 docker server(Docker Daemon) 交互的 API Client，对应的结构体中存放着服务端的地址、通信方式（unix. fd, tcp）等信息。</li><li><code>getRefFunc</code>这个函数是这个命令的核心函数，其发送请求 get 请求来获取指定 container 的 JSON 信息，这个下面再分析。</li><li><code>inspect.Inspect()</code>这个函数 的作用是将<code>getRefFunc</code>得到的 JSON 格式的信息输出到 Docker Client 的输出端。</li></ul><h3 id="client-ContainerInspectWithRaw-ctx-ref-opts-size"><a href="#client-ContainerInspectWithRaw-ctx-ref-opts-size" class="headerlink" title="client.ContainerInspectWithRaw(ctx, ref, opts.size)"></a>client.ContainerInspectWithRaw(ctx, ref, opts.size)</h3><p>github.com/docker/docker/client/container_inspect.go: 30</p><p>从调用路径中可以看出，这里引用的是 Docker Daemon 的实现</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *Client)</span> <span class="title">ContainerInspectWithRaw</span><span class="params">(ctx context.Context, containerID <span class="keyword">string</span>, getSize <span class="keyword">bool</span>)</span> <span class="params">(types.ContainerJSON, []<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> containerID == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> types.ContainerJSON&#123;&#125;, <span class="literal">nil</span>, objectNotFoundError&#123;object: <span class="string">&quot;container&quot;</span>, id: containerID&#125;</span><br><span class="line">&#125;</span><br><span class="line">query := url.Values&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> getSize &#123;</span><br><span class="line">query.Set(<span class="string">&quot;size&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">serverResp, err := cli.get(ctx, <span class="string">&quot;/containers/&quot;</span>+containerID+<span class="string">&quot;/json&quot;</span>, query, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">defer</span> ensureReaderClosed(serverResp)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> types.ContainerJSON&#123;&#125;, <span class="literal">nil</span>, wrapResponseError(err, serverResp, <span class="string">&quot;container&quot;</span>, containerID)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">body, err := ioutil.ReadAll(serverResp.body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> types.ContainerJSON&#123;&#125;, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> response types.ContainerJSON</span><br><span class="line">rdr := bytes.NewReader(body)</span><br><span class="line">err = json.NewDecoder(rdr).Decode(&amp;response)</span><br><span class="line"><span class="keyword">return</span> response, body, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最核心的是这行代码</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">serverResp, err := cli.get(ctx, <span class="string">&quot;/containers/&quot;</span>+containerID+<span class="string">&quot;/json&quot;</span>, query, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>向 Docker Daemon 发送 get 请求，并获取响应。</p><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><img src="https://images.961110.xyz/images/2021/11/28/docker-inspect--Docker-Client-.png" style="zoom: 50%;" /><p>接下来看 Docker Daemon 的处理过程。</p><h2 id="Docker-Daemon"><a href="#Docker-Daemon" class="headerlink" title="Docker Daemon"></a>Docker Daemon</h2><p>Docker Daemon 这一端从 <code>containerRouter.initRoutes()</code>开始分析，这个函数填充了 container 相关的一些 API 的路由了逻辑，其中就包括了 <code>docker inspect</code>这个命令</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">![ContainerInspectCurrent() 处理流程](C:/Users/JasonChio/Desktop/ContainerInspectCurrent()%<span class="number">20</span>%E5%A4%<span class="number">84</span>%E7%<span class="number">90</span>%<span class="number">86</span>%E6%B5%<span class="number">81</span>%E7%A8%<span class="number">8</span>B.png)<span class="function"><span class="keyword">func</span> <span class="params">(r *containerRouter)</span> <span class="title">initRoutes</span><span class="params">()</span></span> &#123;</span><br><span class="line">r.routes = []router.Route&#123;</span><br><span class="line">...</span><br><span class="line">router.NewGetRoute(<span class="string">&quot;/containers/&#123;name:.*&#125;/json&quot;</span>, r.getContainersByName),</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>r.getContainersByName</code>调用的是<code>containerRouter.backend.ContainerInspect()</code>，进而根据 API 版本进行不同的函数调用，在 1.20 以上的版本调用的是 <code>daemon.ContainerInspectCurrent()</code>，就执行到了一个需要关注的函数</p><h3 id="Daemon-ContainerInspectCurrent"><a href="#Daemon-ContainerInspectCurrent" class="headerlink" title="Daemon.ContainerInspectCurrent()"></a>Daemon.ContainerInspectCurrent()</h3><p>该函数处理流程图如下</p><img src="https://images.961110.xyz/images/2021/11/29/ContainerInspectCurrent-.png" style="zoom: 50%;" /><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(daemon *Daemon)</span> <span class="title">ContainerInspectCurrent</span><span class="params">(name <span class="keyword">string</span>, size <span class="keyword">bool</span>)</span> <span class="params">(*types.ContainerJSON, error)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 根据输入参数获取对应 container 结构体对象</span></span><br><span class="line">container, err := daemon.GetContainer(name)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 获取指定 container 的基本信息</span></span><br><span class="line">base, err := daemon.getInspectData(container)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定 container 的 Endpoint 配置信息</span></span><br><span class="line">apiNetworks := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*networktypes.EndpointSettings)</span><br><span class="line"><span class="keyword">for</span> name, epConf := <span class="keyword">range</span> container.NetworkSettings.Networks &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 获取指定 container 的 挂载点 配置信息</span></span><br><span class="line">mountPoints := container.GetMountPoints()</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 获取指定 container 的网络配置信息</span></span><br><span class="line">networkSettings := &amp;types.NetworkSettings&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 组装成 JSON 信息返回</span></span><br><span class="line"><span class="keyword">return</span> &amp;types.ContainerJSON&#123;</span><br><span class="line">ContainerJSONBase: base,</span><br><span class="line">Mounts:            mountPoints,</span><br><span class="line">Config:            container.Config,</span><br><span class="line">NetworkSettings:   networkSettings,</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>daemon.GetContainer(name)</code>这个函数的参数名叫做 name，但是 name 实际上可能是容器名、容器完整的 ID、容器 ID 的前缀这三种可能，<code>GetContainer()</code>内部对这三种情况进行了单独处理，最后还是通过容器 ID 来获取对应的容器（容器这个结构体的对象）</p><h3 id="Daemon-GetContainer"><a href="#Daemon-GetContainer" class="headerlink" title="Daemon.GetContainer()"></a>Daemon.GetContainer()</h3><p>daemon/container.go: 38</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(daemon *Daemon)</span> <span class="title">GetContainer</span><span class="params">(prefixOrName <span class="keyword">string</span>)</span> <span class="params">(*container.Container, error)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 省略掉的就是上面提到的分三种情况处理的代码，最后通过 containerID 来获取 container 对象</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> daemon.containers.Get(containerID), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>Get()</code> 方法实现于 container/memory_store.go: 29，其实现思路是根据容器 ID 在 memoryStore 中获取 ID 对应的容器对象，memoryStore 的实现如下</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> memoryStore <span class="keyword">struct</span> &#123;</span><br><span class="line">s <span class="keyword">map</span>[<span class="keyword">string</span>]*Container</span><br><span class="line">sync.RWMutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是一个简单的 map，保存在内存中。</p><h3 id="流程图-1"><a href="#流程图-1" class="headerlink" title="流程图"></a>流程图</h3><img src="https://images.961110.xyz/images/2021/11/29/docker-inspect--Docker-Daemon-.png" style="zoom:50%;" /><h2 id="docker-inspect-命令执行流程图"><a href="#docker-inspect-命令执行流程图" class="headerlink" title="docker inspect 命令执行流程图"></a>docker inspect 命令执行流程图</h2><img src="https://images.961110.xyz/images/2021/11/29/docker-inspect-.png" style="zoom:50%;" /><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>无</p>]]></content>
      
      
      <categories>
          
          <category> 毕设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 毕设 </tag>
            
            <tag> Docker </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编码开发规范</title>
      <link href="/posts/41554.html"/>
      <url>/posts/41554.html</url>
      
        <content type="html"><![CDATA[<h2 id="项目命名规范"><a href="#项目命名规范" class="headerlink" title="项目命名规范"></a>项目命名规范</h2><ol><li>项目名称用汉字，而项目 URL 不要用拼音，尽量用英文</li><li>项目 URL 不用大写、下划线</li><li>项目 URL 不用有歧义的缩写，如 src, led</li></ol><h2 id="代码库命名"><a href="#代码库命名" class="headerlink" title="代码库命名"></a>代码库命名</h2><p>英文：首先找官方的翻译</p><p><img src="https://images.961110.xyz/images/2021/11/22/01c9badceb5f05852709a733e7ae9211.png" alt="image-20211122144217905"></p><h2 id="Git-规范"><a href="#Git-规范" class="headerlink" title="Git 规范"></a>Git 规范</h2><h3 id="分支规范"><a href="#分支规范" class="headerlink" title="分支规范"></a>分支规范</h3><p>每个需求一个分支</p><h4 id="Git-Flow"><a href="#Git-Flow" class="headerlink" title="Git Flow"></a>Git Flow</h4><p>都是双分支结构，一个开发分支，一个主分支。</p><h5 id="简易-Git-Flow"><a href="#简易-Git-Flow" class="headerlink" title="简易 Git Flow"></a>简易 Git Flow</h5><p><img src="https://images.961110.xyz/images/2021/11/22/Git-Flow.png" alt="image-20211122144655829"></p><h5 id="严格版简易-Git-Flow"><a href="#严格版简易-Git-Flow" class="headerlink" title="严格版简易 Git Flow"></a>严格版简易 Git Flow<img src="https://images.961110.xyz/images/2021/11/22/Git-Flowca311f5bf49e8ac1.png" alt="image-20211122144757206"></h5><h4 id="分支命名"><a href="#分支命名" class="headerlink" title="分支命名"></a>分支命名</h4><p>命名以分支类型开头+数字+简易描述</p><p><img src="https://images.961110.xyz/images/2021/11/22/49134bf300d2a7631eb132607102bf49.png" alt="image-20211122144848896"></p><h2 id="Git-add-规范"><a href="#Git-add-规范" class="headerlink" title="Git add 规范"></a>Git add 规范</h2><ol><li>依赖包通过网络安装，进行依赖管理，不可以直接提交第三方包</li><li>build 的结果也不要提交上去</li><li>未发布到仓库的依赖包，可以创建一个仓库，放入需要的依赖包</li><li>不用的代码直接删除，需要的时候通过 git 历史找回</li></ol><h2 id="Git-commit-规范"><a href="#Git-commit-规范" class="headerlink" title="Git commit 规范"></a>Git commit 规范</h2><p> 使用 git cz 工具</p><p>原子性提交：每次提交都是可回滚的（一个需求可以提交好几次）</p><h2 id="Git-push-规范"><a href="#Git-push-规范" class="headerlink" title="Git push 规范"></a>Git push 规范</h2><p>主分支</p><ul><li>禁止强制推送（push –force）</li><li>禁止篡改历史（reset），只可以 revert</li></ul><p>开发分支</p><ul><li>允许强制推送</li><li>允许 rebase</li></ul><h2 id="代码合并规范"><a href="#代码合并规范" class="headerlink" title="代码合并规范"></a>代码合并规范</h2><ul><li>直接合并会产生一条垃圾历史</li><li>压缩合并（Squash）适合合并无关痛痒的 commit，以合并时的 commit message 为准</li><li>rebase 不产生垃圾历史</li></ul><h2 id="Git-tag-规范"><a href="#Git-tag-规范" class="headerlink" title="Git tag 规范"></a>Git tag 规范</h2><p>版本格式：主版本号.次版本号.修订号</p><ol><li>主版本号(Major)：不兼容的修改，</li><li>次版本号(Minor)：向下兼容的功能性新增，</li><li>修订号(Patch)：向下兼容的问题修正。</li></ol><p>是否需要前缀 v: 看个人喜好</p><p><img src="https://images.961110.xyz/images/2021/11/22/Git-tag-sample.png" alt="image-20211122155615007"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://www.bilibili.com/video/BV18q4y1n7Bd?p=1&amp;share_medium=iphone&amp;share_plat=ios&amp;share_session_id=43521A93-AADA-4B7D-B501-C2B8DC28DB0A&amp;share_source=COPY&amp;share_tag=s_i&amp;timestamp=1637545301&amp;unique_k=NuF4QQb">https://www.bilibili.com/video/BV18q4y1n7Bd?p=1&amp;share_medium=iphone&amp;share_plat=ios&amp;share_session_id=43521A93-AADA-4B7D-B501-C2B8DC28DB0A&amp;share_source=COPY&amp;share_tag=s_i&amp;timestamp=1637545301&amp;unique_k=NuF4QQb</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中文文案排版指北</title>
      <link href="/posts/39632.html"/>
      <url>/posts/39632.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>【转载】原文地址 <a href="https://www.quchao.net/Chinese-Copywriting-Guidelines.html">www.quchao.net</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>日常生活、写博、工作、学习中，我们每个人都会遇到文案排版问题。<br>借着新的一年，往后都延用本文新规范来写作，有机会我会再写一下整体大纲结构以及配色突出。  </p><p>统一中文文案、排版的相关用法，降低团队成员 / 访客之间的沟通阅读成本，增加网站气质。</p><hr><h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><p>「有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。 毕竟爱情跟书写都需要适时地留白。 与大家共勉之。」 ——<a href="https://github.com/vinta/pangu.js">vinta/paranoid-auto-spacing</a></p><h3 id="中英文之间需要增加空格"><a href="#中英文之间需要增加空格" class="headerlink" title="中英文之间需要增加空格"></a>中英文之间需要增加空格</h3><p>正确：  </p><blockquote><p>在 LeanCloud 上，数据存储是围绕 <code>AVObject</code> 进行的。</p></blockquote><p>错误：  </p><blockquote><p>在 LeanCloud 上，数据存储是围绕<code>AVObject</code>进行的。</p><p>在 LeanCloud 上，数据存储是围绕<code>AVObject</code> 进行的。</p></blockquote><p>完整的正确用法：  </p><blockquote><p>在 LeanCloud 上，数据存储是围绕 <code>AVObject</code> 进行的。每个 <code>AVObject</code> 都包含了与 JSON 兼容的 key-value 对应的数据。数据是 schema-free 的，你不需要在每个 <code>AVObject</code> 上提前指定存在哪些键，只要直接设定对应的 key-value 即可。</p></blockquote><p>例外：「豆瓣FM」等产品名词，按照官方所定义的格式书写。</p><h3 id="中文与数字之间需要增加空格"><a href="#中文与数字之间需要增加空格" class="headerlink" title="中文与数字之间需要增加空格"></a>中文与数字之间需要增加空格</h3><p>正确：  </p><blockquote><p>今天出去买菜花了 5000 元。</p></blockquote><p>错误：  </p><blockquote><p>今天出去买菜花了 5000元。</p><p>今天出去买菜花了5000 元。</p></blockquote><h3 id="数字与单位之间需要增加空格"><a href="#数字与单位之间需要增加空格" class="headerlink" title="数字与单位之间需要增加空格"></a>数字与单位之间需要增加空格</h3><p>正确：  </p><blockquote><p>我家的光纤入屋宽带有 10 Gbps，SSD 一共有 20 TB</p></blockquote><p>错误：  </p><blockquote><p>我家的光纤入屋宽带有 10Gbps，SSD 一共有 20TB</p></blockquote><p>例外：度 / 百分比与数字之间不需要增加空格。</p><p>正确：</p><blockquote><p>今天是 233° 的高温。</p><p>新 MacBook Pro 有 15% 的 CPU 性能提升。</p></blockquote><p>错误：  </p><blockquote><p>今天是 233 ° 的高温。</p><p>新 MacBook Pro 有 15 % 的 CPU 性能提升。</p></blockquote><h3 id="全角标点与其他字符之间不加空格"><a href="#全角标点与其他字符之间不加空格" class="headerlink" title="全角标点与其他字符之间不加空格"></a>全角标点与其他字符之间不加空格</h3><p>正确：  </p><blockquote><p>刚刚买了一部 iPhone，好开心！</p></blockquote><p>错误：  </p><blockquote><p>刚刚买了一部 iPhone ，好开心！</p><p>刚刚买了一部 iPhone， 好开心！</p></blockquote><h4 id="用-text-spacing-来挽救？"><a href="#用-text-spacing-来挽救？" class="headerlink" title="用 text-spacing 来挽救？"></a>用 <code>text-spacing</code> 来挽救？</h4><p>CSS Text Module Level 4 的 <a href="https://www.w3.org/TR/css-text-4/#text-spacing-property"><code>text-spacing</code></a> 和 Microsoft 的 <a href="https://msdn.microsoft.com/library/ms531164(v=vs.85).aspx"><code>-ms-text-autospace</code></a> 可以实现自动为中英文之间增加空白。不过目前并未普及，另外在其他应用场景，例如 macOS、iOS、Windows 等用户介面目前并不存在这个特性，所以请继续保持随手加空格的习惯。</p><hr><h2 id="标点符号"><a href="#标点符号" class="headerlink" title="标点符号"></a>标点符号</h2><h3 id="不重复使用标点符号"><a href="#不重复使用标点符号" class="headerlink" title="不重复使用标点符号"></a>不重复使用标点符号</h3><p>正确：</p><blockquote><p>德国队竟然战胜了巴西队！</p><p>她竟然对你说「喵」？！</p></blockquote><p>错误：</p><blockquote><p>德国队竟然战胜了巴西队！！</p><p>德国队竟然战胜了巴西队！！！！！！！！</p><p>她竟然对你说「喵」？？！！</p><p>她竟然对你说「喵」？！？！？？！！</p></blockquote><hr><h2 id="全角和半角"><a href="#全角和半角" class="headerlink" title="全角和半角"></a>全角和半角</h2><p>不明白什么是全角（全形）与半角（半形）符号？请查看维基百科词条『<a href="https://zh.wikipedia.org/wiki/%E5%85%A8%E5%BD%A2%E5%92%8C%E5%8D%8A%E5%BD%A2">全形和半形</a>』。</p><h3 id="使用全角中文标点"><a href="#使用全角中文标点" class="headerlink" title="使用全角中文标点"></a>使用全角中文标点</h3><p>正确：</p><blockquote><p>嗨！你知道嘛？今天前台的小妹跟我说「喵」了哎！</p><p>核磁共振成像（NMRI）是什么原理都不知道？JFGI！</p></blockquote><p>错误：</p><blockquote><p>嗨! 你知道嘛? 今天前台的小妹跟我说 “喵” 了哎！</p><p>嗨! 你知道嘛?今天前台的小妹跟我说 “喵” 了哎！</p><p>核磁共振成像 (NMRI) 是什么原理都不知道? JFGI!</p><p>核磁共振成像(NMRI)是什么原理都不知道?JFGI!</p></blockquote><h3 id="数字使用半角字符"><a href="#数字使用半角字符" class="headerlink" title="数字使用半角字符"></a>数字使用半角字符</h3><p>正确：</p><blockquote><p>这个蛋糕只卖 1000 元。</p></blockquote><p>错误：</p><blockquote><p>这个蛋糕只卖 １０００ 元。</p></blockquote><p>例外：在设计稿、宣传海报中如出现极少量数字的情形时，为方便文字对齐，是可以使用全形数字的。</p><h3 id="遇到完整的英文整句、特殊名词，其内容使用半角标点"><a href="#遇到完整的英文整句、特殊名词，其内容使用半角标点" class="headerlink" title="遇到完整的英文整句、特殊名词，其内容使用半角标点"></a>遇到完整的英文整句、特殊名词，其内容使用半角标点</h3><p>正确：</p><blockquote><p>贾伯斯那句话是怎么说的？「Stay hungry, stay foolish.」</p><p>推荐你阅读《Hackers &amp; Painters: Big Ideas from the Computer Age》，非常的有趣。</p></blockquote><p>错误：</p><blockquote><p>贾伯斯那句话是怎么说的？「Stay hungry，stay foolish。」</p><p>推荐你阅读《Hackers＆Painters：Big Ideas from the Computer Age》，非常的有趣。</p></blockquote><hr><h2 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h2><h3 id="专有名词使用正确的大小写"><a href="#专有名词使用正确的大小写" class="headerlink" title="专有名词使用正确的大小写"></a>专有名词使用正确的大小写</h3><p>大小写相关用法原属于英文书写范畴，不属于本 wiki 讨论内容，在这里只对部分易错用法进行简述。</p><p>正确：</p><blockquote><p>使用 GitHub 登录</p><p>我们的客户有 GitHub、Foursquare、Microsoft Corporation、Google、Facebook, Inc.。</p></blockquote><p>错误：</p><blockquote><p>使用 github 登录</p><p>使用 GITHUB 登录</p><p>使用 Github 登录</p><p>使用 gitHub 登录</p><p>使用 gｲんĤЦ8 登录</p><p>我们的客户有 github、foursquare、microsoft corporation、google、facebook, inc.。</p><p>我们的客户有 GITHUB、FOURSQUARE、MICROSOFT CORPORATION、GOOGLE、FACEBOOK, INC.。</p><p>我们的客户有 Github、FourSquare、MicroSoft Corporation、Google、FaceBook, Inc.。</p><p>我们的客户有 gitHub、fourSquare、microSoft Corporation、google、faceBook, Inc.。</p><p>我们的客户有 gｲんĤЦ8、ｷouЯƧquﾑгє、๓เςг๏ร๏Ŧt ς๏гק๏гคtเ๏ภn、900913、ƒ4ᄃëв๏๏к, IПᄃ.。</p></blockquote><p>注意：当网页中需要配合整体视觉风格而出现全部大写／小写的情形，HTML 中请使用标淮的大小写规范进行书写；并通过 <code>text-transform: uppercase;</code>／<code>text-transform: lowercase;</code> 对表现形式进行定义。</p><h3 id="不要使用不地道的缩写"><a href="#不要使用不地道的缩写" class="headerlink" title="不要使用不地道的缩写"></a>不要使用不地道的缩写</h3><p>正确：</p><blockquote><p>我们需要一位熟悉 JavaScript、HTML5，至少理解一种框架（如 Backbone.js、AngularJS、React 等）的前端开发者。</p></blockquote><p>错误：</p><blockquote><p>我们需要一位熟悉 Js、h5，至少理解一种框架（如 backbone、angular、RJS 等）的 FED。</p></blockquote><hr><h2 id="争议"><a href="#争议" class="headerlink" title="争议"></a>争议</h2><p>以下用法略带有个人色彩，即：无论是否遵循下述规则，从语法的角度来讲都是<strong>正确</strong>的。</p><h3 id="链接之间增加空格"><a href="#链接之间增加空格" class="headerlink" title="链接之间增加空格"></a>链接之间增加空格</h3><p>用法：</p><blockquote><p>请 <a href="#">提交一个 issue</a> 并分配给相关同事。</p><p>访问我们网站的最新动态，请 <a href="#">点击这里</a> 进行订阅！</p></blockquote><p>对比用法：</p><blockquote><p>请<a href="#">提交一个 issue</a>并分配给相关同事。</p><p>访问我们网站的最新动态，请<a href="#">点击这里</a>进行订阅！</p></blockquote><h3 id="简体中文使用直角引号"><a href="#简体中文使用直角引号" class="headerlink" title="简体中文使用直角引号"></a>简体中文使用直角引号</h3><p>用法：</p><blockquote><p>「老师，『有条不紊』的『紊』是什么意思？」</p></blockquote><p>对比用法：</p><blockquote><p>“老师，‘有条不紊’的‘紊’是什么意思？”</p></blockquote><hr><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><table><thead><tr><th>仓库</th><th>语言</th></tr></thead><tbody><tr><td><a href="https://github.com/vinta/paranoid-auto-spacing" target="_blank">vinta/paranoid-auto-spacing<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></td><td>JavaScript</td></tr><tr><td><a href="https://github.com/huei90/pangu.node" target="_blank">huei90/pangu.node<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></td><td>Node.js</td></tr><tr><td><a href="https://github.com/huacnlee/auto-correct" target="_blank">huacnlee/auto-correct<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></td><td>Ruby</td></tr><tr><td><a href="https://github.com/sparanoid/space-lover" target="_blank">sparanoid/space-lover<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></td><td>PHP (WordPress)</td></tr><tr><td><a href="https://github.com/NauxLiu/auto-correct" target="_blank">nauxliu/auto-correct<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></td><td>PHP</td></tr><tr><td><a href="https://github.com/jxlwqq/chinese-typesetting" target="_blank">jxlwqq/chinese-typesetting<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></td><td>PHP</td></tr><tr><td><a href="https://github.com/hotoo/pangu.vim" target="_blank">hotoo/pangu.vim<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></td><td>Vim</td></tr><tr><td><a href="https://github.com/sparanoid/grunt-auto-spacing" target="_blank">sparanoid/grunt-auto-spacing<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></td><td>Node.js (Grunt)</td></tr><tr><td><a href="https://github.com/hjiang/scripts/blob/master/add-space-between-latin-and-cjk" target="_blank">hjiang/scripts/add-space-between-latin-and-cjk<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></td><td>Python</td></tr><tr><td><a href="https://github.com/hustcc/hint" target="_blank">hustcc/hint<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></td><td>Python</td></tr><tr><td><a href="https://github.com/studygolang/autocorrect" target="_blank">studygolang/autocorrect<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></td><td>Go</td></tr></tbody></table><hr><h2 id="谁在这样做？"><a href="#谁在这样做？" class="headerlink" title="谁在这样做？ "></a>谁在这样做？ </h2><table><thead><tr><th>网站</th><th>文案</th><th>UGC</th></tr></thead><tbody><tr><td><a href="https://www.apple.com/cn/" target="_blank">Apple 中国<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></td><td>是</td><td>N/A</td></tr><tr><td><a href="https://www.apple.com/hk/" target="_blank">Apple 香港<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></td><td>是</td><td>N/A</td></tr><tr><td><a href="https://www.apple.com/tw/" target="_blank">Apple 台湾<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></td><td>是</td><td>N/A</td></tr><tr><td><a href="https://www.microsoft.com/zh-cn/" target="_blank">Microsoft 中国<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></td><td>是</td><td>N/A</td></tr><tr><td><a href="https://www.microsoft.com/zh-hk/" target="_blank">Microsoft 香港<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></td><td>是</td><td>N/A</td></tr><tr><td><a href="https://www.microsoft.com/zh-tw/" target="_blank">Microsoft 台湾<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></td><td>是</td><td>N/A</td></tr><tr><td><a href="https://leancloud.cn/" target="_blank">LeanCloud<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></td><td>是</td><td>N/A</td></tr><tr><td><a href="https://www.v2ex.com/" target="_blank">V2EX<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></td><td>是</td><td>是</td></tr><tr><td><a href="https://apple4us.com/" target="_blank">Apple4us<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></td><td>是</td><td>N/A</td></tr><tr><td><a href="https://ruby-china.org/" target="_blank">Ruby China<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></td><td>是</td><td>标题达成</td></tr><tr><td><a href="https://phphub.org/" target="_blank">PHPHub<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></td><td>是</td><td>标题达成</td></tr><tr><td><a href="https://sspai.com/" target="_blank">少数派<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-darkreader-inline-stroke="" style="--darkreader-inline-stroke:currentColor;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a></td><td>是</td><td>N/A</td></tr></tbody></table><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>  <a href="https://www.thoughtco.com/guidelines-for-using-capital-letters-1691724">Guidelines for Using Capital Letters - ThoughtCo.</a></li><li>  <a href="https://en.wikipedia.org/wiki/Letter_case">Letter case - Wikipedia</a></li><li>  <a href="https://en.oxforddictionaries.com/grammar/punctuation">Punctuation - Oxford Dictionaries</a></li><li>  <a href="https://owl.english.purdue.edu/owl/section/1/6/">Punctuation - The Purdue OWL</a></li><li>  <a href="https://www.wikihow.com/Use-English-Punctuation-Correctly">How to Use English Punctuation Correctly - wikiHow</a></li><li>  <a href="https://zh.opensuse.org/index.php?title=Help:%E6%A0%BC%E5%BC%8F">格式 - openSUSE</a></li><li>  <a href="https://zh.wikipedia.org/wiki/%E5%85%A8%E5%BD%A2%E5%92%8C%E5%8D%8A%E5%BD%A2">全形和半形 - 维基百科</a></li><li>  <a href="https://zh.wikipedia.org/wiki/%E5%BC%95%E8%99%9F">引号 - 维基百科</a></li><li>  <a href="https://zh.wikipedia.org/wiki/%E7%96%91%E5%95%8F%E9%A9%9A%E5%98%86%E8%99%9F">疑问惊叹号 - 维基百科</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker源码分析（四）—— Docker Daemon 启动流程</title>
      <link href="/posts/2533.html"/>
      <url>/posts/2533.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>博文分析的Docker源码基于19.03版本，阅读工具采用Goland，追踪的是<code>docker run</code>命令的执行过程。</p><p>第一次阅读Docker源码，如有纰漏还请轻喷，喷完希望能够通过邮件或者留言的方式指出问题。</p><p>限于篇幅以及关注重点的原因，部分个人认为不重要的代码会用省略号代替。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>照例还是先摆出 Docker 的架构，<strong>架构在心中，源码轻松读</strong>。</p><p>在上两篇博文中跟踪了 Docker Daemon 中创建和运行容器的过程，但是缺失了像 <a href="https://blog.961110.xyz/posts/64829.html">Docker源码分析（一）—— docker run 命令在 Docker Client 中的执行</a> 一文中，Daemon 客户端启动的过程跟踪，所以在本文中将对其启动过程进行简单分析。</p><table>    <tr>        <td ><center><img src="https://images.961110.xyz/images/2021/11/16/docker-architecture.png" >图1  Docker 架构（官网图） </center></td>        <td ><center><img src="https://images.961110.xyz/images/2021/11/16/Docker.png"  >图2 Docker 架构图（分组件）</center></td>    </tr></table><p>在 Client 中调用<code>ContainerStart()</code>，向 Daemon 发送 <code>resp, err := cli.post(ctx, &quot;/containers/&quot;+containerID+&quot;/start&quot;, query, nil, nil)</code>，然后 Daemon 调用 <code>r.postContainersStart()</code>启动容器。</p><h2 id="Docker-Daemon-整体启动过程"><a href="#Docker-Daemon-整体启动过程" class="headerlink" title="Docker Daemon 整体启动过程"></a>Docker Daemon 整体启动过程</h2><h3 id="func-main"><a href="#func-main" class="headerlink" title="func main()"></a>func main()</h3><p>和 Docker Client 一样，Docker Daemon 的入口函数也是 <code>func main()</code>，位于 <code>cmd/dockerd/docker.go: 71</code></p><img src="https://images.961110.xyz/images/2021/11/21/Docker-Daemon-1fc84a77d77879d9.png" style="zoom: 33%;" /><p>在 <a href="https://blog.961110.xyz/posts/64829.html">Docker源码分析（一）—— docker run 命令在 Docker Client 中的执行</a> 一文中提到过，Docker 利用 Cobra 这个命令行库构建了各种 Docker 命令，所以 Daemon 在执行命令的时候同样需要构建一个命令执行对象也就是图中 <code>cmd, err := newDaemonCommand()</code> 这一句，设置好各种参数和命令上述，然后去执行。</p><p>在<code>newDaemonCommand()</code>这个函数创建了一个<code>cobra.Command</code>的对象，在创建的时候绑定了一个匿名函数，函数里调用了<code>runDaemon()</code>函数，这个函数是待会儿要重点分析的函数。</p><p>如果没有猜错的话，绑定的那个匿名函数会在<code>cmd.Execute()</code>的时候被调用，从而接受 Docker Client 的各种请求。</p><p><code>runDaemon()</code>函数的实现只有两行，但是扮演了重要的角色。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runDaemon</span><span class="params">(opts *daemonOptions)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   daemonCli := NewDaemonCli()</span><br><span class="line">   <span class="keyword">return</span> daemonCli.start(opts)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NewDaemonCli"><a href="#NewDaemonCli" class="headerlink" title="NewDaemonCli()"></a>NewDaemonCli()</h3><p>函数实现</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDaemonCli</span><span class="params">()</span> *<span class="title">DaemonCli</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;DaemonCli&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单纯就是创建一个 DaemonCli 对象，其包含的数据有</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> DaemonCli <span class="keyword">struct</span> &#123;</span><br><span class="line">*config.Config<span class="comment">// 配置信息</span></span><br><span class="line">configFile *<span class="keyword">string</span><span class="comment">// 配置文件</span></span><br><span class="line">flags      *pflag.FlagSet<span class="comment">// 参数信息</span></span><br><span class="line"></span><br><span class="line">api             *apiserver.Server<span class="comment">// APIServer</span></span><br><span class="line">d               *daemon.Daemon<span class="comment">// daemon对象</span></span><br><span class="line">authzMiddleware *authorization.Middleware <span class="comment">// authzMiddleware， enables to dynamically reload the authorization plugins，认证插件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中APIServer包含的数据有</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">cfg           *Config<span class="comment">//apiserver的配置信息</span></span><br><span class="line">servers       []*HTTPServer<span class="comment">//httpServer结构体对象，包括http.Server和net.Listener监听器。</span></span><br><span class="line">routers       []router.Router<span class="comment">//路由表对象Route,包括Handler,Method, Path</span></span><br><span class="line">routerSwapper *routerSwapper<span class="comment">//路由交换器对象，使用新的路由交换旧的路由器</span></span><br><span class="line">middlewares   []middleware.Middleware<span class="comment">//中间件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>daemonCli.start()</code>的实现过程中会发挥重要作用。</p><h3 id="daemonCli-start-opts"><a href="#daemonCli-start-opts" class="headerlink" title="daemonCli.start(opts)"></a>daemonCli.start(opts)</h3><p>没错，这个函数贼长，总的来说就是配置 Daemon 客户端、开启服务端的监听以便接受请求、获取 libcontainerd 的地址、初始化接受授请求的路由表、等待请求到来。</p><img src="https://images.961110.xyz/images/2021/11/21/DaemonCli.starte849a93c2dbd7894.png" style="zoom:33%;" /><p><code>preNotifySystem()</code>的实现是空的，不知道为什么会有这么一个调用存在。</p><p>在创建 Daemon 对象的时候（<code>daemon.NewDaemon()</code>），会对网络进行初始化，包括网络控制器和三个内质网络（controller、none、bridge）</p><p>初始化路由表的部分非常关键，已经在 <a href="https://blog.961110.xyz/posts/19054.html#initRouter-opts-routerOptions">Docker源码分析（二）—— docker run 命令在 Docker Daemon中的执行</a> 已经分析过了，可以跳转看一下。</p><p><code>notifySystem()</code>通知系统已经做好准备，可以接受请求了。</p><p><code>errAPI := &lt;-serveAPIWait</code>在等待 apiserver 执行出错，不出错就会阻塞到这里</p><p>下面就是执行出错后守卫的工作。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://www.cnblogs.com/wen123456/p/14187569.html">DOCKER源码分析2 docker daemon启动流程 - luoyuna - 博客园 (cnblogs.com)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 毕设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 毕设 </tag>
            
            <tag> Docker </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker源码分析（三）—— docker start 命令在 Docker Daemon中的执行</title>
      <link href="/posts/56133.html"/>
      <url>/posts/56133.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>博文分析的Docker源码基于19.03版本，阅读工具采用Goland，追踪的是<code>docker run</code>命令的执行过程。</p><p>第一次阅读Docker源码，如有纰漏还请轻喷，喷完希望能够通过邮件或者留言的方式指出问题。</p><p>限于篇幅以及关注重点的原因，部分个人认为不重要的代码会用省略号代替。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>照例还是先摆出 Docker 的架构，<strong>架构在心中，源码轻松读</strong>。</p><p>在上一篇博文中跟踪了 Docker Daemon 中创建容器的过程，下一步就是 Client 向 Daemon 发送容器启动命令，所以在这篇博文中跟踪的是 Daemon 启动容器的过程。</p><table>    <tr>        <td ><center><img src="https://images.961110.xyz/images/2021/11/16/docker-architecture.png" >图1  Docker 架构（官网图） </center></td>        <td ><center><img src="https://images.961110.xyz/images/2021/11/16/Docker.png"  >图2 Docker 架构图（分组件）</center></td>    </tr></table><p>在 Client 中调用<code>ContainerStart()</code>，向 Daemon 发送 <code>resp, err := cli.post(ctx, &quot;/containers/&quot;+containerID+&quot;/start&quot;, query, nil, nil)</code>，然后 Daemon 调用 <code>r.postContainersStart()</code>启动容器。</p><h2 id="Docker-Daemon-处理启动容器的请求流程"><a href="#Docker-Daemon-处理启动容器的请求流程" class="headerlink" title="Docker Daemon 处理启动容器的请求流程"></a>Docker Daemon 处理启动容器的请求流程</h2><p>上文提到 Dcoker Client 通过 REST API 与 Docker Daemon 进行交互，启动容器的请求是当然在 Daemon 中也有相应的路由逻辑，</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">router.NewPostRoute(<span class="string">&quot;/containers/&#123;name:.*&#125;/start&quot;</span>, r.postContainersStart)</span><br></pre></td></tr></table></figure><p><code>postContainersStart()</code>就是对应的处理函数。</p><h3 id="postContainersStart"><a href="#postContainersStart" class="headerlink" title="postContainersStart()"></a>postContainersStart()</h3><img src="https://images.961110.xyz/images/2021/11/19/postContainersStart.png" style="zoom:50%;" /><p>可以看出本函数主要是对 Client 传来的数据进行解析和校验，最后调用<code>s.backend.ContainerStart(vars[&quot;name&quot;], hostConfig, checkpoint, checkpointDir)</code>启动镜像，这里的<code>s.backend</code>同样是 Daemon 对象，<code>vars[&quot;name&quot;]</code>是容器名。</p><h3 id="ContainerStart"><a href="#ContainerStart" class="headerlink" title="ContainerStart()"></a>ContainerStart()</h3><img src="https://images.961110.xyz/images/2021/11/19/ContainerStart.png" style="zoom: 50%;" /><p>从上图可以看出，这个函数主要助兴了一些参数以及兼容性配置，最后调用<code>daemon.containerStart(container, checkpoint, checkpointDir, true)</code>准备容器运行所需的所有条件。</p><h3 id="containerStart"><a href="#containerStart" class="headerlink" title="containerStart()"></a>containerStart()</h3><p>daemon/start.go:102</p><img src="https://images.961110.xyz/images/2021/11/19/containerStart.png" alt="image-20211119193411476" style="zoom: 67%;" /><p>在这个函数中，挂载了基本文件系统（可读写层）、初始化了网络配置、创建了符合 OCI 标准的容器 spec、获取了 Libcontainerd 的配置，基于上述的条件 create 了容器，随后启动容器并设置容器的状态为 running。</p><p><code>daemon.containerd.Create()</code>中的<code>daemon.containerd</code>指的是 libcontainerd.client，让我们再回顾一下 Docker 的架构。</p><p><img src="https://images.961110.xyz/images/2021/11/16/Docker.png"></p><p>所以下面创建的过程已经到了 containerd 的层次了</p><p>下面继续跟进 <code>Create()</code> 的过程</p><h3 id="daemon-containerd-Create"><a href="#daemon-containerd-Create" class="headerlink" title="daemon.containerd.Create()"></a>daemon.containerd.Create()</h3><p>libcontainerd/remote/client.go: 127</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *client)</span> <span class="title">Create</span><span class="params">(ctx context.Context, id <span class="keyword">string</span>, ociSpec *specs.Spec, runtimeOptions <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   bdir := c.bundleDir(id)</span><br><span class="line">   c.logger.WithField(<span class="string">&quot;bundle&quot;</span>, bdir).WithField(<span class="string">&quot;root&quot;</span>, ociSpec.Root.Path).Debug(<span class="string">&quot;bundle dir created&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用传入的 spec 和 containerd 创建容器    </span></span><br><span class="line">   _, err := c.client.NewContainer(ctx, id,</span><br><span class="line">      containerd.WithSpec(ociSpec),</span><br><span class="line">      containerd.WithRuntime(runtimeName, runtimeOptions),</span><br><span class="line">      WithBundle(bdir, ociSpec),</span><br><span class="line">   )</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>c.client</code>指的是 containerd client。</p><p>目前为止，Docker Daemon 创建容器的部分已经结束，现在回过头去看怎么启动容器。</p><h3 id="Start"><a href="#Start" class="headerlink" title="Start()"></a>Start()</h3><p>libcontainerd/remote/client.go: 146</p><p>daemon/start.go:102 的 <code>containerStart()</code>函数创建完容器后，紧接着调用下面的代码启动容器。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pid, err := daemon.containerd.Start(context.Background(), container.ID, checkpointDir,</span><br><span class="line">   container.StreamConfig.Stdin() != <span class="literal">nil</span> || container.Config.Tty,</span><br><span class="line">   container.InitializeStdio)</span><br></pre></td></tr></table></figure><p><img src="https://images.961110.xyz/images/2021/11/19/Start.png" alt="image-20211119213607191"></p><p>在这个函数中，利用刚刚创建好的容器，根据其 ID 获取对应的容器，然后创建一个启动任务去启动容器。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Start create and start a task for the specified containerd id</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *client)</span> <span class="title">Start</span><span class="params">(ctx context.Context, id, checkpointDir <span class="keyword">string</span>, withStdin <span class="keyword">bool</span>, attachStdio libcontainerdtypes.StdioCallback)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 根据 ID 获取容器</span></span><br><span class="line">ctr, err := c.getContainer(ctx, id)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">cp             *types.Descriptor</span><br><span class="line">t              containerd.Task</span><br><span class="line">rio            cio.IO</span><br><span class="line">stdinCloseSync = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">spec, err := ctr.Spec(ctx)</span><br><span class="line">labels, err := ctr.Labels(ctx)</span><br><span class="line"></span><br><span class="line">bundle := labels[DockerContainerBundlePath]</span><br><span class="line">uid, gid := getSpecUser(spec)</span><br><span class="line">t, err = ctr.NewTask(ctx,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">string</span>)</span> <span class="params">(cio.IO, error)</span></span> &#123;</span><br><span class="line">fifos := newFIFOSet(bundle, libcontainerdtypes.InitProcessName, withStdin, spec.Process.Terminal)</span><br><span class="line"></span><br><span class="line">rio, err = c.createIO(fifos, id, libcontainerdtypes.InitProcessName, stdinCloseSync, attachStdio)</span><br><span class="line"><span class="keyword">return</span> rio, err</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(_ context.Context, _ *containerd.Client, info *containerd.TaskInfo)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">info.Checkpoint = cp</span><br><span class="line"><span class="keyword">if</span> runtime.GOOS != <span class="string">&quot;windows&quot;</span> &#123;</span><br><span class="line">info.Options = &amp;runctypes.CreateOptions&#123;</span><br><span class="line">IoUid:       <span class="keyword">uint32</span>(uid),</span><br><span class="line">IoGid:       <span class="keyword">uint32</span>(gid),</span><br><span class="line">NoPivotRoot: os.Getenv(<span class="string">&quot;DOCKER_RAMDISK&quot;</span>) != <span class="string">&quot;&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Make sure we set the runhcs options to debug if we are at debug level.</span></span><br><span class="line"><span class="keyword">if</span> c.logger.Level == logrus.DebugLevel &#123;</span><br><span class="line">info.Options = &amp;options.Options&#123;Debug: <span class="literal">true</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line">...</span><br><span class="line"><span class="comment">// Signal c.createIO that it can call CloseIO</span></span><br><span class="line"><span class="built_in">close</span>(stdinCloseSync)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := t.Start(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> _, err := t.Delete(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.logger.WithError(err).WithField(<span class="string">&quot;container&quot;</span>, id).</span><br><span class="line">Error(<span class="string">&quot;failed to delete task after fail start&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>, wrapError(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">int</span>(t.Pid()), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再往下追踪任务的创建和启动，也是通过发送 RPC 请求的方式与下层组件沟通</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *tasksClient)</span> <span class="title">Create</span><span class="params">(ctx context.Context, in *CreateTaskRequest, opts ...grpc.CallOption)</span> <span class="params">(*CreateTaskResponse, error)</span></span> &#123;</span><br><span class="line">out := <span class="built_in">new</span>(CreateTaskResponse)</span><br><span class="line">err := c.cc.Invoke(ctx, <span class="string">&quot;/containerd.services.tasks.v1.Tasks/Create&quot;</span>, in, out, opts...)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> out, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *tasksClient)</span> <span class="title">Start</span><span class="params">(ctx context.Context, in *StartRequest, opts ...grpc.CallOption)</span> <span class="params">(*StartResponse, error)</span></span> &#123;</span><br><span class="line">out := <span class="built_in">new</span>(StartResponse)</span><br><span class="line">err := c.cc.Invoke(ctx, <span class="string">&quot;/containerd.services.tasks.v1.Tasks/Start&quot;</span>, in, out, opts...)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> out, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>越看感觉越迷糊，也没有对应的文章可以学习，姑且分析到这里吧。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://www.cnblogs.com/wen123456/p/14187666.html">DOCKER源码分析5 daemon端对container start的处理 - luoyuna - 博客园 (cnblogs.com)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 毕设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 毕设 </tag>
            
            <tag> Docker </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker源码分析（二）—— docker run 命令在 Docker Daemon中的执行</title>
      <link href="/posts/19054.html"/>
      <url>/posts/19054.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>博文分析的Docker源码基于19.03版本，阅读工具采用Goland，追踪的是 docker run 命令的执行过程。</p><p>第一次阅读Docker源码，如有纰漏还请轻喷，喷完希望能够通过邮件或者留言的方式指出问题。</p><p>限于篇幅以及关注重点的原因，部分个人认为不重要的代码会用省略号代替。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>照例还是先摆出 Docker 的架构，<strong>架构在心中，源码轻松读</strong>。</p><p>在上一篇博文中跟踪了<code>docker run</code>命令在 Docker Client 的执行过程，于是就有了本篇博文———分析 <code>docker run</code>在 Docker Daemon 中的执行过程。</p><table>    <tr>        <td ><center><img src="https://images.961110.xyz/images/2021/11/16/docker-architecture.png" >图1  Docker 架构（官网图） </center></td>        <td ><center><img src="https://images.961110.xyz/images/2021/11/16/Docker.png"  >图2 Docker 架构图（分组件）</center></td>    </tr></table>上篇博文提到，在 Docker Client 中调用：`serverResp, err := cli.post(ctx, "/containers/create", query, body, nil)``resp, err := cli.post(ctx, "/containers/"+containerID+"/start", query, nil, nil)`两条语句向 Docker Daemon 发送创建容器和启动容器的请求，所以在本篇博文中将从如何处理`"/containers/create"`这个请求开始分析执行流程。<h2 id="Docker-Daemon-处理-Docker-Client-请求的过程"><a href="#Docker-Daemon-处理-Docker-Client-请求的过程" class="headerlink" title="Docker Daemon 处理 Docker Client 请求的过程"></a>Docker Daemon 处理 Docker Client 请求的过程</h2><p>从 Docker Client 发送的请求可以看出其使用 REST API 与 Docker Daemon 进行交互，那 Docker Daemon 中一定会有相应的路由逻辑，所以从初始化路由开始跟踪。</p><h3 id="initRouter-opts-routerOptions"><a href="#initRouter-opts-routerOptions" class="headerlink" title="initRouter(opts routerOptions)"></a>initRouter(opts routerOptions)</h3><p>这个函数的作用就是初始化路由逻辑。</p><p>向上追溯其调用链路：<code>initRouter(routerOptions)</code>&lt;–<code>daemonCli.start(opts)</code>&lt;–<code>runDaemon(opts)</code>&lt;–<code>newDaemonCommand()</code>&lt;–<code>main()</code>可以清楚得看出 Docker Daemon 创建 DaemonCommand 对象的过程中进行了路由的初始化，这个后面再分析，先追踪初始化路由的过程。</p><p><img src="https://images.961110.xyz/images/2021/11/18/initRouter.png" alt="image-20211118204241671"></p><p>源代码如下</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initRouter</span><span class="params">(opts routerOptions)</span></span> &#123;</span><br><span class="line"><span class="comment">// 获取容器解码器</span></span><br><span class="line">decoder := runconfig.ContainerDecoder&#123;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 创建各个组件的路由表</span></span><br><span class="line">routers := []router.Router&#123;</span><br><span class="line"><span class="comment">// we need to add the checkpoint router before the container router or the DELETE gets masked</span></span><br><span class="line">checkpointrouter.NewRouter(opts.daemon, decoder),</span><br><span class="line">container.NewRouter(opts.daemon, decoder),</span><br><span class="line">image.NewRouter(opts.daemon.ImageService()),</span><br><span class="line">systemrouter.NewRouter(opts.daemon, opts.cluster, opts.buildCache, opts.buildkit, opts.features),</span><br><span class="line">volume.NewRouter(opts.daemon.VolumesService()),</span><br><span class="line">build.NewRouter(opts.buildBackend, opts.daemon, opts.features),</span><br><span class="line">sessionrouter.NewRouter(opts.sessionManager),</span><br><span class="line">swarmrouter.NewRouter(opts.cluster),</span><br><span class="line">pluginrouter.NewRouter(opts.daemon.PluginManager()),</span><br><span class="line">distributionrouter.NewRouter(opts.daemon.ImageService()),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 根据设置好的路由表初始化apiServer的路由器</span></span><br><span class="line">opts.api.InitRouter(routers...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个函数中创建了一个路由表，包含 image, volume, container 等路由项，向下追踪 container 的路由项，看看 <code>container.NewRouter(opts.daemon, decoder)</code>是怎样执行的。</p><h3 id="NewRouter-b-Backend-decoder-httputils-ContainerDecoder"><a href="#NewRouter-b-Backend-decoder-httputils-ContainerDecoder" class="headerlink" title="NewRouter(b Backend, decoder httputils.ContainerDecoder)"></a>NewRouter(b Backend, decoder httputils.ContainerDecoder)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NewRouter initializes a new container router</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRouter</span><span class="params">(b Backend, decoder httputils.ContainerDecoder)</span> <span class="title">router</span>.<span class="title">Router</span></span> &#123;</span><br><span class="line">r := &amp;containerRouter&#123;</span><br><span class="line">backend: b,</span><br><span class="line">decoder: decoder,</span><br><span class="line">&#125;</span><br><span class="line">r.initRoutes()</span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个函数中创建了一个<code>containerRouter</code>的对象，其中<code>backend</code>就是<code>initRouter()</code>在调用时传入的<code>daemon.Daemon</code>对象。</p><p>继续看<code>initRoutes()</code>函数</p><h3 id="func-r-containerRouter-initRoutes"><a href="#func-r-containerRouter-initRoutes" class="headerlink" title="func (r *containerRouter) initRoutes()"></a>func (r *containerRouter) initRoutes()</h3><p>下面是这个函数完整的代码，可以看到 REST API 经典的 get, psot, put, delete 方法，后面跟着资源路径。 </p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// initRoutes initializes the routes in container router</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *containerRouter)</span> <span class="title">initRoutes</span><span class="params">()</span></span> &#123;</span><br><span class="line">r.routes = []router.Route&#123;</span><br><span class="line"><span class="comment">// HEAD</span></span><br><span class="line">router.NewHeadRoute(<span class="string">&quot;/containers/&#123;name:.*&#125;/archive&quot;</span>, r.headContainersArchive),</span><br><span class="line"><span class="comment">// GET</span></span><br><span class="line">router.NewGetRoute(<span class="string">&quot;/containers/json&quot;</span>, r.getContainersJSON),</span><br><span class="line">router.NewGetRoute(<span class="string">&quot;/containers/&#123;name:.*&#125;/export&quot;</span>, r.getContainersExport),</span><br><span class="line">router.NewGetRoute(<span class="string">&quot;/containers/&#123;name:.*&#125;/changes&quot;</span>, r.getContainersChanges),</span><br><span class="line">router.NewGetRoute(<span class="string">&quot;/containers/&#123;name:.*&#125;/json&quot;</span>, r.getContainersByName),</span><br><span class="line">router.NewGetRoute(<span class="string">&quot;/containers/&#123;name:.*&#125;/top&quot;</span>, r.getContainersTop),</span><br><span class="line">router.NewGetRoute(<span class="string">&quot;/containers/&#123;name:.*&#125;/logs&quot;</span>, r.getContainersLogs),</span><br><span class="line">router.NewGetRoute(<span class="string">&quot;/containers/&#123;name:.*&#125;/stats&quot;</span>, r.getContainersStats),</span><br><span class="line">router.NewGetRoute(<span class="string">&quot;/containers/&#123;name:.*&#125;/attach/ws&quot;</span>, r.wsContainersAttach),</span><br><span class="line">router.NewGetRoute(<span class="string">&quot;/exec/&#123;id:.*&#125;/json&quot;</span>, r.getExecByID),</span><br><span class="line">router.NewGetRoute(<span class="string">&quot;/containers/&#123;name:.*&#125;/archive&quot;</span>, r.getContainersArchive),</span><br><span class="line"><span class="comment">// POST</span></span><br><span class="line">router.NewPostRoute(<span class="string">&quot;/containers/create&quot;</span>, r.postContainersCreate),</span><br><span class="line">router.NewPostRoute(<span class="string">&quot;/containers/&#123;name:.*&#125;/kill&quot;</span>, r.postContainersKill),</span><br><span class="line">router.NewPostRoute(<span class="string">&quot;/containers/&#123;name:.*&#125;/pause&quot;</span>, r.postContainersPause),</span><br><span class="line">router.NewPostRoute(<span class="string">&quot;/containers/&#123;name:.*&#125;/unpause&quot;</span>, r.postContainersUnpause),</span><br><span class="line">router.NewPostRoute(<span class="string">&quot;/containers/&#123;name:.*&#125;/restart&quot;</span>, r.postContainersRestart),</span><br><span class="line">router.NewPostRoute(<span class="string">&quot;/containers/&#123;name:.*&#125;/start&quot;</span>, r.postContainersStart),</span><br><span class="line">router.NewPostRoute(<span class="string">&quot;/containers/&#123;name:.*&#125;/stop&quot;</span>, r.postContainersStop),</span><br><span class="line">router.NewPostRoute(<span class="string">&quot;/containers/&#123;name:.*&#125;/wait&quot;</span>, r.postContainersWait),</span><br><span class="line">router.NewPostRoute(<span class="string">&quot;/containers/&#123;name:.*&#125;/resize&quot;</span>, r.postContainersResize),</span><br><span class="line">router.NewPostRoute(<span class="string">&quot;/containers/&#123;name:.*&#125;/attach&quot;</span>, r.postContainersAttach),</span><br><span class="line">router.NewPostRoute(<span class="string">&quot;/containers/&#123;name:.*&#125;/copy&quot;</span>, r.postContainersCopy), <span class="comment">// Deprecated since 1.8, Errors out since 1.12</span></span><br><span class="line">router.NewPostRoute(<span class="string">&quot;/containers/&#123;name:.*&#125;/exec&quot;</span>, r.postContainerExecCreate),</span><br><span class="line">router.NewPostRoute(<span class="string">&quot;/exec/&#123;name:.*&#125;/start&quot;</span>, r.postContainerExecStart),</span><br><span class="line">router.NewPostRoute(<span class="string">&quot;/exec/&#123;name:.*&#125;/resize&quot;</span>, r.postContainerExecResize),</span><br><span class="line">router.NewPostRoute(<span class="string">&quot;/containers/&#123;name:.*&#125;/rename&quot;</span>, r.postContainerRename),</span><br><span class="line">router.NewPostRoute(<span class="string">&quot;/containers/&#123;name:.*&#125;/update&quot;</span>, r.postContainerUpdate),</span><br><span class="line">router.NewPostRoute(<span class="string">&quot;/containers/prune&quot;</span>, r.postContainersPrune),</span><br><span class="line">router.NewPostRoute(<span class="string">&quot;/commit&quot;</span>, r.postCommit),</span><br><span class="line"><span class="comment">// PUT</span></span><br><span class="line">router.NewPutRoute(<span class="string">&quot;/containers/&#123;name:.*&#125;/archive&quot;</span>, r.putContainersArchive),</span><br><span class="line"><span class="comment">// DELETE</span></span><br><span class="line">router.NewDeleteRoute(<span class="string">&quot;/containers/&#123;name:.*&#125;&quot;</span>, r.deleteContainers),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点关注一下这两行代码</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">router.NewPostRoute(<span class="string">&quot;/containers/create&quot;</span>, r.postContainersCreate)</span><br><span class="line">router.NewPostRoute(<span class="string">&quot;/containers/&#123;name:.*&#125;/start&quot;</span>, r.postContainersStart)</span><br></pre></td></tr></table></figure><p>第二个参数就是对应的处理函数，在这两个函数中分别做容器创建和启动的工作。</p><h2 id="Docker-Daemon-处理创建容器的请求流程"><a href="#Docker-Daemon-处理创建容器的请求流程" class="headerlink" title="Docker Daemon 处理创建容器的请求流程"></a>Docker Daemon 处理创建容器的请求流程</h2><h3 id="postContainersCreate"><a href="#postContainersCreate" class="headerlink" title="postContainersCreate"></a>postContainersCreate</h3><p>api/server/router/container/container_routes.go: 453</p><p>代码不是很复杂，只需要关注重点内容即可，主要是解析 client 传来的数据并根据版本进行相应的配置，然后创建容器，最后给 client 返回结果。</p><p><img src="https://images.961110.xyz/images/2021/11/18/postContainerCreate.png" alt="image-20211118204056283"></p><p>实现代码如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *containerRouter)</span> <span class="title">postContainersCreate</span><span class="params">(ctx context.Context, w http.ResponseWriter, r *http.Request, vars <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// 解析表单是否合法</span></span><br><span class="line"><span class="keyword">if</span> err := httputils.ParseForm(r); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查表达内容是否为JSON格式</span></span><br><span class="line"><span class="keyword">if</span> err := httputils.CheckForJSON(r); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从表单中获取名字（&quot;/container/create&quot;）</span></span><br><span class="line">name := r.Form.Get(<span class="string">&quot;name&quot;</span>)</span><br><span class="line"><span class="comment">// 获取 client 传过来的config, hostConfig, networkingConfig数据</span></span><br><span class="line">config, hostConfig, networkingConfig, err := s.decoder.DecodeConfig(r.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">version := httputils.VersionFromContext(ctx)</span><br><span class="line">adjustCPUShares := versions.LessThan(version, <span class="string">&quot;1.19&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据API版本号进行针对性配置</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据配置创建容器</span></span><br><span class="line">ccr, err := s.backend.ContainerCreate(types.ContainerCreateConfig&#123;</span><br><span class="line">Name:             name,</span><br><span class="line">Config:           config,</span><br><span class="line">HostConfig:       hostConfig,</span><br><span class="line">NetworkingConfig: networkingConfig,</span><br><span class="line">AdjustCPUShares:  adjustCPUShares,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给 client 返回创建的结果</span></span><br><span class="line"><span class="keyword">return</span> httputils.WriteJSON(w, http.StatusCreated, ccr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中出现的各个config主要是为了容器的可移植性，config 中包含了容器的基本信息：name、输入输出流等；host相关不可移植的保存在 HostConfig 中。</p><p>这个函数中需要关注的重点是这一段。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ccr, err := s.backend.ContainerCreate(types.ContainerCreateConfig&#123;</span><br><span class="line">Name:             name,</span><br><span class="line">Config:           config,</span><br><span class="line">HostConfig:       hostConfig,</span><br><span class="line">NetworkingConfig: networkingConfig,</span><br><span class="line">AdjustCPUShares:  adjustCPUShares,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>代码中的<code>s.backend</code>其实就是<code>daemon.Daemon</code>对象，参数就是用 client 传来的数据解析出的各个配置信息创建的<code>ContainerCreateConfig</code>对象</p><p>往下追踪调用的是这个函数</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(daemon *Daemon)</span> <span class="title">ContainerCreate</span><span class="params">(params types.ContainerCreateConfig)</span> <span class="params">(containertypes.ContainerCreateCreatedBody, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> daemon.containerCreate(createOpts&#123;</span><br><span class="line">params:                  params,</span><br><span class="line">managed:                 <span class="literal">false</span>,</span><br><span class="line">ignoreImagesArgsEscaped: <span class="literal">false</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>managed</code>和<code>ignoreImagesArgsEscaped</code>这两个参数的意思不详。</p><h3 id="containerCreate-opts-createOpts"><a href="#containerCreate-opts-createOpts" class="headerlink" title="containerCreate(opts createOpts)"></a>containerCreate(opts createOpts)</h3><p>daemon/create.go: 55</p><p><img src="https://images.961110.xyz/images/2021/11/18/containerCreate.png" alt="image-20211118204547389"></p><p>这个函数中主要是检验 config, hostconfig, networkingconfig 的合理性，进而正确地创建镜像。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(daemon *Daemon)</span> <span class="title">containerCreate</span><span class="params">(opts createOpts)</span> <span class="params">(containertypes.ContainerCreateCreatedBody, error)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">...</span><br><span class="line"><span class="comment">// // 验证HostConfig和Container Config之间的合法性</span></span><br><span class="line">warnings, err := daemon.verifyContainerSettings(os, opts.params.HostConfig, opts.params.Config, <span class="literal">false</span>)</span><br><span class="line">    </span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 验证NetworkingConfig的正确性，如client的配置中是否为一个容器创建时配置了超过1个network，查看IPAMConfig是否有效</span></span><br><span class="line">err = verifyNetworkingConfig(opts.params.NetworkingConfig)</span><br><span class="line">    </span><br><span class="line">...</span><br><span class="line"><span class="comment">// 调整HostConfig不正常的值，如CPUShares、Memory</span></span><br><span class="line">err = daemon.adaptContainerSettings(opts.params.HostConfig, opts.params.AdjustCPUShares)</span><br><span class="line">    </span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">container, err := daemon.create(opts)</span><br><span class="line">    </span><br><span class="line">....</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 返回运行结果</span></span><br><span class="line"><span class="keyword">return</span> containertypes.ContainerCreateCreatedBody&#123;ID: container.ID, Warnings: warnings&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步关注<code>container, err := daemon.create(opts)</code>这行代码，其返回了创建成功的容器。</p><h3 id="func-daemon-Daemon-create-opts-createOpts"><a href="#func-daemon-Daemon-create-opts-createOpts" class="headerlink" title="func (daemon *Daemon) create(opts createOpts)"></a>func (daemon *Daemon) create(opts createOpts)</h3><img src="https://images.961110.xyz/images/2021/11/18/docker-create.png" alt="docker  create" style="zoom: 33%;" /><p>在这个函数中创建容器进一步调用了<code>daemon.newContainer(opts.params.Name, os, opts.params.Config, opts.params.HostConfig, imgID, opts.managed)</code>创建容器，</p><p>其他的部分主要是为容器的运行做准备：</p><ul><li>找到容器所依赖的镜像ID，并根据镜像配置容器的运行 OS；</li><li>将用户传过来的容器 config 与所依赖镜像 JSON 文件描述的 config 进行合并并验证合法性</li><li>设置安全性选项</li><li>在挂载了 labels 后，创建可读写层</li><li>以 root uid gid的属性创建目录，并修改权限，在<code>/var/lib/docker/containers</code>目录下创建容器文件，并在容器文件下创建 checkpoints 目录</li><li>注册所有挂载到容器的数据卷</li><li>没有设置网络就设置 default 网络</li><li>在 /var/lib/docker/aufs/mnt目录下创建文件以及设置工作目录</li><li>更新网络设置</li><li>将 container 对象 json 化后写入到本地磁盘进行持久化</li><li>向 Docker Daemon 注册新 container</li></ul><h3 id="daemon-newContainer"><a href="#daemon-newContainer" class="headerlink" title="daemon.newContainer()"></a>daemon.newContainer()</h3><p>daemon/container.go: 130</p><p><img src="https://images.961110.xyz/images/2021/11/18/newContainer.png"></p><p>在这个函数中主要是为容器生成了 ID 和 name，创建了一个 basecontainer 对象，其本身也就是 container 结构体的对象，随后对 basecontainer 对象的一些属性进行初始化，最后返回 basecontainer。</p><p><strong>至此已经完成了对 container 对象的创建和初始化</strong>，目前整个的流程图如下。</p><p><img src="https://images.961110.xyz/images/2021/11/18/r.postContainersCreatede976bc83f5b619b.png" alt="r.postContainersCreate()"></p><p>最后在<code>postContainersCreate()</code>中的<code>return httputils.WriteJSON(w, http.StatusCreated, ccr)</code>，将结果返回给 Docker Client。在 Client 中一下步就是调用 ContainerStart()，向 Docker Daemon 发送 <code>resp, err := cli.post(ctx, &quot;/containers/&quot;+containerID+&quot;/start&quot;, query, nil, nil)</code>，然后 Docker Daemon 调用 <code>r.postContainersStart()</code>启动容器。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://www.cnblogs.com/wen123456/p/14187663.html">DOCKER源码分析4 daemon端对container create的处理 - luoyuna - 博客园 (cnblogs.com)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 毕设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 毕设 </tag>
            
            <tag> Docker </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker源码分析（一）—— docker run 命令在 Docker Client 中的执行</title>
      <link href="/posts/64829.html"/>
      <url>/posts/64829.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>博文分析的Docker源码基于19.03版本，阅读工具采用Goland，追踪的是 docker run 命令的执行过程。</p><p>第一次阅读Docker源码，如有纰漏还请轻喷，喷完希望能够通过邮件或者留言的方式指出问题。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><table>    <tr>        <td ><center><img src="https://images.961110.xyz/images/2021/11/16/docker-architecture.png" >图1  Docker 架构（官网图） </center></td>        <td ><center><img src="https://images.961110.xyz/images/2021/11/16/Docker.png"  >图2 Docker 架构图（分组件）</center></td>    </tr></table><p>Docker是一个典型的 C/S 架构，Docker Client作为直接与用户交互的一端，其作用是将用户的命令解析然后通过REST API传递给 Docker Daemon 执行（虽然真正执行的也不是 Docker Daemon）。</p><h2 id="docker-run-命令在-Docker-Client-中的执行"><a href="#docker-run-命令在-Docker-Client-中的执行" class="headerlink" title="docker run 命令在 Docker Client 中的执行"></a>docker run 命令在 Docker Client 中的执行</h2><p>Dcoker Client 作为 Docker 整个架构中的最前端，其主要作用就是和用户交互。当用户输入命令时，最终的执行是靠更下层的 Docker Daemon，所以分析的流程终结点就是找到如何解析用户命令并发给 Docker Daemon 以及获取响应。</p><h3 id="func-main"><a href="#func-main" class="headerlink" title="func main()"></a>func main()</h3><p>Docker Client 的入口函数是<code>func main()</code>， 在这个函数中主要做了以下几个工作：</p><ol><li>创建 Dcoker客户端 DockerCli 对象</li><li>根据 DockerCli 对象解析命令行参数，生成带有命令行参数以及客户端配置信息的 DcokerCommand 对象</li><li>根据输入参数 args 执行命令</li></ol><img src="https://images.961110.xyz/images/2021/11/16/Docker-Client-main.png" alt="image-20211117105757983" style="zoom: 67%;" /><p>核心的代码就两条</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cli\cmd\docker\docker.<span class="keyword">go</span>: <span class="number">285</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Dcoker客户端 DockerCli 对象</span></span><br><span class="line">dockerCli, err := command.NewDockerCli()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 DockerCli 对象解析命令行参数，生成带有命令行参数以及客户端配置信息的 DcokerCommand 命令行对象，执行命令</span></span><br><span class="line">err := runDocker(dockerCli)</span><br></pre></td></tr></table></figure><h3 id="command-NewDockerCli"><a href="#command-NewDockerCli" class="headerlink" title="command.NewDockerCli()"></a>command.NewDockerCli()</h3><p>主要作用是使用各种默认选项初始化一个 DockerCli，包括</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cli/command/cli.<span class="keyword">go</span>: <span class="number">490</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDockerCli</span><span class="params">(ops ...DockerCliOption)</span> <span class="params">(*DockerCli, error)</span></span> &#123;</span><br><span class="line">cli := &amp;DockerCli&#123;&#125;</span><br><span class="line">defaultOps := []DockerCliOption&#123;</span><br><span class="line">WithContentTrustFromEnv(),</span><br><span class="line">WithContainerizedClient(containerizedengine.NewClient),</span><br><span class="line">&#125;</span><br><span class="line">cli.contextStoreConfig = DefaultContextStoreConfig()</span><br><span class="line">ops = <span class="built_in">append</span>(defaultOps, ops...)</span><br><span class="line"><span class="keyword">if</span> err := cli.Apply(ops...); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> cli.out == <span class="literal">nil</span> || cli.in == <span class="literal">nil</span> || cli.err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 设置标准输入、输出、错误输出</span></span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cli, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="runDocker-dockerCli"><a href="#runDocker-dockerCli" class="headerlink" title="runDocker(dockerCli)"></a>runDocker(dockerCli)</h3><p>创建 DockerCommand 对象、解析参数、执行命令都是在这个函数中完成的。</p><img src="https://images.961110.xyz/images/2021/11/17/Docker-Client-runDocker.png" alt="image-20211117113448273" style="zoom:50%;" /><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cli\cmd\docker\docker.<span class="keyword">go</span>: <span class="number">249</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runDocker</span><span class="params">(dockerCli *command.DockerCli)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// 根据 DockerCli 对象解析命令行参数，生成带有命令行参数以及客户端配置信息的 DcokerCommand 命令行对象</span></span><br><span class="line">tcmd := newDockerCommand(dockerCli)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析全局 flags</span></span><br><span class="line">cmd, args, err := tcmd.HandleGlobalFlags()</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 完成全局选项解析并初始化docker客户端（tcmd结构体中带有 DockerCli 对象）</span></span><br><span class="line"><span class="keyword">if</span> err := tcmd.Initialize(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析参数别名</span></span><br><span class="line">args, os.Args, err = processAliases(dockerCli, cmd, args, os.Args)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 参数是否合法</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(args) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> _, _, err := cmd.Find(args); err != <span class="literal">nil</span> &#123;</span><br><span class="line">err := tryPluginRun(dockerCli, cmd, args[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">if</span> !pluginmanager.IsNotFound(err) &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cmd.SetArgs(args)</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 执行</span></span><br><span class="line"><span class="keyword">return</span> cmd.Execute()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中需要对两行重点代码进行分析：</p><ol><li><code>tcmd := newDockerCommand(dockerCli)</code></li><li><code>return cmd.Execute()</code></li></ol><h3 id="newDockerCommand-dockerCli"><a href="#newDockerCommand-dockerCli" class="headerlink" title="newDockerCommand(dockerCli)"></a>newDockerCommand(dockerCli)</h3><h4 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h4><p>Docker Client中使用 Cobra 这个命令行库构建 Docker 命令，其基本用法大概是四步：</p><ol><li>定义一个主命令（包含命令执行函数等）</li><li>定义若干子命令（包含命令执行函数等，根据需要可以为子命令定义子命令），并添加到主命令</li><li>为命令添加选项</li><li>执行命令</li></ol><p>其结构由三部分组成：命令 (commands)、参数 (arguments)、标志 (flags)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> URL --bare</span><br></pre></td></tr></table></figure><ul><li>git：主命令</li><li>clone：子命令</li><li>URL：参数，即 clone 作用的对象</li><li>–bare：标志</li></ul><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>直接在命令行输入<code>docker</code>看到的效果，就可以在下面的代码中找到对应的实现，不过这里看到的是 Docker Client 中实现的效果，想要看 Docker Daemon 中实现的效果可以输入 <code>sudo /usr/bin/dockerd -h</code></p><img src="https://images.961110.xyz/images/2021/11/17/docker-cobra.png" alt="image-20211117112841317" style="zoom: 50%;" /><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newDockerCommand</span><span class="params">(dockerCli *command.DockerCli)</span> *<span class="title">cli</span>.<span class="title">TopLevelCommand</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">cmd := &amp;cobra.Command&#123;</span><br><span class="line">Use:              <span class="string">&quot;docker [OPTIONS] COMMAND [ARG...]&quot;</span>,</span><br><span class="line">Short:            <span class="string">&quot;A self-sufficient runtime for containers&quot;</span>,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">opts, flags, helpCmd = cli.SetupRootCommand(cmd)</span><br><span class="line">...</span><br><span class="line">cmd.SetOutput(dockerCli.Out())</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 将 run、build 等一些命令的执行函数添加到 commands 中</span></span><br><span class="line">commands.AddCommands(cmd, dockerCli)</span><br><span class="line">...</span><br><span class="line"><span class="comment">// flags must be the top-level command flags, not cmd.Flags()</span></span><br><span class="line"><span class="keyword">return</span> cli.NewTopLevelCommand(cmd, dockerCli, opts, flags)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中需要关注的是<code>commands.AddCommands(cmd, dockerCli)</code>，在这个函数中会添加所有子命令以及子命令的选项，比如 run, build, image 等</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddCommands</span><span class="params">(cmd *cobra.Command, dockerCli command.Cli)</span></span> &#123;</span><br><span class="line">cmd.AddCommand(</span><br><span class="line">...</span><br><span class="line"><span class="comment">// container</span></span><br><span class="line">container.NewContainerCommand(dockerCli),</span><br><span class="line">container.NewRunCommand(dockerCli),</span><br><span class="line"></span><br><span class="line"><span class="comment">// image</span></span><br><span class="line">image.NewImageCommand(dockerCli),</span><br><span class="line">image.NewBuildCommand(dockerCli),</span><br><span class="line"></span><br><span class="line"><span class="comment">// builder</span></span><br><span class="line">builder.NewBuilderCommand(dockerCli),</span><br><span class="line">...</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> runtime.GOOS == <span class="string">&quot;linux&quot;</span> &#123;</span><br><span class="line"><span class="comment">// engine</span></span><br><span class="line">cmd.AddCommand(engine.NewEngineCommand(dockerCli))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中创建 <code>docker run</code> 命令的部分就是在<code>container.NewRunCommand()</code>函数中。</p><p>在使用 <code>docker run</code>命令时，就可以看到该函数实现的效果。</p><img src="https://images.961110.xyz/images/2021/11/17/image-20211117161046326.png" alt="image-20211117161046326" style="zoom:50%;" /><p>在<code>NewRunCommand()</code>中调用<code>runRun(dockerCli, cmd.Flags(), &amp;opts, copts)</code>，在这个函数中会解析参数并生成容器的配置，调用<code>runContainer(dockerCli, ropts, copts, containerConfig)</code>函数。</p><p>调用流程图如下</p><img src="https://images.961110.xyz/images/2021/11/17/runContainer.png" alt="image-20211117160902172" style="zoom: 67%;" /><h3 id="runContainer"><a href="#runContainer" class="headerlink" title="runContainer()"></a>runContainer()</h3><p>cli/command/container/run.go: 93</p><p>从这个函数中可以看出，<code>docker run</code>其实执行了两个核心的步骤：</p><ol><li>创建容器：<code>createResponse, err := createContainer(ctx, dockerCli, containerConfig, &amp;opts.createOptions)</code></li><li>启动容器：<code>err := client.ContainerStart(ctx, createResponse.ID, types.ContainerStartOptions&#123;&#125;)</code></li></ol><img src="https://images.961110.xyz/images/2021/11/17/runContainerb3382fc06811dffe.png" alt="image-20211117210548863" style="zoom:67%;" /><p>下面跟踪一下这两个函数。</p><h3 id="createContainer"><a href="#createContainer" class="headerlink" title="createContainer"></a>createContainer</h3><p>cli/command/container/create.go: 178</p><img src="https://images.961110.xyz/images/2021/11/17/createContainer.png" alt="image-20211117211323919" style="zoom:50%;" /><p>这个函数中需要重点关注的是红色字体的这个函数调用，它向 Docker Daemon 发送 post 请求：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">serverResp, err := cli.post(ctx, <span class="string">&quot;/containers/create&quot;</span>, query, body, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>请求创建容器并获取 Server 的响应。</p><h3 id="ContainerStart"><a href="#ContainerStart" class="headerlink" title="ContainerStart"></a>ContainerStart</h3><p>github.com/docker/docker/client/container_start.go: 11</p><p>这个函数比较简短，直接上代码。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *Client)</span> <span class="title">ContainerStart</span><span class="params">(ctx context.Context, containerID <span class="keyword">string</span>, options types.ContainerStartOptions)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">query := url.Values&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(options.CheckpointID) != <span class="number">0</span> &#123;</span><br><span class="line">query.Set(<span class="string">&quot;checkpoint&quot;</span>, options.CheckpointID)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(options.CheckpointDir) != <span class="number">0</span> &#123;</span><br><span class="line">query.Set(<span class="string">&quot;checkpoint-dir&quot;</span>, options.CheckpointDir)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resp, err := cli.post(ctx, <span class="string">&quot;/containers/&quot;</span>+containerID+<span class="string">&quot;/start&quot;</span>, query, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">ensureReaderClosed(resp)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样是向 Docker Daemon 发送 post 请求，这次请求的是启动容器</p><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>Docker Client 向 Docker Daemon 发送了创建容器、启动容器的请求，Docker Client 这一端的需要关注的执行流基本结束，下面就是跟踪 Docker Daemon 中的执行流。</p><p>在cmd/docker/docker.go文件的<code>runDocker()</code>函数末尾有<code>return cmd.Execute()</code>这一行代码，所处的位置如图示</p><img src="https://images.961110.xyz/images/2021/11/17/cmd.Execute.png" alt="image-20211117213550937" style="zoom:50%;" /><p>追踪其调用流，跟踪到了<code>github.com/spf13/cobra/command.go</code>文件的<code>execute()</code>函数，已经到了第三方库中，函数执行的过程大致是三个阶段：</p><ol><li>c.preRun()</li><li>c.Run(c, argWoFlags)</li><li>c.PostRun(c, argWoFlags)</li></ol><p>具体执行没有继续深入，结合 cobra 的命令结果，猜测可能是因为其命令结构是树形的，所以有先后执行关系，进而有了以上三个阶段</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://www.cnblogs.com/wen123456/p/14187555.html">DOCKER源码分析1 docker client命令行执行流程 - luoyuna - 博客园 (cnblogs.com)</a></li><li><a href="https://www.jianshu.com/p/63dd2075eb22">Golang | 使用 Cobra 构建命令行工具 - 简书 (jianshu.com)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 毕设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 毕设 </tag>
            
            <tag> Docker </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker架构</title>
      <link href="/posts/4242.html"/>
      <url>/posts/4242.html</url>
      
        <content type="html"><![CDATA[<h2 id="Docker-架构及组件作用"><a href="#Docker-架构及组件作用" class="headerlink" title="Docker 架构及组件作用"></a>Docker 架构及组件作用</h2><p><img src="https://images.961110.xyz/images/2021/11/11/Docker.png" alt="Docker组件"></p><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p>OCI现在有两个标准：</p><ul><li>the Runtime Specification (runtime-spec) ，指出如何运行已经解压到disk上的filesystem bundle</li><li>the Image Specification (image-spec)</li></ul><p>都是为了兼容性和可移植的特性。其中runc就是一种runtime spec的实现。</p><h3 id="bundle"><a href="#bundle" class="headerlink" title="bundle"></a>bundle</h3><p><code>filesystem bundle</code> 就是一个目录，提供 config.json 文件和 rootfs 文件系统</p><h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><p>config 描述了当前容器的配置: OCI 版本，启动程序路径与参数，挂载哪些文件系统，平台相关的比如 cgroup, namespaces, cpu quota 等等</p><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>runc 启动的容器，都会把状态文件 state.json 存到一个地方，默认路径是 <code>/run/runc/$&#123;container_id&#125;</code>，通过 <code>runc state</code> 获取的状态来自于这个文件</p><p><code>runc run</code> 根据提供的 filesystem bundle 生成创建容器所需要各种配置，然后创建子进程 <code>runc init</code>，同时父进程 <code>runc run</code> 设置子进程 <code>runc init</code> 的 cgroup, namespaces 等等。子进程 <code>runc init</code> 也要做一部份容器内的初始化，比如创建网络接口路由等等，最后 <code>runc init</code> 系统调用 <code>exec</code> 执行真正的 cmd，而 <code>runc run</code> 退出后，cmd 进程要么由操作系统 1 号进程接管，要么在 docker 环境中被 <code>containerd-shim</code> 接管。</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p><code>$GOPATH\src\github.com\docker\docker\</code>项目的结构组成</p><ul><li>api：定义 API，使用了 Swagger2.0 这个工具来生成 API，配置文件在api/swagger.yaml</li><li>builder：用来 build docker 镜像的包，看来历史比较悠久了</li><li>cli：使用 cobra 工具生成的 docker 客户端命令行解析器。</li><li>client：接收cli的请求，调用 RESTful API 中的接口，向 server 端发送 http 请求。</li><li>cmd：其中包括docker和dockerd两个包，他们分别包含了客户端和服务端的 main 函数入口。</li><li>container：容器的配置管理，对不同的 platform 适配。</li><li>contrib：这个目录包括一些有用的脚本、镜像和其他非 docker core 中的部分。</li><li>daemon：这个包中将 docker deamon 运行时状态 expose 出来。</li><li>distribution：负责 docker 镜像的 pull、push 和镜像仓库的维护。</li><li>dockerversion：编译的时候自动生成的。</li><li>docs：文档。这个目录已经不再维护，文档在另一个仓库里。</li><li>errdefs: 一些常见的错误</li><li>hack：创建 docker 开发环境和编译打包时用到的脚本和配置文件。</li><li>image：用于构建 docker 镜像的。</li><li>integration: 集成测试</li><li>integration-cli：集成测试</li><li>internal: </li><li>layer：管理 union file system driver 上的 read-only 和 read-write mounts。</li><li>libcontainerd：访问内核中的容器系统调用。</li><li>oci：Open Container Interface 库</li><li>opts：命令行的选项库。</li><li>man：生成 man pages。</li><li>migrate：将老版本的 graph 目录转换成新的 metadata。</li><li>patches: </li><li>pkg：</li><li>plugin：docker 插件后端实现包。</li><li>profiles：里面有 apparmor 和 seccomp 两个目录。用于内核访问控制。</li><li>project：项目管理的一些说明文档。</li><li>reference：处理 docker store 中镜像的 reference。</li><li>registry：docker registry 的实现。</li><li>reports: </li><li>restartmanager：处理重启后的动作。</li><li>rootless: </li><li>runconfig：配置格式解码和校验。</li><li>vendor：各种依赖包。</li><li>volume：docker volume 的实现。</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://jimmysong.io/blog/docker-source-code-analysis-code-structure/">Docker源码分析第一篇——代码结构</a></li><li><a href="https://www.jianshu.com/p/b448b4db9c5c">docker 学习笔记1：什么是 runc</a></li><li><a href="https://www.jianshu.com/p/5ca02db248ee">Containerd到底是干啥的？</a></li><li><a href="https://blog.csdn.net/qq_34556414/article/details/112247223">组件组成：剖析 Docker 组件作用及其底层工作原理</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 毕设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 毕设 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 10 通过以太网共享WiFi网络</title>
      <link href="/posts/14412.html"/>
      <url>/posts/14412.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>宿舍上传速度太慢，想要把硬盘数据备份到云端网盘，只能把NAS搬到实验室。但是实验室没有网线接口，只能通过带网口的拓展坞共享网络给NAS。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="开启共享"><a href="#开启共享" class="headerlink" title="开启共享"></a>开启共享</h3><p>如图示进入适配器配置页面</p><img src="https://images.961110.xyz/images/2021/11/09/a4ab00b80f7175e00c8ec195afac8297.png" alt="image-20211109164126283" style="zoom: 50%;" /><p>开启WLAN的共享，以太网3就是拓展坞里的网卡。开启之后，WLAN后会多“共享的”这几个字</p><img src="https://images.961110.xyz/images/2021/11/09/WLAN.png" alt="image-20211109164252170" style="zoom:50%;" /><h3 id="配置中转网卡"><a href="#配置中转网卡" class="headerlink" title="配置中转网卡"></a>配置中转网卡</h3><p>如图示进入以太网3的IP配置页面</p><p>IP和子网掩码都是自动填好的，DNS服务器要设置成和WLAN一样的。</p><img src="https://images.961110.xyz/images/2021/11/09/e4da94844f916fd700d4583067137e18.png" alt="image-20211109164526100" style="zoom:50%;" /><img src="https://images.961110.xyz/images/2021/11/09/WLAN-DNSe4c505deeee6901a.png" alt="image-20211109165034807" style="zoom:50%;" /><h3 id="配置需要网络的机器"><a href="#配置需要网络的机器" class="headerlink" title="配置需要网络的机器"></a>配置需要网络的机器</h3><p>以Ubuntu为例，界面右上角打开有线设置（我这里用的是中文版，英文版相比读者应该也看得懂）</p><img src="https://images.961110.xyz/images/2021/11/09/Ubuntu-wired-setting.png" alt="image-20211109165156462" style="zoom:50%;" /><p>地址就写192.168.137.2-192.168.137.254之间随便一个，子网掩码写255.255.255.0，网关写192.168.137.1，DNS写Windows 10 WLAN的DNS服务器地址</p><img src="https://images.961110.xyz/images/2021/11/09/Ubuntu-IP.png" alt="image-20211109165412737" style="zoom:50%;" /><p>不出意外应该可以上网了。</p><blockquote><p>DNS服务器地址一定要配置，不然没有网！</p></blockquote><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="http://www.cqnu0001.com/article/89038.html">win10将WLAN网络共享给以太网 (cqnu0001.com)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Windows 10 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 10下为Powershell设置全局代理</title>
      <link href="/posts/38820.html"/>
      <url>/posts/38820.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>使用 GoLand 阅读 Docker 源码的时候，缺少一些必要的依赖包，需要自己下载，所以要自己安装，但是不出意外的超时了。</p><h2 id="设置方法"><a href="#设置方法" class="headerlink" title="设置方法"></a>设置方法</h2><p>打开Powershell终端，输入</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">env:HTTP_PROXY=<span class="string">&quot;http://127.0.0.1:端口&quot;</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash">env:HTTPS_PROXY=<span class="string">&quot;http://127.0.0.1:端口</span></span></span><br></pre></td></tr></table></figure><p>其中端口是本地代理软件设置的端口，Clash是7890。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://blog.csdn.net/weixin_44120025/article/details/110950434">WIN10给powershell设置全局代理</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 代理 </tag>
            
            <tag> Powershell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 免密提交</title>
      <link href="/posts/40815.html"/>
      <url>/posts/40815.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>毕设需要修改Docker代码，在fork后克隆到本地，修改后推送到github发现需要输入密码，所以有了这篇博文。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>将仓库克隆到本地时，使用的是http的方法，也就是</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/xxx/xxx.git</span><br></pre></td></tr></table></figure><p>所以应该改为ssh的方式，即</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:xxx/xxx.git</span><br></pre></td></tr></table></figure><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h4 id="免密push"><a href="#免密push" class="headerlink" title="免密push"></a>免密push</h4><ol><li><p>查看当前方式</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br><span class="line"></span><br><span class="line">origin  https://github.com/xxx/xxx.git (fetch)</span><br><span class="line">origin  https://github.com/xxx/xxx.git (push)</span><br></pre></td></tr></table></figure></li><li><p>移除当前远程仓库</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote rm origin</span></span><br></pre></td></tr></table></figure></li><li><p>添加新的远程仓库链接并查看是否改变</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote add origin git@github.com:xxx/xxx.git</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br><span class="line"></span><br><span class="line">origin  git@github.com:xxx/xxx.git (fetch)</span><br><span class="line">origin  git@github.com:xxx/xxx.git (push)</span><br></pre></td></tr></table></figure></li><li><p>在改动之后需要设置上游要跟踪的分支，与此同时会自动执行一次 git push 命令，</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push --set-upstream origin master</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="Permission-denied"><a href="#Permission-denied" class="headerlink" title="Permission denied"></a>Permission denied</h4><p>在上面一通操作完成后，如果在push的时候提示Permission </p><img src="https://images.961110.xyz/images/2021/11/02/git-push-permission-denied1df07a46f1a7bca9.png" alt="image-20211102150353591" style="zoom:67%;" /><p>需要重新生成秘钥</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa -C <span class="string">&quot;你的GitHub注册邮箱&quot;</span></span></span><br></pre></td></tr></table></figure><img src="https://images.961110.xyz/images/2021/11/02/3bbe8926552e1625fa534430761177dc.png" alt="image-20211102150112039" style="zoom: 50%;" /><p>复制公钥（文件的内容）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim /home/jason/.ssh/id_rsa.pub</span></span><br></pre></td></tr></table></figure><p>在Github个人设置页面，增加新的SSH key</p><img src="https://images.961110.xyz/images/2021/11/02/SSH-keys.png" alt="image-20211102150559897" style="zoom:50%;" /><p>title起一个名字，key填入刚刚复制的公钥。</p><img src="https://images.961110.xyz/images/2021/11/02/create-new-keydd12a7fe91d06071.png" alt="image-20211102150900313" style="zoom:50%;" /><p>不出意外应该可以免密推送了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://blog.csdn.net/yychuyu/article/details/80186783?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2.no_search_link">解决git push代码到github上一直提示输入用户名及密码的问题_码到成功-CSDN博客_git push 密码</a></li><li><a href="https://www.cnblogs.com/ckxlovejava/p/9707192.html">git@github.com: Permission denied (publickey). fatal: Could not read from remote repository. - ckx0709 - 博客园 (cnblogs.com)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Linux </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译Docker Engine源码的两种方法以及遇到的问题</title>
      <link href="/posts/21885.html"/>
      <url>/posts/21885.html</url>
      
        <content type="html"><![CDATA[<h2 id="前情梗概"><a href="#前情梗概" class="headerlink" title="前情梗概"></a>前情梗概</h2><p>Docker是前后端分离的架构，社区版本的Docker-CE前端部分由<a href="https://github.com/docker/cli">docker/cli: The Docker CLI</a>维护，后端部分由<a href="https://github.com/moby/moby">moby/moby: Moby Project</a>维护。从Docker 20.10 release版本开始，Docker Engine 和 Docker CLI单独从各自的项目编译。</p><p><img src="https://images.961110.xyz/images/2021/10/30/docker-ce-overview.jpg" alt="docker-ce-overview"></p><p>这次Docker Engine源码编译选择的是19.03的版本，通过两种方式进行了尝试：</p><ol><li>通过官方指定方式，使用docker-dev镜像在容器中编译；</li><li>本地构建编译环境，在本机中编译。</li></ol><h2 id="使用docker-dev镜像在容器中编译"><a href="#使用docker-dev镜像在容器中编译" class="headerlink" title="使用docker-dev镜像在容器中编译"></a>使用docker-dev镜像在容器中编译</h2><h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><p>因为是要在容器中编译，所以肯定先要安装好Docker，安装步骤可以参考<a href="https://docs.docker.com/engine/install/ubuntu/">官方文档</a>或者其他教程贴。</p><h3 id="克隆moby仓库并切换到相应分支"><a href="#克隆moby仓库并切换到相应分支" class="headerlink" title="克隆moby仓库并切换到相应分支"></a>克隆moby仓库并切换到相应分支</h3><p>克隆仓库</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/moby/moby.git</span></span><br></pre></td></tr></table></figure><p>查看所有分支</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -a</span></span><br><span class="line"></span><br><span class="line">* (HEAD detached at origin/19.03)</span><br><span class="line">  19.03</span><br><span class="line">  master</span><br><span class="line">  remotes/origin/1.12.x</span><br><span class="line">  remotes/origin/1.13.x</span><br><span class="line">  remotes/origin/17.03.x</span><br><span class="line">  remotes/origin/17.04.x</span><br><span class="line">  remotes/origin/17.05.x</span><br><span class="line">  remotes/origin/19.03</span><br><span class="line">  remotes/origin/20.10</span><br><span class="line">  remotes/origin/HEAD -&gt; origin/master</span><br><span class="line">  remotes/origin/docs</span><br><span class="line">  remotes/origin/master</span><br></pre></td></tr></table></figure><p>切换到对应分支</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout remotes/origin/19.03</span></span><br></pre></td></tr></table></figure><p>如果想要从当前分支另起一个分支</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b dry-run-test</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -a</span></span><br><span class="line"></span><br><span class="line">* dry-run-test</span><br><span class="line">  master</span><br><span class="line">  remotes/origin/1.12.x</span><br><span class="line">  remotes/origin/1.13.x</span><br><span class="line">  remotes/origin/17.03.x</span><br><span class="line">  remotes/origin/17.04.x</span><br><span class="line">  remotes/origin/17.05.x</span><br><span class="line">  remotes/origin/19.03</span><br><span class="line">  remotes/origin/20.10</span><br><span class="line">  remotes/origin/HEAD -&gt; origin/master</span><br><span class="line">  remotes/origin/docs</span><br><span class="line">  remotes/origin/dry-run-test</span><br><span class="line">  remotes/origin/master</span><br></pre></td></tr></table></figure><h3 id="清空所有现有镜像和容器"><a href="#清空所有现有镜像和容器" class="headerlink" title="清空所有现有镜像和容器"></a>清空所有现有镜像和容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker ps -a</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker system prune -a</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker images</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker rmi -f $(docker images -q -a -f dangling=<span class="literal">true</span>)</span></span><br></pre></td></tr></table></figure><h3 id="利用Dockerfile构建docker-dev镜像"><a href="#利用Dockerfile构建docker-dev镜像" class="headerlink" title="利用Dockerfile构建docker-dev镜像"></a>利用Dockerfile构建docker-dev镜像</h3><p>安装make工具</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install make</span><br></pre></td></tr></table></figure><p>在项目根目录直接输入</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make BIND_DIR=. shell</span></span><br></pre></td></tr></table></figure><p>在Makefile文件中对应执行的是</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">build: bundles</span></span><br><span class="line"><span class="variable">$(<span class="built_in">warning</span> The docker client CLI has moved to github.com/docker/cli. For a dev-test cycle involving the CLI, run:$&#123;\n&#125; DOCKER_CLI_PATH=/host/path/to/cli/binary make <span class="built_in">shell</span> $&#123;\n&#125; then change the cli <span class="built_in">and</span> compile into a binary at the same location.$&#123;\n&#125;)</span></span><br><span class="line">DOCKER_BUILDKIT=<span class="string">&quot;$&#123;DOCKER_BUILDKIT&#125;&quot;</span> docker build --build-arg=GO_VERSION $&#123;BUILD_APT_MIRROR&#125; $&#123;DOCKER_BUILD_ARGS&#125; $&#123;DOCKER_BUILD_OPTS&#125; -t <span class="string">&quot;<span class="variable">$(DOCKER_IMAGE)</span>&quot;</span> -f <span class="string">&quot;<span class="variable">$(DOCKERFILE)</span>&quot;</span> .</span><br></pre></td></tr></table></figure><p>大体意思是调用<code>docker build</code>依据设置的环境变量和的传入的参数遵从Dockerfile构建<code>docker-dev</code>镜像。</p><p>如果构成过程没有错误的话，终端输出的末尾应该会有如下的提示</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> =&gt; [dev  8/25] RUN update-alternatives --set iptables  /usr/sbin/iptables-legacy  || true  &amp;&amp; update-alternative  0.4s</span><br><span class="line"> =&gt; [dev  9/25] RUN pip3 install yamllint==1.16.0                                                                  5.7s</span><br><span class="line"> =&gt; [dev 10/25] COPY --from=dockercli     /build/ /usr/local/cli                                                   0.2s</span><br><span class="line"> =&gt; [dev 11/25] COPY --from=frozen-images /build/ /docker-frozen-images                                            0.7s</span><br><span class="line"> =&gt; [dev 12/25] COPY --from=swagger       /build/ /usr/local/bin/                                                  0.1s</span><br><span class="line">...</span><br><span class="line"> =&gt; [dev 22/25] COPY --from=rootlesskit   /build/ /usr/local/bin/                                                  0.1s</span><br><span class="line"> =&gt; [dev 23/25] COPY --from=vpnkit        /vpnkit /usr/local/bin/vpnkit.x86_64                                     0.2s</span><br><span class="line"> =&gt; [dev 24/25] COPY --from=proxy         /build/ /usr/local/bin/                                                  0.1s</span><br><span class="line"> =&gt; [dev 25/25] WORKDIR /go/src/github.com/docker/docker                                                           0.0s</span><br><span class="line"> =&gt; exporting to image                                                                                             7.1s</span><br><span class="line"> =&gt; =&gt; exporting layers                                                                                            7.1s</span><br><span class="line"> =&gt; =&gt; writing image sha256:1bc0901b7d2b1f958a24445ca93c73401a60e2f9e301255ea092002bb8c1c7b9                       0.0s</span><br><span class="line"> =&gt; =&gt; naming to docker.io/library/docker-dev:dry-run-test                                                         0.0s</span><br></pre></td></tr></table></figure><p>构建完成后可以先查看一下刚刚构建出的镜像</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~ docker image ls -a</span><br><span class="line">REPOSITORY   TAG            IMAGE ID       CREATED      SIZE</span><br><span class="line">docker-dev   dry-run-test   1bc0901b7d2b   2 days ago   2.07GB</span><br></pre></td></tr></table></figure><p>构建完成后也会有启动<code>docker-dev</code>的命令提示</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --rm -i --privileged  -e DOCKER_CROSSPLATFORMS -e BUILD_APT_MIRROR -e BUILDFLAGS -e KEEPBUNDLE -e DOCKER_BUILD_ARGS -e DOCKER_BUILD_GOGC -e DOCKER_BUILD_OPTS -e DOCKER_BUILD_PKGS -e DOCKER_BUILDKIT -e DOCKER_BASH_COMPLETION_PATH -e DOCKER_CLI_PATH -e DOCKER_DEBUG -e DOCKER_EXPERIMENTAL -e DOCKER_GITCOMMIT -e DOCKER_GRAPHDRIVER -e DOCKER_LDFLAGS -e DOCKER_PORT -e DOCKER_REMAP_ROOT -e DOCKER_STORAGE_OPTS -e DOCKER_TEST_HOST -e DOCKER_USERLANDPROXY -e DOCKERD_ARGS -e TEST_INTEGRATION_DIR -e TEST_SKIP_INTEGRATION -e TEST_SKIP_INTEGRATION_CLI -e TESTDEBUG -e TESTDIRS -e TESTFLAGS -e TESTFLAGS_INTEGRATION -e TESTFLAGS_INTEGRATION_CLI -e TEST_FILTER -e TIMEOUT -e VALIDATE_REPO -e VALIDATE_BRANCH -e VALIDATE_ORIGIN_BRANCH -e HTTP_PROXY -e HTTPS_PROXY -e NO_PROXY -e http_proxy -e https_proxy -e no_proxy -e VERSION -e PLATFORM -e DEFAULT_PRODUCT_LICENSE -e PRODUCT -v &quot;/home/jason/repos/moby-fork/.:/go/src/github.com/docker/docker/.&quot; -v &quot;/home/jason/repos/moby-fork/.git:/go/src/github.com/docker/docker/.git&quot; -v docker-dev-cache:/root/.cache    -t &quot;docker-dev:dry-run-test&quot; bash</span><br></pre></td></tr></table></figure><p>进入之后，可以看一下当前目录有哪些文件</p><img src="https://images.961110.xyz/images/2021/11/01/344dda91545cbed1cc59cf2daa90a848.png" alt="image-20211101111913141" style="zoom: 67%;" /><p>从镜像启动命令可以看出，实际是将主机的moby目录挂载到了当前路径。也就是说，如果在主机或者<code>docker-dev</code>中修改了代码，会同步修改。</p><h3 id="docker-dev环境"><a href="#docker-dev环境" class="headerlink" title="docker-dev环境"></a>docker-dev环境</h3><h4 id="docker-version"><a href="#docker-version" class="headerlink" title="docker version"></a>docker version</h4><p>初始环境中是没有docker engine的，需要自行编译</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@c17a2f34853b:/go/src/github.com/docker/docker# docker version</span><br><span class="line">Client:</span><br><span class="line"> Version:      17.06.2-ce</span><br><span class="line"> API version:  1.30</span><br><span class="line"> Go version:   go1.8.3</span><br><span class="line"> Git commit:   cec0b72</span><br><span class="line"> Built:        Tue Sep  5 19:57:21 2017</span><br><span class="line"> OS/Arch:      linux/amd64</span><br><span class="line"> Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</span><br></pre></td></tr></table></figure><h4 id="go-env"><a href="#go-env" class="headerlink" title="go env"></a>go env</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@9e6c8aab5a7f:/go/src/github.com/docker/docker# go env</span><br><span class="line">GO111MODULE=&quot;off&quot;</span><br><span class="line">GOARCH=&quot;amd64&quot;</span><br><span class="line">GOBIN=&quot;&quot;</span><br><span class="line">GOCACHE=&quot;/root/.cache/go-build&quot;</span><br><span class="line">GOENV=&quot;/root/.config/go/env&quot;</span><br><span class="line">GOEXE=&quot;&quot;</span><br><span class="line">GOFLAGS=&quot;&quot;</span><br><span class="line">GOHOSTARCH=&quot;amd64&quot;</span><br><span class="line">GOHOSTOS=&quot;linux&quot;</span><br><span class="line">GONOPROXY=&quot;&quot;</span><br><span class="line">GONOSUMDB=&quot;&quot;</span><br><span class="line">GOOS=&quot;linux&quot;</span><br><span class="line">GOPATH=&quot;/go&quot;</span><br><span class="line">GOPRIVATE=&quot;&quot;</span><br><span class="line">GOPROXY=&quot;https://goproxy.cn,direct&quot;</span><br><span class="line">GOROOT=&quot;/usr/local/go&quot;</span><br><span class="line">GOSUMDB=&quot;sum.golang.org&quot;</span><br><span class="line">GOTMPDIR=&quot;&quot;</span><br><span class="line">GOTOOLDIR=&quot;/usr/local/go/pkg/tool/linux_amd64&quot;</span><br><span class="line">GCCGO=&quot;gccgo&quot;</span><br><span class="line">AR=&quot;ar&quot;</span><br><span class="line">CC=&quot;gcc&quot;</span><br><span class="line">CXX=&quot;g++&quot;</span><br><span class="line">CGO_ENABLED=&quot;1&quot;</span><br><span class="line">GOMOD=&quot;&quot;</span><br><span class="line">CGO_CFLAGS=&quot;-g -O2&quot;</span><br><span class="line">CGO_CPPFLAGS=&quot;&quot;</span><br><span class="line">CGO_CXXFLAGS=&quot;-g -O2&quot;</span><br><span class="line">CGO_FFLAGS=&quot;-g -O2&quot;</span><br><span class="line">CGO_LDFLAGS=&quot;-g -O2&quot;</span><br><span class="line">PKG_CONFIG=&quot;pkg-config&quot;</span><br><span class="line">GOGCCFLAGS=&quot;-fPIC -m64 -pthread -fmessage-length=0 -fdebug-prefix-map=/tmp/go-build033151478=/tmp/go-build -gno-record-gcc-switches&quot;</span><br></pre></td></tr></table></figure><h3 id="编译docker-binary"><a href="#编译docker-binary" class="headerlink" title="编译docker binary"></a>编译docker binary</h3><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@c17a2f34853b:/go/src/github.com/docker/docker# hack/make.sh binary</span><br><span class="line"></span><br><span class="line">Removing bundles/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">---&gt;</span><span class="bash"> Making bundle: binary (<span class="keyword">in</span> bundles/binary)</span></span><br><span class="line">Building: bundles/binary-daemon/dockerd-dev</span><br><span class="line">GOOS=&quot;&quot; GOARCH=&quot;&quot; GOARM=&quot;&quot;</span><br><span class="line">Created binary: bundles/binary-daemon/dockerd-dev</span><br><span class="line">Copying nested executables into bundles/binary-daemon</span><br><span class="line"></span><br><span class="line">root@c17a2f34853b:/go/src/github.com/docker/docker#</span><br></pre></td></tr></table></figure><p>内容如下</p><img src="https://images.961110.xyz/images/2021/11/01/binary.png" alt="image-20211101115527967" style="zoom:67%;" /><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>在项目目录输入<code>make install</code>，会把刚刚编译生成的各个执行文件拷贝到<code>/usr/local/bin/</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@c17a2f34853b:/go/src/github.com/docker/docker# make install</span><br><span class="line">Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</span><br><span class="line">Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</span><br><span class="line">Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</span><br><span class="line">Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</span><br><span class="line">KEEPBUNDLE=1 hack/make.sh install-binary</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">---&gt;</span><span class="bash"> Making bundle: install-binary (<span class="keyword">in</span> bundles/install-binary)</span></span><br><span class="line">Installing dockerd to /usr/local/bin/</span><br><span class="line">Installing runc to /usr/local/bin/</span><br><span class="line">Installing containerd to /usr/local/bin/</span><br><span class="line">Installing ctr to /usr/local/bin/</span><br><span class="line">Installing containerd-shim to /usr/local/bin/</span><br><span class="line">Installing docker-proxy to /usr/local/bin/</span><br><span class="line">Installing docker-init to /usr/local/bin/</span><br><span class="line">Installing rootlesskit to /usr/local/bin/</span><br><span class="line">Installing rootlesskit-docker-proxy to /usr/local/bin/</span><br><span class="line">Installing dockerd-rootless.sh to /usr/local/bin/</span><br><span class="line">Installing vpnkit to /usr/local/bin/</span><br><span class="line"></span><br><span class="line">root@c17a2f34853b:/go/src/github.com/docker/docker#</span><br></pre></td></tr></table></figure><p>输入<code>dockerd &amp;</code>在后台启动dockerd（如果想要开启debug模式的话，加一个<code>-D</code>参数），然后输入<code>docker version</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@c17a2f34853b:/go/src/github.com/docker/docker# docker version</span><br><span class="line">DEBU[2021-11-01T04:00:11.890237855Z] Calling GET /_ping</span><br><span class="line">DEBU[2021-11-01T04:00:11.891512505Z] Calling GET /v1.30/version</span><br><span class="line">Client:</span><br><span class="line"> Version:      17.06.2-ce</span><br><span class="line"> API version:  1.30</span><br><span class="line"> Go version:   go1.8.3</span><br><span class="line"> Git commit:   cec0b72</span><br><span class="line"> Built:        Tue Sep  5 19:57:21 2017</span><br><span class="line"> OS/Arch:      linux/amd64</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Version:      dev</span><br><span class="line"> API version:  1.40 (minimum version 1.12)</span><br><span class="line"> Go version:   go1.13.15</span><br><span class="line"> Git commit:   e2b63fbe46</span><br><span class="line"> Built:        Mon Nov  1 03:53:11 2021</span><br><span class="line"> OS/Arch:      linux/amd64</span><br><span class="line"> Experimental: false</span><br><span class="line">root@c17a2f34853b:/go/src/github.com/docker/docker#</span><br></pre></td></tr></table></figure><p>可以看到刚刚编译好的dockerd已经运行起来了，版本也是我们的dev版。</p><p>可以用hello world这个检查镜像试试运行是否正常：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker run hello-world</span></span><br><span class="line"></span><br><span class="line">Unable to find image &#x27;hello-world:latest&#x27; locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">2db29710123e: Pull complete</span><br><span class="line">Digest: sha256:37a0b92b08d4919615c3ee023f7ddb068d12b8387475d64c622ac30f45c29c51</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line">INFO[2021-11-01T06:36:18.265460389Z] shim containerd-shim started                  address=&quot;unix:///run/containerd/s/92a66bf121c2fc3d2061a0e56a70ac73c148421caab878528d96b31a6cf23b24&quot; debug=false pid=912</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">INFO[2021-11-01T06:36:18.494924873Z] shim reaped                                   id=7f500aadff4b87ef747825e95a182bc00fe033dcacb4f976aa3b4fd8db98cea4</span><br><span class="line">INFO[2021-11-01T06:36:18.505731593Z] ignoring event                                module=libcontainerd namespace=moby topic=/tasks/delete type=&quot;*events.TaskDelete&quot;</span><br><span class="line">root@c17a2f34853b:/go/src/github.com/docker/docker#</span><br></pre></td></tr></table></figure><h3 id="使用docker-dev镜像编译遇到的问题"><a href="#使用docker-dev镜像编译遇到的问题" class="headerlink" title="使用docker-dev镜像编译遇到的问题"></a>使用docker-dev镜像编译遇到的问题</h3><p>在国内最主要的就是网络问题，其他的都好解决。</p><h4 id="从github克隆项目超时"><a href="#从github克隆项目超时" class="headerlink" title="从github克隆项目超时"></a>从github克隆项目超时</h4><p>终端输出没有记录到，不过这个问题和下面一个问题相同，都是因为被墙的原因。</p><h4 id="go-install超时"><a href="#go-install超时" class="headerlink" title="go install超时"></a>go install超时</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  moby git:(master) ✗ make build</span><br><span class="line">docker build  --build-arg=GO_VERSION  -f &quot;Dockerfile&quot; --target=final   -t &quot;docker-dev&quot; .</span><br><span class="line">[+] Building 873.7s (41/75)</span><br><span class="line">...</span><br><span class="line"> =&gt; CANCELED [dockercli 2/2] RUN --mount=type=cache,target=/root/.cache/go-build     --mount=type=cache,target=/  24.6s</span><br><span class="line">------</span><br><span class="line"><span class="meta"> &gt;</span><span class="bash"> [vndr 1/1] RUN --mount=<span class="built_in">type</span>=cache,target=/root/.cache/go-build     --mount=<span class="built_in">type</span>=cache,target=/go/pkg/mod         GOBIN=/build/ GO111MODULE=on go install <span class="string">&quot;github.com/LK4D4/vndr@v0.1.2&quot;</span>      &amp;&amp; /build/vndr --<span class="built_in">help</span>:</span></span><br><span class="line"><span class="meta"> &gt;</span><span class="bash"> <span class="comment">#49 24.73 go install: github.com/LK4D4/vndr@v0.1.2: github.com/LK4D4/vndr@v0.1.2: Get &quot;https://proxy.golang.org/github.com/%21l%21k4%21d4/vndr/@v/v0.1.2.info&quot;: dial tcp 172.217.160.81:443: connect: connection refused</span></span></span><br><span class="line">------</span><br><span class="line">------</span><br><span class="line"><span class="meta"> &gt;</span><span class="bash"> [shfmt 1/1] RUN --mount=<span class="built_in">type</span>=cache,target=/root/.cache/go-build     --mount=<span class="built_in">type</span>=cache,target=/go/pkg/mod         GOBIN=/build/ GO111MODULE=on go install <span class="string">&quot;mvdan.cc/sh/v3/cmd/shfmt@v3.0.2&quot;</span>      &amp;&amp; /build/shfmt --version:</span></span><br><span class="line"><span class="meta"> &gt;</span><span class="bash"> <span class="comment">#55 24.68 go install: mvdan.cc/sh/v3/cmd/shfmt@v3.0.2: mvdan.cc/sh/v3/cmd/shfmt@v3.0.2: Get &quot;https://proxy.golang.org/mvdan.cc/sh/v3/cmd/shfmt/@v/v3.0.2.info&quot;: dial tcp 172.217.160.81:443: connect: connection refused</span></span></span><br><span class="line">------</span><br><span class="line">executor failed running [/bin/sh -c GOBIN=/build/ GO111MODULE=on go install &quot;mvdan.cc/sh/v3/cmd/shfmt@$&#123;SHFMT_VERSION&#125;&quot;      &amp;&amp; /build/shfmt --version]: exit code: 1</span><br><span class="line">make: *** [Makefile:214: build] Error 1</span><br><span class="line">➜  moby git:(master) ✗</span><br></pre></td></tr></table></figure><h4 id="go无法找到mian模块"><a href="#go无法找到mian模块" class="headerlink" title="go无法找到mian模块"></a>go无法找到mian模块</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  moby git:(69f9c8c906) ✗ make BIND_DIR=. shell</span><br><span class="line"></span><br><span class="line">Makefile:157: The docker client CLI has moved to github.com/docker/cli. For a dev-test cycle involving the CLI, run:</span><br><span class="line"> DOCKER_CLI_PATH=/host/path/to/cli/binary make shell</span><br><span class="line"> then change the cli and compile into a binary at the same location.</span><br><span class="line"></span><br><span class="line">DOCKER_BUILDKIT=&quot;1&quot; docker build --build-arg=GO_VERSION  --build-arg=CROSS=false --target=dev -t &quot;docker-dev:HEAD&quot; -f &quot;Dockerfile&quot; .</span><br><span class="line">[+] Building 8.9s (30/68)</span><br><span class="line">...</span><br><span class="line">------</span><br><span class="line"><span class="meta"> &gt;</span><span class="bash"> [vndr 3/3] RUN PREFIX=/build ./install.sh vndr:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">42 3.016 + RM_GOPATH=0</span></span><br><span class="line"><span class="meta">#</span><span class="bash">42 3.016 + TMP_GOPATH=</span></span><br><span class="line"><span class="meta">#</span><span class="bash">42 3.016 + : /build</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#</span><span class="bash">42 6.332 + go build -buildmode=pie -v -o /build/vndr .</span></span><br><span class="line"><span class="meta">#</span><span class="bash">42 6.361 go: cannot find main module, but found .git/config <span class="keyword">in</span> /tmp/tmp.ZFV3RuyK4q/src/github.com/LK4D4/vndr</span></span><br><span class="line"><span class="meta">#</span><span class="bash">42 6.361       to create a module there, run:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">42 6.361       go mod init</span></span><br><span class="line">------</span><br><span class="line">executor failed running [/bin/sh -c PREFIX=/build ./install.sh $INSTALL_BINARY_NAME]: exit code: 1</span><br><span class="line">make: *** [Makefile:158: build] Error 1</span><br></pre></td></tr></table></figure><p>仿佛是因为<strong>GO111MODULE</strong>这个环境变量的问题，在Dockerfile将其配置为<code>off</code>之后就编译成功了。需要了解原理的话看最后的参考链接。</p><h4 id="文件不完整"><a href="#文件不完整" class="headerlink" title="文件不完整"></a>文件不完整</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">20 2.670 + url=https://download.docker.com/linux/static</span></span><br><span class="line"><span class="meta">#</span><span class="bash">20 2.670 + curl -Ls https://download.docker.com/linux/static/stable/x86_64/docker-17.06.2-ce.tgz</span></span><br><span class="line"><span class="meta">#</span><span class="bash">20 2.674 + tar -xz docker/docker</span></span><br><span class="line"><span class="meta">#</span><span class="bash">20 276.2</span></span><br><span class="line"><span class="meta">#</span><span class="bash">20 276.2 gzip: stdin: unexpected end of file</span></span><br><span class="line"><span class="meta">#</span><span class="bash">20 276.2 tar: Unexpected EOF <span class="keyword">in</span> archive</span></span><br><span class="line"><span class="meta">#</span><span class="bash">20 276.2 tar: Error is not recoverable: exiting now</span></span><br><span class="line">------</span><br><span class="line">executor failed running [/bin/sh -c PREFIX=/build ./install.sh $INSTALL_BINARY_NAME]: exit code: 2</span><br><span class="line">make: *** [Makefile:158: build] Error 1</span><br></pre></td></tr></table></figure><p>目测是下载docker-17.06.2-ce.tgz这个文件的时候没有下载完整，<code>make clean</code>后重新build一次。</p><h4 id="提示docker-client-CLI项目已经搬迁"><a href="#提示docker-client-CLI项目已经搬迁" class="headerlink" title="提示docker client CLI项目已经搬迁"></a>提示docker client CLI项目已经搬迁</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Makefile:157: The docker client CLI has moved to github.com/docker/cli. For a dev-test cycle involving the CLI, run:</span><br><span class="line"> DOCKER_CLI_PATH=/host/path/to/cli/binary make shell</span><br><span class="line"> then change the cli and compile into a binary at the same location.</span><br><span class="line"></span><br><span class="line">DOCKER_BUILDKIT=&quot;1&quot; docker build --build-arg=GO_VERSION  --build-arg=CROSS=false --target=dev -t &quot;docker-dev:dry-run-test&quot; -f &quot;Dockerfile&quot; .</span><br></pre></td></tr></table></figure><p>这个影响不大，是因为前后端分开维护的原因。可以自行编译CLI，<a href="https://github.com/moby/moby/blob/master/docs/contributing/set-up-dev-env.md">参考链接</a>，不编译也不影响。</p><h2 id="在本地配置环境进行编译"><a href="#在本地配置环境进行编译" class="headerlink" title="在本地配置环境进行编译"></a>在本地配置环境进行编译</h2><h3 id="安装依赖的库"><a href="#安装依赖的库" class="headerlink" title="安装依赖的库"></a>安装依赖的库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libbtrfs-dev</span><br><span class="line">sudo apt-get install libbtrfs0</span><br><span class="line">sudo apt-get install gcc</span><br><span class="line">sudo apt-get install pkg-config</span><br><span class="line">sudo apt-get install libdevmapper-dev</span><br></pre></td></tr></table></figure><h3 id="安装并配置GO开发环境"><a href="#安装并配置GO开发环境" class="headerlink" title="安装并配置GO开发环境"></a>安装并配置GO开发环境</h3><p>教程请移步其他博客。</p><h3 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h3><p>将<a href="https://github.com/moby/moby">moby的项目</a>克隆到<code>$GOPATH/src/github.com/docker/</code>目录下，并将moby更名为docker，也就是说docker源码的路径是<code>$GOPATH/src/github.com/docker/docker</code></p><img src="https://images.961110.xyz/images/2021/11/01/docker.png" alt="image-20211101170629004" style="zoom:67%;" /><h3 id="编译-1"><a href="#编译-1" class="headerlink" title="编译"></a>编译</h3><p>在docker源码目录下输入</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">VERSION=testbuild DOCKER_GITCOMMIT=1 ./hack/make.sh binary</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ul><li><code>VERSION=xxx</code>是指定构建后的docker版本，比如直接安装，会显示<code>18.09.3</code>，此处我们将版本命名为<code>testbuild</code>。</li><li>在编译指令中，你还可以选择储存引擎，只需要再命令前加上<code>DOCKER_GRAPHDRIVER=overlay2</code>就可以了</li><li>构建完成后，生成的二进制文件储存在<code>$GOPATH/src/github.com/docker/docker/bundles/binary-daemon</code>目录下，名字是<code>dockerd</code>。使用<code>ls -l</code>命令可以看到这里已经创建了软连接<code>dockerd -&gt; dockerd-testbuild</code></li></ul><h3 id="替换docker启动文件"><a href="#替换docker启动文件" class="headerlink" title="替换docker启动文件"></a>替换docker启动文件</h3><p>用生成的<code>dockerd</code>替换掉当前系统的docker启动文件。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 停止系统中正在运行的dockerd</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl stop docker</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">找到docker服务文件的位置</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl cat docker.service</span></span><br><span class="line"><span class="meta">#</span><span class="bash">输出的第一行就是docker.service的路径，修改ExecStart</span></span><br><span class="line">/lib/systemd/system/docker.service</span><br></pre></td></tr></table></figure><p>修改docker.service，找到<code>ExecStart=/usr/bin/dockerd xxx</code>，将其中的<code>/usr/bin.dockerd</code>替换成刚刚生成的二进制文件，也就是<code>$GOPATH/src/github.com/docker/docker/bundles/binary-daemon/dockerd</code></p><p><strong>注意</strong>：这里的<code>$GOPATH</code>要用绝对路径，每个人设置的路径是不同的。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $GOPATH</span><br></pre></td></tr></table></figure><h3 id="重载及启动docker服务"><a href="#重载及启动docker服务" class="headerlink" title="重载及启动docker服务"></a>重载及启动docker服务</h3><p>替换完成后，终端输入</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> systemctl daemon-reload</span></span><br></pre></td></tr></table></figure><p>重载完成后，就可以启动引擎了</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> systemctl start docker</span></span><br></pre></td></tr></table></figure><p>验证是否替换成功，执行<code>sudo docker version</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  binary-daemon docker version</span><br><span class="line">Client: Docker Engine - Community</span><br><span class="line"> Version:           20.10.10</span><br><span class="line"> API version:       1.40</span><br><span class="line"> Go version:        go1.16.9</span><br><span class="line"> Git commit:        b485636</span><br><span class="line"> Built:             Mon Oct 25 07:42:59 2021</span><br><span class="line"> OS/Arch:           linux/amd64</span><br><span class="line"> Context:           default</span><br><span class="line"> Experimental:      true</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Engine:</span><br><span class="line">  Version:          testbuild</span><br><span class="line">  API version:      1.40 (minimum version 1.12)</span><br><span class="line">  Go version:       go1.13.15</span><br><span class="line">  Git commit:       1</span><br><span class="line">  Built:            Fri Oct 29 11:14:50 2021</span><br><span class="line">  OS/Arch:          linux/amd64</span><br><span class="line">  Experimental:     false</span><br><span class="line"> containerd:</span><br><span class="line">  Version:          1.4.11</span><br><span class="line">  GitCommit:        5b46e404f6b9f661a205e28d59c982d3634148f8</span><br><span class="line"> runc:</span><br><span class="line">  Version:          1.0.2</span><br><span class="line">  GitCommit:        v1.0.2-0-g52b36a2</span><br><span class="line"> docker-init:</span><br><span class="line">  Version:          0.19.0</span><br><span class="line">  GitCommit:        de40ad0</span><br><span class="line">➜  binary-daemon</span><br></pre></td></tr></table></figure><p>可以看到Docker Engine已经替换成了刚刚编译的版本。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://ops.tips/blog/compiling-your-own-forked-docker-release/">Compiling and running your own forked Docker release | OpsTips</a></li><li><a href="https://github.com/moby/moby/blob/master/docs/contributing/set-up-dev-env.md">moby/set-up-dev-env.md at master · moby/moby (github.com)</a></li><li><a href="https://swayye.xyz/2019/09/03/%E5%88%A9%E7%94%A8go%E7%BC%96%E8%AF%91%E5%99%A8%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91docker/">利用go编译器源码编译docker | 一葉扁舟 (swayye.xyz)</a></li><li><a href="https://github.com/docker/docker-ce">docker/docker-ce: This repository is deprecated and will be archived (Docker CE itself is NOT deprecated) see the https://github.com/docker/docker-ce/blob/master/README.md</a></li><li><a href="https://github.com/docker/cli">docker/cli: The Docker CLI (github.com)</a></li><li><a href="https://github.com/moby/moby">moby/moby: Moby Project - a collaborative project for the container ecosystem to assemble container-based systems (github.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/374372749">GO111MODULE 是个啥？ - 知乎 (zhihu.com)</a></li><li><a href="https://www.a-programmer.top/2019/04/24/%E7%BC%96%E8%AF%91docker%E6%BA%90%E7%A0%81%E5%B9%B6%E7%94%B1%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%90%AF%E5%8A%A8docker/">编译docker源码并由二进制启动docker | 成长录-知行合一 (a-programmer.top)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 毕设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 毕设 </tag>
            
            <tag> Docker </tag>
            
            <tag> Docker源码编译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMware虚拟机使用主机代理</title>
      <link href="/posts/60538.html"/>
      <url>/posts/60538.html</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>虚拟机网页使用主机代理，<a href="https://blog.961110.xyz/posts/60538.html#%E7%A1%AE%E5%AE%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5">点击链接跳转</a></li><li>虚拟机终端使用主机代理，<a href="https://blog.961110.xyz/posts/60538.html#%E7%BB%88%E7%AB%AF%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE">点击链接跳转</a></li></ul></blockquote><h2 id="确定虚拟机网络连接"><a href="#确定虚拟机网络连接" class="headerlink" title="确定虚拟机网络连接"></a>确定虚拟机网络连接</h2><p>在虚拟机设置页面里面可以找到网络适配器的选项，常用的就是桥接和NAT模式。</p><p><img src="https://images.961110.xyz/images/2021/10/27/cfee8f430d38afc804c18db63639499e.png" alt="image-20211027133942723" style="zoom:50%;" /><img src="https://images.961110.xyz/images/2021/10/27/NAT.png" alt="image-20211027133902778" style="zoom: 67%;" /></p><p>我这里之前<a href="https://blog.961110.xyz/posts/5768.html">设置过静态IP</a>，所以沿用NAT模式。</p><p>当然也可以选择桥接模式，设置代理的方法都是一样的。</p><h2 id="确定网卡"><a href="#确定网卡" class="headerlink" title="确定网卡"></a>确定网卡</h2><p>打开虚拟网络编辑器，查看桥接或者NAT模式对应的网卡。</p><img src="https://images.961110.xyz/images/2021/10/24/gatewayIP.png" alt="image-20211024115756744" style="zoom:50%;" /><p>我这里用的是NAT模式，如下图可以看到使用的网卡是VMnet8</p><img src="https://images.961110.xyz/images/2021/10/27/4f92fbe9575fe10143b1e168a2e97967.png" alt="image-20211027140608855" style="zoom: 67%;" /><p>我这里用的是Clash for Windows</p><p>需要打开允许局域网（Allow LAN）的选项，端口的话默认7890就可以，有需要可以自行更改。</p><img src="https://images.961110.xyz/images/2021/10/27/clashforWindows.png" alt="image-20211027140244748" style="zoom:50%;" /><p>把光标移动到Clash for Windows页面允许局域网选项，页面下方会自动显示不同适配器对应的IP，VMnet8对应的192.168.74.1。</p><img src="https://images.961110.xyz/images/2021/10/27/IP.png" alt="image-20211027140822152" style="zoom:50%;" /><h2 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h2><h3 id="系统代理设置"><a href="#系统代理设置" class="headerlink" title="系统代理设置"></a>系统代理设置</h3><p>在虚拟机图形化界面的右上角进行网络设置。</p><img src="https://images.961110.xyz/images/2021/10/27/Ubuntu20.04.png" alt="image-20211027134307360" style="zoom:67%;" /><p>点击设置Network Proxy设置代理</p><img src="https://images.961110.xyz/images/2021/10/27/proxy-setting.png" alt="image-20211027141049935" style="zoom:50%;" /><p>代理服务器地址设置成VMnet8的IP，端口设置成Clash for Windows的端口</p><img src="https://images.961110.xyz/images/2021/10/27/Proxy.png" alt="image-20211027141222842" style="zoom:67%;" /><h3 id="终端代理设置"><a href="#终端代理设置" class="headerlink" title="终端代理设置"></a>终端代理设置</h3><p>我用的shell是zsh，编辑配置文件。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim ~/.zshrc</span><br></pre></td></tr></table></figure><p>增加的内容如下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> proxy</span></span><br><span class="line">proxy () &#123;</span><br><span class="line">  export http_proxy=&quot;http://192.168.74.1:7890&quot;</span><br><span class="line">  export https_proxy=$http_proxy</span><br><span class="line">  export socks5_proxy=&quot;http://192.168.74.1:7890&quot;</span><br><span class="line">  echo &quot;HTTP Proxy on&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> noproxy</span></span><br><span class="line">noproxy () &#123;</span><br><span class="line">  unset http_proxy</span><br><span class="line">  unset https_proxy</span><br><span class="line">  echo &quot;HTTP Proxy off&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>开启或者关闭代理</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  proxy</span><br><span class="line">HTTP Proxy on</span><br><span class="line">➜  noproxy</span><br><span class="line">HTTP Proxy off</span><br><span class="line">➜  Downloads</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl www.google.com -I</span><br></pre></td></tr></table></figure><p>返回状态为 200 说明设置成功。</p><p>如果用 bash，可以直接上面命令的 <code>~/.zshrc</code> 换成 <code>./.bash_profile</code></p><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>桥接模式直接将代理服务器设置成主机的IP即可。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://www.cnblogs.com/mysticbinary/p/14522644.html">zsh设置代理 - Mysticbinary - 博客园 (cnblogs.com)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Linux </tag>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux（树莓派）安装Frpc</title>
      <link href="/posts/29306.html"/>
      <url>/posts/29306.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>树莓派是用校园网联网的，如果长时间不联网就需要重新验证登录，届时IP也会跟着变化，所以是个比较麻烦的事情。</p><p>同样用笔记本开热点给树莓派用，每次连接分配给树莓派的IP也是不固定的。</p><p>如果是通过网线共享笔记本的网络，又比较繁琐，毕竟多拖了一根线。</p><p>之前看到了有大佬写了自动登录校园网的Python脚本，所以有了这边博文。总体的想法是利用大佬的脚本自动登录校园网，通过Frp实现内网穿透，如果发现树莓派IP变化后，可以通过穿透出来的VNC端口开启远程桌面，进而获得树莓派的新IP。</p><p>如果没有Frp服务器的同学，可以写一个脚本，在每次IP变化后通过发送邮件或其他方式获取IP，参考链接<a href="https://zhangshenjia.com/it/raspberry_pi/raspbian-ipmailer/">树莓派Raspbian开机自动发ip邮件的解决方案</a>。</p><h2 id="下载安装Frpc"><a href="#下载安装Frpc" class="headerlink" title="下载安装Frpc"></a>下载安装Frpc</h2><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p><a href="https://github.com/fatedier/frp/releases/tag/v0.38.0">Release v0.38.0 · fatedier/frp (github.com)</a></p><p>直接到Github项目的发布页下载好对应的版本即可。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>解压压缩包，将可执行文件和配置文件复制到相应目录</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">这里需要<span class="built_in">cd</span>到加压缩frp压缩包的文件位置，解压后会看到文件里有frpc的启动程序</span></span><br><span class="line">cd /home/pi/frp/</span><br><span class="line"></span><br><span class="line">sudo mkdir /usr/local/bin/frpc</span><br><span class="line">sudo cp frpc /usr/local/bin/frpc</span><br><span class="line"></span><br><span class="line">sudo mkdir /etc/frpc</span><br><span class="line">sudo cp frpc.ini /etc/frpc/frpc.ini</span><br></pre></td></tr></table></figure><p>修改systemd文件夹中<code>frpc.service</code>文件，</p><p>内容如下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Frp Client Service</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">User=nobody</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5s</span><br><span class="line">ExecStart=/usr/local/bin/frpc/frpc -c /etc/frpc/frpc.ini</span><br><span class="line">ExecReload=/usr/local/bin/frpc/frpc reload -c /etc/frpc/frpc.ini</span><br><span class="line">LimitNOFILE=1048576</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>将该文件复制到如下文件夹<code>/usr/lib/systemd/system/</code></p><h2 id="配置Frpc"><a href="#配置Frpc" class="headerlink" title="配置Frpc"></a>配置Frpc</h2><h3 id="修改Fprc配置"><a href="#修改Fprc配置" class="headerlink" title="修改Fprc配置"></a>修改Fprc配置</h3><p>如果服务端还没有配置好的，可以直接百度Fprs配置教程。</p><p>修改<code>/etc/frpc/frpc.ini</code>文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = xxx.xxx.xxx.xxx</span><br><span class="line">server_port = 7000</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> [SSH]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">type</span> = tcp</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> local_ip = 127.0.0.1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> local_port = 22</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> remote_port = 7002</span></span><br><span class="line"></span><br><span class="line">[raspberry-vnc]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 5900</span><br><span class="line">remote_port = 7005</span><br></pre></td></tr></table></figure><p>不建议穿透SSH端口，降低风险。</p><p>vnc服务的默认端口是5900，如果还没有开启VNC服务，可以到<a href="https://blog.961110.xyz/posts/59454.html#%E5%BC%80%E5%90%AFVNC">树莓派4B启动配置 | Jason’s Blog (961110.xyz)</a>开启VNC服务</p><h3 id="设置Frpc服务自启动"><a href="#设置Frpc服务自启动" class="headerlink" title="设置Frpc服务自启动"></a>设置Frpc服务自启动</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable frpc</span><br><span class="line">systemctl start frpc</span><br></pre></td></tr></table></figure><p>查看服务状态</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl status frpc</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://www.jianshu.com/p/41560282c302">frpc开机自启动 - 简书 (jianshu.com)</a></li><li><a href="https://blog.csdn.net/haostart_/article/details/110249574">自动登录武汉理工大学鉴湖宿舍校园网的方式-python及exe程序_haostart_的博客-CSDN博客</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> 教程 </tag>
            
            <tag> 配置 </tag>
            
            <tag> frp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 20.04 提示找不到 python</title>
      <link href="/posts/1027.html"/>
      <url>/posts/1027.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址 <a href="https://blog.csdn.net/GerZhouGengCheng/article/details/118468389">blog.csdn.net</a></p></blockquote><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>Ubuntu 20.04 Focal 默认自带 python3.8，但是根据指引，所有引用 python 的包必须显示指定 python3 或其他 python 版本。</p><p>Ubuntu 从 20.04 开始不再将 python 加入<code>PATH</code>环境变量，在编译安装一些软件会提示无法运行并提示找不到 python，然而 python3 已安装，需要额外重定向。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install python-is-python3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>或者手动创建 symlink</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ln -s /usr/bin/python3 /usr/bin/python</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>检查是否配置成功：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">whereis python</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Linux </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMware授权服务启动失败、ens33网卡没有IP地址解决方案</title>
      <link href="/posts/3687.html"/>
      <url>/posts/3687.html</url>
      
        <content type="html"><![CDATA[<h3 id="VMware授权服务启动失败"><a href="#VMware授权服务启动失败" class="headerlink" title="VMware授权服务启动失败"></a>VMware授权服务启动失败</h3><p>启动虚拟机报错，根据提示是因为授权服务未能成功启动。</p><img src="https://images.961110.xyz/images/2021/10/25/VMware.png" alt="image-20211025164644686" style="zoom: 67%;" /><p>右下角Windows搜索栏直接搜索服务，然后找到VMware Authorization Service，双击设置其启动类型为自动，应用，然后点击启动。</p><img src="https://images.961110.xyz/images/2021/10/25/VMware-Authorization-Service.png" alt="image-20211025165252791" style="zoom:50%;" /><p>这个时候应该可以启动虚拟机了。</p><h3 id="ens33网卡没有IP地址"><a href="#ens33网卡没有IP地址" class="headerlink" title="ens33网卡没有IP地址"></a>ens33网卡没有IP地址</h3><img src="https://images.961110.xyz/images/2021/10/25/ens33IP.png" alt="image-20211025165646238" style="zoom:50%;" /><p>跟上述原因相同，也有可能是因为VMware DHCP Service没有启动解决办法类似。</p><img src="https://images.961110.xyz/images/2021/10/25/IP.png" alt="image-20211025165851601" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Linux </tag>
            
            <tag> VMware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统更换软件源</title>
      <link href="/posts/32224.html"/>
      <url>/posts/32224.html</url>
      
        <content type="html"><![CDATA[<h3 id="明确自己的发行版本"><a href="#明确自己的发行版本" class="headerlink" title="明确自己的发行版本"></a>明确自己的发行版本</h3><p><strong>确保与自己的Linux分发版本一致</strong>，不然会出现下载的编译器版本<strong>不匹配问题</strong>。</p><p>有以下三种方法：</p><ol><li><p><code>lsb_release -a</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jason@ubuntu:/etc/apt$ lsb_release -a</span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID: Ubuntu</span><br><span class="line">Description:    Ubuntu 20.04.3 LTS</span><br><span class="line">Release:        20.04</span><br><span class="line">Codename:       focal</span><br></pre></td></tr></table></figure></li><li><p>查看配置文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jason@ubuntu:/etc/apt$ ls /etc/ | grep &quot;release&quot;</span><br><span class="line">lsb-release</span><br><span class="line">os-release</span><br><span class="line"></span><br><span class="line">jason@ubuntu:/etc/apt$ cat /etc/os-release</span><br><span class="line">NAME=&quot;Ubuntu&quot;</span><br><span class="line">VERSION=&quot;20.04.3 LTS (Focal Fossa)&quot;</span><br><span class="line">ID=ubuntu</span><br><span class="line">ID_LIKE=debian</span><br><span class="line">PRETTY_NAME=&quot;Ubuntu 20.04.3 LTS&quot;</span><br><span class="line">VERSION_ID=&quot;20.04&quot;</span><br><span class="line">HOME_URL=&quot;https://www.ubuntu.com/&quot;</span><br><span class="line">SUPPORT_URL=&quot;https://help.ubuntu.com/&quot;</span><br><span class="line">BUG_REPORT_URL=&quot;https://bugs.launchpad.net/ubuntu/&quot;</span><br><span class="line">PRIVACY_POLICY_URL=&quot;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy&quot;</span><br><span class="line">VERSION_CODENAME=focal</span><br><span class="line">UBUNTU_CODENAME=focal</span><br><span class="line"></span><br><span class="line">jason@ubuntu:/etc/apt$ cat /etc/lsb-release</span><br><span class="line">DISTRIB_ID=Ubuntu</span><br><span class="line">DISTRIB_RELEASE=20.04</span><br><span class="line">DISTRIB_CODENAME=focal</span><br><span class="line">DISTRIB_DESCRIPTION=&quot;Ubuntu 20.04.3 LTS&quot;</span><br></pre></td></tr></table></figure></li><li><p><code>cat /etc/issue</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jason@ubuntu:/etc/apt$ cat /etc/issue</span><br><span class="line">Ubuntu 20.04.3 LTS \n \l</span><br></pre></td></tr></table></figure></li></ol><h3 id="查找对应的软件源"><a href="#查找对应的软件源" class="headerlink" title="查找对应的软件源"></a>查找对应的软件源</h3><p>清华大学镜像源链接：<a href="https://mirrors.tuna.tsinghua.edu.cn/">清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a></p><p>直接搜索对应的发行版</p><img src="https://images.961110.xyz/images/2021/10/24/Ubuntu.png" alt="image-20211024164923972" style="zoom:50%;" /><p>进去之后就可以看到使用帮助，<strong>记得选择自己的Ubuntu版本</strong></p><img src="https://images.961110.xyz/images/2021/10/24/Ubuntu7357b30fc9ba54cb.png" alt="image-20211024164949010" style="zoom:50%;" /><p><strong>在 ARM(arm64, armhf)、PowerPC(ppc64el)、RISC-V(riscv64) 和 S390x 等架构的设备上（对应官方源为ports.ubuntu.com）请使用 <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/">ubuntu-ports 镜像</a>。</strong></p><h3 id="替换软件源配置文件内容"><a href="#替换软件源配置文件内容" class="headerlink" title="替换软件源配置文件内容"></a>替换软件源配置文件内容</h3><p><strong>备份！！！</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure><p>然后清空或者直接删除</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jason@ubuntu:/etc/apt$ sudo -i</span><br><span class="line">root@ubuntu:~# sudo cat /dev/null &gt; sources.list</span><br><span class="line">root@ubuntu:~# file sources.list</span><br><span class="line">sources.list: empty</span><br><span class="line">root@ubuntu:~# vim sources.list</span><br><span class="line">root@ubuntu:~# exit</span><br><span class="line">logout</span><br><span class="line">jason@ubuntu:/etc/apt$</span><br></pre></td></tr></table></figure><p>更新软件源镜像</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ol><li><a href="https://www.cnblogs.com/wojiatingting/p/6879084.html">Linux查看系统发行版本 - 星星&amp;之火 - 博客园 (cnblogs.com)</a></li><li><a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">ubuntu | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a></li><li><a href="https://www.jb51.net/article/100462.htm">Linux 中清空或删除大文件内容的五种方法_Linux_脚本之家 (jb51.net)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vmware虚拟机Ubuntu20.04.3 LTS设置静态IP并使用ssh连接</title>
      <link href="/posts/5768.html"/>
      <url>/posts/5768.html</url>
      
        <content type="html"><![CDATA[<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><ol><li><p>安装net-tools，解决<code>ifconfig</code>命令找不到的问题</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install net-tools</span><br></pre></td></tr></table></figure></li><li><p>安装openssh-server，开启ssh服务</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">   sudo apt-get install openssh-server</span><br><span class="line">   sudo service ssh start</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 设置静态IP</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 查看网关IP</span></span></span><br><span class="line"></span><br><span class="line">点击虚拟网络编辑器</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://images.961110.xyz/images/2021/10/24/gatewayIP.png&quot; alt=&quot;image-20211024115756744&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 查看网关IP以及DHCP范围</span></span></span><br><span class="line"></span><br><span class="line">查看网关IP</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://images.961110.xyz/images/2021/10/24/get-gateway-IP.png&quot; alt=&quot;image-20211024120112875&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">查看DHCP范围</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://images.961110.xyz/images/2021/10/24/DHCP-range.png&quot; alt=&quot;image-20211024120215689&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">将静态IP设置成范围之内的就可以，我选择192.168.74.222</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 设置静态IP</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">### 查看网卡信息</span></span></span><br><span class="line"></span><br><span class="line">输入`ifconfig`查看网卡的名称，可以看到是`ens33`</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://images.961110.xyz/images/2021/10/24/7ea2a1247790a95580b6056738221623.png&quot; alt=&quot;image-20211024120653533&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">与Ubuntu 16不同，在Ubuntu 18之后默认使用netplan来管理网络，配置文件是`yaml`文件</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">### 设置静态IP</span></span></span><br><span class="line"></span><br><span class="line">配置文件如下，**最好做一个备份**。</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">sudo vim /etc/netplan/01-network-manager-all.yaml</span><br></pre></td></tr></table></figure></li></ol><p>内容如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">network:</span></span><br><span class="line">  <span class="attr">version:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">renderer:</span> <span class="string">NetworkManager</span></span><br><span class="line">  <span class="attr">ethernets:</span></span><br><span class="line">    <span class="attr">ens33:</span></span><br><span class="line">      <span class="attr">dhcp4:</span> <span class="literal">no</span></span><br><span class="line">      <span class="attr">addresses:</span> [<span class="number">192.168</span><span class="number">.74</span><span class="number">.222</span><span class="string">/24</span>]</span><br><span class="line">      <span class="attr">gateway4:</span>  <span class="number">192.168</span><span class="number">.74</span><span class="number">.2</span></span><br><span class="line">      <span class="attr">nameservers:</span></span><br><span class="line">        <span class="attr">addresses:</span> [<span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>, <span class="number">114.114</span><span class="number">.114</span><span class="number">.114</span>]</span><br></pre></td></tr></table></figure><p><strong>缩进一定要对齐，且冒号之后要有一个空格。</strong></p><p>保存后，提交修改，使用<code>ifconfig</code>查看是否修改成功。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo netplan apply</span><br></pre></td></tr></table></figure><h2 id="使用ssh连接"><a href="#使用ssh连接" class="headerlink" title="使用ssh连接"></a>使用ssh连接</h2><h3 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h3><p>在首选项里可以设置虚拟机在VMware关闭后继续运行。</p><img src="https://images.961110.xyz/images/2021/10/24/gatewayIP.png" alt="image-20211024115756744" style="zoom:50%;" /><p>勾选Workstation关闭后保持虚拟机运行，就可以关掉VMware了。</p><img src="https://images.961110.xyz/images/2021/10/24/58a0ca43677d6443b173b79c33547567.png" alt="image-20211024122045615" style="zoom:50%;" /><h3 id="ssh连接"><a href="#ssh连接" class="headerlink" title="ssh连接"></a>ssh连接</h3><p>如果想要免密登录，可以在git-bash下输入，然后输入密码验证就好了。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-copy-id -i C:\\Users\\用户名\\.ssh\\id_rsa.pub jason@虚拟机IP</span><br></pre></td></tr></table></figure><p>否则，直接ssh连接就好了。</p><h2 id="设置虚拟机开机自启"><a href="#设置虚拟机开机自启" class="headerlink" title="设置虚拟机开机自启"></a>设置虚拟机开机自启</h2><p>可以参考下面两个博文</p><ol><li><a href="https://blog.csdn.net/weixin_42808782/article/details/116485359">win10设置vmware 虚拟机开机自启动_丛娟的博客-CSDN博客_vmware虚拟机开机自启动</a></li><li><a href="https://blog.csdn.net/qq_16149777/article/details/73162480?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5.no_search_link">Windows设置VMware开机自动启动，虚拟机也启动_张懿的博客-CSDN博客_vmware开机自动启动虚拟机</a></li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://blog.csdn.net/u014454538/article/details/88646689">ubuntu18.04配置静态ip和动态ip_lucyLee的博客-CSDN博客_ubuntu配置静态ip</a></li><li><a href="https://blog.csdn.net/chaofanjun/article/details/106663662">Ubuntu20.04配置静态ip_chaofanjun-CSDN博客</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Linux </tag>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 linux 后台运行脚本命令和程序的方法大全</title>
      <link href="/posts/36766.html"/>
      <url>/posts/36766.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址 <a href="https://blog.csdn.net/davidhzq/article/details/102766881">https://blog.csdn.net/davidhzq/article/details/102766881</a></p></blockquote><p>需要在 linux 后台执行任务的情况还是经常会遇到的，比如一些费时的操作，或者一些需要长时间存在的程序。当然你也可以把这些任务做成守护进程或者后台服务，但这需要额外的工作量。linux 提供了很多方法可以直接将普通的命令、脚本、应用程序以后台的形式运行起来，这样就不会阻塞终端窗口的继续使用。常用的涉及后台执行的命令有十几多个，包括：&amp;、ctrl+z、bg、fg、nohup、disown、setsid、(cmd)、jobs、ps、kill 等。</p><p>下面先对每个命令的功能作用做一个简单的介绍，然后分别给出使用案例进行详细解释。</p><h2 id="1、后台执行脚本命令功能介绍"><a href="#1、后台执行脚本命令功能介绍" class="headerlink" title="1、后台执行脚本命令功能介绍"></a>1、后台执行脚本命令功能介绍</h2><p><code>&amp;</code>：将当前命令以后台的形式运行；<br><code>ctrl+z</code>：将前台任务转后台并冻结；<br><code>bg</code>：将后台冻结的任务再次运行起来；<br><code>fg</code>：将后台任务重新转前台执行；<br><code>nohup</code>：隔离终端挂断信号，是命令的前缀；<br><code>disown</code>：隔离终端挂断信号，事后使用；<br><code>setsid</code>：重新创建一个会话进程来执行任务；<br><code>(cmd)</code>：创建一个独立 shell 来执行命令；<br><code>jobs</code>：查看在后台运行的任务列表；<br><code>ps</code>：查看正在运行的进程信息；<br><code>kill</code>：杀掉某个进程；</p><p> 下面就分别对上面的命令举例来说说如何让脚本命令在后台执行，先看一下测试用例。</p><h2 id="2、后台脚本任务测试用例"><a href="#2、后台脚本任务测试用例" class="headerlink" title="2、后台脚本任务测试用例"></a>2、后台脚本任务测试用例</h2><p> 下面所有的例子中的脚本统一使用这个脚本，它的功能是每 2 秒打印一次当前时间。hzqtest8.sh 是测试脚本的名字，.sh 文件最好放在当前用户默认目录中（如果你放在其他目录了，请注意权限问题！）。</p><p><strong>1）创建脚本：</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">创建脚本文件</span></span><br><span class="line">hzq@ubuntu:~$ sudo gedit hzqtest8.sh</span><br><span class="line">[sudo] hzq 的密码：</span><br><span class="line"><span class="meta">#</span><span class="bash">输入脚本内容</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">for ((i = 0; i &lt; 10; i++)); do</span><br><span class="line">    sleep 2</span><br><span class="line">    echo $(date)</span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span><span class="bash">保存退出。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2）赋予执行权限：</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hzq@ubuntu:~$ sudo chmod 755 hzqtest8.s</span><br></pre></td></tr></table></figure><h2 id="3、linux-后台运行命令和脚本任务的例子"><a href="#3、linux-后台运行命令和脚本任务的例子" class="headerlink" title="3、linux 后台运行命令和脚本任务的例子"></a>3、linux 后台运行命令和脚本任务的例子</h2><p> 下面通过 6 个典型的使用案例来解释各个命令的功能和使用方法。</p><h4 id="●-例1：用-amp"><a href="#●-例1：用-amp" class="headerlink" title="● 例1：用 &amp;"></a>● 例1：用 &amp;</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hzq@ubuntu:~$ ./hzqtest8.sh &amp;</span><br></pre></td></tr></table></figure><p> 功能：&amp; 加在一个命令的最后，可以把当前行的命令放在后台执行。注意 &amp; 前面有空格。</p><p> 这种方法中，当非正常退出当前 shell 终端时（包括直接叉掉、杀死、直接注销关机等），后台运行的 hzqtest8.sh 也会结束。这是因为脚本在后台运行时，运行脚本的父进程是当前 shell 终端进程，关闭当前 shell 终端时，会发送 hangup 挂断信号给子进程，子进程收到 hangup 信号后也就退出了。</p><p> 但是，如果用 exit 退出，ctrl+d 退出，命令可以继续在后台运行。</p><h4 id="●-例2：用-nohup-和-amp"><a href="#●-例2：用-nohup-和-amp" class="headerlink" title="● 例2：用 nohup 和 &amp;"></a>● 例2：用 nohup 和 &amp;</h4><p>为了解决上面的问题可以用下面的例子，</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hzq@ubuntu:~$ nohup ./hzqtest8.sh &amp;</span><br><span class="line">[1] 3640</span><br><span class="line">hzq@ubuntu:~$ nohup: 忽略输入并把输出追加到&#x27;nohup.out&#x27;</span><br><span class="line">hzq@ubuntu:~$</span><br></pre></td></tr></table></figure><p> 功能：命令前加上 nohup 可以让你退出 shell 之后继续运行相应的进程。nohup 就是忽略当前任务挂断信号的意思。这样就解决上面的问题了。</p><p> 输入 nohup 命令之后会给出提示：nohup: ignoring input and appending output to ‘nohup.out’（中文版参见上文），这是正常提示，直接打回车就可以。</p><ul><li>  nohup 默认会把标准输出重定向到默认文件 nohup.out 中，你可以自定义该输出文件，如下例子。</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hzq@ubuntu:~$ nohup ./hzqtest8.sh &gt;hzqout.txt &amp;</span><br><span class="line">[1] 3668</span><br><span class="line">hzq@ubuntu:~$ nohup: 忽略输入重定向错误到标准输出端</span><br><span class="line"></span><br><span class="line">[1]+  已完成               nohup ./hzqtest8.sh &gt; hzqout.txt</span><br><span class="line">hzq@ubuntu:~$</span><br><span class="line"><span class="meta">#</span><span class="bash">看一下输出文件里的内容。</span></span><br><span class="line">hzq@ubuntu:~$ cat hzqout.txt</span><br><span class="line">2019年 10月 25日 星期五 23:37:48 CST</span><br><span class="line">2019年 10月 25日 星期五 23:37:49 CST</span><br><span class="line">2019年 10月 25日 星期五 23:37:50 CST</span><br><span class="line">2019年 10月 25日 星期五 23:37:51 CST</span><br></pre></td></tr></table></figure><ul><li>  如果输入 nohup 后不想打回车，可以用下面的例子，</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hzq@ubuntu:~$ nohup ./hzqtest8.sh &gt;hzqout.txt 2&gt;&amp;1 &amp;</span><br><span class="line">[1] 3690</span><br><span class="line">hzq@ubuntu:~$ cat hzqout.txt</span><br><span class="line">nohup: 忽略输入</span><br><span class="line">2019年 10月 25日 星期五 23:38:53 CST</span><br><span class="line">2019年 10月 25日 星期五 23:38:54 CST</span><br><span class="line">2019年 10月 25日 星期五 23:38:55 CST</span><br><span class="line">2019年 10月 25日 星期五 23:38:56 CST</span><br><span class="line">2019年 10月 25日 星期五 23:39:02 CST</span><br><span class="line">[1]+  已完成               nohup ./hzqtest8.sh &gt; hzqout.txt 2&gt;&amp;1</span><br><span class="line">hzq@ubuntu:~$</span><br></pre></td></tr></table></figure><p> 功能解释：2&gt;&amp;1 是将错误提示信息的输出 重定向到 标准输出，而这里的标准输出已经重定向到 hzqout.txt 文件，也就是说标准的错误提示也直接输出到 out.file 文件中，所以就没有提示了，也就不用再打回车了。</p><ul><li>  另外，如果你的后台任务没有输出，你可以直接重定向到 / dev/null</li></ul><h4 id="●-例3：用-ctrl-z、jobs-和-bg"><a href="#●-例3：用-ctrl-z、jobs-和-bg" class="headerlink" title="● 例3：用 ctrl+z、jobs 和 bg"></a>● 例3：用 ctrl+z、jobs 和 bg</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hzq@ubuntu:~$ ./hzqtest8.sh</span><br><span class="line">2019年 10月 25日 星期五 23:56:15 CST</span><br><span class="line">2019年 10月 25日 星期五 23:56:16 CST</span><br><span class="line">2019年 10月 25日 星期五 23:56:17 CST</span><br><span class="line">2019年 10月 25日 星期五 23:56:18 CST</span><br><span class="line">^Z[3]   已完成               nohup ./hzqtest8.sh &gt; /dev/null 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line">[4]+  已停止               ./hzqtest8.sh</span><br><span class="line">hzq@ubuntu:~$ jobs</span><br><span class="line">[4]+  已停止               ./hzqtest8.sh</span><br><span class="line">hzq@ubuntu:~$ bg 4</span><br><span class="line">[4]+ ./hzqtest8.sh &amp;</span><br><span class="line">hzq@ubuntu:~$ 2019年 10月 25日 星期五 23:57:04 CST</span><br><span class="line">2019年 10月 25日 星期五 23:57:05 CST</span><br><span class="line">2019年 10月 25日 星期五 23:57:06 CST</span><br><span class="line">2019年 10月 25日 星期五 23:57:07 CST</span><br><span class="line">2019年 10月 25日 星期五 23:57:08 CST</span><br><span class="line">2019年 10月 25日 星期五 23:57:09 CST</span><br><span class="line"></span><br><span class="line">[4]+  已完成               ./hzqtest8.sh</span><br><span class="line">hzq@ubuntu:~$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 功能：上面的例子中脚本命令事先已经正常执行，然后你可能发现这个任务执行时间比较长，一直独占着终端窗口的使用，很不方便。</p><p> ctrl+z 命令可以将当前的前台任务转后台，也就是放到后台任务池中了，这个时候前台窗口就变成非阻塞状态了，但是要注意转过去的任务在后台默认是冻结状态。从上面例子中可以看出任务输出了 4 行之后中断了。</p><p> 这个时候需要用到 bg 命令，bg 命令的功能就是将后台冻结的任务再次运行起来，但是它需要一个任务 ID 号，而 jobs 命令就是查看所有任务状态的，包括 ID 号。</p><p> 例子中的 bg 4 就是当前任务号码。</p><p> 该例子中没有使用 nohup，有需要的同学可以自行加上，包括重定向都是可以加上的。</p><h4 id="●-例4：用-disown、jobs-和-amp"><a href="#●-例4：用-disown、jobs-和-amp" class="headerlink" title="● 例4：用 disown、jobs 和 &amp;"></a>● 例4：用 disown、jobs 和 &amp;</h4><p> 上面的例子中没有使用 nohup 命令，所以当终端环境强行退出时，后台正在执行的任务 (作业 / 命令 / 程序 / 脚本) 也会退出，由于各种原因你可能想事后加上 nohup 的功能（忽略终端关闭信号），看下面的例子。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hzq@ubuntu:~$ ./hzqtest8.sh &gt;hzqout.txt 2&gt;&amp;1 &amp;</span><br><span class="line">[1] 7168</span><br><span class="line">hzq@ubuntu:~$ jobs</span><br><span class="line">[1]+  运行中               ./hzqtest8.sh &gt; hzqout.txt 2&gt;&amp;1 &amp;</span><br><span class="line">hzq@ubuntu:~$ disown -h %1</span><br><span class="line">hzq@ubuntu:~$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 功能：disown 也是隔离终端挂断信号，但主要用于事后使用。上面执行完 disown 之后，你可以强行关闭终端窗口，然后等待 1 分钟后去查看重定向文件 hzqout.txt 看看有没有执行成功，如果成功里面有完整的 10 条信息，并且是连续的。下面的结果可以看到已经成功执行了。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hzq@ubuntu:~$ ps -ef |grep hzqtest</span><br><span class="line">hzq        7166   7152  0 01:11 pts/1    00:00:00 grep --color=auto hzqtest</span><br><span class="line"><span class="meta">#</span><span class="bash">确认后台进程已经执行完毕退出，后面会解释用法。</span></span><br><span class="line">hzq@ubuntu:~$ cat hzqout.txt</span><br><span class="line">2019年 10月 26日 星期六 01:11:16 CST</span><br><span class="line">2019年 10月 26日 星期六 01:11:20 CST</span><br><span class="line">2019年 10月 26日 星期六 01:11:24 CST</span><br><span class="line">2019年 10月 26日 星期六 01:11:28 CST</span><br><span class="line">hzq@ubuntu:~$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="●-例5：用-setsid-和-amp"><a href="#●-例5：用-setsid-和-amp" class="headerlink" title="● 例5：用 setsid 和 &amp;"></a>● 例5：用 setsid 和 &amp;</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hzq@ubuntu:~$ setsid ./hzqtest8.sh &amp;</span><br><span class="line">[1] 3001</span><br><span class="line">hzq@ubuntu:~$ 2019年 10月 26日 星期六 16:27:09 CST</span><br><span class="line">2019年 10月 26日 星期六 16:27:11 CST</span><br><span class="line">2019年 10月 26日 星期六 16:27:13 CST</span><br><span class="line">2019年 10月 26日 星期六 16:27:15 CST</span><br><span class="line">2019年 10月 26日 星期六 16:27:17 CST</span><br><span class="line"></span><br><span class="line">[1]+  已完成               setsid ./hzqtest8.sh</span><br><span class="line">hzq@ubuntu:~$</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 功能：setsid 是重新创建一个会话进程来执行任务。setsid 可以起到和 nohup 类似的效果，但是 setsid 更彻底，所以严格上说 setsid 不是忽略终端关闭信号，而是这个后台任务创建之后就与当前终端没有关系了，所以当前终端的关闭自然不会影响到它。</p><p> 同然的原理，大家估计已经想到了，jobs 命令在这个时候是不起作用的。</p><p> 另外，和 nohup 还有一个区别就是，不用多打一个回车，因为它没有提示信息。</p><h4 id="●-例6：用-小括号-圆括号-和-amp"><a href="#●-例6：用-小括号-圆括号-和-amp" class="headerlink" title="● 例6：用 小括号 / 圆括号 和 &amp;"></a>● 例6：用 小括号 / 圆括号 和 &amp;</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hzq@ubuntu:~$ (./hzqtest8.sh &amp;)</span><br><span class="line">hzq@ubuntu:~$ 2019年 10月 26日 星期六 23:58:26 CST</span><br><span class="line">2019年 10月 26日 星期六 23:58:28 CST</span><br><span class="line">2019年 10月 26日 星期六 23:58:30 CST</span><br><span class="line">2019年 10月 26日 星期六 23:58:32 CST</span><br><span class="line">2019年 10月 26日 星期六 23:58:34 CST</span><br><span class="line">hzq@ubuntu:~$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 功能：小括号可以起到和 setsid 类似的效果，小括号是创建一个独立 shell 来执行命令，当前的后台任务创建之后就与当前终端没有关系了，所以终端的关闭也不会影响到它。</p><p> 同然的原理，jobs 命令在这个时候是不起作用的。</p><p> 另外，和 setsid 一样，圆括号执行命令不用多打一个回车，因为它没有提示信息。</p><h2 id="4、查看后台任务的命令"><a href="#4、查看后台任务的命令" class="headerlink" title="4、查看后台任务的命令"></a>4、查看后台任务的命令</h2><p> 常用的有 jobs 和 ps 命令，区别是 jobs 用于查看当前终端后台运行的任务，换了终端就看不到了（包括关闭终端再重新打开也看不到的）。而 ps 命令用于查看全局所有后台进程的信息，当然可以看到别的终端运行的后台任务。</p><p><strong>1）jobs 命令</strong><br>功能：查看当前终端任务信息</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hzq@ubuntu:~$ jobs -l</span><br><span class="line">[1]-  3427 运行中               nohup ./hzqtest8.sh &amp;</span><br><span class="line">[2]+  3445 运行中               nohup firefox &amp;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>jobs -l 选项可以多显示一个 PID 信息。<br>第一列：任务序号，注意并不是 PID。<br>第二列：+ 号表示当前顶部任务，- 号其次任务，没符号是其他任务。<br>第三列：PID（上面例子中，默认情况下没有 PID）。例<br>第四列：状态，四种（运行中，已停止，已完成，已杀死）。例<br>第五列：任务名称（即刚才运行的命令）。</p><p><strong>2）ps 命令</strong><br>功能：全局查看进程信息</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hzq@ubuntu:~$ ps -ef |grep gedit</span><br><span class="line">root       3791   2566  0 00:29 pts/0    00:00:00 sudo gedit</span><br><span class="line">root       3792   3791  0 00:29 pts/0    00:00:00 gedit</span><br><span class="line">root       3802   2566  0 00:30 pts/0    00:00:00 sudo gedit</span><br><span class="line">root       3803   3802  0 00:30 pts/0    00:00:00 gedit</span><br><span class="line">hzq        3820   2566  0 00:44 pts/0    00:00:00 grep --color=auto gedit</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> ps 命令是 Process Status 的缩写，功能比较强大，参数非常多，尤其与其他命令组合时可以完成很复杂的操作。<br> ps -ef |grep hzqtest 是常见用法之一，<br> e：表示列出所有进程，f：表示输出完整格式，<br> grep hzqtest：表示过滤筛选 “hzqtest” 关键字。<br> 上面例子中，第一列：用户名，第二列：PID，第三列：父级 PID，最后一列：命令名称或路径</p><h2 id="5、关闭后台任务的命令"><a href="#5、关闭后台任务的命令" class="headerlink" title="5、关闭后台任务的命令"></a>5、关闭后台任务的命令</h2><p> 处于 linux 后台的任务有几种关闭方式：任务运行完毕自行退出；通过交互方式退出（包括传入参数对话，界面操作，终端 ctrl+c 等）；通过进程管理工具杀掉；关闭系统退出等。</p><p> <strong>kill 命令：属于进程管理工具，功能：杀掉进程。</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hzq@ubuntu:~$ jobs</span><br><span class="line">[2]   已停止               nohup firefox</span><br><span class="line">[3]-  已停止               nohup sudo gedit</span><br><span class="line">[4]+  已停止               nohup sudo gedit</span><br><span class="line">hzq@ubuntu:~$ kill -9 %2</span><br><span class="line"></span><br><span class="line">[2]   已停止               nohup firefox</span><br><span class="line">hzq@ubuntu:~$ jobs</span><br><span class="line">[2]   已杀死               nohup firefox</span><br><span class="line">[3]-  已停止               nohup sudo gedit</span><br><span class="line">[4]+  已停止               nohup sudo gedit</span><br><span class="line">hzq@ubuntu:~$ jobs</span><br><span class="line">[3]-  已停止               nohup sudo gedit</span><br><span class="line">[4]+  已停止               nohup sudo gedit</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>  1）上面的例子中先通过 jobs 命令查看任务号，然后通过任务号 %N 杀死进程！最后再次查询发现 jobs 中的任务已经减少了。</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hzq@ubuntu:~$ ps -ef |grep gedit</span><br><span class="line">root       3791   2566  0 00:29 pts/0    00:00:00 sudo gedit</span><br><span class="line">root       3792   3791  0 00:29 pts/0    00:00:00 gedit</span><br><span class="line">root       3802   2566  0 00:30 pts/0    00:00:00 sudo gedit</span><br><span class="line">root       3803   3802  0 00:30 pts/0    00:00:00 gedit</span><br><span class="line">hzq        3829   2566  0 00:59 pts/0    00:00:00 grep --color=auto gedit</span><br><span class="line">hzq@ubuntu:~$ sudo kill -9 3791</span><br><span class="line">[sudo] hzq 的密码： </span><br><span class="line">[3]-  已杀死               nohup sudo gedit</span><br><span class="line">hzq@ubuntu:~$ ps -ef |grep gedit</span><br><span class="line">root       3792    912  0 00:29 pts/0    00:00:00 gedit</span><br><span class="line">root       3802   2566  0 00:30 pts/0    00:00:00 sudo gedit</span><br><span class="line">root       3803   3802  0 00:30 pts/0    00:00:00 gedit</span><br><span class="line">hzq        3835   2566  0 01:01 pts/0    00:00:00 grep --color=auto gedit</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>  2）上面的例子中先通过 ps 命令查看任务 PID，然后通过 PID 杀掉进程，注意上面例子中使用了管理员权限。</li><li>  3）如果你的任务还没有转到后台运行，那么直接 Ctrl+c 就可以终止了。或者你也可以将后台任务转到前台然后执行 ctrl+c 来终止。该方法可参考下面举例。</li></ul><h2 id="6、前后台任务的转换"><a href="#6、前后台任务的转换" class="headerlink" title="6、前后台任务的转换"></a>6、前后台任务的转换</h2><p><strong>1）fg 命令</strong><br>功能：将后台中的任务调至前台并继续运行。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hzq@ubuntu:~$ jobs</span><br><span class="line">[1]-  运行中               nohup gedit &amp;</span><br><span class="line">[2]+  运行中               nohup ./hzqtest8.sh &amp;</span><br><span class="line">hzq@ubuntu:~$ fg 1</span><br><span class="line">nohup gedit</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先通过上面介绍的 jobs 命令查看任务信息，然后用 fg N 将选中的任务调到前台，跳到前台之后终端界面被阻塞，此时终端不能做别的事情了。</p><p><strong>2）Ctrl + z 命令</strong><br>功能：将正在前台执行的命令作业放到后台，并冻结运行状态。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hzq@ubuntu:~$ ./hzqtest8.sh</span><br><span class="line">2019年 10月 27日 星期日 01:53:31 CST</span><br><span class="line">2019年 10月 27日 星期日 01:53:33 CST</span><br><span class="line">^Z</span><br><span class="line">[3]+  已停止               ./hzqtest8.sh</span><br><span class="line">hzq@ubuntu:~$ jobs</span><br><span class="line">[3]+  已停止               ./hzqtest8.sh</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>例子中先正常运行任务脚本，可以看到刚开始是正常输出的，执行 ctrl+z 之后，提示任务已停止，用 jobs 查看任务已在后台并处于停止状态。</p><p><strong>3）bg 命令</strong><br>功能：将后台冻结的任务再次运行起来，运行后任务还在后台。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hzq@ubuntu:~$ jobs</span><br><span class="line">[1]+  已停止               ./hzqtest8.sh</span><br><span class="line">hzq@ubuntu:~$ bg 1</span><br><span class="line">[1]+ ./hzqtest8.sh &amp;</span><br><span class="line">hzq@ubuntu:~$ 2019年 10月 27日 星期日 01:58:17 CST</span><br><span class="line">2019年 10月 27日 星期日 01:58:19 CST</span><br><span class="line">2019年 10月 27日 星期日 01:58:21 CST</span><br><span class="line"></span><br><span class="line">[1]+  已完成               ./hzqtest8.sh</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面例子中先用 jobs 查看有一个任务处于后台停止状态，执行 bg 1 之后任务继续在后台运行，并继续输出剩余信息。</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker更新日志（截止到2020年9月10日）</title>
      <link href="/posts/32194.html"/>
      <url>/posts/32194.html</url>
      
        <content type="html"><![CDATA[<p>原文地址 <a href="https://blog.csdn.net/wuzheng8023/article/details/108514370">Docker更新日志（截止到2020年9月10日）</a></p><p>本文记录 docker-ce 从 17.03 到 19.03 更新日志情况，主要内容为更新版本所修复的问题和新增功能等。所有内容来自官方文档的更新日志，很多地方有翻译不准确情况，仅供简单参考。</p><p><strong>官方版本记录日志：<a href="https://docs.docker.com/engine/release-notes/">https://docs.docker.com/engine/release-notes/</a></strong></p><h3 id="版本号：19-03"><a href="#版本号：19-03" class="headerlink" title="版本号：19.03"></a>版本号：19.03</h3><p>首次发布时间： 2019-07-22</p><h4 id="构造相关"><a href="#构造相关" class="headerlink" title="构造相关"></a>构造相关</h4><ul><li>  buildkit：修复并行构建多个映像时并发映射写入异常的问题。<a href="https://github.com/moby/moby/pull/40780">moby/moby＃40780</a></li><li>  buildkit：修复了防止与用户级之间的非超级用户拥有文件的问题。<a href="https://github.com/moby/moby/pull/40955">moby/moby＃40955</a></li><li>  避免在 Windows 上创建无关的临时文件。<a href="https://github.com/moby/moby/pull/40877">moby/moby＃40877</a></li><li>  builder-next：修复极端情况下的死锁问题。<a href="https://github.com/moby/moby/pull/40557">moby/moby＃40557</a></li><li>  builder-next：允许使用现代符号哈希进行 ssh 转发。<a href="https://github.com/docker/engine/pull/453">docker/engine＃453</a></li><li>  builder-next：触发后清除 onbuild 规则。<a href="https://github.com/docker/engine/pull/453">docker/engine＃453</a></li><li>  builder-next：修复了启用用户名空间时目录权限的问题。<a href="https://github.com/moby/moby/pull/40440">moby/moby＃40440</a></li><li>  来修复 Windows 1903 上的 docker 构建失败。<a href="https://github.com/docker/engine/pull/429">docker / engine＃429</a></li><li>  builder-next：<code>entitlements</code>在构建器配置中添加。<a href="https://github.com/docker/engine/pull/412">docker/engine＃412</a></li><li>  修复 builder-next：在使用 build secret 或通过 userns-remap 进行 ssh 转发时出现权限错误。<a href="https://github.com/docker/engine/pull/420">docker/engine＃420</a></li><li>  修复 builder-next：在已经复制的目录中复制符号链接。<a href="https://github.com/docker/engine/pull/420">docker/engine＃420</a></li><li>  修复 builder-next：解决第三方注册表的摘要。<a href="https://github.com/docker/engine/pull/339">docker/engine＃339</a></li><li>  修复 builder-next：当守护程序通过套接字激活启动时，将建立用户名称空间。<a href="https://github.com/docker/engine/pull/373">docker/engine＃373</a></li><li>  修复 builder-next; 会话：释放每个连接转发的 ssh 套接字连接。<a href="https://github.com/docker/engine/pull/373">docker/engine＃373</a></li><li>  修复 build-next：llbsolver：多个缓存导入器上的错误。<a href="https://github.com/docker/engine/pull/373">docker/engine＃373</a></li><li>  修复<code>COPY --from</code>Windows 上不存在的目录。<a href="https://github.com/moby/moby/pull/39695">moby/moby＃39695</a></li><li>  修复 builder-next：元数据命令在历史记录中未创建时间。<a href="https://github.com/moby/moby/issues/39456">moby/moby＃39456</a></li><li>  修复 builder-next：关闭图层导出错误的进度。<a href="https://github.com/moby/moby/pull/39782">moby/moby＃39782</a></li><li>  将 buildkit 更新到 588c73e1e4。<a href="https://github.com/moby/moby/pull/39781">moby/moby＃39781</a></li><li>  固定<code>COPY --from</code>以保留所有权。<a href="https://github.com/moby/moby/pull/38599">moby/moby＃38599</a></li><li>生成器下一个：<ul><li>  添加了内联缓存支持<code>--cache-from</code>。<a href="https://github.com/docker/engine/pull/215">docker/engine＃215</a></li><li>  允许输出配置。<a href="https://github.com/moby/moby/pull/38898">moby/moby＃38898</a></li><li>  修复了 gcr 解决方法令牌缓存。<a href="https://github.com/docker/engine/pull/212">docker/engine＃212</a></li><li>  <code>stopprogress</code>调用下载错误。<a href="https://github.com/docker/engine/pull/215">docker/engine＃215</a></li><li>  Buildkit 现在使用 systemd 的<code>resolv.conf</code>。<a href="https://github.com/docker/engine/pull/260">docker / engine＃260</a>。</li><li>  现在可以设置 buildkit 输出。<a href="https://github.com/docker/cli/pull/1766">docker/ cli＃1766</a></li><li>  查找特定于 Dockerfile 的 dockerignore 文件（例如 Dockerfile.dockerignore）以查找忽略的路径。<a href="https://github.com/docker/engine/pull/215">docker/engine＃215</a></li><li>  自动检测 x86，arm 和 arm64 二进制文件是否可以执行进程。 <a href="https://github.com/docker/engine/pull/215">docker/engine＃215</a></li><li>  将 buildkit 更新为 1f89ec1。<a href="https://github.com/docker/engine/pull/260">docker/engine＃260</a></li><li>  <code>docker/dockerfile:1.1</code>默认情况下使用 Dockerfile 前端版本。 <a href="https://github.com/docker/engine/pull/215">docker/engine＃215</a></li><li>  不再依赖外部镜像进行 COPY / ADD 操作。 <a href="https://github.com/docker/engine/pull/215">docker/engine＃215</a></li></ul></li></ul><h4 id="客户端相关"><a href="#客户端相关" class="headerlink" title="客户端相关"></a>客户端相关</h4><ul><li>  修复了使用多个配置文件（例如，使用 Docker Desktop 时使用 Windows vs WSL2）时无法从注册表注销的错误 <a href="https://github.com/docker/cli/pull/2592">docker / cli＃2592</a></li><li>  修复回归问题，防止上下文元数据被读取 <a href="https://github.com/docker/cli/pull/2586">docker / cli＃2586</a></li><li>  升级 Golang 1.13.12 <a href="https://github.com/docker/cli/pull/2575">docker / cli＃2575</a></li><li>  修复与旧 engine 的版本协商。<a href="https://github.com/docker/cli/pull/2538">docker/ cli＃2538</a></li><li>  避免通过主机名设置 SSH 标志。<a href="https://github.com/docker/cli/pull/2560">docker/ cli＃2560</a></li><li>  当 DOCKER_CLI_EXPERIMENTAL 无效时，解决异常问题。<a href="https://github.com/docker/cli/pull/2558">docker/ cli＃2558</a></li><li>  通过升级到 1.13.11，避免对 s390x 造成潜在的异常。<a href="https://github.com/docker/cli/pull/2532">docker/ cli＃2532</a></li><li>  解决单字符卷的紧急情况。<a href="https://github.com/docker/cli/pull/2471">docker/ cli＃2471</a></li><li>  惰性守护程序功能检测可避免简单命令长时间超时。<a href="https://github.com/docker/cli/pull/2442">docker/ cli＃2442</a></li><li>  Windows 上的 Docker 上下文检查现在更快。<a href="https://github.com/docker/cli/pull/2516">docker/ cli＃2516</a></li><li>  升级 Golang 1.13.10。<a href="https://github.com/docker/cli/pull/2431">docker/ cli＃2431</a></li><li>  将 gopkg.in/yaml.v2 碰撞到 v2.2.8。<a href="https://github.com/docker/cli/pull/2470">docker/ cli＃2470</a></li><li>  升级 Golang 1.12.17。<a href="https://github.com/docker/cli/pull/2342">docker/ cli＃2342</a></li><li>  将 google.golang.org/grpc 连接到 v1.23.1。<a href="https://github.com/docker/cli/pull/1884">docker/ cli＃1884</a> <a href="https://github.com/docker/cli/pull/2373">docker/ cli＃2373</a></li><li>  添加了对 Docker Template 0.1.6 的支持。</li><li>  缓解别名过多的 YAML 文件。<a href="https://github.com/docker/cli/pull/2119">docker/ cli＃2119</a></li><li>  修复非 Windows <a href="https://github.com/docker/cli/pull/1990">docker / cli＃1990</a> 上的 Windows 绝对路径检测</li><li>  修复了的 zsh 完成脚本<code>docker login --username</code>。</li><li>  修复上下文：在上产生一致的输出<code>context create</code>。<a href="https://github.com/docker/cli/pull/1874">docker/ cli＃1985</a></li><li>  修复了对 HTTP 代理环境变量的支持。<a href="https://github.com/docker/cli/pull/2059">docker/ cli＃2059</a></li><li>  已将<code>--pids-limit</code>标志添加到<code>docker update</code>。<a href="https://github.com/docker/cli/pull/1765">docker/ cli＃1765</a></li><li>  添加了对服务的 systctl 支持。<a href="https://github.com/docker/cli/pull/1754">docker/ cli＃1754</a></li><li>  添加了<code>template_driver</code>对撰写文件的支持。<a href="https://github.com/docker/cli/pull/1746">docker/ cli＃1746</a></li><li>  添加了<code>--device</code>对 Windows 的支持。<a href="https://github.com/docker/cli/pull/1606">docker/ cli＃1606</a></li><li>  添加了对数据路径端口配置的支持。<a href="https://github.com/docker/cli/pull/1509">docker/ cli＃1509</a></li><li>  添加了快速上下文切换：命令。<a href="https://github.com/docker/cli/pull/1501">docker/ cli＃1501</a></li><li>  增加了对<code>--mount type=bind,bind-nonrecursive,...</code> <a href="https://github.com/docker/cli/pull/1430">docker / cli＃1430 的支持</a></li><li>  增加了每个节点的最大副本数。<a href="https://github.com/docker/cli/pull/1612">docker/ cli＃1612</a></li><li>  添加了静音拉动镜像的选项。<a href="https://github.com/docker/cli/pull/882">docker/ cli＃882</a></li><li>  添加了一个单独的<code>--domainname</code>标志。<a href="https://github.com/docker/cli/pull/1130">docker/ cli＃1130</a></li><li>  在中增加了对秘密驱动程序的支持<code>docker stack deploy</code>。<a href="https://github.com/docker/cli/pull/1783">docker/ cli＃1783</a></li><li>  增加了将 swarm <code>Configs</code>用作<code>CredentialSpecs</code>服务的功能。 <a href="https://github.com/docker/cli/pull/1781">docker/ cli＃1781</a></li><li>  增加了<code>--security-opt systempaths=unconfined</code>支持。<a href="https://github.com/docker/cli/pull/1808">docker/ cli＃1808</a></li><li>  添加了用于编写和运行 CLI 插件的基本框架。<a href="https://github.com/docker/cli/pull/1564">docker/ cli＃1564</a> <a href="https://github.com/docker/cli/pull/1898">docker/ cli＃1898</a></li><li>  将 Docker App 升级到 v0.8.0。<a href="https://github.com/docker/docker-ce-packaging/pull/341">docker / docker-ce-packaging＃341</a></li><li>  添加了对 Docker buildx 的支持。<a href="https://github.com/docker/docker-ce-packaging/pull/336">docker/ docker-ce-packaging＃336</a></li><li>  添加了对 Docker Assemble v0.36.0 的支持。</li><li>  添加了对 Docker Cluster v1.0.0-rc2 的支持。</li><li>  添加了对 Docker 模板 v0.1.4 的支持。</li><li>  添加了对 Docker Registry v0.1.0-rc1 的支持。</li><li>  将 google.golang.org/grpc 连接到 v1.20.1。<a href="https://github.com/docker/cli/pull/1884">docker/ cli＃1884</a></li><li>  CLI 更改为将驱动程序特定选项传递给<code>docker run</code>。<a href="https://github.com/docker/cli/pull/1767">docker/ cli＃1767</a></li><li>  重击 Golang 1.12.5。<a href="https://github.com/docker/cli/pull/1875">docker/ cli＃1875</a></li><li>  <code>docker system info</code>现在，输出将隔离与客户机和守护程序有关的信息。 <a href="https://github.com/docker/cli/pull/1638">docker/ cli＃1638</a></li><li>  （实验性）以 Kubernetes 为目标时，增加了<code>x-pull-secret: some-pull-secret</code>对 compose-files 服务配置的支持。<a href="https://github.com/docker/cli/pull/1617">docker/ cli＃1617</a></li><li>  （实验性）以 Kubernetes 为目标时，增加了<code>x-pull-policy:</code> 对 compose-files 服务配置的支持。<a href="https://github.com/docker/cli/pull/1617">docker/ cli＃1617</a></li><li>  cp，保存，导出：现在可以防止覆盖不规则文件。<a href="https://github.com/docker/cli/pull/1515">docker/ cli＃1515</a></li><li>  现在允许堆栈文件上的 npipe 卷类型。<a href="https://github.com/docker/cli/pull/1195">docker/ cli＃1195</a></li><li>  修复了 tty 初始大小错误。<a href="https://github.com/docker/cli/pull/1529">docker/ cli＃1529</a></li><li>  解决了标签从环境变量复制值的问题。 <a href="https://github.com/docker/cli/pull/1671">docker/ cli＃1671</a></li></ul><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><ul><li>  将 API 版本更新为 v1.40。<a href="https://github.com/moby/moby/pull/38089">moby/moby＃38089</a></li><li>  向<code>/info</code>端点添加了警告，并将检测移至守护程序。 <a href="https://github.com/moby/moby/pull/37502">moby/moby＃37502</a></li><li>  添加了对<code>/_ping</code>端点的 HEAD 支持。<a href="https://github.com/moby/moby/pull/38570">moby/moby＃38570</a></li><li>  添加了<code>Cache-Control</code>标头以禁用缓存<code>/_ping</code>端点。 <a href="https://github.com/moby/moby/pull/38569">moby/moby＃38569</a></li><li>  添加<code>containerd</code>，<code>runc</code>和<code>docker-init</code>版本<code>/version</code>。 <a href="https://github.com/moby/moby/pull/37974">moby/moby＃37974</a></li><li>  添加了未记录的<code>/grpc</code>端点并注册了 BuildKit 的控制器。 <a href="https://github.com/moby/moby/pull/38990">moby/moby＃38990</a></li></ul><h4 id="实验性功能"><a href="#实验性功能" class="headerlink" title="实验性功能"></a>实验性功能</h4><ul><li>  使用 TTY 启用容器的检查点 / 还原。<a href="https://github.com/moby/moby/pull/38405">moby/moby＃38405</a></li><li>  LCOW：添加了对内存和 CPU 限制的支持。<a href="https://github.com/moby/moby/pull/37296">moby/moby＃37296</a></li><li>  Windows：添加了 ContainerD 运行时。<a href="https://github.com/moby/moby/pull/38541">moby/moby＃38541</a></li><li>  Windows：LCOW 现在需要 Windows RS5 +。<a href="https://github.com/moby/moby/pull/39108">moby/moby＃39108</a></li></ul><h4 id="安全相关"><a href="#安全相关" class="headerlink" title="安全相关"></a>安全相关</h4><ul><li>apparmor：为用户添加缺少的规则。<a href="https://github.com/moby/moby/pull/40564">moby/moby＃40564</a></li><li>SElinux：修复了重新标记时未检测到的 ENOTSUP 错误。<a href="https://github.com/moby/moby/pull/40946">moby/moby＃40946</a></li><li>装<code>runc</code>在容器中。[CVE-2019-14271](<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?&gt;CVE-2017-18367">https://cve.mitre.org/cgi-bin/cvename.cgi?&gt;CVE-2017-18367</a></a></p> </li><li> <p>固定在 Glibc 下的 chroot 中加载基于 nsswitch 的配置。&lt;a href=)</li><li>安装：添加 BindOptions.NonRecursive（API v1.40）。<a href="https://github.com/moby/moby/pull/38003">moby/moby＃38003</a></li><li>seccomp：列入白名单<code>io_pgetevents()</code>。<a href="https://github.com/moby/moby/pull/38895">moby/moby＃38895</a></li><li>seccomp：<code>ptrace(2)</code>现在允许 4.8 + 内核。<a href="https://github.com/moby/moby/pull/38137">moby/moby＃38137</a></li></ul><h4 id="运行相关"><a href="#运行相关" class="headerlink" title="运行相关"></a>运行相关</h4><ul><li>升级 Golang 1.13.12 Moby <a href="https://github.com/moby/moby/pull/41082">/ Moby＃41082</a></li><li>通过升级到 1.13.11，避免对 s390x 造成潜在的异常。<a href="https://github.com/moby/moby/pull/40978">moby/moby＃40978</a></li><li>修复在 / etc / subuid 和 / etc / subgid 中使用 UID 创建名称空间时 docker 崩溃的问题。<a href="https://github.com/moby/moby/pull/40562">moby/moby＃40562</a></li><li>改进 ARM 平台匹配。<a href="https://github.com/moby/moby/pull/40758">moby/moby＃40758</a></li><li>overlay2：显示支持文件系统。<a href="https://github.com/moby/moby/pull/40652">moby/moby＃40652</a></li><li>将 CRIU 更新到 v3.13“Silicon Willet”。<a href="https://github.com/moby/moby/pull/40850">moby/moby＃40850</a></li><li>成功回退后，仅显示注册表 v2 schema1 弃用警告，而不是出现任何注册表错误。<a href="https://github.com/moby/moby/pull/40681">moby/moby＃40681</a></li><li>在 Windows 上将 FILE_SHARE_DELETE 用于日志文件。<a href="https://github.com/moby/moby/pull/40563">moby/moby＃40563</a></li><li>升级 Golang 1.13.10。<a href="https://github.com/moby/moby/pull/40803">moby/moby＃40803</a></li><li>改善某些 nscd 配置的 <a href="https://nvd.nist.gov/vuln/detail/CVE-2019-14271">CVE-2019-14271</a> 缓解措施。</li><li>overlay：删除 modprobe 执行程序。<a href="https://github.com/moby/moby/pull/40462">moby/moby＃40462</a></li><li>selinux：设置文件标签时显示更好的错误消息。<a href="https://github.com/moby/moby/pull/40547">moby/moby＃40547</a></li><li>加快初始统计信息收集。<a href="https://github.com/moby/moby/pull/40549">moby/moby＃40549</a></li><li>使用 XDG_CONFIG_HOME 中的 certs.d。<a href="https://github.com/moby/moby/pull/40461">moby/moby＃40461</a></li><li>升级 Golang 1.12.17。<a href="https://github.com/moby/moby/pull/40533">moby/moby＃40533</a></li><li>将 google.golang.org/grpc 连接到 v1.23.1。<a href="https://github.com/moby/moby/pull/40566">moby/moby＃40566</a></li><li>将容器化的二进制文件更新为 v1.2.13。<a href="https://github.com/moby/moby/pull/40540">moby/moby＃40540</a></li><li>防止将停止的容器显示为在边缘情况下运行。<a href="https://github.com/moby/moby/pull/40555">moby/moby＃40555</a></li><li>防止潜在的锁定。<a href="https://github.com/moby/moby/pull/40604">moby/moby＃40604</a></li><li>升级 Golang 1.12.16。<a href="https://github.com/moby/moby/pull/40433">moby/moby＃40433</a></li><li>将容器化的二进制文件更新为 v1.2.12。<a href="https://github.com/moby/moby/pull/40453">moby/moby＃40433</a></li><li>更新到 runc v1.0.0-rc10。<a href="https://github.com/moby/moby/pull/40453">moby/moby＃40433</a></li><li>修复 Lgetxattr 中可能出现的运行时紧急情况。<a href="https://github.com/docker/engine/pull/454">docker/engine＃454</a></li><li>无根：修复代理 UDP 数据包。<a href="https://github.com/docker/engine/pull/434">docker/engine＃434</a></li><li>将 Golang 升至 1.12.12。<a href="https://github.com/docker/engine/pull/418">docker/engine＃418</a></li><li>更新到 RootlessKit 到 v0.7.0，以使用装载名称空间和 seccomp 加固 slirp4netns。<a href="https://github.com/docker/engine/pull/397">docker/engine＃397</a></li><li>修复了从事件处理器传播 GetContainer 错误的问题。<a href="https://github.com/docker/engine/pull/407">docker/engine＃407</a></li><li>修复 OCI 图片推送。<a href="https://github.com/docker/engine/pull/405">docker/engine＃405</a></li><li>将 Golang 升至 1.12.10。<a href="https://github.com/docker/engine/pull/387">docker/engine＃387</a></li><li>装箱至 1.2.10。<a href="https://github.com/docker/engine/pull/385">docker/engine＃385</a></li><li>分发：拉出 v2 schema1 清单时修改警告逻辑。<a href="https://github.com/docker/engine/pull/368">docker/engine＃368</a></li><li><code>POST /images/create</code>提供错误的平台选项时，修复返回 500 状态代码的问题。<a href="https://github.com/docker/engine/pull/365">docker /engine＃365</a></li><li><code>POST /build</code>提供错误的平台选项时，修复返回 500 状态代码的问题。<a href="https://github.com/docker/engine/pull/365">docker /engine＃365</a></li><li>修复由于结构成员未对齐而导致的 32 位 ARMv7 异常。<a href="https://github.com/docker/engine/pull/363">docker/engine＃363</a></li><li>修复了链接到不存在的容器时返回 “无效参数” 的问题。<a href="https://github.com/docker/engine/pull/352">docker/engine＃352</a></li><li>修复 overlay2：使用内核 &gt; = 5.2 时，安装时出现繁忙错误。<a href="https://github.com/docker/engine/pull/332">docker/engine＃332</a></li><li>修复<code>docker rmi</code>卡在某些配置错误的系统中，例如死掉的 NFS 共享。<a href="https://github.com/docker/engine/pull/335">docker/engine＃335</a></li><li>修复对执行过程的阻塞 I / O 的处理。<a href="https://github.com/docker/engine/pull/296">docker/engine＃296</a></li><li>修复 jsonfile 记录器：跟踪<code>max-size</code>设置为和时卡住的日志<code>max-file=1</code>。<a href="https://github.com/docker/engine/pull/378">docker/engine＃378</a></li><li>将 Golang 升至 1.12.8。</li><li>当对容器使用 XFS 磁盘配额时，修复潜在的 engine 异常。<a href="https://github.com/moby/moby/pull/39644">moby/moby＃39644</a></li><li><code>dockerd</code>现在允许以非 root 用户身份运行（无根模式）。 <a href="https://github.com/moby/moby/pull/38050">moby/moby＃380050</a></li><li>无根：为<code>lxc-user-nic</code>SUID 二进制文件提供了可选支持。 <a href="https://github.com/docker/engine/pull/208">docker/engine＃208</a></li><li>向 HostConfig 添加了 DeviceRequests 以支持 NVIDIA GPU。<a href="https://github.com/moby/moby/pull/38828">moby/moby＃38828</a></li><li>添加了<code>--device</code>对 Windows 的支持。<a href="https://github.com/moby/moby/pull/37638">moby/moby＃37638</a></li><li>添加了<code>memory.kernelTCP</code>对 linux 的支持。<a href="https://github.com/moby/moby/pull/37043">moby/moby＃37043</a></li><li>Windows 凭据规范现在可以直接传递到 engine。 <a href="https://github.com/moby/moby/pull/38777">moby/moby＃38777</a></li><li>在 docker update 中添加了 pids-limit 支持。<a href="https://github.com/moby/moby/pull/32519">moby/moby＃32519</a></li><li>添加了对功能列表的支持。<a href="https://github.com/moby/moby/pull/38380">moby/moby＃38380</a></li><li>守护程序：现在默认使用 “专用” ipc 模式。<a href="https://github.com/moby/moby/pull/35621">moby/moby＃35621</a></li><li>守护程序：切换到信号量门控的 WaitGroup 来执行启动任务。<a href="https://github.com/moby/moby/pull/38301">moby/moby＃38301</a></li><li>现在使用 docker.sock 所有权<code>idtools.LookupGroup</code>而不是解析<code>/etc/group</code>文件来修复：<code>api.go doesn&#39;t respect nsswitch.conf</code>。<a href="https://github.com/moby/moby/pull/38126">moby/moby＃38126</a></li><li>cli：使用多参考滤镜时固定镜像滤镜。<a href="https://github.com/moby/moby/pull/38171">moby/moby＃38171</a></li><li>将 Golang 提升至 1.12.5。<a href="https://github.com/docker/engine/pull/209">docker/engine＃209</a></li><li>被撞<code>containerd</code>至 1.2.6。<a href="https://github.com/moby/moby/pull/39016">moby/moby＃39016</a></li><li>已连接<code>runc</code>到 1.0.0-rc8，opencontainers / selinux v1.2.2。<a href="https://github.com/docker/engine/pull/210">docker/engine＃210</a></li><li>被撞<code>google.golang.org/grpc</code>到 v1.20.1。<a href="https://github.com/docker/engine/pull/215">docker/engine＃215</a></li><li>在 aufs 和图层存储中优化的性能可用于大规模并行容器的创建 / 删除。 <a href="https://github.com/moby/moby/pull/39209">moby/moby</a><a href="https://github.com/moby/moby/pull/39135">＃39135</a> <a href="https://github.com/moby/moby/pull/39209">moby/moby＃39209</a></li><li>根现在传递给 chroot 以获取 chroot Tar / Untar（CVE-2018-15664）Moby <a href="https://github.com/moby/moby/pull/39292">/ Moby＃39292</a></li><li><code>docker --init</code>用 / dev 绑定安装修复。<a href="https://github.com/moby/moby/pull/37665">moby/moby＃37665</a></li><li>大于 255 并使用该<code>--device-read-bps</code>选项时，现在将获取正确的设备号。 <a href="https://github.com/moby/moby/pull/39212">moby/moby＃39212</a></li><li>修复了<code>Path does not exist</code>路径绝对存在时的错误。<a href="https://github.com/moby/moby/pull/39251">moby/moby＃39251</a></li></ul><h4 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h4><ul><li>  修复回归问题，防止守护程序在 systemd-nspawn 环境中启动 <a href="https://github.com/moby/moby/pull/41124">moby / moby＃41124</a> <a href="https://github.com/moby/libnetwork/pull/2567">moby / libnetwork＃2567</a></li><li>  修复了在 swarm 中创建覆盖网络的重试逻辑 <a href="https://github.com/moby/moby/pull/41124">moby/moby#41124</a> <a href="https://github.com/moby/libnetwork/pull/2565">moby/libnetwork#2565</a></li><li>  禁用 IPv6 路由器广告以防止地址欺骗。[moby/moby＃41009](<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?&gt;CVE-2020-13401">https://cve.mitre.org/cgi-bin/cvename.cgi?&gt;CVE-2020-13401</a></a></li><li> 修复 DNS 后备回归。&lt;a href=)</li><li>  重新启动时解决潜在的紧急情况。<a href="https://github.com/moby/moby/pull/40809">moby/moby＃40809</a></li><li>  将正确的网络值分配给默认网桥 “子网” 字段。<a href="https://github.com/moby/moby/pull/40565">moby/moby＃40565</a></li><li>  回滚 libnetwork 更改以修复<code>DOCKER-USER</code>iptables 链问题。<a href="https://github.com/docker/engine/pull/404">docker/engine＃404</a></li><li>  通过禁用网络，防止连接到容器的网络出现混乱。<a href="https://github.com/moby/moby/pull/39589">moby/moby＃39589</a></li><li>  将 IPVLAN 驱动程序移出了实验阶段。 <a href="https://github.com/moby/moby/pull/38983">moby/moby＃38983</a></li><li>  添加了对 “悬挂” 过滤器的支持。<a href="https://github.com/moby/moby/pull/31551">moby / moby＃31551 docker</a> <a href="https://github.com/docker/libnetwork/pull/2230">/ libnetwork＃2230</a></li><li>  现在，当使用来更新服务时，负载均衡器沙箱将被删除<code>--network-rm</code>。 <a href="https://github.com/docker/engine/pull/213">docker/engine＃213</a></li><li>  Windows：现在强制将指定的零 IP 强制<code>PortBindings</code>为 IPv4zero（0.0.0.0）。 <a href="https://github.com/docker/libnetwork/pull/2376">docker/ libnetwork＃2376</a></li></ul><h4 id="集群相关"><a href="#集群相关" class="headerlink" title="集群相关"></a>集群相关</h4><ul><li>  增加记录器的重新装填率，以避免挂在服务日志上。<a href="https://github.com/moby/moby/pull/40628">moby/moby＃40628</a></li><li>  修复了重启后单个 swarm 管理器停留在 Down 状态的问题。<a href="https://github.com/moby/moby/pull/40831">moby/moby＃40831</a></li><li>  task.db 不再无限期增长。[moby / moby＃40830]</li><li>  解决了无法删除具有多个任务的节点的问题。<a href="https://github.com/docker/swarmkit/pull/2867">docker/ swarmkit＃2867</a></li><li>  添加了对每个节点最大副本数的支持。<a href="https://github.com/moby/moby/pull/37940">moby/moby＃37940</a></li><li>  从 Swarmkit 配置中添加了对 GMSA CredentialSpecs 的支持。<a href="https://github.com/moby/moby/pull/38632">moby/moby＃38632</a></li><li>  添加了对服务中 sysctl 选项的支持。<a href="https://github.com/moby/moby/pull/37701">moby/moby＃37701</a></li><li>  添加了对节点标签过滤的支持。<a href="https://github.com/moby/moby/pull/37650">moby/moby＃37650</a></li><li>  Windows：在 docker service create + stack yml 中增加了对命名管道安装的支持。 <a href="https://github.com/moby/moby/pull/37400">moby/moby＃37400</a></li><li>  现在支持 VXLAN UDP 端口配置。<a href="https://github.com/moby/moby/pull/38102">moby/moby＃38102</a></li><li>  现在在 Enforcer 中使用服务放置约束。<a href="https://github.com/docker/swarmkit/pull/2857">docker/ swarmkit＃2857</a></li><li>  增加了节点和机密的最大 recv gRPC 消息大小。 <a href="https://github.com/docker/engine/pull/256">docker/engine＃256</a></li></ul><h4 id="日志相关"><a href="#日志相关" class="headerlink" title="日志相关"></a>日志相关</h4><ul><li>避免由于关闭已关闭的日志文件而导致容器日志无法旋转的情况。<a href="https://github.com/moby/moby/pull/40921">moby/moby＃40921</a></li><li>修复了读取日志日志的问题 <a href="https://github.com/moby/moby/pull/37819">moby/moby#37819</a> <a href="http://github.com/moby/moby/pull/38859">moby/moby#38859</a></li><li>在 Windows 上启用了 gcplogs 驱动程序。<a href="https://github.com/moby/moby/pull/37717">moby/moby＃37717</a></li><li>为 RFC5424 syslog 格式添加了零填充。<a href="https://github.com/moby/moby/pull/38335">moby/moby＃38335</a></li><li>添加<code>IMAGE_NAME</code>属性以<code>journald</code>记录事件。<a href="https://github.com/moby/moby/pull/38032">moby/moby＃38032</a></li></ul><h4 id="弃用"><a href="#弃用" class="headerlink" title="弃用"></a>弃用</h4><ul><li>  不推荐使用映像清单 v2 schema1，而推荐使用 v2 schema2。将来的 Docker 版本将完全不再支持 v2 schema1。<a href="https://github.com/moby/moby/pull/39365">moby/moby＃39365</a></li><li>  删除了 v1.10 迁移器。<a href="https://github.com/moby/moby/pull/38265">moby/moby＃38265</a></li><li>  现在跳过自动选择中已弃用的存储驱动程序。<a href="https://github.com/moby/moby/pull/38019">moby/moby＃38019</a></li><li>  不建议使用的<code>aufs</code>存储驱动程序，并添加了警告。<a href="https://github.com/moby/moby/pull/38090">moby/moby＃38090</a></li><li>  删除了对 17.09 的支持。</li></ul><h4 id="已知问题"><a href="#已知问题" class="headerlink" title="已知问题"></a>已知问题</h4><ul><li>在大型集群的某些情况下，作为 Swarm 部分的一部分，Docker 信息可能包含 error <code>code = ResourceExhausted desc = grpc: received message larger than max (5351376 vs. 4194304)</code>。这并不表示用户有任何故障或配置错误，并且不需要响应。</li><li>将所有服务重新部署为新服务时，可能会发生 Orchestrator 端口冲突。由于短时间内有许多 Swarm 管理器请求，因此某些服务无法接收流量，并且<code>404</code>在部署后会导致错误。<ul><li>  ** 解决方法：** 通过重新启动所有任务<code>docker service update --force</code>。</li></ul></li><li>具有目录遍历的 <a href="https://nvd.nist.gov/vuln/detail/CVE-2018-15664">CVE-2018-15664</a> symlink-exchange 攻击。解决方法，直到在即将进行的修补程序发行版中提供正确的修复程序：<code>docker pause</code>容器之前执行文件操作。<a href="https://github.com/moby/moby/pull/39252">moby/moby＃39252</a></li><li><code>docker cp</code>CVE 缓解导致的回归。当的来源<code>docker cp</code>设为时，会产生错误<code>/</code>。</li><li><h4 id="新问题"><a href="#新问题" class="headerlink" title="新问题"></a>新问题</h4><ul><li>```<br>  DOCKER-USER  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line">    iptables 链丢失：docker / for-linux＃810。用户无法在此 iptables 链的顶部执行其他容器网络流量过滤。如果您不自定义 iptable 链，则不会受到此问题的影响 DOCKER-USER</span><br><span class="line">    </span><br><span class="line">    *   解决办法：</span><br><span class="line">        </span><br><span class="line">        在 docker 守护程序启动后插入 iptables 链。例如：</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">iptables -N DOCKER-USER  </span><br><span class="line">iptables -I FORWARD -j DOCKER-USER  </span><br><span class="line">iptables -A DOCKER-USER -j RETURN  </span><br></pre></td></tr></table></figure></li></ul><h4 id="现有"><a href="#现有" class="headerlink" title="现有"></a>现有</h4><ul><li>在某些集群较大的情况下，作为 Swarm 部分的一部分，docker 信息可能包含 error <code>code = ResourceExhausted desc = grpc: received message larger than max (5351376 vs. 4194304)</code>。这并不表示用户有任何故障或配置错误，并且不需要响应。</li><li>将所有服务重新部署为新服务时，可能会发生 Orchestrator 端口冲突。由于在短时间内有许多群集管理器请求，因此某些服务无法接收流量，并且 404 在部署后会导致错误。<ul><li>  ** 解决方法：** 通过重新启动所有任务<code>docker service update --force</code>。</li></ul></li><li>具有目录遍历的 <a href="https://nvd.nist.gov/vuln/detail/CVE-2018-15664">CVE-2018-15664</a> symlink-exchange 攻击。解决方法，直到在即将进行的修补程序发行版中提供正确的修复程序：<code>docker pause</code>容器之前执行文件操作。<a href="https://github.com/moby/moby/pull/39252">moby/moby＃39252</a></li><li><code>docker cp</code>CVE 缓解导致的回归。当的来源<code>docker cp</code>设为时，会产生错误<code>/</code>。</li></ul></li><li>在某些集群较大的情况下，作为 Swarm 部分的一部分，docker 信息可能包含 error <code>code = ResourceExhausted desc = grpc: received message larger than max (5351376 vs. 4194304)</code>。这并不表示用户有任何故障或配置错误，并且不需要响应。</li><li>将所有服务重新部署为新服务时，可能会发生 Orchestrator 端口冲突。由于在短时间内有许多群集管理器请求，因此某些服务无法接收流量，并且<code>404</code>在部署后会导致错误。<ul><li>  解决方法：通过重新启动所有任务<code>docker service update --force</code>。</li></ul></li><li>由于缺少 FORWARD 链中的 Iptables 规则，流量无法流出主机。缺少的规则是：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/sbin/iptables --wait -C FORWARD -o docker_gwbridge -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">/sbin/iptables --wait -C FORWARD -o docker0 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">    </span><br></pre></td></tr></table></figure><ul><li>  解决方法：使用脚本和 cron 定义重新添加这些规则。该脚本必须包含 “-C” 命令以检查规则的存在，以及 “ -A” 命令以添加规则。定期在 cron 上运行脚本，例如，每个 分钟。</li><li>  受影响的版本：18.09.1、19.03.0</li></ul></li><li>具有目录遍历的 <a href="https://nvd.nist.gov/vuln/detail/CVE-2018-15664">CVE-2018-15664</a> symlink-exchange 攻击。解决方法，直到在即将进行的修补程序发行版中提供正确的修复程序：<code>docker pause</code>容器之前执行文件操作。<a href="https://github.com/moby/moby/pull/39252">moby/moby＃39252</a></li><li><code>docker cp</code>CVE 缓解导致的回归。当的来源<code>docker cp</code>设为时，会产生错误<code>/</code>。</li><li>在某些情况下，在大型集群中，泊坞窗信息可能会在 Swarm 部分中包含 error <code>code = ResourceExhausted desc = grpc: received message larger than max (5351376 vs. 4194304)</code>。这并不表示用户有任何故障或配置错误，并且不需要响应。</li><li>将所有服务重新部署为新服务时，可能会发生 Orchestrator 端口冲突。由于在短时间内有许多群集管理器请求，因此某些服务无法接收流量，并且 404 在部署后会导致错误。<ul><li>  解决方法：通过重新启动所有任务<code>docker service update --force</code>。</li></ul></li><li>由于缺少 FORWARD 链中的 Iptables 规则，流量无法流出主机。缺少的规则是：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/sbin/iptables --wait -C FORWARD -o docker_gwbridge -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">/sbin/iptables --wait -C FORWARD -o docker0 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">    </span><br></pre></td></tr></table></figure><ul><li>  解决方法：使用脚本和 cron 定义重新添加这些规则。该脚本必须包含 “-C” 命令以检查规则的存在，以及 “ -A” 命令以添加规则。定期在 cron 上运行脚本，例如，每个 分钟。</li><li>  受影响的版本：18.09.1、19.03.0</li></ul></li><li>具有目录遍历的 <a href="https://nvd.nist.gov/vuln/detail/CVE-2018-15664">CVE-2018-15664</a> symlink-exchange 攻击。解决方法，直到在即将进行的修补程序发行版中提供正确的修复程序：<code>docker pause</code>容器之前执行文件操作。<a href="https://github.com/moby/moby/pull/39252">moby/moby＃39252</a></li><li><code>docker cp</code>CVE 缓解导致的回归。当的来源<code>docker cp</code>设为时，会产生错误<code>/</code>。</li><li>在某些集群较大的情况下，作为 Swarm 部分的一部分，docker 信息可能包含 error <code>code = ResourceExhausted desc = grpc: received message larger than max (5351376 vs. 4194304)</code>。这并不表示用户有任何故障或配置错误，并且不需要响应。</li><li>将所有服务重新部署为新服务时，可能会发生 Orchestrator 端口冲突。由于在短时间内有许多群集管理器请求，因此某些服务无法接收流量，并且 404 在部署后会导致错误。<ul><li>  解决方法：通过重新启动所有任务<code>docker service update --force</code>。</li></ul></li><li>由于缺少 FORWARD 链中的 Iptables 规则，流量无法流出主机。缺少的规则是：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/sbin/iptables --wait -C FORWARD -o docker_gwbridge -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">/sbin/iptables --wait -C FORWARD -o docker0 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">    </span><br></pre></td></tr></table></figure><ul><li>  解决方法：使用脚本和 cron 定义重新添加这些规则。该脚本必须包含 “-C” 命令以检查规则的存在，以及 “ -A” 命令以添加规则。定期在 cron 上运行脚本，例如，每个 分钟。</li><li>  受影响的版本：18.09.1、19.03.0</li></ul></li><li>具有目录遍历的 <a href="https://nvd.nist.gov/vuln/detail/CVE-2018-15664">CVE-2018-15664</a> symlink-exchange 攻击。解决方法，直到在即将进行的修补程序发行版中提供正确的修复程序：<code>docker pause</code>容器之前执行文件操作。<a href="https://github.com/moby/moby/pull/39252">moby/moby＃39252</a></li><li><code>docker cp</code>CVE 缓解导致的回归。当的来源<code>docker cp</code>设为时，会产生错误。</li></ul><h4 id="打包相关"><a href="#打包相关" class="headerlink" title="打包相关"></a>打包相关</h4><ul><li>修复 ARM 基于 ARM64 构建。<a href="https://github.com/moby/moby/pull/41027">moby/moby＃41027</a></li><li>支持 RHEL 8 软件包</li></ul><h3 id="版本号：18-09"><a href="#版本号：18-09" class="headerlink" title="版本号：18.09"></a>版本号：18.09</h3><p>首次发布时间： 2018-11-08</p><h4 id="客户端相关-1"><a href="#客户端相关-1" class="headerlink" title="客户端相关"></a>客户端相关</h4><ul><li>  在非 Windows 上修复 Windows 绝对路径检测。<a href="https://github.com/docker/cli/pull/1990">docker/ cli＃1990</a></li><li>  修复 Docker 拒绝从 Windows 上的委托文件加载密钥的问题。<a href="https://github.com/docker/cli/pull/1968">docker/ cli＃1968</a></li><li>  bash 和 zsh 的完成脚本更新。</li><li>  修复了<code>parallelism</code>和<code>max_failure_ratio</code>字段的回滚配置类型插值。</li><li>  修复了 tty 初始大小错误。<a href="https://github.com/docker/cli/pull/1775">docker/ cli＃1775</a></li><li>  修复了 Dial-stdio goroutine 泄漏。<a href="https://github.com/docker/cli/pull/1795">docker/ cli＃1795</a></li><li>  修复了用于跟踪部署的堆栈通知程序的选择器。<a href="https://github.com/docker/cli/pull/1794">docker/ cli＃1794</a></li></ul><h4 id="日志相关-1"><a href="#日志相关-1" class="headerlink" title="日志相关"></a>日志相关</h4><ul><li>  修复了读取日志日志的问题。 <a href="https://github.com/moby/moby/pull/37819">moby/moby#37819</a> <a href="https://github.com/moby/moby/pull/38859">moby/moby#38859</a></li><li>  添加了一个修复程序，该修复程序现在允许记录器插件的日志行较大。<a href="https://github.com/moby/moby/pull/39038">moby/moby＃39038</a></li></ul><h4 id="网络相关-1"><a href="#网络相关-1" class="headerlink" title="网络相关"></a>网络相关</h4><ul><li>  通过禁用网络，防止连接到容器的网络出现混乱。<a href="https://github.com/moby/moby/pull/39589">moby/moby＃39589</a></li><li>  应用程序的修订服务端口随机变为不可用。<a href="https://github.com/docker/libnetwork/pull/2069">docker/ libnetwork＃2069</a></li><li>  修复清理<code>--config-only</code>网络<code>--config-from</code>网络剃毛的问题。<a href="https://github.com/docker/libnetwork/pull/2373">docker/ libnetwork＃2373</a></li><li>  修复了<code>--network-rm</code>无法删除网络的错误。<a href="https://github.com/moby/moby/pull/39174">moby/moby＃39174</a></li><li>  关闭代理后，请清理集群提供程序。<a href="https://github.com/docker/libnetwork/pull/2354">docker/ libnetwork＃2354</a></li><li>  Windows：现在，如果用户未指定主机端口，则选择一个随机主机端口。<a href="https://github.com/docker/libnetwork/pull/2369">docker/ libnetwork＃2369</a></li><li>  修复<code>network=host</code>了<code>resolv.conf</code>与错误的使用<code>systemd-resolved</code>。<a href="https://github.com/docker/engine/pull/180">docker/engine＃180</a></li><li>  修复了 Windows ARP 条目在负载下随机损坏的问题。<a href="https://github.com/docker/engine/pull/192">docker/engine＃192</a></li><li>  缩短 exec-root 中的控制器 ID，使其不命中 UNIX_PATH_MAX。<a href="https://github.com/docker/engine/pull/424">docker/engine＃424</a></li><li>  修复 drivers / overlay / encryption.go 中的紧急情况。<a href="https://github.com/docker/engine/pull/424">docker/engine＃424</a></li><li>  修复 hwaddr 设置我们和 udev 之间的比赛。<a href="https://github.com/docker/engine/pull/439">docker/engine＃439</a></li></ul><h4 id="运行相关-1"><a href="#运行相关-1" class="headerlink" title="运行相关"></a>运行相关</h4><ul><li>  更新至 Go 1.11.13。</li><li>  当对容器使用 XFS 磁盘配额时，修复潜在的 engine 异常。<a href="https://github.com/moby/moby/pull/39644">moby/moby＃39644</a></li><li>  在调试模式下运行 Docker Engine 时，屏蔽了更新到日志文件的机密。[docker stack deploy用于重新部署包含非外部机密的堆栈，则日志将包含该机密。](<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?&gt;CVE-2019-13509">https://cve.mitre.org/cgi-bin/cvename.cgi?&gt;CVE-2019-13509</a></a>：如果 Dockerengine 以调试模式运行，并&lt;code onclick=)</li><li>  [在 aufs 和图层存储中添加了性能优化，有助于大规模并行创建和删除容器。](<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?&gt;CVE-2019-13509">https://cve.mitre.org/cgi-bin/cvename.cgi?&gt;CVE-2019-13509</a></a>：如果 Dockerengine 以调试模式运行，并&lt;code onclick=)<a href="https://github.com/moby/moby/pull/39107">Moby / moby＃39107</a>，<a href="https://github.com/moby/moby/pull/39107">Moby</a> <a href="https://github.com/moby/moby/pull/39135">/ moby＃39135</a></li><li>  已将容器更新为版本 1.2.6。<a href="https://github.com/moby/moby/pull/39016">moby/moby＃39016</a></li><li>  修复了具有目录遍历的 <a href="https://nvd.nist.gov/vuln/detail/CVE-2018-15664">CVE-2018-15664</a> symlink-exchange 攻击。<a href="https://github.com/moby/moby/pull/39357">moby/moby＃39357</a></li><li>  Windows：修复了对的支持<code>docker service create --limit-cpu</code>。<a href="https://github.com/moby/moby/pull/39190">moby/moby＃39190</a></li><li>  守护程序：修复了镜像验证问题。 <a href="https://github.com/moby/moby/pull/38991">moby/moby＃38991</a></li><li>  Docker 不再支持在 ID 映射中对 UID 和 GID 范围进行排序。<a href="https://github.com/moby/moby/pull/39288">moby/moby＃39288</a></li><li>  现在显示已停止的容器，其重启策略为<code>Restarting</code>。<a href="https://github.com/docker/engine/pull/181">docker/engine＃181</a></li><li>  现在对执行人员使用原始流程规范。<a href="https://github.com/docker/engine/pull/178">docker/engine＃178</a></li><li>  修复<code>docker cp</code>了文件名大于 100 个字符的错误。<a href="https://github.com/moby/moby/pull/38634">moby/moby＃38634</a></li><li>  已修复，<code>layer/layer_store</code>以确保<code>NewInputTarStream</code>释放资源。<a href="https://github.com/moby/moby/pull/38413">moby/moby＃38413</a></li><li>  增加了 GRPC 的限制<code>GetConfigs</code>。<a href="https://github.com/moby/moby/pull/38800">moby/moby＃38800</a></li><li>  更新了<code>containerd</code>1.2.5。<a href="https://github.com/docker/engine/pull/173">docker/engine＃173</a></li></ul><h4 id="集群相关-1"><a href="#集群相关-1" class="headerlink" title="集群相关"></a>集群相关</h4><ul><li>  修复 “grpc：收到的邮件大于最大数量” 错误。<a href="https://github.com/moby/moby/pull/39306">moby/moby＃39306</a></li><li>  修复了无法删除多个任务的节点的问题。<a href="https://github.com/docker/swarmkit/pull/2867">docker/ swarmkit＃2867</a></li><li>  修复了删除节点时泄漏的任务资源。<a href="https://github.com/docker/engine/pull/185">docker/engine＃185</a></li><li>  修复了将节点加入集群时 nil 指针异常的问题。<a href="https://github.com/moby/moby/issues/38618">moby/moby＃38618</a></li><li>  修复了如果设置了 http 代理的群集节点无法加入为主节点的问题。[moby / moby＃36951]</li></ul><h4 id="构造相关-1"><a href="#构造相关-1" class="headerlink" title="构造相关"></a>构造相关</h4><ul><li>  修复了构建仅包含注释的 dockerfile 时的紧急错误。<a href="https://github.com/moby/moby/pull/38487">moby/moby＃38487</a></li><li>  添加了 GCR 身份验证问题的解决方法。<a href="https://github.com/moby/moby/pull/38246">moby/moby＃38246</a></li><li>  下一步生成器：修复了 GCR 令牌缓存实施解决方法中的错误。<a href="https://github.com/moby/moby/pull/39183">moby/moby＃39183</a></li><li>  修复<code>DOCKER_BUILDKIT=1 docker build --squash ..</code> <a href="https://github.com/docker/engine/pull/176">docker / engine＃176</a></li><li>  修复了 <a href="https://nvd.nist.gov/vuln/detail/CVE-2019-13139">CVE-2019-13139</a>，添加了验证，<code>git ref</code>以避免将其误解为标志。<a href="https://github.com/moby/moby/pull/38944">moby/moby＃38944</a></li></ul><h4 id="已知问题-1"><a href="#已知问题-1" class="headerlink" title="已知问题"></a>已知问题</h4><ul><li>升级过程中有一些<a href="https://docs.docker.com/ee/upgrade">重要更改</a>，如果未正确遵循，则会对升级期间在 Swarm 上运行的应用程序的可用性产生影响。这些限制影响从 18.09 之前的任何版本到 18.09 或更高版本的任何升级。</li><li>升级过程中有一些<a href="https://docs.docker.com/ee/upgrade">重要更改</a>，如果未正确遵循，则会对升级期间在 Swarm 上运行的应用程序的可用性产生影响。这些限制影响从 18.09 之前的任何版本到 18.09 或更高版本的任何升级。</li><li>已修复，<code>COPY</code>并且<code>ADD</code>具有多个 ``，不会使缓存无效<code>DOCKER_BUILDKIT=1</code>。<a href="https://github.com/moby/moby/issues/38964">moby/moby＃38964</a></li><li>升级过程中有一些<a href="https://docs.docker.com/ee/upgrade">重要更改</a>，如果未正确遵循，则会对升级期间在 Swarm 上运行的应用程序的可用性产生影响。这些限制影响从 18.09 之前的任何版本到 18.09 或更高版本的任何升级。</li><li>升级过程中有一些<a href="https://docs.docker.com/ee/upgrade">重要更改</a>，如果未正确遵循，则会对升级期间在 Swarm 上运行的应用程序的可用性产生影响。这些限制影响从 18.09 之前的任何版本到 18.09 或更高版本的任何升级。</li><li><a href="https://docs.docker.com/ee/upgrade">升级过程</a>中有一些<a href="https://docs.docker.com/ee/upgrade">重要更改</a>，如果未正确遵循，则会对升级期间在 Swarm 上运行的应用程序的可用性产生影响。这些限制影响从 18.09 之前的任何版本到 18.09 或更高版本的任何升级。</li><li><a href="https://docs.docker.com/ee/upgrade">升级过程</a>中有一些<a href="https://docs.docker.com/ee/upgrade">重要更改</a>，如果未正确遵循，则会对升级期间在 Swarm 上运行的应用程序的可用性产生影响。这些限制影响从 18.09 之前的任何版本到 18.09 或更高版本的任何升级。</li><li><a href="https://docs.docker.com/ee/upgrade">升级过程</a>中有一些<a href="https://docs.docker.com/ee/upgrade">重要更改</a>，如果未正确遵循，则会对升级期间在 Swarm 上运行的应用程序的可用性产生影响。这些限制影响从 18.09 之前的任何版本到 18.09 或更高版本的任何升级。</li><li>从 18.09.0 升级到 18.09.1 时，<code>containerd</code>在 Ubuntu 上没有升级到正确的版本。</li><li><a href="https://docs.docker.com/ee/upgrade">升级过程</a>中有一些<a href="https://docs.docker.com/ee/upgrade">重要更改</a>，如果未正确遵循，则会对升级期间在 Swarm 上运行的应用程序的可用性产生影响。这些限制影响从 18.09 之前的任何版本到 18.09 或更高版本的任何升级。</li><li><a href="https://docs.docker.com/ee/upgrade">升级过程</a>中有一些<a href="https://docs.docker.com/ee/upgrade">重要更改</a>，如果未正确遵循，则会对升级期间在 Swarm 上运行的应用程序的可用性产生影响。这些限制影响从 18.09 之前的任何版本到 18.09 或更高版本的任何升级。</li><li>使用 <a href="https://github.com/boot2docker/boot2docker/releases/download/v18.09.0/boot2docker.iso%EF%BC%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8A%E7%9A%84%E8%8A%82%E7%82%B9%E8%A2%AB%E6%8B%92%E7%BB%9D%E8%BF%9E%E6%8E%A5%E3%80%82%E5%9C%A8">https://github.com/boot2docker/boot2docker/releases/download/v18.09.0/boot2docker.iso，虚拟机上的节点被拒绝连接。在</a> virtualbox 创建的 docker-machine VM 中对群集端口的任何发布都不会响应。这是在 docker-machine 版本 0.15 和 0.16 的 macOS 和 Windows 10 上发生的。  以下<code>docker run</code>命令有效，允许从主机浏览器进行访问：  <code>docker run -d -p 4000:80 nginx</code>  但是，以下<code>docker service</code>命令失败，导致 curl / chrome 无法连接（连接被拒绝）：  <code>docker service create -p 5000:80 nginx</code>  使用 docker-machine 配置 18.09.0 云虚拟机时，此问题不明显。  解决方法：<ul><li>  使用不依赖 boot2docker 的云 VM。</li><li>  <code>docker run</code> 不受影响。</li><li>  对于 Swarm，设置 VIRTUALBOX_BOOT2DOCKER_URL = https：//github.com/boot2docker/boot2docker/releases/download/v18.06.1-ce/boot2docker.iso。</li></ul>  此问题已在 18.09.1。中解决。</li></ul><h4 id="打包相关-1"><a href="#打包相关-1" class="headerlink" title="打包相关"></a>打包相关</h4><ul><li>  为 docker.service 添加 docker.socket 要求。<a href="https://github.com/docker/docker-ce-packaging/pull/276">docker / docker-ce-packaging＃276</a></li><li>  为基于 RHEL 的发行版添加套接字激活。<a href="https://github.com/docker/docker-ce-packaging/pull/274">docker / docker-ce-packaging＃274</a></li><li>  为 RPM 软件包添加 libseccomp 要求。<a href="https://github.com/docker/docker-ce-packaging/pull/266">docker/ docker-ce-packaging＃266</a></li></ul><h4 id="运行修复和更新部分"><a href="#运行修复和更新部分" class="headerlink" title="运行修复和更新部分"></a>运行修复和更新部分</h4><ul><li>  更新到 Go 版本 1.10.8。</li><li>  容器名称生成器中的已修改名称。<a href="https://github.com/docker/engine/pull/159">docker/engine＃159</a></li><li>  复制现有文件夹时，现在将忽略目标文件系统不支持 xattr 时的 xattr 设置错误。<a href="https://github.com/docker/engine/pull/135">docker/engine＃135</a></li><li>  Graphdriver：固定的 “设备” 模式，如果设置了 “字符设备” 位。<a href="https://github.com/docker/engine/pull/160">docker/engine＃160</a></li><li>  修复了在无法连接到容器时 nil 指针取消引用的问题。<a href="https://github.com/docker/engine/pull/162">docker/engine＃162</a></li><li>  启动失败时删除了过时的容器对象。<a href="https://github.com/docker/engine/pull/154">docker/engine＃154</a></li></ul><h4 id="网络修复部分"><a href="#网络修复部分" class="headerlink" title="网络修复部分"></a>网络修复部分</h4><ul><li>  Windows：现在避免重新生成网络 ID，以防止损坏对网络的引用。<a href="https://github.com/docker/engine/pull/149">docker/engine＃149</a></li><li>  Windows：修复了<code>- restart always</code>在指定网络时无法解决独立容器上的标志的问题。（docker / 升级＃1037）</li><li>  修复了如果管理器未连接到覆盖网络时从 networkdb 解决 IPAM 状态的问题。（docker / 升级＃1049）</li><li>  将 Go 语言升级到 1.10.6 以解决 <a href="https://nvd.nist.gov/vuln/detail/CVE-2018-16873">CVE-2018-16873</a>，<a href="https://nvd.nist.gov/vuln/detail/CVE-2018-16874">CVE-2018-16874</a> 和 <a href="https://nvd.nist.gov/vuln/detail/CVE-2018-16875">CVE-2018-16875</a>。</li><li>  修复了用于长度为 0 的内容和路径验证的 authz 插件。</li><li>  添加<code>/proc/asound</code>到屏蔽路径 <a href="https://github.com/docker/engine/pull/126">docker / engine＃126</a></li></ul><h4 id="修复部分"><a href="#修复部分" class="headerlink" title="修复部分"></a>修复部分</h4><ul><li>  在 RHEL/CentOS 上禁用运行 c 中的 kmem 会计 (docker/escalation#614, docker/escalation#692) <a href="https://github.com/docker/engine/pull/121">docker/engine#121</a></li><li>  修复了效率低下的网络配置 <a href="https://github.com/docker/engine/pull/123">docker / engine＃123</a></li><li>  修复了 docker 系统修剪，直到过滤器才接受 <a href="https://github.com/docker/engine/pull/122">docker / engine＃122</a></li><li>  避免在<code>containerd</code>取消设置凭据 <a href="https://github.com/docker/engine/pull/122">docker / engine＃122 中</a></li><li>  修复了 Debian 上的 iptables 兼容性 <a href="https://github.com/docker/engine/pull/107">docker / engine＃107</a></li><li>  修复了将 Docker 主机默认架构设置为 tcp 的问题 <a href="https://github.com/docker/cli/pull/1454">docker / cli＃1454</a></li><li>  修复了 bash 完成<code>service update --force</code><a href="https://github.com/docker/cli/pull/1526">docker / cli＃1526</a></li><li>  Windows：清理 DetachVhd 尝试</li><li>  API：正确处理无效的 JSON 以返回 400 状态的 <a href="https://github.com/docker/engine/pull/110">docker / engine＃110</a></li><li>  API：忽略 API &lt;1.39 上的默认地址池 <a href="https://github.com/docker/engine/pull/118">docker / engine＃118</a></li><li>  API：将缺少的默认地址池字段添加到 <a href="https://github.com/docker/engine/pull/119">docker / engine＃119</a></li><li>  awslogs：在限制考虑 UTF-8 规范化 <a href="https://github.com/docker/engine/pull/112">docker / engine＃112</a></li><li>  禁止在 HTTP 错误响应读取超过 1MB 的内容 <a href="https://github.com/docker/engine/pull/114">docker / engine＃114</a></li><li>  apparmor：允许接收来自的信号<code>docker kill</code><a href="https://github.com/docker/engine/pull/116">docker / engine＃116</a></li><li>  overlay2：如果可能，使用 index = off（在挂载上修复 EBUSY）<a href="https://github.com/docker/engine/pull/84">docker / engine＃84</a></li><li>  BuildKit：不要取消 buildkit 状态请求。<a href="https://github.com/moby/moby/pull/37597">moby/moby＃37597</a></li><li>  修复如果在 docker 构建过程中缺少构建参数，则不会显示错误 <a href="https://github.com/moby/moby/pull/37396">moby/moby#37396</a></li><li>  修复了添加 8GB 文件时的错误 “意外 EOF”<a href="https://github.com/moby/moby/pull/37771">Moby / Moby＃37771</a></li><li>  LCOW：确保在<code>COPY</code>/ 上填充平台<code>ADD</code>。<a href="https://github.com/moby/moby/pull/37563">moby/moby＃37563</a></li><li>  修复了将一系列主机端口映射到单个容器端口的问题 <a href="https://github.com/docker/cli/pull/1102">docker / cli＃1102</a></li><li>  修正<code>trust inspect</code>拼写错误：“ <code>AdminstrativeKeys</code>” <a href="https://github.com/docker/cli/pull/1300">docker / cli＃1300</a></li><li>  修复了环境文件解析，以导入缺少的变量和没有名称的变量。<a href="https://github.com/docker/cli/pull/1019">docker/ cli＃1019</a></li><li>  修复了当运行<code>docker image prune</code>大量悬空镜像时可能出现的 “内存不足异常”<a href="https://github.com/docker/cli/pull/1432">docker / cli＃1432</a> / <a href="https://github.com/docker/cli/pull/1423">docker / cli＃1423</a></li><li>  修复 Windows 上 ConEmu 和 ConsoleZ 中的管道处理 <a href="https://github.com/moby/moby/pull/37600">moby / moby＃37600</a></li><li>  修复 Windows 上长时间启动的问题，并使用非 hns 控制的 Hyper-V 网络 <a href="https://github.com/docker/engine/pull/67">docker / engine＃67</a> / <a href="https://github.com/moby/moby/pull/37774">moby / moby＃37774</a></li><li>  修复了在配置文件和 cli 都定义了 “运行时” 选项时守护程序无法启动的问题 <a href="https://github.com/docker/engine/pull/57">docker / engine＃57</a> / <a href="https://github.com/moby/moby/pull/37871">moby / moby＃37871</a></li><li>  放宽对<code>/etc/docker</code>目录的权限，以防止在使用<code>docker manifest inspect</code>时出现 “permission denied” 错误 <a href="https://github.com/docker/engine/pull/56">docker/engine#56</a> / <a href="https://github.com/moby/moby/pull/37847">moby/moby#37847</a></li><li>  服务拒绝修复与大量<code>cpuset-cpus</code>和<code>cpuset-mems</code> <a href="https://github.com/docker/engine/pull/70">docker/enginer＃70</a> / <a href="https://github.com/moby/moby/pull/37967">MOBY / MOBY＃37967</a></li><li>  LCOW：添加<code>--platform</code>到 docker <code>docker import</code> <a href="https://github.com/docker/cli/pull/1375">/ cli＃1375</a> / <a href="https://github.com/docker/cli/pull/1371">docker / cli＃1371</a></li><li>  LCOW：默认在 Windows 上添加 LinuxMetadata 支持 <a href="https://github.com/moby/moby/pull/37514">Moby / moby＃37514</a></li><li>  LCOW：安装到较短的容器路径，以避免命令行长度限制 <a href="https://github.com/moby/moby/pull/37659">moby / moby＃37659</a></li><li>  LCOW：使用错误的缓存层修复了构建器 <a href="https://github.com/moby/moby/pull/37356">Moby / moby＃37356</a></li><li>  修复了 json-log 文件描述符在使用<code>--follow</code>时泄漏的问题 <a href="https://github.com/docker/engine/pull/48">docker/engine#48</a> <a href="https://github.com/moby/moby/pull/37576">moby/moby#37576</a> <a href="https://github.com/moby/moby/pull/37734">moby/moby#37734</a></li><li>  修复了在关闭 kqueue 上的监视器时可能出现的死锁 <a href="https://github.com/moby/moby/pull/37392">moby/moby#37392</a></li><li>  使用基于轮询的观察器来解决 Windows 的文件缓存问题 <a href="https://github.com/moby/moby/pull/37412">Moby / moby＃37412</a></li><li>  通过为网络层提供适当的 resolv.conf 来处理 systemd 解决的情况 <a href="https://github.com/moby/moby/pull/37485">moby / moby</a></li><li>  删除对 TLS &lt;1.2 的支持 <a href="https://github.com/moby/moby/pull/37660">moby / moby＃37660</a></li><li>  Seccomp：将<code>CAP_SYS_NICE</code>默认 seccomp 配置文件链接的白名单系统调用 <a href="https://github.com/moby/moby/pull/37242">moby / moby＃37242</a></li><li>  Seccomp：将 syslog 系统调用移至<code>CAP_SYS_ADMIN</code>或<code>CAP_SYSLOG</code>进行把控 <a href="https://github.com/docker/engine/pull/64">docker / engine＃64</a> / <a href="https://github.com/moby/moby/pull/37929">moby / moby＃37929</a></li><li>  SELinux：修复了在启用 selinux 的系统上通过 Mounts API 指定的本地卷的重新标记的方法 <a href="https://github.com/moby/moby/pull/37739">moby / moby＃37739</a></li><li>  如果可以通过不安全的连接访问 REST API，则添加警告 <a href="https://github.com/moby/moby/pull/37684">moby / moby＃37684</a></li><li>  当在系统信息显示时，从 URL 屏蔽代理凭据 <a href="https://github.com/docker/engine/pull/72">docker / engine＃72</a> / <a href="https://github.com/moby/moby/pull/37934">moby / moby＃37934</a></li><li>  修复了 btrfs 的挂载传播 <a href="https://github.com/docker/engine/pull/86">docker / engine＃86</a> / <a href="https://github.com/moby/moby/pull/38026">moby / moby＃38026</a></li><li>  修正零指针引用在节点分配 <a href="https://github.com/docker/engine/pull/94">docker/engine#94</a> / <a href="https://github.com/docker/swarmkit/pull/2764">docker/swarmkit#2764</a></li></ul><h4 id="改进部分"><a href="#改进部分" class="headerlink" title="改进部分"></a>改进部分</h4><ul><li>  更新至 BuildKit 0.3.3 docker <a href="https://github.com/docker/engine/pull/122">/ engine＃122</a></li><li>  更新为容器化的 1.2.2 <a href="https://github.com/docker/engine/pull/144">docker / engine＃144</a></li><li>  提供了有关使用不建议使用的旧版覆盖和 devicemapper 存储驱动程序其他警告 <a href="https://github.com/docker/engine/pull/85">docker / engine＃85</a></li><li>  修剪：在构建缓存修剪之前执行镜像修剪 <a href="https://github.com/docker/cli/pull/1532">docker / cli＃1532</a></li><li>  为实验性 CLI 命令添加了 bash <a href="https://github.com/docker/cli/pull/1542">补全</a>（清单）<a href="https://github.com/docker/cli/pull/1542">docker / cli＃1542</a></li><li>  Windows：允许 Windows 10 上的进程隔离 <a href="https://github.com/docker/engine/pull/81">docker / engine＃81</a></li><li>  `` 在 / info 响应不返回 “ ”<a href="https://github.com/moby/moby/pull/37472">moby / moby＃37472</a></li><li>  BuildKit：更改<code>--console=[auto,false,true]</code>至<code>--progress=[auto,plain,tty]</code> <a href="https://github.com/docker/cli/pull/1276">docker/ CLI＃1276</a></li><li>  BuildKit：设置 BuildKit 的 ExportedProduct 变量以在将来显示有用的错误。<a href="https://github.com/moby/moby/pull/37439">moby/moby＃37439</a></li><li>  <code>--data-path-addr</code>连接到不支持此选项的守护程序时隐藏标记 <a href="https://github.com/docker/cli/pull/1240">docker / docker / cli＃1240</a></li><li>  如果启用了 BuildKit，则仅显示特定于 buildkit 的标志 docker <a href="https://github.com/docker/cli/pull/1438">/ cli＃1438</a> / docker <a href="https://github.com/docker/cli/pull/1427">/ cli＃1427</a></li><li>  改进了版本输出对齐方式 <a href="https://github.com/docker/cli/pull/1204">docker / cli＃1204</a></li><li>  按自然顺序对插件名称和网络进行排序 <a href="https://github.com/docker/cli/pull/1166">docker / cli＃1166</a>，<a href="https://github.com/docker/cli/pull/1266">docker / cli＃1266</a></li><li>  更新 bash 和 zsh <a href="https://github.com/docker/cli/issues?q=label:area/completion+milestone:18.09.0+is:closed">完成脚本</a></li><li>  将日志级别传递到容器。<a href="https://github.com/moby/moby/pull/37419">moby/moby＃37419</a></li><li>  在东西覆盖负载使用直接服务器返回（DSR）平衡 <a href="https://github.com/docker/engine/pull/93">docker / 发动机＃93</a> / <a href="https://github.com/docker/libnetwork/pull/2270">docker/ libnetwork＃2270</a></li><li>  Builder：使用 buildkit 时暂时禁用桥接网络。<a href="https://github.com/moby/moby/pull/37691">moby/moby＃37691</a></li><li>  阻止任务开始直到节点附件准备就绪 <a href="https://github.com/moby/moby/pull/37604">Moby / Moby＃37604</a></li><li>  将提供的外部 CA 证书传播到 swarm 中的外部 CA 对象。<a href="https://github.com/docker/cli/pull/1178">docker/ cli＃1178</a></li><li>  移除 Ubuntu 14.04“Trusty Tahr” 作为受支持的平台 <a href="https://github.com/docker/docker-ce-packaging/pull/255">docker-ce-packaging＃255</a> / <a href="https://github.com/docker/docker-ce-packaging/pull/254">docker-ce-packaging＃254</a></li><li>  删除 Debian 8“Jessie” 作为受支持的平台 <a href="https://github.com/docker/docker-ce-packaging/pull/255">docker-ce-packaging＃255</a> / <a href="https://github.com/docker/docker-ce-packaging/pull/254">docker-ce-packaging＃254</a></li><li>  删除容器和 Runc 二进制文件 docker <a href="https://github.com/docker/engine/pull/61">/ engine＃61</a> / <a href="https://github.com/moby/moby/pull/37907">moby / moby＃37907</a>，<a href="https://github.com/moby/moby/pull/37907">docker</a> <a href="https://github.com/docker/docker-ce-packaging/pull/241">-ce-packaging＃241 的</a> ‘docker-‘前缀</li><li>  将 “engine”，“ cli” 和“ containerd”拆分为单独的程序包，并作为单独的系统服务容器运行 <a href="https://github.com/docker/docker-ce-packaging/pull/131">docker-ce-packaging＃131</a>，<a href="https://github.com/docker/docker-ce-packaging/pull/158">docker-ce-packaging＃158</a></li><li>  升级 Go 到 1.10.4 <a href="https://github.com/docker/docker-ce-packaging/pull/181">docker-ce-packaging#181</a></li><li>  <code>-ce</code>从版本字符串删除后缀 <a href="https://github.com/docker/docker-ce-packaging/pull/206">docker-ce-packaging＃206</a></li></ul><h4 id="安全修复部分"><a href="#安全修复部分" class="headerlink" title="安全修复部分"></a>安全修复部分</h4><ul><li>更新<code>runc</code>以解决一个严重漏洞，该漏洞使特制容器可以在主机上获得管理特权。[](<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?&gt;CVE-2019-5736">https://cve.mitre.org/cgi-bin/cvename.cgi?&gt;CVE-2019-5736</a></a></li><li> 使用 3.13 内核的 Ubuntu 14.04 客户将需要升级到受支持的 Ubuntu 4.x 内核</li></ul><p></p>&lt;h4 id=)新功能<ul><li>  API 版本更新为 1.39 <a href="https://github.com/moby/moby/pull/37640">Moby / moby＃37640</a></li><li>  添加了对使用 SSH 远程连接的支持 <a href="https://github.com/docker/cli/pull/1014">docker / cli＃1014</a></li><li>  Builder：向 API 添加了修剪选项 <a href="https://github.com/moby/moby/pull/37651">Moby / moby＃37651</a></li><li>  向<code>/info</code>端点添加了 “警告” ，并将检测移动到守护程序 <a href="https://github.com/moby/moby/pull/37502">moby / moby＃37502</a></li><li>  允许 BuildKit 构建在未启用实验模式的情况下运行。现在可以使用 daemon.json 中的选项配置 Buildkit.json <a href="https://github.com/moby/moby/pull/37593">moby / moby＃37593</a> <a href="https://github.com/moby/moby/pull/37686">moby / moby＃37686</a> <a href="https://github.com/moby/moby/pull/37692">moby / moby＃37692</a> <a href="https://github.com/moby/moby/pull/37686">docker</a> <a href="https://github.com/docker/cli/pull/1303">/ cli＃1303</a> <a href="https://github.com/docker/cli/pull/1275">docker / cli＃1275</a></li><li>  添加了对<code>--secret</code>使用 BuildKit 时使用标志的构建时机密的支持 <a href="https://github.com/docker/cli/pull/1288">docker/ cli＃1288</a></li><li>  <code>docker build --ssh $SSHMOUNTID=$SSH_AUTH_SOCK</code>使用 BuildKit [ 时添加了 SSH 代理套接字转发器（） <a href="https://github.com/docker/cli/pull/1438">docker/cli#1438</a> / <a href="https://github.com/docker/cli/pull/1419">docker/cli#1419</a></li><li>  在 Windows 上添加了对<code>--chown</code>标志<code>ADD</code>和<code>COPY</code>命令的标志支持<a href="https://github.com/moby/moby/pull/35521">＃35521</a></li><li>  <code>builder prune</code>向修剪 BuildKit 构建缓存添加了子命令 <a href="https://github.com/docker/cli/pull/1295">docker/cli#1295</a> <a href="https://github.com/docker/cli/pull/1334">docker/cli#1334</a></li><li>  BuildKit：为 BuildKit 构建缓存添加可配置的垃圾收集策略 <a href="https://github.com/docker/engine/pull/59">docker/engine#59</a> / <a href="https://github.com/moby/moby/pull/37846">moby/moby#37846</a></li><li>  BuildKit：添加了对<code>docker build --pull ...</code>使用 BuildKit 的支持 <a href="https://github.com/moby/moby/pull/37613">moby / moby＃37613</a></li><li>  BuildKit：使用 BuildKit 时添加支持或 “注册表镜像” 和“不安全注册表” <a href="https://github.com/docker/engine/pull/59">docker/engine#59</a> / <a href="https://github.com/moby/moby/pull/37852">moby/moby#37852</a></li><li>  BuildKit：启用网络模式和桥接。<a href="https://github.com/moby/moby/pull/37620">moby/moby＃37620</a></li><li>  添加了<code>docker engine</code>子命令来管理作为特权容器在容器之上运行的 Docker Engine 的生命周期，并允许升级到 Docker Engine Enterprise <a href="https://github.com/docker/cli/pull/1260">docker / cli＃1260</a></li><li>  <code>docker info</code>输出已公开产品许可证 <a href="https://github.com/docker/cli/pull/1313">docker / cli＃1313</a></li><li>  显示守护程序在<code>docker info</code>输出产生的警告 <a href="https://github.com/docker/cli/pull/1225">docker / cli＃1225</a></li><li>  添加了 “本地” 日志驱动程序 <a href="https://github.com/moby/moby/pull/37092">moby / moby＃37092</a></li><li>  Amazon CloudWatch：添加<code>awslogs-endpoint</code>日志记录选项 <a href="https://github.com/moby/moby/pull/37374">moby / moby＃37374</a></li><li>  添加了对全局默认地址池的支持 <a href="https://github.com/moby/moby/pull/37558">moby / moby＃37558 docker</a> <a href="https://github.com/docker/cli/pull/1233">/ cli＃1233</a></li><li>  配置的容器化日志级别与 dockerd 相同 <a href="https://github.com/moby/moby/pull/37419">moby / moby＃37419</a></li><li>  为 cri-containerd <a href="https://github.com/moby/moby/pull/37519">moby / moby</a> 添加了配置选项<a href="https://github.com/moby/moby/pull/37519">＃37519</a></li><li>  将容器化的客户端更新为 v1.2.0-rc.1 <a href="https://github.com/moby/moby/pull/37664">moby / moby＃37664</a>，<a href="https://github.com/moby/moby/pull/37664">docker</a> <a href="https://github.com/docker/engine/pull/75">/ engine＃75</a> / <a href="https://github.com/moby/moby/pull/37710">moby / moby＃37710</a></li><li>  添加了对全局默认地址池的支持 <a href="https://github.com/moby/moby/pull/37558">moby / moby＃37558 docker</a> <a href="https://github.com/docker/cli/pull/1233">/ cli＃1233</a></li><li>  将<code>POST /session</code>端点移出实验。<a href="https://github.com/moby/moby/pull/40028">moby/moby＃40028</a></li></ul><h4 id="弃用-1"><a href="#弃用-1" class="headerlink" title="弃用"></a>弃用</h4>  Docker 已弃用对 Device Mapper 作为存储驱动程序的支持。目前将继续支持它，但是在将来的版本中将删除该支持。<h4 id="终止服务"><a href="#终止服务" class="headerlink" title="终止服务"></a>终止服务</h4>  在此版本中，Docker 还删除了对 TLS &lt;1.2 <a href="https://github.com/moby/moby/pull/37660">moby / moby＃37660</a>，Ubuntu 14.04“ Trusty <a href="https://github.com/moby/moby/pull/37660">Tahr</a> ” <a href="https://github.com/moby/moby/pull/37660">docker</a> <a href="https://github.com/docker/docker-ce-packaging/pull/255">-ce-packaging＃255</a> / <a href="https://github.com/docker/docker-ce-packaging/pull/254">docker-ce-packaging＃254</a> 和 Debian 8“Jessie” <a href="https://github.com/docker/docker-ce-packaging/pull/255">docker-ce 的支持。 -packaging＃255</a> / <a href="https://github.com/docker/docker-ce-packaging/pull/255">docker</a> <a href="https://github.com/docker/docker-ce-packaging/pull/254">-ce-packaging＃254</a>。<h3 id="版本号：18-06"><a href="#版本号：18-06" class="headerlink" title="版本号：18.06"></a>版本号：18.06</h3>  首次发布时间： 2018-07-18<h4 id="Docker-Engine-的安全修复程序"><a href="#Docker-Engine-的安全修复程序" class="headerlink" title="Docker Engine 的安全修复程序"></a>Docker Engine 的安全修复程序</h4><ul><li>更改<code>runc</code>关键漏洞补丁的应用方式，以将修补程序包括在 RPM 软件包中。 <a href="https://github.com/docker/engine/pull/156">docker/engine#156</a></li><li>更新<code>runc</code>以解决一个严重漏洞，该漏洞使特制容器可以在主机上获得管理特权。[](<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?&gt;CVE-2019-5736">https://cve.mitre.org/cgi-bin/cvename.cgi?&gt;CVE-2019-5736</a></a></p> </li><li> <p>使用 3.13 内核的 Ubuntu 14.04 客户将需要升级到受支持的 Ubuntu 4.x 内核</p> </li></ul><p></p>&lt;h4 id=)构造相关<ul><li>  如果在 docker build 期间缺少 build args，则不会修复任何错误。<a href="https://github.com/docker/engine/pull/25">docker/engine＃25</a></li><li>  设置 BuildKit 的 ExportedProduct 变量以显示有用的错误。<a href="https://github.com/docker/engine/pull/21">docker/engine＃21</a></li><li>  Builder：修复多级通配符副本上的图层泄漏。<a href="https://github.com/moby/moby/pull/37178">moby/moby＃37178</a></li><li>  修复了无效环境变量替换的解析。<a href="https://github.com/moby/moby/pull/37134">moby/moby＃37134</a></li><li>  生成器：使用基础镜像中的拱门信息。<a href="https://github.com/moby/moby/pull/37197">moby/moby</a><a href="https://github.com/moby/moby/pull/36816">＃36816</a> <a href="https://github.com/moby/moby/pull/37197">moby/moby＃37197</a></li><li>  基于 <a href="https://github.com/moby/buildkit">BuildKit 的</a>新的实验生成器后端。要启用，请在实验模式下运行守护程序，然后<code>DOCKER_BUILDKIT=1</code>在 Docker CLI 上设置环境变量。<a href="https://github.com/moby/moby/pull/37151">moby / moby＃37151</a> <a href="https://github.com/docker/cli/pull/1111">docker / cli＃1111</a></li><li>  修复了在多阶段构建中处理大写目标名称的问题。<a href="https://github.com/moby/moby/pull/36960">moby/moby＃36960</a></li></ul><h4 id="客户端相关-2"><a href="#客户端相关-2" class="headerlink" title="客户端相关"></a>客户端相关</h4><ul><li>  各种 Shell 完成脚本更新：<a href="https://github.com/docker/cli/pull/1229">docker / cli＃1229</a>， <a href="https://github.com/docker/cli/pull/1268">docker / cli＃1268</a> 和 <a href="https://github.com/docker/cli/pull/1272">docker / cli＃1272</a></li><li>  修复<code>DOCKER_CONFIG</code>警告消息和后备搜索。<a href="https://github.com/docker/cli/pull/1241">docker/ cli＃1241</a></li><li>  修复<code>docker stack</code>命令和子命令上的帮助消息标志。<a href="https://github.com/docker/cli/pull/1267">docker/ cli＃1267</a></li></ul><h4 id="运行相关-2"><a href="#运行相关-2" class="headerlink" title="运行相关"></a>运行相关</h4><ul><li>默认情况下，禁用在端口 10010 上侦听的 CRI 插件。<a href="https://github.com/docker/engine/pull/29">docker/engine＃29</a></li><li>将容器更新到 v1.1.2。<a href="https://github.com/docker/engine/pull/33">docker/engine＃33</a></li><li>Windows：如果终止调用，则不要调用 HCS 关闭。<a href="https://github.com/docker/engine/pull/31">docker/engine＃31</a></li><li>Windows：为 Windows 日志监视程序选择基于轮询的监视程序。<a href="https://github.com/docker/engine/pull/34">docker/engine＃34</a></li><li>将 spf13 / cobra 碰撞到 v0.0.3，将 pflag 碰撞到 v1.0.1。<a href="https://github.com/moby/moby/pull/37106">moby/moby＃37106</a></li><li>添加对新的 Kubernetes v1beta2 堆栈 API 的支持。<a href="https://github.com/docker/cli/pull/899">docker/ cli＃899</a></li><li>K8s：部署时更强大的堆栈错误检测。<a href="https://github.com/docker/cli/pull/948">docker/ cli＃948</a></li><li>在 compose 3.7 中支持回滚配置。<a href="https://github.com/docker/cli/pull/409">docker/ cli＃409</a></li><li>更新 Cobra 和 pflag，并使用内置的–version 功能。<a href="https://github.com/docker/cli/pull/1069">docker/ cli＃1069</a></li><li><code>docker stack deploy --prune</code>使用空名称修复，删除所有服务。<a href="https://github.com/docker/cli/pull/1088">docker/ cli＃1088</a></li><li>[Kubernetes] 堆栈服务过滤器。<a href="https://github.com/docker/cli/pull/1023">docker/ cli＃1023</a></li><li>仅在帮助中的 root，stack 和 version 命令中显示 orchestrator 标志。<a href="https://github.com/docker/cli/pull/1106">docker/ cli＃1106</a></li><li><code>Extras</code>在撰写配置类型上添加一个字段。<a href="https://github.com/docker/cli/pull/1126">docker/ cli＃1126</a></li><li>将选项添加到 compose loader。<a href="https://github.com/docker/cli/pull/1128">docker/ cli＃1128</a></li><li>修复始终在 Kubernetes 上的 docker stack ps 命令中列出节点的问题。<a href="https://github.com/docker/cli/pull/1093">docker/ cli＃1093</a></li><li>修复在堆栈 rm 错误消息中两次显示输出的问题。<a href="https://github.com/docker/cli/pull/1093">docker/ cli＃1093</a></li><li>使用自定义 HTTP 请求扩展客户端 API。<a href="https://github.com/moby/moby/pull/37071">moby/moby＃37071</a></li><li>更改了针对不可读文件的错误消息，以阐明. Dockerignore 条目的可能性。<a href="https://github.com/docker/cli/pull/1053">docker/ cli＃1053</a></li><li>在配置文件中将 kubernetes.allNamespaces 值限制为 “enabled” 或“ disabled”。<a href="https://github.com/docker/cli/pull/1087">docker/ cli＃1087</a></li><li>在 help 命令中初始化 Docker 客户端时检查错误。<a href="https://github.com/docker/cli/pull/1119">docker/ cli＃1119</a></li><li>Kubernetes 更好的命名空间体验。使用〜/ .kube / config 中定义的名称空间来解决堆栈命令。为 docker stack ls 命令添加一个 NAMESPACE 列。为 docker stack ls 命令添加–all-namespaces 标志。<a href="https://github.com/docker/cli/pull/991">docker/ cli＃991</a></li><li>导出推送并保存。<a href="https://github.com/docker/cli/pull/1123">docker/ cli＃1123</a></li><li>导出拉为公共功能。<a href="https://github.com/docker/cli/pull/1026">docker/ cli＃1026</a></li><li>从实验性删除 Kubernetes 命令。<a href="https://github.com/docker/cli/pull/1068">docker/ cli＃1068</a></li><li>添加配置 / 秘密服务检查漂亮。<a href="https://github.com/docker/cli/pull/1006">docker/ cli＃1006</a></li><li>在 Kubernetes 上按名称修复服务过滤。<a href="https://github.com/docker/cli/pull/1101">docker/ cli＃1101</a></li><li>修复中的组件信息对齐<code>docker version</code>。<a href="https://github.com/docker/cli/pull/1065">docker/ cli＃1065</a></li><li>修复 cpu / 内存限制和保留在服务更新时重置。<a href="https://github.com/docker/cli/pull/1079">docker/ cli＃1079</a></li><li>清单清单：请求特定的权限。<a href="https://github.com/docker/cli/pull/1024">docker/ cli＃1024</a></li><li>设置–orchestrator = all 还会设置–all-namespaces，除非设置了特定的–namespace。<a href="https://github.com/docker/cli/pull/1059">docker/ cli＃1059</a></li><li>一起使用–compress 和–stream 时，可以解决紧急情况。<a href="https://github.com/docker/cli/pull/1105">docker/ cli＃1105</a></li><li>从 x / net / context 切换到上下文。<a href="https://github.com/docker/cli/pull/1038">docker/ cli＃1038</a></li><li>将–init 选项添加到中<code>docker service create</code>。<a href="https://github.com/docker/cli/pull/479">docker/ cli＃479</a></li><li>修复了合并–stream 和–quiet 标志时显示生成构建命令的垃圾输出的错误。<a href="https://github.com/docker/cli/pull/1090">docker/ cli＃1090</a></li><li><code>init</code>在 3.7 模式中添加支持。<a href="https://github.com/docker/cli/pull/1129">docker/ cli＃1129</a></li><li>修复 Docker 信任签名者删除。<a href="https://github.com/docker/cli/pull/1112">docker/ cli＃1112</a></li><li>修复来自 docker inspect 的错误消息 <a href="https://github.com/docker/cli/pull/1071">docker/ cli＃1071</a></li><li>允许<code>x-*</code>在第 3 级对象上扩展。<a href="https://github.com/docker/cli/pull/1097">docker/ cli＃1097</a></li><li>无效的协调器现在会生成错误，而不是被静默忽略。<a href="https://github.com/docker/cli/pull/1055">docker/ cli＃1055</a></li><li>在 docker stack ls 命令中添加了 ORCHESTRATOR 列。<a href="https://github.com/docker/cli/pull/973">docker/ cli＃973</a></li><li>在将 host-ip 用于已发布的服务端口时发出警告。<a href="https://github.com/docker/cli/pull/1017">docker/ cli＃1017</a></li><li>添加了通过<code>DOCKER_CLI_EXPERIMENTAL</code>环境变量启用实验性 cli 功能的选项。<a href="https://github.com/docker/cli/pull/1138">docker/ cli＃1138</a></li><li>将 exec_die 添加到已知容器事件的列表中。<a href="https://github.com/docker/cli/pull/1028">docker/ cli＃1028</a></li><li>[K8s] 对未解释的 Config 文件进行环境变量扩展。<a href="https://github.com/docker/cli/pull/974">docker/ cli＃974</a></li><li>在解析组成文件以在 Kubernetes 上部署时，在 stderr 上为每个不支持的功能打印警告。<a href="https://github.com/docker/cli/pull/903">docker/ cli＃903</a></li><li>添加了有关 pids 计数的描述。<a href="https://github.com/docker/cli/pull/1045">docker/ cli＃1045</a></li><li>修剪时警告用户使用过滤器。<a href="https://github.com/docker/cli/pull/1043">docker/ cli＃1043</a></li><li>修复<code>--rollback-*</code>选项覆盖<code>--update-*</code>选项。<a href="https://github.com/docker/cli/pull/1052">docker/ cli＃1052</a></li><li>更新附加，生成，提交，Cp，创建子命令鱼补全。<a href="https://github.com/docker/cli/pull/1005">docker/ cli＃1005</a></li><li>为添加 bash 完成<code>dockerd --default-address-pool</code>。<a href="https://github.com/docker/cli/pull/1173">docker/ cli＃1173</a></li><li>为<code>exec_die</code>事件添加 bash 完成。<a href="https://github.com/docker/cli/pull/1173">docker/ cli＃1173</a></li><li>更新 docker-credential-helper，因此<code>pass</code>不会在每个 docker 命令上都调用它。<a href="https://github.com/docker/cli/pull/1184">docker/ cli＃1184</a></li><li>修复了旋转群集外部 CA 的问题。<a href="https://github.com/docker/cli/pull/1199">docker/ cli＃1199</a></li><li>改进版本输出对齐方式。<a href="https://github.com/docker/cli/pull/1207">docker/ cli＃1207</a></li><li>为添加 bash 完成<code>service create|update --init</code>。<a href="https://github.com/docker/cli/pull/1210">docker/ cli＃1210</a></li><li>Aufs：记录为什么不支持 aufs。<a href="https://github.com/moby/moby/pull/36995">moby/moby＃36995</a></li><li>在 Windows 上隐藏实验性检查点功能。<a href="https://github.com/docker/cli/pull/1094">docker/ cli＃1094</a></li><li>Lcow：允许客户端为 LCOW 容器自定义功能和设备 cgroup 规则。<a href="https://github.com/moby/moby/pull/37294">moby/moby＃37294</a></li><li>将 Windows 中可执行输出的给定路径更改为可执行输出的实际位置。<a href="https://github.com/moby/moby/pull/37295">moby/moby＃37295</a></li><li>添加 Windows 回收站测试并将 hcsshim 更新到 v0.6.11。<a href="https://github.com/moby/moby/pull/36994">moby/moby＃36994</a></li><li>进行运行时允许添加任何参数。<a href="https://github.com/moby/moby/pull/37190">moby/moby＃37190</a></li><li>优化 ContainerTop（）又名 docker top。<a href="https://github.com/moby/moby/pull/37131">moby/moby＃37131</a></li><li>在 32 位计算机上修复编译。<a href="https://github.com/moby/moby/pull/37292">moby/moby＃37292</a></li><li>将 API 版本更新为 <a href="https://github.com/moby/moby/pull/37141">v138。moby / moby＃37141</a></li><li>修复<code>docker service update --host-add</code>不会更新现有的主机条目。<a href="https://github.com/docker/cli/pull/1054">docker/ cli＃1054</a></li><li>修复 ExecIds 的大头贴文件类型。<a href="https://github.com/moby/moby/pull/36962">moby/moby＃36962</a></li><li>修正了摇摇卷类型的生成。<a href="https://github.com/moby/moby/pull/37060">moby/moby＃37060</a></li><li>修复卷 / 服务包中的错误声明。<a href="https://github.com/moby/moby/pull/37211">moby/moby＃37211</a></li><li>当插件运行时，重新启动时修复守护进程紧急情况。<a href="https://github.com/moby/moby/pull/37234">moby/moby＃37234</a></li><li>从 “标签” 选项构建 “ LABEL” 命令并将其添加到最后阶段。<a href="https://github.com/moby/moby/pull/37011">moby/moby＃37011</a></li><li>修复执行启动和调整大小之间的竞争条件<a href="https://github.com/moby/moby/pull/37172">。.moby / moby＃37172</a></li><li>替代故障缓解<code>TestExecInteractiveStdinClose</code>。<a href="https://github.com/moby/moby/pull/37143">moby/moby＃37143</a></li><li>RawAccess 允许将一组路径设置为未屏蔽或只读。<a href="https://github.com/moby/moby/pull/36644">moby/moby＃36644</a></li><li>明确说明 github.com 前缀是一项旧功能。<a href="https://github.com/moby/moby/pull/37174">moby/moby＃37174</a></li><li>将 Golang 升至 1.10.3。<a href="https://github.com/docker/cli/pull/1122">docker/ cli＃1122</a></li><li>关闭 ReadClosers 以防止 xz 僵尸。<a href="https://github.com/moby/moby/pull/34218">moby/moby＃34218</a></li><li>Daemon.ContainerStop（）：修复了超时错误。<a href="https://github.com/moby/moby/pull/36874">moby/moby＃36874</a></li><li>Daemon.setMounts（）：复制切片。<a href="https://github.com/moby/moby/pull/36991">moby/moby＃36991</a></li><li>描述大方端口定义的 IP 字段。<a href="https://github.com/moby/moby/pull/36971">moby/moby＃36971</a></li><li>将卷交互提取到卷服务。<a href="https://github.com/moby/moby/pull/36688">moby/moby＃36688</a></li><li>修复了 docker image v1，v1.1 和 v1.2 规范中的 markdown 格式。<a href="https://github.com/moby/moby/pull/37051">moby/moby＃37051</a></li><li>改进 GetTimestamp 解析。<a href="https://github.com/moby/moby/pull/35402">moby/moby＃35402</a></li><li>Jsonmessage：将消息传递给 aux 回调。<a href="https://github.com/moby/moby/pull/37064">moby/moby＃37064</a></li><li>覆盖 2：删除未使用的 cdMountFrom（）帮助函数。<a href="https://github.com/moby/moby/pull/37041">moby/moby＃37041</a></li><li>覆盖：修复覆盖存储驱动程序，而忽略了未知的存储驱动程序选项。<a href="https://github.com/moby/moby/pull/37040">moby/moby＃37040</a></li><li>删除一些未使用的贡献项目。<a href="https://github.com/moby/moby/pull/36977">moby/moby＃36977</a></li><li>Restartmanager：不要对创建的容器应用重启策略。<a href="https://github.com/moby/moby/pull/36924">moby/moby＃36924</a></li><li>设置 ExecID 的项目类型。<a href="https://github.com/moby/moby/pull/37121">moby/moby＃37121</a></li><li>在 Linux 版本的 dockerd 中使用 go-systemd const 代替魔术字符串。<a href="https://github.com/moby/moby/pull/37136">moby/moby＃37136</a></li><li>使用 stdlib TLS 拨号程序。<a href="https://github.com/moby/moby/pull/36687">moby/moby＃36687</a></li><li>根据 <a href="https://docs.docker.com/config/labels-custom">https://docs.docker.com/config/labels-custom</a> - 配置使用保留名称空间（com.docker。*，io.docker。_或 org.dockerproject。_）的 engine 标签时发出警告。元数据 /。<a href="https://github.com/moby/moby/pull/36921">moby/moby＃36921</a></li><li>修复消息中缺少的插件名称。<a href="https://github.com/moby/moby/pull/37052">moby/moby＃37052</a></li><li>修复 CONTRIBUTING.md 中的链接锚点。<a href="https://github.com/moby/moby/pull/37276">moby/moby＃37276</a></li><li>修复到 Docker Toolbox 的链接。<a href="https://github.com/moby/moby/pull/37240">moby/moby＃37240</a></li><li>修复误用的跳过条件。<a href="https://github.com/moby/moby/pull/37179">moby/moby＃37179</a></li><li>修复绑定挂载在某些情况下不起作用。<a href="https://github.com/moby/moby/pull/37031">moby/moby＃37031</a></li><li>修复 fd 泄漏。<a href="https://github.com/moby/moby/pull/37184">moby/moby＃37184</a></li><li>修复流利的局部检测。<a href="https://github.com/moby/moby/pull/37029">moby/moby＃37029</a></li><li>修复 version-history.md 中的错误链接。<a href="https://github.com/moby/moby/pull/37049">moby/moby＃37049</a></li><li>允许 vim 对 dockerfile 中的 D 不区分大小写。<a href="https://github.com/moby/moby/pull/37235">moby/moby＃37235</a></li><li>添加<code>t.Name()</code>到测试中，以便服务名称是唯一的。<a href="https://github.com/moby/moby/pull/37166">moby/moby＃37166</a></li><li>如果 backendfs 是没有 d_type 支持的 extfs，则添加其他消息。<a href="https://github.com/moby/moby/pull/37022">moby/moby＃37022</a></li><li>添加 api 版本检查以检查新功能中的测试。<a href="https://github.com/moby/moby/pull/37169">moby/moby＃37169</a></li><li>添加用于推拉的镜像指标。<a href="https://github.com/moby/moby/pull/37233">moby/moby＃37233</a></li><li>添加<code>init</code>对服务的支持。<a href="https://github.com/moby/moby/pull/37183">moby/moby＃37183</a></li><li>在 pkg / term / proxy.go 中添加转义键数组长度的验证。<a href="https://github.com/moby/moby/pull/36918">moby/moby＃36918</a></li><li>当 overlay2 的链接 ID 为空时，请勿删除此链接<a href="https://github.com/moby/moby/pull/36161">。.moby / moby＃36161</a></li><li>通过定义 Self（）修复在 OpenBSD 上的构建。<a href="https://github.com/moby/moby/pull/37301">moby/moby＃37301</a></li><li>Windows：修复了对 Hyper-v 隔离容器的命名管道支持。<a href="https://github.com/docker/engine/pull/2">docker/engine＃2</a> <a href="https://github.com/docker/cli/pull/1165">docker/ cli＃1165</a></li><li>修正清单清单，以始终使用正确的大小。<a href="https://github.com/docker/cli/pull/1183">docker/ cli＃1183</a></li><li>注册 OCI 媒体类型。<a href="https://github.com/docker/engine/pull/4">docker/engine＃4</a></li><li>将容器更新到 v1.1.1 <a href="https://github.com/docker/engine/pull/17">docker / engine＃17</a></li><li>LCOW：在清单列表中，Windows 优先于 Linux。<a href="https://github.com/docker/engine/pull/3">docker/engine＃3</a></li><li><code>MaskPaths</code>直接使用容器添加添加代码路径中使用的更新以解决 [docker/engine＃15](<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?&gt;CVE-2018-10892">https://cve.mitre.org/cgi-bin/cvename.cgi?&gt;CVE-2018-10892</a></a>。&lt;a href=)</li><li>添加<code>/proc/acpi</code>到掩码路径以解决 [docker/engine＃14](<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?&gt;CVE-2018-10892">https://cve.mitre.org/cgi-bin/cvename.cgi?&gt;CVE-2018-10892</a></a>。&lt;a href=)</li><li>  修复 bindmount 自动创建种族。<a href="https://github.com/docker/engine/pull/11">docker/engine＃11</a></li></ul><h4 id="日志相关-2"><a href="#日志相关-2" class="headerlink" title="日志相关"></a>日志相关</h4><ul><li>  允许 awslogs 使用非阻塞模式。<a href="https://github.com/moby/moby/pull/36522">moby / moby＃36522</a></li><li>  改善流利的日志驱动程序上长日志行的记录。.moby <a href="https://github.com/moby/moby/pull/36159">/ moby＃36159</a></li><li>  重新排序 CHANGELOG.md 以通过<code>make validate</code>测试。<a href="https://github.com/moby/moby/pull/37047">moby/moby＃37047</a></li><li>  更新事件，执行，导出，历史记录，镜像，导入，检查，加载和登录子命令鱼的完成。<a href="https://github.com/docker/cli/pull/1061">docker/ cli＃1061</a></li><li>  更新 RingLogger 环形缓冲区的文档。<a href="https://github.com/moby/moby/pull/37084">moby/moby＃37084</a></li><li>  添加日志失败 / 部分的指标。<a href="https://github.com/moby/moby/pull/37034">moby/moby＃37034</a></li><li>  修复日志记录插件崩溃无法恢复的问题。<a href="https://github.com/moby/moby/pull/37028">moby/moby＃37028</a></li><li>  修复日志记录测试类型。<a href="https://github.com/moby/moby/pull/37070">moby/moby＃37070</a></li><li>  修复日志 API 中的竞争条件。<a href="https://github.com/moby/moby/pull/37062">moby/moby＃37062</a></li><li>  修复了日志文件阅读器和轮换中的一些问题。<a href="https://github.com/moby/moby/pull/37063">moby/moby＃37063</a></li></ul><h4 id="弃用-2"><a href="#弃用-2" class="headerlink" title="弃用"></a>弃用</h4><ul><li>  文档保留的名称空间已弃用。<a href="https://github.com/docker/cli/pull/1040">docker/ cli＃1040</a></li></ul><h4 id="网络相关-2"><a href="#网络相关-2" class="headerlink" title="网络相关"></a>网络相关</h4><ul><li>  允许用户为 Docker 网络指定默认地址池。<a href="https://github.com/moby/moby/pull/36396">moby / moby＃36396 docker</a> <a href="https://github.com/docker/cli/pull/818">/ cli＃818</a></li><li>  为 ipam state <a href="https://github.com/docker/libnetwork/pull/2147">doccker / libnetwork＃2417</a> 添加日志</li><li>  修复覆盖网络驱动程序 <a href="https://github.com/docker/libnetwork/pull/2143">doccker / libnetwork＃2143</a> 中的竞争条件</li><li>  将等待时间添加到 <a href="https://github.com/docker/libnetwork/pull/2142">xtables</a> 锁定警告 <a href="https://github.com/docker/libnetwork/pull/2142">doccker / libnetwork＃2142</a></li><li>  当 firewalld 处于活动状态时过滤 <a href="https://github.com/docker/libnetwork/pull/2135">xtables</a> 锁定警告 <a href="https://github.com/docker/libnetwork/pull/2135">doccker / libnetwork＃2135</a></li><li>  从 x / net / context 切换到 context <a href="https://github.com/docker/libnetwork/pull/2140">doccker / libnetwork＃2140</a></li><li>  为拆分的八卦群集 <a href="https://github.com/docker/libnetwork/pull/2134">doccker / libnetwork＃2134</a> 添加恢复机制</li><li>  现在，对网络附件任务运行 docker inspect 会返回完整的任务对象。<a href="https://github.com/moby/moby/pull/35246">moby/moby＃35246</a></li><li>  一些容器 / 网络清理。<a href="https://github.com/moby/moby/pull/37033">moby/moby＃37033</a></li><li>  修复网络检查覆盖网络。<a href="https://github.com/moby/moby/pull/37045">moby/moby＃37045</a></li><li>  提高 Linux 负载平衡的可伸缩性。<a href="https://github.com/docker/engine/pull/16">docker/engine＃16</a></li><li>  将日志级别从错误更改为警告。<a href="https://github.com/docker/engine/pull/19">docker/engine＃19</a></li></ul><h4 id="集群相关-2"><a href="#集群相关-2" class="headerlink" title="集群相关"></a>集群相关</h4><ul><li>  修复用于跳过正在运行的任务的条件。<a href="https://github.com/docker/swarmkit/pull/2677">docker/ swarmkit＃2677</a></li><li>  修复任务排序。<a href="https://github.com/docker/swarmkit/pull/2712">docker/ swarmkit＃2712</a></li><li>  在 docker stack ls 中使用–orchestrator = all 列出 Swarm 和 Kubernetes 的堆栈。使用 docker stack ls 允许 Kubernetes 多次出现–namespace。<a href="https://github.com/docker/cli/pull/1031">docker/ cli＃1031</a></li><li>  Bump SwarmKit 删除不推荐使用的 grpc 元数据包装器。<a href="https://github.com/moby/moby/pull/36905">moby/moby＃36905</a></li><li>  在不匹配的 Swarm 和 Kubernetes 主机上工作时，为–orchestrator = all 发出错误。<a href="https://github.com/docker/cli/pull/1035">docker/ cli＃1035</a></li><li>  使用定义为 Orchestrator 的 Kubernetes 修复损坏的 swarm 命令。“–orchestrator” 标志不再是全局的，而是位于堆栈命令和子命令的本地 docker <a href="https://github.com/docker/cli/pull/1137">/ cli＃1137</a> <a href="https://github.com/docker/cli/pull/1139">docker / cli＃1139</a></li><li>  Bump swarmkit 包含任务收割者修复程序和更多指标。<a href="https://github.com/docker/engine/pull/13">docker/engine＃13</a></li><li>  删除具有未分配任务的服务时，避免泄漏。<a href="https://github.com/docker/engine/pull/27">docker/engine＃27</a></li><li>  在分派器上修复批量批处理。<a href="https://github.com/docker/engine/pull/27">docker/engine＃27</a></li></ul><h3 id="版本号：18-05"><a href="#版本号：18-05" class="headerlink" title="版本号：18.05"></a>版本号：18.05</h3>  首次发布时间： 2018-05-09<h4 id="构造相关-2"><a href="#构造相关-2" class="headerlink" title="构造相关"></a>构造相关</h4><ul><li>  添加<code>netbsd</code>兼容性的包<code>pkg/term</code>。<a href="https://github.com/moby/moby/pull/36887">moby/moby＃36887</a></li><li>  标准化中间版本到的内部工件的输出路径<code>/build/</code>。<a href="https://github.com/moby/moby/pull/36858">moby/moby＃36858</a></li></ul><h4 id="客户端相关-3"><a href="#客户端相关-3" class="headerlink" title="客户端相关"></a>客户端相关</h4><ul><li>  修复<code>docker stack deploy</code>参考标记。<a href="https://github.com/docker/cli/pull/981">docker/ cli＃981</a></li><li>  修复 docker stack 在服务更新为后部署重新部署服务<code>--force</code>。<a href="https://github.com/docker/cli/pull/963">docker/ cli＃963</a></li><li>  为添加 bash 完成<code>secret|config create --template-driver</code>。<a href="https://github.com/docker/cli/pull/1004">docker/ cli＃1004</a></li><li>  为 docker trust 子命令添加与补全。<a href="https://github.com/docker/cli/pull/984">docker/ cli＃984</a></li><li>  修复 docker 历史记录的–format 示例。<a href="https://github.com/docker/cli/pull/980">docker/ cli＃980</a></li><li>  使用网络合并 composefile 修复错误。<a href="https://github.com/docker/cli/pull/983">docker/ cli＃983</a></li></ul><h4 id="日志相关-3"><a href="#日志相关-3" class="headerlink" title="日志相关"></a>日志相关</h4><ul><li>  标准化了存储驱动程序日志消息的属性。<a href="https://github.com/moby/moby/pull/36492">moby/moby＃36492</a></li><li>  改进记录器中的部分消息支持。<a href="https://github.com/moby/moby/pull/35831">moby/moby＃35831</a></li></ul><h4 id="网络相关-3"><a href="#网络相关-3" class="headerlink" title="网络相关"></a>网络相关</h4><ul><li>  允许使用更大的预设属性值，请勿覆盖。<a href="https://github.com/docker/libnetwork/pull/2124">docker/ libnetwork＃2124</a></li><li>  networkdb：handleNodeEvent 中的用户写锁定。 <a href="https://github.com/docker/libnetwork/pull/2136">docker/ libnetwork＃2136</a></li><li>  导入 libnetwork 修复程序以滚动更新。<a href="https://github.com/moby/moby/pull/36638">moby/moby＃36638</a></li><li>  更新 libnetwork 以改善桥网络隔离规则的可扩展性。<a href="https://github.com/moby/moby/pull/36774">moby/moby＃36774</a></li><li>  修复滥用的网络对象名称。<a href="https://github.com/moby/moby/pull/36745">moby/moby＃36745</a></li></ul><h4 id="运行相关-3"><a href="#运行相关-3" class="headerlink" title="运行相关"></a>运行相关</h4><ul><li>  LCOW：实施<code>docker save</code>。<a href="https://github.com/moby/moby/pull/36599">moby / moby＃36599</a></li><li>  Pkg：devmapper：动态加载 dm_task_deferred_remove。<a href="https://github.com/moby/moby/pull/35518">moby/moby＃35518</a></li><li>  Windows：在 graphdriver 中添加 GetLayerPath 实现。<a href="https://github.com/moby/moby/pull/36738">moby/moby＃36738</a></li><li>  修复写入失败时 Windows 层泄漏的问题。<a href="https://github.com/moby/moby/pull/36728">moby/moby＃36728</a></li><li>  在用户 NS 中运行时，修复 FIFO，套接字和设备文件。<a href="https://github.com/moby/moby/pull/36756">moby/moby＃36756</a></li><li>  修复 docker 版本输出对齐方式。<a href="https://github.com/docker/cli/pull/965">docker/ cli＃965</a></li><li>  始终使 sysfs 具有特权读写。<a href="https://github.com/moby/moby/pull/36808">moby/moby＃36808</a></li><li>  将 Golang 升至 1.10.1。<a href="https://github.com/moby/moby/pull/35739">moby/moby＃35739</a></li><li>  升级容器客户端。<a href="https://github.com/moby/moby/pull/36684">moby/moby＃36684</a></li><li>  将 golang.org/x/net 推送到 go1.10 版本提交。<a href="https://github.com/moby/moby/pull/36894">moby/moby＃36894</a></li><li>  Context.WithTimeout：调用取消函数。<a href="https://github.com/moby/moby/pull/36920">moby/moby＃36920</a></li><li>  复制：避免将所有系统内存与 authz 插件一起使用。<a href="https://github.com/moby/moby/pull/36595">moby / moby＃36595</a></li><li>  守护程序 / 集群：在配置期间处理部分附件条目。<a href="https://github.com/moby/moby/pull/36769">moby/moby＃36769</a></li><li>  使容器安装可绑定。<a href="https://github.com/moby/moby/pull/36768">moby/moby＃36768</a></li><li>  关机前进行额外检查。<a href="https://github.com/moby/moby/pull/36879">moby/moby＃36879</a></li><li>  将安装解析移动到单独的程序包。<a href="https://github.com/moby/moby/pull/36896">moby/moby＃36896</a></li><li>  没有全局卷驱动程序存储。<a href="https://github.com/moby/moby/pull/36637">moby/moby＃36637</a></li><li>  Pkg / 安装改进。<a href="https://github.com/moby/moby/pull/36091">moby/moby＃36091</a></li><li>  放松一些 libcontainerd 客户端锁定。<a href="https://github.com/moby/moby/pull/36848">moby/moby＃36848</a></li><li>  删除对 api 包的守护程序依赖性。<a href="https://github.com/moby/moby/pull/36912">moby/moby＃36912</a></li><li>  删除重试以进行服务更新。<a href="https://github.com/moby/moby/pull/36827">moby/moby＃36827</a></li><li>  还原未加密的存储警告提示。<a href="https://github.com/docker/cli/pull/1008">docker/ cli＃1008</a></li><li>  支持取消<code>directory.Size()</code>。<a href="https://github.com/moby/moby/pull/36734">moby/moby＃36734</a></li><li>  从 x / net / context-&gt; 上下文切换。<a href="https://github.com/moby/moby/pull/36904">moby/moby＃36904</a></li><li>  修复了检查内容类型是否正确的功能<code>application/json</code>。<a href="https://github.com/moby/moby/pull/36778">moby/moby＃36778</a></li><li>  添加默认的 pollSettings 配置功能。<a href="https://github.com/moby/moby/pull/36706">moby/moby＃36706</a></li><li>  在对 daemonWaitCh 进行操作之前判断是否添加。<a href="https://github.com/moby/moby/pull/36651">moby/moby＃36651</a></li><li>  解决以非 root 用户身份运行音量测试的问题<a href="https://github.com/moby/moby/pull/36935">。.moby / moby＃36935</a></li></ul><h4 id="集群相关-3"><a href="#集群相关-3" class="headerlink" title="集群相关"></a>集群相关</h4><ul><li>  RoleManager 将从集群成员删除检测到的节点 <a href="https://github.com/docker/swarmkit/pull/2548">docker / swarmkit＃2548</a></li><li>  Scheduler / TaskReaper：处理标记为关闭的未分配任务 <a href="https://github.com/docker/swarmkit/pull/2574">docker / swarmkit＃2574</a></li><li>  避免预定义的错误日志。<a href="https://github.com/docker/swarmkit/pull/2561">docker/ swarmkit＃2561</a></li><li>  任务收割者应删除尚未分配插槽的任务。<a href="https://github.com/docker/swarmkit/pull/2557">docker/ swarmkit＃2557</a></li><li>  代理报告 FIPS 状态。<a href="https://github.com/docker/swarmkit/pull/2587">docker/ swarmkit＃2587</a></li><li>  修复：timeMutex 关键部分之外的关键操作。<a href="https://github.com/docker/swarmkit/pull/2603">docker/ swarmkit＃2603</a></li><li>  在 engine 配置中公开 swarmkit 的 Raft 调整参数。<a href="https://github.com/moby/moby/pull/36726">moby/moby＃36726</a></li><li>  使内部 / 测试 / 守护进程。守护进程集群。<a href="https://github.com/moby/moby/pull/36826">moby/moby＃36826</a></li></ul><h3 id="版本号：18-04"><a href="#版本号：18-04" class="headerlink" title="版本号：18.04"></a>版本号：18.04</h3>  首次发布时间：2018-04-10<h4 id="构造相关-3"><a href="#构造相关-3" class="headerlink" title="构造相关"></a>构造相关</h4><ul><li>  修复构建器和客户端中的拼写错误。 <a href="https://github.com/moby/moby/pull/36424">moby/moby#36424</a></li></ul><h4 id="客户端相关-4"><a href="#客户端相关-4" class="headerlink" title="客户端相关"></a>客户端相关</h4><ul><li>  在版本命令中打印 Stack API 和 Kubernetes 版本。<a href="https://github.com/docker/cli/pull/898">docker/ cli＃898</a></li><li>  修复版本命令中的 Kubernetes 重复项。<a href="https://github.com/docker/cli/pull/953">docker cli＃953</a></li><li>  在帮助中使用 HasAvailableFlags 代替 HasFlags for Options。<a href="https://github.com/docker/cli/pull/959">docker/ cli＃959</a></li><li>  添加对强制变量的支持以进行堆栈部署。<a href="https://github.com/docker/cli/pull/893">docker/ cli＃893</a></li><li>  修复 docker stack services 命令的端口输出。<a href="https://github.com/docker/cli/pull/943">docker/ cli＃943</a></li><li>  弃用未加密的存储。<a href="https://github.com/docker/cli/pull/561">docker/ cli＃561</a></li><li>  不要为 ConfigFile 设置默认文件名。<a href="https://github.com/docker/cli/pull/917">docker/ cli＃917</a></li><li>  修复撰写网络名称。<a href="https://github.com/docker/cli/pull/941">docker cli＃941</a></li></ul><h4 id="日志相关-4"><a href="#日志相关-4" class="headerlink" title="日志相关"></a>日志相关</h4><ul><li>  静默登录：使用 cred 存储中的凭据登录。<a href="https://github.com/docker/cli/pull/139">docker/ cli＃139</a></li><li>  添加对日志文件可压缩性的支持。<a href="https://github.com/moby/moby/pull/29932">docker＃29932</a></li><li>  使用非阻塞日志记录模式修复空的 LogPath。<a href="https://github.com/moby/moby/pull/36272">docker36272</a></li></ul><h4 id="网络相关-4"><a href="#网络相关-4" class="headerlink" title="网络相关"></a>网络相关</h4><ul><li>  防止显式删除入口网络。<a href="https://github.com/moby/moby/pull/36538">docker＃36538</a></li></ul><h4 id="运行相关-4"><a href="#运行相关-4" class="headerlink" title="运行相关"></a>运行相关</h4><ul><li>  Devmapper 清理改进。<a href="https://github.com/moby/moby/pull/36307">docker＃36307</a></li><li>  Devmapper.Mounted：删除。<a href="https://github.com/moby/moby/pull/36437">docker＃36437</a></li><li>  Devmapper / Remove（）：使用 Rmdir，忽略错误。<a href="https://github.com/moby/moby/pull/36438">docker＃36438</a></li><li>  LCOW - 将平台解析器指令更改为 FROM 语句标志。<a href="https://github.com/moby/moby/pull/35089">moby/moby＃35089</a></li><li>  将守护程序服务代码拆分为 Windows 文件。<a href="https://github.com/moby/moby/pull/36653">moby/moby＃36653</a></li><li>  Windows：阻止拉高级别镜像。<a href="https://github.com/moby/moby/pull/36327">moby/moby＃36327</a></li><li>  Windows：合并 36586 后，Hyper-V 容器损坏。<a href="https://github.com/moby/moby/pull/36610">moby/moby＃36610</a></li><li>  Windows：移动 kernel_windows 以使用 golang 注册表功能。<a href="https://github.com/moby/moby/pull/36617">moby/moby＃36617</a></li><li>  Windows：在容器退出时传回系统错误。<a href="https://github.com/moby/moby/pull/35967">moby/moby＃35967</a></li><li>  Windows：删除服务模式。<a href="https://github.com/moby/moby/pull/36267">moby/moby＃36267</a></li><li>  Windows：报告版本和 UBR。<a href="https://github.com/moby/moby/pull/36451">moby/moby＃36451</a></li><li>  将 Runc 碰撞到 1.0.0-rc5。<a href="https://github.com/moby/moby/pull/36449">moby/moby＃36449</a></li><li>  装载失败表示失败的路径。<a href="https://github.com/moby/moby/pull/36407">moby/moby＃36407</a></li><li>  更改 errdefs.getImplementer（）的返回值。<a href="https://github.com/moby/moby/pull/36489">moby/moby＃36489</a></li><li>  客户端：修复 hijackedconn 从缓冲区读取的问题。<a href="https://github.com/moby/moby/pull/36663">moby/moby＃36663</a></li><li>  内容编码协商已添加到存档请求。<a href="https://github.com/moby/moby/pull/36164">moby/moby＃36164</a></li><li>  后台程序 / 统计信息：更灵活的 CPU 采样。<a href="https://github.com/moby/moby/pull/36519">moby / moby＃36519</a></li><li>  守护程序 / 统计信息：删除令人讨厌的类型文件。<a href="https://github.com/moby/moby/pull/36494">moby/moby＃36494</a></li><li>  守护程序：使用上下文错误而不是发明新的错误。<a href="https://github.com/moby/moby/pull/36670">moby/moby＃36670</a></li><li>  在非 amd64 架构（v2）上启用 CRIU。<a href="https://github.com/moby/moby/pull/36676">moby/moby＃36676</a></li><li>  在关闭 stdin 到连接的容器后修复间歇性客户端挂起 <a href="https://github.com/moby/moby/pull/36517">Moby / moby＃36517</a></li><li>  重新启动后修复容器导出上的守护程序紧急情况<a href="https://github.com/moby/moby/pull/36586">＃36586</a></li><li>  多阶段 Moby 的 Dockerfile 的后续修复。<a href="https://github.com/moby/moby/pull/36425">moby/moby＃36425</a></li><li>  在 Docker 映像中冻结 busybox 和最新的 glibc。<a href="https://github.com/moby/moby/pull/36375">moby/moby＃36375</a></li><li>  如果容器将以非 root 用户身份运行，请允许早期删除有效上限。<a href="https://github.com/moby/moby/pull/36587">moby/moby＃36587</a></li><li>  层：删除元数据存储界面。<a href="https://github.com/moby/moby/pull/36504">moby/moby＃36504</a></li><li>  对 dockerd 的次要优化。<a href="https://github.com/moby/moby/pull/36577">moby / moby＃36577</a></li><li>  将 statx syscall 列入白名单。<a href="https://github.com/moby/moby/pull/36417">moby/moby＃36417</a></li><li>  添加缺少的错误返回信息以创建插件。<a href="https://github.com/moby/moby/pull/36646">moby/moby＃36646</a></li><li>  修复 AppArmor 不应用于 Exec 进程的问题。<a href="https://github.com/moby/moby/pull/36466">moby/moby＃36466</a></li><li>  Daemon / logger / ring.go：日志错误不是实例。<a href="https://github.com/moby/moby/pull/36475">moby/moby＃36475</a></li><li>  如果未收集任何统计信息，请修复统计信息收集器旋转的 CPU。<a href="https://github.com/moby/moby/pull/36609">moby/moby＃36609</a></li><li>  修复（分发）：摘要缓存如果是身份验证，则不应移动。<a href="https://github.com/moby/moby/pull/36509">moby / moby＃36509</a></li><li>  确保在失败时删除插件容器。<a href="https://github.com/moby/moby/pull/36715">moby/moby＃36715</a></li><li>  碰撞到容器 1.0.3。<a href="https://github.com/moby/moby/pull/36749">moby/moby＃36749</a></li><li>  不要对插件安装片排序。<a href="https://github.com/moby/moby/pull/36711">moby/moby＃36711</a></li></ul><h4 id="集群相关-4"><a href="#集群相关-4" class="headerlink" title="集群相关"></a>集群相关</h4><ul><li>  修复了使调度程序关闭与正在进行的 rpcs 同步的问题。<a href="https://github.com/moby/moby/pull/36371">moby/moby＃36371</a></li><li>  将筏 ElectionTick 增加到 10xHeartbeatTick。<a href="https://github.com/moby/moby/pull/36672">moby/moby＃36672</a></li><li>  在守护程序配置中使 Swarm Manager Raft 仲裁参数可配置。<a href="https://github.com/moby/moby/pull/36726">moby/moby＃36726</a></li><li>  入口网络不应是可连接的。<a href="https://github.com/docker/swarmkit/pull/2523">docker/ swarmkit＃2523</a></li><li>  [经理 / 州] 将 Fernet 添加为筏加密的选项。<a href="https://github.com/docker/swarmkit/pull/2535">docker/ swarmkit＃2535</a></li><li>  记录 GRPC 服务器错误。 <a href="https://github.com/docker/swarmkit/pull/2541">docker/ swarmkit＃2541</a></li><li>  在经理级别记录领导层的变化。<a href="https://github.com/docker/swarmkit/pull/2542">docker/ swarmkit＃2542</a></li><li>  删除容器的执行程序。<a href="https://github.com/docker/swarmkit/pull/2568">docker/ swarmkit＃2568</a></li><li>  代理：没有遥控器可用时的退避会话。<a href="https://github.com/docker/swarmkit/pull/2570">docker/ swarmkit＃2570</a></li><li>  [ca / manager] 完全删除根 CA 密钥加密支持。<a href="https://github.com/docker/swarmkit/pull/2573">docker/ swarmkit＃2573</a></li><li>  修复代理日志记录竞赛。<a href="https://github.com/docker/swarmkit/pull/2578">docker/ swarmkit＃2578</a></li><li>  添加逻辑以按顺序还原网络。<a href="https://github.com/docker/swarmkit/pull/2571">docker/ swarmkit＃2571</a></li></ul><h3 id="版本号：18-03"><a href="#版本号：18-03" class="headerlink" title="版本号：18.03"></a>版本号：18.03</h3>  首次发布时间：2018-03-21<h4 id="构造相关-4"><a href="#构造相关-4" class="headerlink" title="构造相关"></a>构造相关</h4><ul><li>  切换到 - buildmode = pie <a href="https://github.com/moby/moby/pull/34369">moby / moby＃34369</a></li><li>  允许 Dockerfile 在构建上下文 docker <a href="https://github.com/docker/cli/pull/886">/ cli＃886 之外</a></li><li>  构建器: 修正错误的缓存命中塔 <a href="https://github.com/moby/moby/pull/36329">moby/moby#36329</a></li><li>  修复多阶段构建中泄漏到其他映像的文件 <a href="https://github.com/moby/moby/pull/36338">moby/moby#36338</a></li></ul><h4 id="客户端相关-5"><a href="#客户端相关-5" class="headerlink" title="客户端相关"></a>客户端相关</h4><ul><li>  使用网络合并合并文件修复错误 <a href="https://github.com/docker/cli/pull/983">docker / cli＃983</a></li><li>  在使用<code>--force</code>后更新服务后修复 docker stack 部署重新部署服务 <a href="https://github.com/docker/cli/pull/963">docker / cli＃963</a></li><li>  修复 docker 版本输出对齐方式 <a href="https://github.com/docker/cli/pull/965">docker / cli＃965</a></li><li>  简化组合类型的封送处理。配置 docker <a href="https://github.com/docker/cli/pull/895">/ cli＃895</a></li><li>  部署 docke 时添加对多个 composefile 的支持 r <a href="https://github.com/docker/cli/pull/569">/ cli＃569</a></li><li>  修复损坏的 Kubernetes 堆栈标志 docker <a href="https://github.com/docker/cli/pull/831">/ cli＃831</a></li><li>  修复 Kubernetes docker 的堆栈封送处理 <a href="https://github.com/docker/cli/pull/890">/ cli＃890</a></li><li>  修复并简化服务环境的 bash 完成，挂载和标记 <a href="https://github.com/docker/cli/pull/682">docker / cli＃682</a></li><li>  修复<code>before</code>并<code>since</code>过滤<code>docker ps</code> <a href="https://github.com/moby/moby/pull/35938">Moby / Moby＃35938</a></li><li>  修复<code>--label-file</code>奇怪的行为 <a href="https://github.com/docker/cli/pull/838">docker / cli＃838</a></li><li>  修复在不受支持的平台对 defaultCredentialStore（）的编译 <a href="https://github.com/docker/cli/pull/872">docker / cli＃872</a></li><li>  改善和修复镜像的 bash 完成 <a href="https://github.com/docker/cli/pull/717">docker / cli＃717</a></li><li>  在绑定安装的添加了对空源的检查 <a href="https://github.com/docker/cli/pull/824">docker / cli＃824</a></li><li>  从客户端中的环境变量修复 TLS<a href="https://github.com/moby/moby/pull/36270">Moby / Moby＃36270</a></li><li>  泊坞窗现在构建的运行速度更快，当特定注册表凭证助手（S）配置 <a href="https://github.com/docker/cli/pull/840">docker/cli#840</a></li><li>  更新事件过滤器的 zsh 完成用<code>disable</code>，<code>enable</code>，<code>install</code>和<code>remove</code> <a href="https://github.com/docker/cli/pull/372">docker/cli#372</a></li><li>  将空 ID 传递到检查调用时产生错误 <a href="https://github.com/moby/moby/pull/36144">Moby / Moby＃36144</a></li><li>  用于 k8s 控制器的 Marshall 版本 <a href="https://github.com/docker/cli/pull/891">docker/cli#891</a></li><li>  为 HTTP 客户端与插件后端通信设置一个非零超时 <a href="https://github.com/docker/cli/pull/883">docker/cli#883</a></li><li>  为–tls 选项添加 DOCKER_TLS 环境变量 <a href="https://github.com/docker/cli/pull/863">docker/cli#863</a></li><li>  为加密 / 配置添加–模板驱动程序选项 <a href="https://github.com/docker/cli/pull/896">docker/cli#896</a></li><li>  将 docker trust` 命令移除实验范围 docker/cli#934](<a href="https://github.com/docker/cli/pull/934">https://github.com/docker/cli/pull/934</a>) <a href="https://github.com/docker/cli/pull/935">docker/cli#935</a> <a href="https://github.com/docker/cli/pull/944">docker/cli#944</a></li></ul><h4 id="日志相关-5"><a href="#日志相关-5" class="headerlink" title="日志相关"></a>日志相关</h4><ul><li>  AWS 日志 - 不要在最大大小的事件中添加新行 <a href="https://github.com/moby/moby/pull/36078">moby / moby＃36078</a></li><li>  加载插件后移动日志验证器逻辑 <a href="https://github.com/moby/moby/pull/36306">Moby / Moby＃36306</a></li><li>  在 Splunk 日志驱动程序支持代理 <a href="https://github.com/moby/moby/pull/36220">Moby / Moby＃36220</a></li><li>  修正带有空日志的日志尾部 <a href="https://github.com/moby/moby/pull/36305">moby/moby#36305</a></li></ul><h4 id="网络相关-5"><a href="#网络相关-5" class="headerlink" title="网络相关"></a>网络相关</h4><ul><li>  修正了 Memberlist revendor 退出时的死锁问题 <a href="https://github.com/docker/libnetwork/pull/2040">docker/libnetwork#2040</a></li><li>  修复用户指定的 ndots 选项 <a href="https://github.com/docker/libnetwork/pull/2065">docker / libnetwork＃2065</a></li><li>  修复为 Windows 使用 ContainerID 而不是 SandboxID docker <a href="https://github.com/docker/libnetwork/pull/2010">/ libnetwork＃2010</a></li><li>  验证 NetworkingConfig 以确保 EndpointSettings 不是 nil <a href="https://github.com/moby/moby/pull/36077">moby / moby＃36077</a></li><li>  修复<code>DockerNetworkInternalMode</code>问题 <a href="https://github.com/moby/moby/pull/36298">Moby / Moby＃36298</a></li><li>  在可附加网络附件的修复种族<a href="https://github.com/moby/moby/pull/36191">＃36191</a></li><li>  修复<code>InspectNetwork</code>AArch64 超时问题 <a href="https://github.com/moby/moby/pull/36257">Moby / Moby＃36257</a></li><li>  部分覆盖 ID 的缺少详细信息 <a href="https://github.com/moby/moby/pull/35989">Moby / moby＃35989</a></li><li>  更新<code>FindNetwork</code>以解决网络名称重复的问题 <a href="https://github.com/moby/moby/pull/30897">moby / moby＃30897</a></li><li>  禁止附加入口网络 <a href="https://github.com/docker/swarmkit/pull/2523">docker / swarmkit＃2523</a></li><li>  防止隐式删除入口网络 <a href="https://github.com/moby/moby/pull/36538">moby / moby＃36538</a></li><li>  修复 Windows 上旧的 HNS 端点<a href="https://github.com/moby/moby/pull/36603">＃36603</a></li><li>  IPAM 修复了重复的 IP 地址 <a href="https://github.com/docker/libnetwork/pull/2104">docker / libnetwork＃2104</a> <a href="https://github.com/docker/libnetwork/pull/2105">docker / libnetwork＃2105</a></li></ul><h4 id="运行相关-5"><a href="#运行相关-5" class="headerlink" title="运行相关"></a>运行相关</h4><ul><li>  修复 AppArmor 配置文件未应用于<code>docker exec</code>进程 <a href="https://github.com/moby/moby/pull/36466">Moby / Moby＃36466</a></li><li>  不要对插件装载片进行排序 <a href="https://github.com/moby/moby/pull/36711">moby/moby#36711</a></li><li>  守护程序 / 集群：在配置期间处理部分附件条目 <a href="https://github.com/moby/moby/pull/36769">moby / moby＃36769</a></li><li>  将 Golang 撞到 1.9.5 <a href="https://github.com/moby/moby/pull/36779">Moby</a> <a href="https://github.com/docker/cli/pull/986">/</a> <a href="https://github.com/moby/moby/pull/36779">Moby＃36779 docker</a> <a href="https://github.com/docker/cli/pull/986">/ cli＃986</a></li><li>  守护进程 / 统计: 更有弹性的 cpu 采样 <a href="https://github.com/moby/moby/pull/36519">moby/moby#36519</a></li><li>  容器化：更新至 1.0.3 版本 <a href="https://github.com/moby/moby/pull/36749">Moby / Moby＃36749</a></li><li>  修正了写操作失败时的 Windows 层泄漏 <a href="https://github.com/moby/moby/pull/36728">moby/moby#36728</a></li><li>  不要使容器安装不可绑定 <a href="https://github.com/moby/moby/pull/36768">moby/moby#36768</a></li><li>  修复守护进程重启后在容器导出上的守护进程异常 <a href="https://github.com/moby/moby/pull/36586">moby/moby/36586</a></li><li>  修复摘要缓存已在删除的问题 <a href="https://github.com/moby/moby/pull/36509">authErrors Moby / Moby＃36509 上</a></li><li>  确保在失败时删除了插件容器 <a href="https://github.com/moby/moby/pull/36715">Moby / Moby＃36715</a></li><li>  复制：避免将所有系统内存与 authz 插件一起使用 <a href="https://github.com/moby/moby/pull/36595">moby / moby＃36595</a></li><li>  放松一些 libcontainerd 客户端锁定 <a href="https://github.com/moby/moby/pull/36848">moby/moby#36848</a></li><li>  更新<code>hcsshim</code>到 v0.6.10 以解决 <a href="https://portal.msrc.microsoft.com/en-us/security-guidance/advisory/CVE-2018-8115">CVE-2018-8115</a></li><li>  为 Windows 启用 HotAdd <a href="https://github.com/moby/moby/pull/35414">moby/moby#35414</a></li><li>  Graphdriver 修复 hotRemoveVHDs 中的死锁 <a href="https://github.com/moby/moby/pull/36114">moby/moby#36114</a></li><li>  普通挂载，如果只有一层 <a href="https://github.com/moby/moby/pull/36052">moby/moby#36052</a></li><li>  删除临时环境变量 LCOW_API_PLATFORM_IF_OMITTED <a href="https://github.com/moby/moby/pull/36269">moby / moby＃36269</a></li><li>  Revendor Microsoft / opengcs @ v0.3.6 <a href="https://github.com/moby/moby/pull/36108">moby / moby＃36108</a></li><li>  修复 ExitCode 和 PID 问题未显示在 Task.Status.ContainerStatus <a href="https://github.com/moby/moby/pull/36150">moby / moby＃36150</a></li><li>  修复了插件扫描程序过深的问题 <a href="https://github.com/moby/moby/pull/36119">moby / moby＃36119</a></li><li>  不要使 graphdriver homes 私人挂载 <a href="https://github.com/moby/moby/pull/36047">moby / moby＃36047</a></li><li>  不要在清理 zfs / btrfs 递归卸载<a href="https://github.com/moby/moby/pull/36237">＃36237</a></li><li>  如果镜像不存在，请不要还原镜像 <a href="https://github.com/moby/moby/pull/36304">Moby / moby＃36304</a></li><li>  调整模板化配置 / 加密最低 API 版本<a href="https://github.com/moby/moby/pull/36366">＃36366</a></li><li>  容器升级到 1.0.2（cfd04396dc68220d1cecbe686a6cc3aa5ce3667c） <a href="https://github.com/moby/moby/pull/36308">＃36308</a></li><li>  将 Golang 撞到 1.9.4 Moby <a href="https://github.com/moby/moby/pull/36243">/ Moby＃36243</a></li><li>  确保在关机上卸载了守护程序根目录 <a href="https://github.com/moby/moby/pull/36107">Moby / moby＃36107</a></li><li>  将 Runc 更新到 6c55f98695e902427906eed2c799e566e3d3dfb5 <a href="https://github.com/moby/moby/pull/36222">moby/moby#36222</a></li><li>  修复守护程序上的容器清理重启 <a href="https://github.com/moby/moby/pull/36249">moby / moby＃36249</a></li><li>  支持 SCTP 端口映射（将 API 升级到 v1.37）<a href="https://github.com/moby/moby/pull/33922">moby / moby＃33922</a></li><li>  支持 SCTP 端口映射 <a href="https://github.com/docker/cli/pull/278">docker / cli＃278</a></li><li>  修复 ContainerConfig 的 Volumes 属性定义 <a href="https://github.com/moby/moby/pull/35946">Moby / moby＃35946 中</a></li><li>  升级 Moby 和依赖项 <a href="https://github.com/docker/cli/pull/829">docker / cli＃829</a></li><li>  C.RWLayer：在使用之前检查是否为零<a href="https://github.com/moby/moby/pull/36242">＃36242</a></li><li>  添加<code>REMOVE</code>并添加<code>ORPHANED</code>到 TaskState <a href="https://github.com/moby/moby/pull/36146">moby / moby＃36146</a></li><li>  使用固定的错误检测<code>IsErrNotFound</code>和<code>IsErrNotImplemented</code>对<code>ContainerStatPath</code>，<code>CopyFromContainer</code>和<code>CopyToContainer</code>方法 <a href="https://github.com/moby/moby/pull/35979">MOBY / MOBY＃35979</a></li><li>  添加集成 / 内部 / 容器帮助程序包 <a href="https://github.com/moby/moby/pull/36266">moby / moby＃36266</a></li><li>  添加规范的导入路径 <a href="https://github.com/moby/moby/pull/36194">Moby / Moby＃36194</a></li><li>  添加 / 使用 container.Exec（）到集成 <a href="https://github.com/moby/moby/pull/36326">Moby / Moby＃36326</a></li><li>  修复 “–node-generic-resource” 单 / 复数 <a href="https://github.com/moby/moby/pull/36125">moby / moby＃36125</a></li><li>  Daemon.cleanupContainer：在释放使容器 RWLayer 无效<a href="https://github.com/moby/moby/pull/36160">＃36160</a></li><li>  守护程序：将<code>--oom-kill-disable</code>选项传递给容器式 Moby <a href="https://github.com/moby/moby/pull/36201">Moby＃36201</a></li><li>  当存在绑定端口且网络模式为主机 <a href="https://github.com/moby/moby/pull/35510">moby / moby＃35510</a> 时显示警告消息</li><li>  在已重新启动的容器式 <a href="https://github.com/moby/moby/pull/36173">Moby / Moby</a> 上刷新容器式遥控器</li><li>  将守护程序根设置为使用共享传播 <a href="https://github.com/moby/moby/pull/36096">Moby / Moby＃36096</a></li><li>  递归卸载优化<a href="https://github.com/moby/moby/pull/34379">＃34379</a></li><li>  在运行时中执行插件安装<a href="https://github.com/moby/moby/pull/35829">＃35829</a></li><li>  Graphdriver：修复 RefCounter 内存泄漏 <a href="https://github.com/moby/moby/pull/36256">Moby＃36256</a></li><li>  使用连续性 fs 软件包进行卷复制 <a href="https://github.com/moby/moby/pull/36290">Moby / Moby＃36290</a></li><li>  使用 proc / exe 重新执行 <a href="https://github.com/moby/moby/pull/36124">Moby / Moby＃36124</a></li><li>  添加对模板化机密和配置的 API 支持，即 <a href="https://github.com/moby/moby/pull/33702">moby / moby＃33702</a> 和 <a href="https://github.com/moby/moby/pull/36366">moby / moby＃36366</a></li><li>  将 rslave 传播用于从守护程序 roo 进行的挂载 t <a href="https://github.com/moby/moby/pull/36055">moby / moby＃36055</a></li><li>  将 / proc / 键添加到被屏蔽的路径 <a href="https://github.com/moby/moby/pull/36368">moby / moby＃36368</a></li><li>  将 Runc 碰撞到 1.0.0-rc5 Moby <a href="https://github.com/moby/moby/pull/36449">/ Moby＃36449</a></li><li>  修复<code>runc exec</code>了 Big-endian 架构 <a href="https://github.com/moby/moby/pull/36449">Moby / Moby＃36449</a></li><li>  未提供安装名称空间时使用 chroot <a href="https://github.com/moby/moby/pull/36449">moby / moby＃36449</a></li><li>  修复系统切片扩展，以便 cAdvisor 可以使用它 <a href="https://github.com/moby/moby/pull/36449">moby / moby＃36449</a></li><li>  修复安装了错误的 uid / gid <a href="https://github.com/moby/moby/pull/36449">moby / moby 的设备＃36449</a></li><li>  使用 IPC 专用安装架<code>/dev/shm</code>只读修复只读容器 <a href="https://github.com/moby/moby/pull/36526">moby / moby＃36526</a></li></ul><h4 id="集群相关-5"><a href="#集群相关-5" class="headerlink" title="集群相关"></a>集群相关</h4><ul><li>  将木筏选择刻度增加到 10 倍心跳刻度 <a href="https://github.com/moby/moby/pull/36672">Moby / Moby＃36672</a></li><li>  将 EC 私钥替换为 PKCS＃8 PEM <a href="https://github.com/docker/swarmkit/pull/2246">docker / swarmkit＃2246</a></li><li>  修复 IP 与空 EndpointSpec 重叠 <a href="https://github.com/docker/swarmkit/pull/2505">docker / swarmkit＃2505</a></li><li>  添加对 Support SCTP 端口映射的支持 <a href="https://github.com/docker/swarmkit/pull/2298">docker / swarmkit＃2298</a></li><li>  如果仅放置约束发生更改并且已分配的节点满足要求，请不要重新计划任务 <a href="https://github.com/docker/swarmkit/pull/2496">docker / swarmkit＃2496</a></li><li>  确保任务收割者 stopChan 关闭不超过一次 <a href="https://github.com/docker/swarmkit/pull/2491">docker / swarmkit＃2491</a></li><li>  同步修复 <a href="https://github.com/docker/swarmkit/pull/2495">docker / swarmkit＃2495</a></li><li>  添加日志消息以指示如果流未实现的，则消息发送重试 <a href="https://github.com/docker/swarmkit/pull/2483">docker / swarmkit＃2483</a></li><li>  会话，调度程序上的节点事件，心跳调试日志 <a href="https://github.com/docker/swarmkit/pull/2486">docker / swarmkit＃2486</a></li><li>  将群类型添加到 bash 完成事件类型过滤器 <a href="https://github.com/docker/cli/pull/888">docker / cli＃888</a></li><li>  修正了网络检查不能显示群集范围内网络创建时间的问题 <a href="https://github.com/moby/moby/pull/36095">moby/moby#36095</a></li></ul><h3 id="版本号：18-02"><a href="#版本号：18-02" class="headerlink" title="版本号：18.02"></a>版本号：18.02</h3>  首次发布时间： 2018-02-07<h4 id="构造相关-5"><a href="#构造相关-5" class="headerlink" title="构造相关"></a>构造相关</h4><ul><li>  Gitutils：修复检查子模块 <a href="https://github.com/moby/moby/pull/35737">Moby / Moby＃35737</a></li></ul><h4 id="客户端相关-6"><a href="#客户端相关-6" class="headerlink" title="客户端相关"></a>客户端相关</h4><ul><li>  附加：确保附加退出代码与容器相匹配 <a href="https://github.com/docker/cli/pull/696">docker / cli＃696</a></li><li>  在撰写文件中添加了对 tmpfs-mode 的支持 <a href="https://github.com/docker/cli/pull/808">docker / cli＃808</a></li><li>  添加新的撰写文件版本 3.6 <a href="https://github.com/docker/cli/pull/808">docker / cli＃808</a></li><li>  在过滤器的修复问题<code>docker ps</code>，其中<code>health=starting</code>不返回任何 <a href="https://github.com/moby/moby/pull/35940">MOBY / MOBY＃35940</a></li><li>  改善已发布端口范围 <a href="https://github.com/docker/cli/pull/581">docker / cli＃581</a></li><li>  跳至 1.9.3 <a href="https://github.com/docker/cli/pull/827">docker / cli＃827</a></li><li>  修复损坏的 Kubernetes 堆栈标志 docker <a href="https://github.com/docker/cli/pull/831">/ cli＃831</a></li><li>  将 “stack” 命令注释为 “ swarm” 和“ kubernetes” docker <a href="https://github.com/docker/cli/pull/804">/ cli＃804</a></li></ul><h4 id="实验性功能-1"><a href="#实验性功能-1" class="headerlink" title="实验性功能"></a>实验性功能</h4><ul><li>  添加清单命令 <a href="https://github.com/docker/cli/pull/138">docker / cli＃138</a></li><li>  LCOW remotefs-Read（）实现中的返回错误 <a href="https://github.com/moby/moby/pull/36051">moby / moby＃36051</a></li><li>  LCOW：Coalesce 守护程序存储，允许双 LCOW 和 WCOW 模式 <a href="https://github.com/moby/moby/pull/34859">moby / moby＃34859</a></li><li>  LCOW：修复 OpenFile 参数 <a href="https://github.com/moby/moby/pull/36043">moby / moby＃36043</a></li><li>  LCOW：提高对 Windows RS3 RTM 内部版本（16299）最低要求 <a href="https://github.com/moby/moby/pull/36065">moby/moby#36065</a></li></ul><h4 id="日志相关-6"><a href="#日志相关-6" class="headerlink" title="日志相关"></a>日志相关</h4><ul><li>  改进守护程序配置重载；记录活动配置 <a href="https://github.com/moby/moby/pull/36019">moby / moby＃36019</a></li><li>  修复了对 ContainerLogs 方法使用 IsErrNotFound 和 IsErrNotImplemented 进行的错误检测 <a href="https://github.com/moby/moby/pull/36000">moby / moby＃36000</a></li><li>  将日记标记添加为 SYSLOG_IDENTIFIER <a href="https://github.com/moby/moby/pull/35570">moby / moby＃35570</a></li><li>  Splunk：在错误响应上限制读取器大小 <a href="https://github.com/moby/moby/pull/35509">Moby / Moby＃35509</a></li></ul><h4 id="网络相关-6"><a href="#网络相关-6" class="headerlink" title="网络相关"></a>网络相关</h4><ul><li>  在发布网络上禁用服务会导致零停机时间部署以及滚动升级 <a href="https://github.com/moby/moby/pull/35960">Moby / Moby＃35960</a></li><li>  如果不同空间中存在多个具有相同名称的网络，则修复服务无法启动 <a href="https://github.com/moby/moby/pull/30897">moby / moby＃30897</a></li><li>  修复使用添加的重复网络<code>docker service update --network-add</code><a href="https://github.com/docker/cli/pull/780">docker / cli＃780</a></li><li>  从 17.09 升级到 17.12 时修复入口网络。 <a href="https://github.com/moby/moby/pull/36003">moby/moby#36003</a></li><li>  修复 ndots 配置 <a href="https://github.com/docker/libnetwork/pull/1995">docker / libnetwork＃1995</a></li><li>  修复如果启用了实时还原，则正在取消配置 IPV6 网络 <a href="https://github.com/docker/libnetwork/pull/2043">docker / libnetwork＃2043</a></li><li>  在嵌入式 DNS 服务器添加对 MX 类型 DNS 查询的支持 <a href="https://github.com/docker/libnetwork/pull/2041">docker / libnetwork＃2041 中</a></li></ul><h4 id="打包相关-2"><a href="#打包相关-2" class="headerlink" title="打包相关"></a>打包相关</h4><ul><li>  在 aarch64 上增加了 Fedora 26、Fedora 27 和 Centos 7 的包装 <a href="https://github.com/docker/docker-ce-packaging/pull/71">docker/docker-ce-packaging#71</a></li><li>  删除了对 Ubuntu Zest 的支持 y <a href="https://github.com/docker/docker-ce-packaging/pull/73">docker / docker-ce-packaging＃73</a></li><li>  删除了对 Fedora 25 的支持 <a href="https://github.com/docker/docker-ce-packaging/pull/72">docker / docker-ce-packaging＃72</a></li></ul><h4 id="运行相关-6"><a href="#运行相关-6" class="headerlink" title="运行相关"></a>运行相关</h4><ul><li>  修复基于管道错误 Docker Daemon 意外关闭 <a href="https://github.com/moby/moby/pull/35968">Moby / Moby＃35968</a></li><li>  修复 Win32 中出现的 hcsshim :: ImportLayer 失败的情况：系统找不到指定的路径 <a href="https://github.com/moby/moby/pull/35924">moby / moby＃35924</a></li><li>  Windows：在构建期间将最大层大小增加到 127GB <a href="https://github.com/moby/moby/pull/35925">Moby / moby＃35925</a></li><li>  修复 Devicemapper：运行 DeleteDevice dm_task_run 失败，导致 Moby <a href="https://github.com/moby/moby/pull/35919">/</a> Moby 失败<a href="https://github.com/moby/moby/pull/35919">＃35919</a></li><li>  介绍 «exec_die» 事件 <a href="https://github.com/moby/moby/pull/35744">moby / moby＃35744</a></li><li>  将 API 更新到版本 1.36 <a href="https://github.com/moby/moby/pull/35744">Moby / Moby＃35744</a></li><li>  修复了<code>docker update</code>不更新 cpu 配额和正在运行的容器的 cpu 周期<a href="https://github.com/moby/moby/pull/36030">＃36030</a></li><li>  使容器 shm 父级成为不可绑定的 Moby <a href="https://github.com/moby/moby/pull/35830">/ Moby＃35830</a></li><li>  使用 pigz 使图片 (图层) 下载速度更快 <a href="https://github.com/moby/moby/pull/35697">moby/moby#35697</a></li><li>  保护守护进程不受体积插件缓慢或死锁的影响 <a href="https://github.com/moby/moby/pull/35441">moby/moby#35441</a></li><li>  修复<code>DOCKER_RAMDISK</code>环境变量未被识别的问题 <a href="https://github.com/moby/moby/pull/35957">moby/moby#35957</a></li><li>  容器升级到 1.0.1（9b55aab90508bd389d7654c4baf173a981477d55） <a href="https://github.com/moby/moby/pull/35986">moby/moby#35986</a></li><li>  更新 runc 以修复启动和执行期间的挂起 <a href="https://github.com/moby/moby/pull/36097">moby/moby#36097</a></li><li>  修复 “–node-generic-resource” 单 / 复数 <a href="https://github.com/moby/moby/pull/36125">moby / moby＃36125</a></li></ul><h3 id="版本号：18-01"><a href="#版本号：18-01" class="headerlink" title="版本号：18.01"></a>版本号：18.01</h3>  首次发布时间：2018-01-10<h4 id="构造相关-6"><a href="#构造相关-6" class="headerlink" title="构造相关"></a>构造相关</h4><ul><li>  如果启用了用户命名空间，则修复文件不会被删除 <a href="https://github.com/moby/moby/pull/35822">moby / moby＃35822</a></li><li>  支持在<code>docker commit --change ...</code>中添加扩展环境变量 <a href="https://github.com/moby/moby/pull/35582">＃35582</a></li></ul><h4 id="客户端相关-7"><a href="#客户端相关-7" class="headerlink" title="客户端相关"></a>客户端相关</h4><ul><li>  从堆栈部署配置中的客户端返回错误 <a href="https://github.com/docker/cli/pull/757">docker / cli＃757</a></li><li>  修复修剪命令中过滤器标记的描述 <a href="https://github.com/docker/cli/pull/774">docker / cli＃774</a></li><li>  将 “pid” 添加到不受支持的选项列表 <a href="https://github.com/docker/cli/pull/768">docker / cli＃768</a></li><li>  添加对实验性 Cli 配置的支持 <a href="https://github.com/docker/cli/pull/758">docker / cli＃758</a></li><li>  为 bash 完成 <a href="https://github.com/docker/cli/pull/749">docker / cli＃749</a> 添加对通用资源的支持</li><li>  修复在 docker exec 的 zsh 完成脚本的错误 <a href="https://github.com/docker/cli/pull/751">docker / cli＃751</a></li><li>  客户端关闭 WebSocket 附加连接时添加调试消息 <a href="https://github.com/moby/moby/pull/35720">Moby / Moby＃35720</a></li><li>  修复对于<code>&quot;docker swarm&quot;</code>完成 <a href="https://github.com/docker/cli/pull/772">docker / cli＃772</a></li></ul><h4 id="文档相关"><a href="#文档相关" class="headerlink" title="文档相关"></a>文档相关</h4><ul><li>  <code>--publish</code>在档中正确引用长语法 <a href="https://github.com/docker/cli/pull/746">docker / cli＃746</a> 文</li><li>  更正了 MAC_ADMIN 和 MAC_OVERRIDE 的描述 <a href="https://github.com/docker/cli/pull/761">docker/cli#761</a></li><li>  更新了开发人员文档以解释外部 CLI <a href="https://github.com/moby/moby/pull/35681">moby / moby＃35681</a></li><li>  修复<code>&quot;on-failure&quot;</code>重启策略被记录为 “失败” 的 <a href="https://github.com/docker/cli/pull/754">docker / cli＃754</a></li><li>  修复 “存储驱动程序选项” 问题 <a href="https://github.com/docker/cli/pull/748">docker/cli#748</a></li></ul><h4 id="实验性功能-2"><a href="#实验性功能-2" class="headerlink" title="实验性功能"></a>实验性功能</h4><ul><li>  将 kubernetes 支持添加到<code>docker stack</code>命令 docker <a href="https://github.com/moby/moby/pull/35765">moby/moby#35765</a></li><li>  不要将容器 ID 附加到自定义目录检查点。 <a href="https://github.com/moby/moby/pull/35726">moby/moby#35726</a></li></ul><h4 id="日志相关-7"><a href="#日志相关-7" class="headerlink" title="日志相关"></a>日志相关</h4><ul><li>  修正了当 GELF 服务器宕机时通过 TCP 使用 GELF 日志驱动程序时守护进程崩溃的问题 <a href="https://github.com/moby/moby/pull/35765">moby/moby#35765</a></li><li>  修复 awslogs 批量大小计算大日志 <a href="https://github.com/moby/moby/pull/35726">moby/moby#35726</a></li></ul><h4 id="网络相关-7"><a href="#网络相关-7" class="headerlink" title="网络相关"></a>网络相关</h4><ul><li>  修复允许 docker 服务在 Windows VM 上启动 <a href="https://github.com/docker/libnetwork/pull/1916">docker/libnetwork#1916</a></li><li>  修复 docker 拦截 DNS 请求在 ICS 网络 <a href="https://github.com/docker/libnetwork/pull/2014">docker/libnetwork#2014</a></li><li>  Windows：添加了新的网络创建驱动程序选项 <a href="https://github.com/docker/libnetwork/pull/2021">docker / libnetwork＃2021</a></li></ul><h4 id="运行相关-7"><a href="#运行相关-7" class="headerlink" title="运行相关"></a>运行相关</h4><ul><li>  在容器启动时验证安装规范，以防止丢失主机路径 <a href="https://github.com/moby/moby/pull/35833">moby/moby#35833</a></li><li>  修复用户名称空间内的 overlay2 存储驱动程序 <a href="https://github.com/moby/moby/pull/35794">moby/moby#35794</a></li><li>  修复繁忙的错误在容器停止 <a href="https://github.com/moby/moby/pull/35674">moby/moby#35674</a></li><li>  修复未使用容器的工作目录的运行状况检查 <a href="https://github.com/moby/moby/pull/35845">moby/moby#35845</a></li><li>  修正了由于设置 fs 配额失败而导致 VFS 图形驱动程序初始化失败的问题 <a href="https://github.com/moby/moby/pull/35827">moby/moby#35827</a></li><li>  修正了被处理的两次容器事件 <a href="https://github.com/moby/moby/pull/35896">moby/moby#35896</a></li></ul><h4 id="集群相关-6"><a href="#集群相关-6" class="headerlink" title="集群相关"></a>集群相关</h4><ul><li>  修正了当服务具有相同数量的主机模式发布端口且发布端口为 0 时发布端口未被更新的问题 <a href="https://github.com/docker/swarmkit/pull/2376">docker/swarmkit#2376</a></li><li>  使任务终止顺序具有确定性 <a href="https://github.com/docker/swarmkit/pull/2265">docker/swarmkit#2265</a></li></ul><h3 id="版本号：17-12"><a href="#版本号：17-12" class="headerlink" title="版本号：17.12"></a>版本号：17.12</h3>  首次发布时间： 2017-12-27<h4 id="日志相关-8"><a href="#日志相关-8" class="headerlink" title="日志相关"></a>日志相关</h4><ul><li>  awslogs：修正大型日志批量大小计算 <a href="https://github.com/moby/moby/pull/35726">Moby / moby＃35726 的</a></li><li>  在 splunk 日志驱动程序中支持代理 <a href="https://github.com/moby/moby/pull/36220">moby / moby＃36220</a></li><li>  Logentries 驱动程序 line-only = true [] byte 输出修复 <a href="https://github.com/moby/moby/pull/35612">moby / moby＃35612</a></li><li>  Logentries 仅行徽标修复程序可保持向后兼容性 <a href="https://github.com/moby/moby/pull/35628">Moby / Moby＃35628</a></li><li>  为日志添加<code>--until</code>标志 <a href="https://github.com/moby/moby/pull/32914">moby/moby#32914</a></li><li>  将 Gelf 日志驱动程序插件添加到 Windows 构建 <a href="https://github.com/moby/moby/pull/35073">Moby / Moby＃35073</a></li><li>  在 splunk 批处理上设置超时发送 Moby <a href="https://github.com/moby/moby/pull/35496">/ Moby＃35496</a></li><li>  更新 Graylog2 / go-gelf <a href="https://github.com/moby/moby/pull/35765">moby / moby＃35765</a></li></ul><h4 id="网络相关-8"><a href="#网络相关-8" class="headerlink" title="网络相关"></a>网络相关</h4><ul><li>  从 17.09 升级到 17.12 时修复入口网络 <a href="https://github.com/moby/moby/pull/36003">Moby / Moby＃36003</a></li><li>  将详细信息添加到部分叠加层 ID <a href="https://github.com/moby/moby/pull/35989">Moby / moby＃35989</a></li><li>  修复如果启用了实时还原功能则取消配置的 IPv6 网络 <a href="https://github.com/docker/libnetwork/pull/2043">docker / libnetwork＃2043</a></li><li>  修复 watchMiss 线程上下文 <a href="https://github.com/docker/libnetwork/pull/2051">docker / libnetwork＃2051</a></li><li>  将负载均衡器沙箱创建 / 删除移动到 libnetwork <a href="https://github.com/moby/moby/pull/35422">moby / moby＃35422</a></li><li>  仅在容器元数据内刷新网络文件 <a href="https://github.com/moby/moby/pull/34224">＃34224</a></li><li>  查找网络恢复时的错误问题 <a href="https://github.com/moby/moby/pull/35634">moby/moby#35634</a></li><li>  修复使用网络连接器的 MIME 类型 <a href="https://github.com/moby/moby/pull/35542">Moby / moby＃35542</a></li><li>  增加了对持久化 Windows 网络驱动程序特定选项的支持 <a href="https://github.com/moby/moby/pull/35563">moby/moby#35563</a></li><li>  修复 netlink 套接字超时和监视泄漏 <a href="https://github.com/moby/moby/pull/35677">moby/moby#35677</a></li><li>  用于网络诊新的守护程序配置断 <a href="https://github.com/moby/moby/pull/35677">Moby / Moby＃35677</a></li><li>  清理节点管理逻辑 <a href="https://github.com/docker/libnetwork/pull/2036">docker / libnetwork＃2036</a></li><li>  还原端点时分配 VIPs <a href="https://github.com/docker/swarmkit/pull/2474">docker / swarmkit＃2474</a></li></ul><h4 id="打包相关-3"><a href="#打包相关-3" class="headerlink" title="打包相关"></a>打包相关</h4><ul><li>  在 docker.service 中设置任务最大值 <a href="https://github.com/docker/docker-ce-packaging/pull/78">docker/docker-ce-packaging#78</a></li><li>  为 Fedora 27 添加包服务 <a href="https://github.com/docker/docker-ce-packaging/pull/59">docker/docker-ce-packaging#59</a></li><li>  除非为打包指定了默认版本控制方案，否则将默认版本控制方案更改为 0.0.0-dev<a href="https://github.com/docker/docker-ce-packaging/pull/67">docker / docker-ce-packaging＃67</a></li><li>  将 Version 传递给 engine 静态构建 <a href="https://github.com/docker/docker-ce-packaging/pull/70">docker / docker-ce-packaging＃70</a></li><li>  在 Debian (stretch/jessie) 和 Ubuntu Zesty 或更新版本上增加了对 aarch64 的支持 <a href="https://github.com/docker/docker-ce-packaging/pull/35">docker/docker-ce-packaging#35</a></li></ul><h4 id="运行相关-8"><a href="#运行相关-8" class="headerlink" title="运行相关"></a>运行相关</h4><ul><li>  将 Golang 升至 1.9.4</li><li>  将容器升至 1.0.1</li><li>  修复 dockerd 重新启动后无法重新连接到容器的问题 <a href="https://github.com/moby/moby/pull/36173">Moby / Moby＃36173</a></li><li>  修复已处理两容器化事件<a href="https://github.com/moby/moby/issues/35891">＃35891</a></li><li>  修复由于无法设置 fs 配额而导致 vfs 图形驱动程序无法初始化的的问题 <a href="https://github.com/moby/moby/pull/35827">Moby / Moby＃35827</a></li><li>  修复不使用容器工作目录进行健康检查的回归 <a href="https://github.com/moby/moby/pull/35845">moby / moby＃35845</a></li><li>  荣誉<code>DOCKER_RAMDISK</code>与集装箱 1.0 <a href="https://github.com/moby/moby/pull/35957">moby/moby＃35957</a></li><li>  更新 Runc 来修复启动和执行期间的挂起 <a href="https://github.com/moby/moby/pull/36097">Moby / Moby＃36097</a></li><li>  Windows：Microsoft / hcsshim @ v.0.6.8 的供应商，部分修复了导入层失败的 <a href="https://github.com/moby/moby/pull/35924">moby / moby＃35924</a></li><li>  不要图形处理器目录成为私人挂载 <a href="https://github.com/moby/moby/pull/36047">moby / moby＃36047</a></li><li>  对来自守护进程根的挂载使用 rslave 传播 <a href="https://github.com/moby/moby/pull/36055">moby/moby#36055</a></li><li>  将守护程序根目录设置为使用共享的挂载传播 <a href="https://github.com/moby/moby/pull/36096">Moby / moby＃36096</a></li><li>  验证启动容器时是否存在安装的路径，而不仅仅是在创建期间存在 <a href="https://github.com/moby/moby/pull/35833">Moby / moby＃35833</a></li><li>  添加<code>REMOVE</code>并添加<code>ORPHANED</code>到 TaskState <a href="https://github.com/moby/moby/pull/36146">moby / moby＃36146</a></li><li>  修复了网络检查未显示群集范围网络的创建时间的问题 <a href="https://github.com/moby/moby/pull/36095">Moby / moby＃36095</a></li><li>  在释放 <a href="https://github.com/moby/moby/pull/36160">Moby</a> <a href="https://github.com/moby/moby/pull/36242">/ Moby</a> <a href="https://github.com/moby/moby/pull/36160">＃36130</a> 和 <a href="https://github.com/moby/moby/pull/36160">Moby</a> <a href="https://github.com/moby/moby/pull/36242">/ Moby</a> <a href="https://github.com/moby/moby/pull/36160">＃36343</a> 时清空容器读写层</li><li>  更新到容器化 v1.0.0 <a href="https://github.com/moby/moby/pull/35707">Moby / Moby＃35707</a></li><li>  让 VFS graphdriver 使用加速的内核内复制 <a href="https://github.com/moby/moby/pull/35537">Moby / Moby＃35537</a></li><li>  修复如果在 docker 构建过程中缺少构建参数，则不会显示错误</li><li>  Go 升级到 1.9.2 <a href="https://github.com/moby/moby/pull/33892">Moby / Moby＃33892</a> <a href="https://github.com/docker/cli/pull/716">docker / cli＃716</a></li><li>  <code>/dev</code>应该可以用<code>--readonly</code>标记为只读<a href="https://github.com/moby/moby/pull/35344">＃35344</a></li><li>  添加自定义构建时图形处理器优先级列表 <a href="https://github.com/moby/moby/pull/35522">moby / moby＃35522</a></li><li>  LCOW：CLI 更改为添加平台标志 - 拉，运行，创建和构建 <a href="https://github.com/docker/cli/pull/474">docker / cli＃474</a></li><li>  在 windows 下调整了<code>docker exec</code>的宽高 <a href="https://github.com/moby/moby/pull/35631">＃35631</a></li><li>  检测 4.0 之前的内核对 overlay2 的支持 <a href="https://github.com/moby/moby/pull/35527">Moby / Moby＃35527</a></li><li>  分离器：在取消挂载以后移除根挂载目录 <a href="https://github.com/moby/moby/pull/34573">moby/moby#34573</a></li><li>  不允许在 NFS 之上覆盖 / 覆盖 2 <a href="https://github.com/moby/moby/pull/35483">moby/moby#35483</a></li><li>  修复插件设置期间可能出现的紧急情况。<a href="https://github.com/moby/moby/pull/35632">moby/moby＃35632</a></li><li>  修正了锁定容器的一些问题 <a href="https://github.com/moby/moby/pull/35501">moby/moby#35501</a></li><li>  修复插件重新计数的一些问题 <a href="https://github.com/moby/moby/pull/35265">moby/moby#35265</a></li><li>  添加 VFS 配额支持 <a href="https://github.com/moby/moby/pull/35231">Moby / Moby＃35231</a></li><li>  跳过先前的 Graphdriver 检测中的空目录 <a href="https://github.com/moby/moby/pull/35528">Moby/ Moby＃35528</a></li><li>  在用户命名空间中运行时跳过 XFS 配额测试 <a href="https://github.com/moby/moby/pull/35526">Moby / Moby</a></li><li>  向配置选项添加了 SubSecondPrecision。<a href="https://github.com/moby/moby/pull/35529">Moby / Moby＃35529</a></li><li>  更新 fsnotify 以修复删除手表时的死锁 <a href="https://github.com/moby/moby/pull/35453">moby/moby#35453</a></li><li>  修复使用<code>--tmpfs /dev/shm</code>时的 “duplicate mount point” 问题 <a href="https://github.com/moby/moby/pull/35467">＃35467</a></li><li>  修复用户使用 <code>/dev/shm</code> 挂载时调整 tmpf 大小的问题 <a href="https://github.com/moby/moby/pull/35316">moby/moby#35316</a></li><li>  修复覆盖和 v4.13 + 内核下的 EBUSY 错误 <a href="https://github.com/moby/moby/pull/34948">moby/moby#34948</a></li><li>  容器：保护健康监控器通道 <a href="https://github.com/moby/moby/pull/35482">Moby / Moby＃35482</a></li><li>  容器：使用互斥锁保护健康状况<a href="https://github.com/moby/moby/pull/35517">＃35517</a></li><li>  容器：更新实时资源 <a href="https://github.com/moby/moby/pull/33731">Moby / Moby＃33731</a></li><li>  当卷仅远程存在时创建标签 <a href="https://github.com/moby/moby/pull/34896">moby / moby＃34896</a></li><li>  修复泄漏的容器 / 执行器状态 <a href="https://github.com/moby/moby/pull/35484">Moby / Moby＃35484</a></li><li>  禁止使用旧版（v1）注册表 <a href="https://github.com/moby/moby/pull/35751">moby / moby＃35751</a> 和 <a href="https://github.com/moby/moby/pull/35751">docker</a> <a href="https://github.com/docker/cli/pull/747">/ cli＃747</a></li><li>  Windows：针对生成器缓存 <a href="https://github.com/moby/moby/pull/35793">Moby / moby＃35793</a> 修复不区分大小写的文件名匹配</li><li>  修复围绕流程处理和错误检查的竞争条件 <a href="https://github.com/moby/moby/pull/35809">Moby / Moby＃35809</a></li><li>  确保在守护程序启动时停止容器 <a href="https://github.com/moby/moby/pull/35805">moby / moby＃35805</a></li><li>  遵循容器命名空间约定 <a href="https://github.com/moby/moby/pull/35812">moby / moby＃35812</a></li></ul><h4 id="集群相关-7"><a href="#集群相关-7" class="headerlink" title="集群相关"></a>集群相关</h4><ul><li>  从群模式删除 watchMiss<a href="https://github.com/docker/libnetwork/pull/2047">docker / libnetwork＃20417</a></li><li>  添加了对集群服务隔离模式 <a href="https://github.com/moby/moby/pull/34424">moby / moby＃34424</a></li><li>  修复任务清理工作以完成 <a href="https://github.com/docker/swarmkit/pull/2477">docker / swarmkit＃2477</a></li></ul><h4 id="客户端相关-8"><a href="#客户端相关-8" class="headerlink" title="客户端相关"></a>客户端相关</h4><ul><li>  修复<code>node-generic-resource</code>错别字 <a href="https://github.com/moby/moby/pull/35970">Moby</a> <a href="https://github.com/moby/moby/pull/36125">/ Moby</a> <a href="https://github.com/moby/moby/pull/35970">＃35970</a> 和 <a href="https://github.com/moby/moby/pull/35970">Moby</a> <a href="https://github.com/moby/moby/pull/36125">/ Moby＃36125</a></li><li>  从堆栈部署配置上的守护程序返回错误创建 / 更新 <a href="https://github.com/docker/cli/pull/757">docker / cli＃757</a></li><li>  在 cli / compose 中删除密钥 / 配置重复项 <a href="https://github.com/docker/cli/pull/671">docker / cli＃671</a></li><li>  将<code>--local</code>标志添加到<code>docker trust sign</code> <a href="https://github.com/docker/cli/pull/575">docker / cli＃575</a></li><li>  添加<code>docker trust inspect</code> <a href="https://github.com/docker/cli/pull/694">docker / cli＃694</a></li><li>  <code>name</code>在机密和配置中添加字段以允许在 Compose 文件中进行插值 <a href="https://github.com/docker/cli/pull/668">docker / cli＃668</a></li><li>  添加<code>--isolation</code>用于设置集群服务隔离模式 <a href="https://github.com/docker/cli/pull/426">docker / cli＃426</a></li><li>  删除不建议使用的 “守护程序” 子命令 <a href="https://github.com/docker/cli/pull/689">docker / cli＃689</a></li><li>  修复<code>rmi -f</code>具有意外错误 <a href="https://github.com/docker/cli/pull/654">docker / cli＃654 的行为</a></li><li>  服务中的集成通用资源创建 <a href="https://github.com/docker/cli/pull/429">docker / cli＃429</a></li><li>  修复堆栈的外部网络 <a href="https://github.com/docker/cli/pull/743">docker / cli＃743</a></li><li>  删除对通过镜像 Shortid docker <a href="https://github.com/docker/cli/pull/753">/ cli＃753</a> 和 <a href="https://github.com/moby/moby/pull/35790">moby / moby＃35790</a> 引用镜像的支持</li><li>  使用 commit-sha 代替标记的集装箱式 <a href="https://github.com/moby/moby/pull/35770">Moby / Moby＃35770</a></li></ul><h4 id="文档相关-1"><a href="#文档相关-1" class="headerlink" title="文档相关"></a>文档相关</h4><ul><li>  更新 1.35 的 API 版本历史记录 <a href="https://github.com/moby/moby/pull/35724">Moby / moby＃35724</a></li></ul><h4 id="构造相关-7"><a href="#构造相关-7" class="headerlink" title="构造相关"></a>构造相关</h4><ul><li>  修正了为断开符号链接构建缓存散列的问题 <a href="https://github.com/moby/moby/pull/34271">moby/moby#34271</a></li><li>  修复长码流同步 <a href="https://github.com/moby/moby/pull/35404">Moby / Moby＃35404</a></li><li>  修复 dockerfile 解析器在长令牌上静默失败的问题 <a href="https://github.com/moby/moby/pull/35429">moby/moby#35429</a></li></ul><h4 id="已知问题-2"><a href="#已知问题-2" class="headerlink" title="已知问题"></a>已知问题</h4><ul><li>  运行状况检查不再使用容器的工作目录 <a href="https://github.com/moby/moby/issues/35843">moby / moby＃35843</a></li><li>  客户端未从堆栈部署配置中返回错误 <a href="https://github.com/docker/cli/pull/757">Moby / Moby＃757</a></li><li>  Docker 在使用 systemd 选项时不能使用内存限制 <a href="https://github.com/moby/moby/issues/35123">moby/moby#35123</a></li></ul><h3 id="版本号：17-11"><a href="#版本号：17-11" class="headerlink" title="版本号：17.11"></a>版本号：17.11</h3>  首次发布时间： 2017-11-20<blockquote><p><strong>重要提示</strong>：Docker CE 17.11 是基于<a href="https://github.com/containerd/containerd/releases/tag/v1.0.0-beta.2">容器化 1.0 beta</a> 的第一个 Docker 版本 。Docker CE 17.11 和更高版本无法识别以早期 Docker 版本开头的容器。如果使用 <a href="https://docs.docker.com/engine/admin/live-restore/#enable-the-live-restore-option">Live Restore</a>，则必须先停止所有容器，然后才能升级到 Docker CE 17.11。如果不这样做，那么在升级后，Docker 将无法识别早于 17.11 的 Docker 版本启动的任何容器，并且它们会在系统上不受管理地继续运行。</p></blockquote><h4 id="构造相关-8"><a href="#构造相关-8" class="headerlink" title="构造相关"></a>构造相关</h4><ul><li>  使用 rm / force-rm 矩阵测试和修复构建<a href="https://github.com/moby/moby/pull/35139">＃35139</a></li><li>  <code>--stream</code>使用大型上下文修复构建<a href="https://github.com/moby/moby/pull/35404">＃35404</a></li></ul><h4 id="客户端相关-9"><a href="#客户端相关-9" class="headerlink" title="客户端相关"></a>客户端相关</h4><ul><li>  从帮助输出隐藏帮助标志 <a href="https://github.com/docker/cli/pull/645">docker / cli＃645</a></li><li>  支持解析组成管道的命名管道 <a href="https://github.com/docker/cli/pull/560">docker / cli＃560</a></li><li>  [Compose] 在插值后将值转换为期望的类型 <a href="https://github.com/docker/cli/pull/601">docker / cli＃601</a></li><li>  在上添加 “秘密” 和“配置”的输出<code>docker stack deploy</code><a href="https://github.com/docker/cli/pull/593">docker / cli＃593</a></li><li>  修复标志说明<code>--host-add</code><a href="https://github.com/docker/cli/pull/648">docker / cli＃648</a></li><li>  不截断 docker service ps 上的 ID –quiet <a href="https://github.com/docker/cli/pull/579">docker / cli＃579</a></li></ul><h4 id="弃用-3"><a href="#弃用-3" class="headerlink" title="弃用"></a>弃用</h4><ul><li>  为同步服务更新更新 bash 完成和弃用 <a href="https://github.com/docker/cli/pull/610">docker / cli＃610</a></li></ul><h4 id="日志相关-9"><a href="#日志相关-9" class="headerlink" title="日志相关"></a>日志相关</h4><ul><li>  复制到日志驱动程序的 bufsize，修复＃34887 <a href="https://github.com/moby/moby/pull/34888">moby/moby#34888</a></li><li>  添加对 GELF 日志驱动程序 TCP 支持 <a href="https://github.com/moby/moby/pull/34758">moby / moby＃34758 的</a></li><li>  为 awslogs 驱动程序添加凭据端点选项 <a href="https://github.com/moby/moby/pull/35055">moby/moby#35055</a></li></ul><h4 id="网络相关-9"><a href="#网络相关-9" class="headerlink" title="网络相关"></a>网络相关</h4><ul><li>  修复删除网络名称掩盖网络 ID<a href="https://github.com/moby/moby/pull/34509">Moby / moby＃34509</a></li><li>  修复了从 500 到 409 的网络创建返回的错误代码 <a href="https://github.com/moby/moby/pull/35030">Moby / Moby＃35030</a></li><li>  修复任务失败，错误为 “无法完成原子操作，已修改密钥” <a href="https://github.com/docker/libnetwork/pull/2004">docker / libnetwork＃2004</a></li></ul><h4 id="运行相关-9"><a href="#运行相关-9" class="headerlink" title="运行相关"></a>运行相关</h4><ul><li>  切换到 Containered 1.0 客户端 <a href="https://github.com/moby/moby/pull/34895">Moby / Moby＃34895</a></li><li>  在 Windows 上增加容器默认关闭超时 <a href="https://github.com/moby/moby/pull/35184">Moby / Moby＃35184</a></li><li>  LCOW：API：添加<code>platform</code>到 / images / create 和 / build <a href="https://github.com/moby/moby/pull/34642">moby / moby＃34642</a></li><li>  停止按版本过滤 Windows 清单列表 <a href="https://github.com/moby/moby/pull/35117">Moby / Moby＃35117</a></li><li>  使用来自 Azure / go-ansiterm 的 Windows 控制台模式常量 <a href="https://github.com/moby/moby/pull/35056">moby / moby＃35056</a></li><li>  Windows 守护程序应遵守 DOCKER_TMPDIR Moby <a href="https://github.com/moby/moby/pull/35077">/ moby＃35077</a></li><li>  Windows：修复启动日志记录 <a href="https://github.com/moby/moby/pull/35253">Moby / Moby＃35253</a></li><li>  在 Windows 版本拉取筛选的支持 <a href="https://github.com/moby/moby/pull/35090">moby / moby＃35090</a></li><li>  在容器 1.0 引入回归后修正了 LCOW <a href="https://github.com/moby/moby/pull/35320">moby/moby#35320</a></li><li>  ContainerWait on remove：不要卡在 rm 上失败 <a href="https://github.com/moby/moby/pull/34999">moby / moby＃34999</a></li><li>  oci：对于用户命名空间的守护程序, 遵循 CL_UNPRIVILEGED <a href="https://github.com/moby/moby/pull/35205">＃35205</a></li><li>  设置 may_detach_mounts 时不要中止 <a href="https://github.com/moby/moby/pull/35172">moby / moby＃35172</a></li><li>  实时还原容器时修复 get 容器 pid 上的异常<a href="https://github.com/moby/moby/pull/35157">＃35157</a></li><li>  <code>/proc/scsi</code>容器的遮罩路径，以防止移除设备（CVE-2017-16539）Moby <a href="https://github.com/moby/moby/pull/35399">/</a> Moby <a href="https://github.com/moby/moby/pull/35399">＃35399</a></li><li>  更新至 github.com/vbatts/<a href="mailto:&#x74;&#x61;&#x72;&#45;&#115;&#112;&#108;&#105;&#116;&#x40;&#x76;&#x30;&#46;&#x31;&#48;&#46;&#50;">&#x74;&#x61;&#x72;&#45;&#115;&#112;&#108;&#105;&#116;&#x40;&#x76;&#x30;&#46;&#x31;&#48;&#46;&#50;</a>（CVE-2017-14992）moby <a href="https://github.com/moby/moby/pull/35424">/ moby＃35424</a></li></ul><h4 id="集群相关-8"><a href="#集群相关-8" class="headerlink" title="集群相关"></a>集群相关</h4><ul><li>  由于 swarmkit 中新的 ipam 选项而修改了集成测试<a href="https://github.com/moby/moby/pull/35103">＃35103</a></li><li>  修复获取集群信息的僵局 [Moby / Moby＃35388(<a href="https://github.com/moby/moby/pull/35388">https://github.com/moby/moby/pull/35388</a>)</li><li>  扩展 TaskStatus 中的 Err 字段的范围，以同时覆盖阻止任务进行的非终端错误 <a href="https://github.com/docker/swarmkit/pull/2287">docker/swarmkit#2287</a></li></ul><h4 id="打包相关-4"><a href="#打包相关-4" class="headerlink" title="打包相关"></a>打包相关</h4><ul><li>  为 Debian 10（Buster）构建软件包 <a href="https://github.com/docker/docker-ce-packaging/pull/50">docker / docker-ce-packaging＃50</a></li><li>  为 Ubuntu 17.10（Artful）构建软件包 <a href="https://github.com/docker/docker-ce-packaging/pull/55">docker / docker-ce-packaging＃55</a></li></ul><h3 id="版本号：17-10"><a href="#版本号：17-10" class="headerlink" title="版本号：17.10"></a>版本号：17.10</h3>  首次发布时间： 2017-10-17<blockquote><p><strong>重要提示</strong>：本版本开始，<code>docker service create</code>，<code>docker service update</code>， <code>docker service scale</code>和<code>docker service rollback</code>使用非分离模式作为默认情况下，使用<code>--detach</code>以保持原来的行为。</p></blockquote><h4 id="构造相关-9"><a href="#构造相关-9" class="headerlink" title="构造相关"></a>构造相关</h4><ul><li>  在上传的构建上下文中将 uid / gid 重置为 0 以与其他客户端共享构建缓存 <a href="https://github.com/docker/cli/pull/513">docker / cli＃513</a></li><li>  添加对<code>ADD</code>没有任何子路的 URL 支持路径 <a href="https://github.com/moby/moby/pull/34217">Moby / Moby＃34217</a></li></ul><h4 id="客户端相关-10"><a href="#客户端相关-10" class="headerlink" title="客户端相关"></a>客户端相关</h4><ul><li>  将输出<code>docker stack rm</code>移至 stdout <a href="https://github.com/docker/cli/pull/491">docker / cli＃491</a></li><li>  在 cli 中将自然排序用于机密和配置 <a href="https://github.com/docker/cli/pull/307">docker / cli＃307</a></li><li>  <code>docker service</code>命令默认使用非分离模式 <a href="https://github.com/docker/cli/pull/525">docker / cli＃525</a></li><li>  在客户端设置 APIVersion，即使 Ping 失败 <a href="https://github.com/docker/cli/pull/546">docker/cli#546</a></li><li>  修复关于<code>docker stack deploy</code> 在不同编译语法的加载器错误 <a href="https://github.com/docker/cli/pull/544">docker/cli#544</a></li><li>  更改默认<code>docker container stats</code>显示格式为 show <code>CONTAINER ID</code>和<code>NAME</code> <a href="https://github.com/docker/cli/pull/565">docker / cli＃565</a></li><li>  将<code>--no-trunc</code>标志添加到<code>docker container stats</code> <a href="https://github.com/docker/cli/pull/565">docker / cli＃565</a></li><li>  添加实验<code>docker trust</code>：<code>view</code>，<code>revoke</code>，<code>sign</code>子<a href="https://github.com/docker/cli/pull/472">泊坞窗 / CLI＃472</a></li><li>  各种文档和 Shell 完成修复程序 <a href="https://github.com/docker/cli/pull/610">docker / cli＃610</a> <a href="https://github.com/docker/cli/pull/611">docker / cli＃611</a> <a href="https://github.com/docker/cli/pull/618">docker / cli＃618</a> <a href="https://github.com/docker/cli/pull/580">docker / cli＃580</a> <a href="https://github.com/docker/cli/pull/598">docker / cli＃598</a> <a href="https://github.com/docker/cli/pull/603">docker / cli＃603</a></li></ul><h4 id="网络相关-10"><a href="#网络相关-10" class="headerlink" title="网络相关"></a>网络相关</h4><ul><li>  在 windows 上使用每个节点、每个网络 LB 端点启用 ILB/ELB <a href="https://github.com/moby/moby/pull/34674">moby/moby#34674</a></li><li>  临时 IP 重用的覆盖修复 <a href="https://github.com/docker/libnetwork/pull/1935">docker / libnetwork＃1935</a></li><li>  序列化 bitseq alloc <a href="https://github.com/docker/libnetwork/pull/1788">docker / libnetwork＃1788</a></li><li>  在链上禁用主机名查找检查 <a href="https://github.com/docker/libnetwork/pull/1974">docker / libnetwork＃1974</a></li></ul><h4 id="运行相关-10"><a href="#运行相关-10" class="headerlink" title="运行相关"></a>运行相关</h4><ul><li>  LCOW：在拆解 Moby / Moby 之前抓住日志来增加 UVM 的可调试性<a href="https://github.com/moby/moby/pull/34846">＃34846</a></li><li>  LCOW：为绑定安装做准备 <a href="https://github.com/moby/moby/pull/34258">Moby / moby＃34258</a></li><li>  LCOW：支持 docker cp，在 builda 上添加 / 复制 <a href="https://github.com/moby/moby/pull/34252">moby/moby#34252</a></li><li>  LCOW：VHDX 引导到只读 <a href="https://github.com/moby/moby/pull/34754">Moby / Moby＃34754</a></li><li>  卷: 在重新标记挂载源之前评估符号链接 <a href="https://github.com/moby/moby/pull/34792">moby/moby#34792</a></li><li>  修改 “docker cp” 以允许在主机 symlinked 目录中添加新的目标文件名 <a href="https://github.com/moby/moby/pull/31993">moby/moby#31993</a></li><li>  增加了对 Windows 的拉取版本过滤 <a href="https://github.com/moby/moby/pull/35090">moby/moby#35090</a></li></ul><h4 id="集群相关-9"><a href="#集群相关-9" class="headerlink" title="集群相关"></a>集群相关</h4><ul><li>  如果<code>docker swarm init --force-new-cluster</code>在辅助节点上执行, 则会产生错误 <a href="https://github.com/moby/moby/pull/34881">Moby / moby＃34881</a></li><li>  加对. node 的支持。群集服务中的主机名模板 <a href="https://github.com/moby/moby/pull/34686">moby/moby#34686</a></li><li>  将 gRPC 请求超时增加到 20 秒以发送快照 <a href="https://github.com/docker/swarmkit/pull/2391">docker / swarmkit＃2391</a></li><li>  如果日志驱动程序设置为<code>none</code>，不要过滤节点 <a href="https://github.com/docker/swarmkit/pull/2396">docker/swarmkit#2396</a></li><li>  将 ipam 选项添加到 ipam 驱动程序请求 <a href="https://github.com/docker/swarmkit/pull/2324">docker / swarmkit＃2324</a></li></ul><h3 id="版本号：17-09"><a href="#版本号：17-09" class="headerlink" title="版本号：17.09"></a>版本号：17.09</h3>  首次发布时间： 2017-12-07<h4 id="构造相关-10"><a href="#构造相关-10" class="headerlink" title="构造相关"></a>构造相关</h4><ul><li>修复共享父级上的配置泄漏 <a href="https://github.com/moby/moby/issues/33753">Moby / Moby＃33753</a></li><li>仅在空的连续行上警告，而不仅仅在注释行上警告 <a href="https://github.com/moby/moby/pull/35004">moby / moby＃35004</a></li><li>将<code>--chown</code>标记添加到<code>ADD/COPY</code>Dockerfile Moby <a href="https://github.com/moby/moby/pull/34263">/ moby＃34263 中的命令</a></li><li>  从 git 仓库构建时修复克隆不需要的文件 <a href="https://github.com/moby/moby/pull/33704">moby / moby＃33704</a></li></ul><h4 id="客户端相关-11"><a href="#客户端相关-11" class="headerlink" title="客户端相关"></a>客户端相关</h4><ul><li>  即使 Ping 失败也可以在客户端上设置 API 版本 <a href="https://github.com/docker/cli/pull/546">docker / cli＃546</a></li><li>  允许使用构成格式为 v3.4 版本的扩展字段 <a href="https://github.com/docker/cli/pull/452">docker / cli＃452</a></li><li>  撰写文件允许为非外部卷指定名称 <a href="https://github.com/docker/cli/pull/306">docker / cli＃306</a></li><li>  支持<code>--compose-file -</code>作为标准 <a href="https://github.com/docker/cli/pull/347">docker/ CLI＃347</a></li><li>  <code>start_period</code>在 Docker Compose 中持运行状况检查 <a href="https://github.com/docker/cli/pull/475">docker / cli＃475</a></li><li>  支持<code>stop-signal</code>在 Docker 堆栈命令 <a href="https://github.com/docker/cli/pull/388">docker / cli＃388 中</a></li><li>  在撰写部署添加对更新顺序的支持 <a href="https://github.com/docker/cli/pull/360">docker / cli＃360 中</a></li><li>  将 ulimits 添加到不受支持的撰写字段 <a href="https://github.com/docker/cli/pull/482">docker / cli＃482</a></li><li>  添加<code>--format</code>到<code>docker-search</code> <a href="https://github.com/docker/cli/pull/440">docker / cli＃440</a></li><li>  以<code>&#123;&#123;.Digest&#125;&#125;</code>格式显示镜像摘要 <a href="https://github.com/docker/cli/pull/439">docker / cli＃439</a></li><li>  在<code>docker stack rm</code>on <code>stdout</code>而不是<code>stderr</code>上打印输出 <a href="https://github.com/docker/cli/pull/491">docker / cli＃491</a></li><li>  修复<code>docker history --format &#123;&#123;json .&#125;&#125;</code>时打印人类可读的时间戳而不是 ISO8601 的时间戳<code>--human=true</code><a href="https://github.com/docker/cli/pull/438">docker / cli＃438</a></li><li>  修复<code>docker stack deploy</code>何时使用秘密或配置的幂等性 <a href="https://github.com/docker/cli/pull/509">docker / cli＃509</a></li><li>  修复随机主机端口显示 <a href="https://github.com/docker/cli/pull/404">docker / cli＃404 的</a></li><li>  修复使用多个加密连接的时候创建服务时重启冗余服务 <a href="https://github.com/moby/moby/issues/34746">Moby / Moby＃34746</a></li></ul><h4 id="网络相关-11"><a href="#网络相关-11" class="headerlink" title="网络相关"></a>网络相关</h4><ul><li>  临时 IP 重用的覆盖修复 <a href="https://github.com/docker/libnetwork/pull/2016">docker / libnetwork＃2016</a></li><li>  修复 NetworkDB 中的 reapTime 逻辑并处理可连接容器的 DNS 清理 <a href="https://github.com/docker/libnetwork/pull/2017">docker / libnetwork＃2017</a></li><li>  在链上禁用主机名查找检查 <a href="https://github.com/docker/libnetwork/pull/2019">docker / libnetwork＃2019</a></li><li>  修复皮棉问题 <a href="https://github.com/docker/libnetwork/pull/2020">docker / libnetwork＃2020</a></li><li>  在 FindNetwork Moby <a href="https://github.com/moby/moby/pull/35634">/</a> Moby 中恢复错误类型<a href="https://github.com/moby/moby/pull/35634">＃35634</a></li><li>  在守护程序配置添加控制平面 MTU 选项 <a href="https://github.com/moby/moby/pull/34103">moby / moby＃34103 中</a></li><li>  将服务虚拟 IP 添加到沙箱的环回地址 <a href="https://github.com/docker/libnetwork/pull/1877">docker / libnetwork＃1877</a></li></ul><h4 id="运行相关-11"><a href="#运行相关-11" class="headerlink" title="运行相关"></a>运行相关</h4><ul><li>  保护<code>health monitor</code>Go Channel <a href="https://github.com/moby/moby/pull/35482">Moby / Moby＃35482</a></li><li>  修复泄漏的容器 / 执行器状态 <a href="https://github.com/moby/moby/pull/35484">Moby / Moby＃35484</a></li><li>  将 / proc / scsi 添加到被屏蔽的路径（补丁程序可解决 [moby / moby /＃35399](<a href="http://cve.mitre.org/cgi-bin/cvename.cgi?&gt;CVE-2017-16539">http://cve.mitre.org/cgi-bin/cvename.cgi?&gt;CVE-2017-16539</a></a>）&lt;a href=)</li><li>  供应商 tar 拆分：修复了防止内存耗尽的问题，该问题可能导致 Docker 守护进程 <a href="https://github.com/moby/moby/pull/35424">moby / moby /＃35424 崩溃</a>修复了 [＃34837](<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?&gt;CVE-2017-14992">https://cve.mitre.org/cgi-bin/cvename.cgi?&gt;CVE-2017-14992</a></a></li><li> 修复 P / Z HubPullSuite 测试 Moby / Moby &lt;a href=)</li><li>  Windows：增加对拉取版本过滤的支持 <a href="https://github.com/moby/moby/pull/35090">moby / moby＃35090</a></li><li>  Windows：停止按版本过滤 Windows 清单列表 <a href="https://github.com/moby/moby/pull/35117">Moby / moby＃35117</a></li><li>  在 chroot 存档中使用 rslave 而不是 rprivate <a href="https://github.com/moby/moby/pull/35217">moby/moby/#35217</a></li><li>  卸载后删除容器 rootfs 挂载路径 <a href="https://github.com/moby/moby/pull/34573">moby/moby#34573</a></li><li>  修正用户 / dev / shm mount 的 tmpfs 大小 <a href="https://github.com/moby/moby/pull/35316">moby / moby＃35316</a></li><li>  设置 may_detach_mounts 时不要中止（改为记录错误） <a href="https://github.com/moby/moby/pull/35172">moby / moby＃35172</a></li><li>  兼容 API 版本时修复版本比较 <a href="https://github.com/moby/moby/pull/35008">Moby / Moby＃35008</a></li><li>  Graphdriver：在 Aufs Moby <a href="https://github.com/moby/moby/pull/34430">/</a> Moby 上提升 overlay2 <a href="https://github.com/moby/moby/pull/34430">＃34430</a></li><li>  LCOW：VHD 启动其他标志 <a href="https://github.com/moby/moby/pull/34451">moby / moby＃34451</a></li><li>  LCOW：请勿阻止出口 <a href="https://github.com/moby/moby/pull/34448">moby/moby#34448</a></li><li>  LCOW：动态沙箱管理 <a href="https://github.com/moby/moby/pull/34170">Moby / Moby＃34170</a></li><li>  LCOW：强制 Hyper-V 隔离 <a href="https://github.com/moby/moby/pull/34468">Moby / Moby＃34468</a></li><li>  LCOW：将 toolsScratchPath 移至 / tmp <a href="https://github.com/moby/moby/pull/34396">moby / moby＃34396</a></li><li>  LCOW：删除硬编码 <a href="https://github.com/moby/moby/pull/34398">Moby / moby＃34398</a></li><li>  LCOW：WORKDIR 正确处理 Moby <a href="https://github.com/moby/moby/pull/34405">/ Moby＃34405</a></li><li>  Windows：命名管道安装 <a href="https://github.com/moby/moby/pull/33852">Moby / Moby＃33852</a></li><li>  修复使用 SELinux 强制模式访问卷时的 “权限被拒绝” 错误 <a href="https://github.com/moby/moby/pull/34684">moby / moby＃34684</a></li><li>  修复层大小报告在 <code>docker system df</code> 为<code>0</code> <a href="https://github.com/moby/moby/pull/34826">moby/moby#34826</a></li><li>  修复了在基于 RHEL 7.4 的内核上删除容器时一些 “设备或资源繁忙” 的错误 <a href="https://github.com/moby/moby/pull/34886">moby / moby＃34886</a></li></ul><h4 id="集群相关-10"><a href="#集群相关-10" class="headerlink" title="集群相关"></a>集群相关</h4><ul><li>  发送快照时增加 gRPC 请求超时 <a href="https://github.com/docker/swarmkit/pull/2404">docker / swarmkit＃2404</a></li><li>  在没有日志驱动程序时修复节点过滤 <a href="https://github.com/docker/swarmkit/pull/2442">docker / swarmkit＃2442</a></li><li>  在尝试更改群集名称时添加错误 <a href="https://github.com/docker/swarmkit/pull/2454">docker / swarmkit /＃2454</a></li><li>  删除节点后删除节点附件 <a href="https://github.com/docker/swarmkit/pull/2456">docker / swarmkit /＃2456</a></li><li>  提供自定义 gRPC 拨号程序以覆盖默认代理拨号程序 <a href="https://github.com/docker/swarmkit/pull/2457">docker / swarmkit /＃2457</a></li><li>  避免对群信息进行递归读取 <a href="https://github.com/moby/moby/pull/35388">moby/moby#35388</a></li><li>  包括是否将群中的管理器作为一部分自动锁定为<code>docker info</code>部分 <a href="https://github.com/docker/cli/pull/471">docker / cli＃471</a></li><li>  添加’docker service rollback’子命令 <a href="https://github.com/docker/cli/pull/205">docker / cli＃205</a></li><li>  如果 gRPC 快照大于 4MB, 则修复管理器无法加入 <a href="https://github.com/docker/swarmkit/pull/2375">docker / swarmkit＃2375</a></li><li>  修复启用 SELinux 的容器中配置文件的 “权限被拒绝” 错误 <a href="https://github.com/moby/moby/pull/34732">moby / moby＃34732</a></li><li>  修复无法在 ARM 节点上部署服务 <a href="https://github.com/moby/moby/pull/34021">Moby / Moby＃34021</a></li></ul><h4 id="日志相关-10"><a href="#日志相关-10" class="headerlink" title="日志相关"></a>日志相关</h4><ul><li>  修复 Splunk 记录器在标签为空且使用原始模式时不传输日志数据的问题 <a href="https://github.com/moby/moby/pull/34520">Moby / Moby＃34520</a></li></ul><h4 id="打包相关-5"><a href="#打包相关-5" class="headerlink" title="打包相关"></a>打包相关</h4><ul><li>  在 Ubuntu 上为 ppc64el 构建脚本 <a href="https://github.com/docker/docker-ce-packaging/pull/43">docker/docker-ce-packaging#43</a></li></ul><h4 id="弃用-4"><a href="#弃用-4" class="headerlink" title="弃用"></a>弃用</h4><ul><li>  删除不赞成使用的<code>--enable-api-cors</code>守护程序标志 <a href="https://github.com/moby/moby/pull/34821">moby / moby＃34821</a></li></ul><h3 id="版本号：17-07"><a href="#版本号：17-07" class="headerlink" title="版本号：17.07"></a>版本号：17.07</h3>  首次发布时间： 2017-08-29<h4 id="API-和客户端"><a href="#API-和客户端" class="headerlink" title="API 和客户端"></a>API 和客户端</h4><ul><li>  在 config.json 添加对代理配置的支持 <a href="https://github.com/docker/cli/pull/93">docker / cli＃93</a></li><li>  默认情况下启用 pprof / debug 端点 <a href="https://github.com/moby/moby/pull/32453">moby / moby＃32453</a></li><li>  现在可以使用上的<code>STDIN</code>new <code>--password-stdin</code>标志来传递密码<code>docker login</code><a href="https://github.com/docker/cli/pull/271">docker / cli＃271</a></li><li>  添加<code>--detach</code>到 docker scale <a href="https://github.com/docker/cli/pull/243">docker / cli＃243</a></li><li>  防止<code>docker logs --no-stream</code>由于不存在的容器而挂起 <a href="https://github.com/moby/moby/pull/34004">Moby / Moby＃34004</a></li><li>  修复<code>docker stack ps</code>打印错误，<code>stdout</code>而不是<code>stderr</code> <a href="https://github.com/docker/cli/pull/298">docker / cli＃298</a></li><li>  修复<code>docker service create</code>在部署期间发生错误时进度条卡住的问题 <a href="https://github.com/docker/cli/pull/259">docker / cli＃259</a></li><li>  改进交互模式下进度条的显示方式 <a href="https://github.com/docker/cli/pull/260">docker / cli＃260</a> <a href="https://github.com/docker/cli/pull/237">docker / cli＃237</a></li><li>  如果<code>docker login --password</code>使用警告，打印警告，并建议使用<code>--password-stdin</code> <a href="https://github.com/docker/cli/pull/270">docker / cli＃270</a></li><li>  使 API 版本兼容更加健壮 <a href="https://github.com/moby/moby/pull/33827">moby / moby＃33827</a></li><li>  当连接到比 Docker 17.05 更老的守护进程时隐藏 <code>--detach</code> <a href="https://github.com/docker/cli/pull/219">docker / cli＃219</a></li><li>  在 <code>GET /networks/(id or name)</code> 添加 <code>scope</code> 过滤器 <a href="https://github.com/moby/moby/pull/33630">moby/moby#33630</a></li></ul><h4 id="构建相关"><a href="#构建相关" class="headerlink" title="构建相关"></a>构建相关</h4><ul><li>  实现长时间运行的交互式会话并逐步发送构建上下文 <a href="https://github.com/moby/moby/pull/32677">moby / moby＃32677 docker</a> <a href="https://github.com/docker/cli/pull/231">/ cli＃231</a> <a href="https://github.com/moby/moby/pull/33859">moby / moby＃33859</a></li><li>  警告空的连续行 <a href="https://github.com/moby/moby/pull/33719">Moby / Moby＃33719</a></li><li>  修复. dockerignore 包含前导 / 不匹配的条目 <a href="https://github.com/moby/moby/pull/32088">moby/moby#32088</a></li></ul><h4 id="日志相关-11"><a href="#日志相关-11" class="headerlink" title="日志相关"></a>日志相关</h4><ul><li>  修复错误的文件模式以旋转日志文件 <a href="https://github.com/moby/moby/pull/33926">Moby / Moby＃33926</a></li><li>  修复 Stderr 日志记录的日志记录和系统日志 Moby <a href="https://github.com/moby/moby/pull/33832">/</a> Moby <a href="https://github.com/moby/moby/pull/33832">＃33832</a></li></ul><h4 id="运行相关-12"><a href="#运行相关-12" class="headerlink" title="运行相关"></a>运行相关</h4><ul><li>  允许停止暂停的容器 <a href="https://github.com/moby/moby/pull/34027">Moby / Moby＃34027</a></li><li>  添加对 overlay2 存储驱动程序的配额支持 <a href="https://github.com/moby/moby/pull/32977">moby/moby#32977</a></li><li>  卸下上的容器锁<code>docker ps</code> <a href="https://github.com/moby/moby/pull/31273">＃31273</a></li><li>  将容器名称存储在 memdb 中 <a href="https://github.com/moby/moby/pull/33886">moby / moby＃33886</a></li><li>  修复<code>docker exec</code>和<code>docker pause</code>之间的竞争状况 <a href="https://github.com/moby/moby/pull/32881">＃32881</a><a href="https://github.com/moby/moby/pull/32881">Moby / Moby</a></li><li>  Devicemapper：重做日志记录并添加<code>--storage-opt dm.libdm_log_level</code> <a href="https://github.com/moby/moby/pull/33845">moby / moby＃33845</a></li><li>  Devicemapper：如果启用了延迟删除，但没有延迟删除，则防止 “设备正在使用” 错误 <a href="https://github.com/moby/moby/pull/33877">moby / moby＃33877</a></li><li>  Devicemapper：使用 KeepAlive 可以防止仍在使用中的任务垃圾收集 <a href="https://github.com/moby/moby/pull/33376">moby / moby＃33376</a></li><li>  如果取消修剪，请报告中间修剪结果 <a href="https://github.com/moby/moby/pull/33979">Moby / moby＃33979</a></li><li>  修复<code>docker rename new_name</code>同时运行导致具有多个名称 <a href="https://github.com/moby/moby/pull/33940">moby / moby＃33940</a></li><li>  修复文件描述符泄漏和错误处理 <a href="https://github.com/moby/moby/pull/33713">Moby / Moby＃33713</a></li><li>  在运行容器时修复 SIGSEGV<a href="https://github.com/docker/cli/pull/303">docker / cli＃303</a></li><li>  停止健康检查时防止 goroutine 泄漏 <a href="https://github.com/moby/moby/pull/33781">Moby / Moby＃33781</a></li><li>  图片：改进商店锁定 <a href="https://github.com/moby/moby/pull/33755">Moby / Moby＃33755</a></li><li>  修复在销毁容器时不会删除 Btrfs 配额组的问题 <a href="https://github.com/moby/moby/pull/29427">Moby / Moby＃29427</a></li><li>  Libcontainerd：修复无法正常获得已停用的容器进程 <a href="https://github.com/moby/moby/pull/33419">Moby / Moby＃33419</a></li><li>Windows 上 Linux 容器的准备<ul><li>  LCOW：服务 VM 公用程序专用暂存空间 <a href="https://github.com/moby/moby/pull/33809">moby / moby＃33809 的</a></li><li>  LCOW：支持大多数操作，但不包括远程文件系统 <a href="https://github.com/moby/moby/pull/33241">moby / moby＃33241</a> <a href="https://github.com/moby/moby/pull/33826">moby / moby＃33826</a></li><li>  LCOW：将目录从 lcow 更改为 “Linux 容器” <a href="https://github.com/moby/moby/pull/33835">moby / moby＃33835</a></li><li>  LCOW：传递命令参数而无需额外引用 <a href="https://github.com/moby/moby/pull/33815">moby / moby＃33815</a></li><li>  LCOW：由于平台架构更改需要进行更新 <a href="https://github.com/moby/moby/pull/33785">moby / moby＃33785</a></li></ul></li></ul><h4 id="集群相关-11"><a href="#集群相关-11" class="headerlink" title="集群相关"></a>集群相关</h4><ul><li>  支持可插入的加密后端 <a href="https://github.com/moby/moby/pull/34157">Moby</a> <a href="https://github.com/moby/moby/pull/34123">/</a> <a href="https://github.com/moby/moby/pull/34157">Moby＃34157 Moby</a> <a href="https://github.com/moby/moby/pull/34123">/</a> <a href="https://github.com/moby/moby/pull/34157">Moby＃34123</a></li><li>  使用自然排序群体堆栈和节点进行排序 <a href="https://github.com/docker/cli/pull/315">docker / cli＃315</a> 对</li><li>  engine 支持群集配置事件 <a href="https://github.com/moby/moby/pull/34032">Moby / Moby＃34032</a></li><li>  只有在加入集群的过程中才传递一个连接地址 <a href="https://github.com/docker/cli/pull/184">docker/cli#184</a></li><li>  修正服务创建时的错误，如果同名网络同时存在于 “本地” 和“群”范围内的网络 <a href="https://github.com/docker/cli/pull/184">docker/cli#184</a></li><li>  （实验性）添加对 swarm 的插件的支持 <a href="https://github.com/moby/moby/pull/33575">moby/moby#33575</a></li></ul><h3 id="版本号：17-06"><a href="#版本号：17-06" class="headerlink" title="版本号：17.06"></a>版本号：17.06</h3>  首次发布时间： 2017-06-28<blockquote><p><strong>注意</strong>：</p><ul><li>  Docker 17.06.0 在映像构建器中存在问题，导致<code>ADD</code>在引用远程<code>.tar.gz</code>文件时 Dockerfile 指令的行为发生变化。该问题将在 Docker 17.06.1 中修复。</li><li>  从 Docker CE 17.06 开始，使用 s390x 架构的 IBM Z 也可以使用 Ubuntu 软件包。</li><li>  默认情况下，Docker 17.06 禁用与旧版（v1）注册表的通信。如果需要与尚未迁移到 v2 协议的注册表进行交互，请设置<code>--disable-legacy-registry=false</code>守护程序选项。与 v1 注册表的交互将在 Docker 17.12 中删除。</li></ul></blockquote><h4 id="客户端相关-12"><a href="#客户端相关-12" class="headerlink" title="客户端相关"></a>客户端相关</h4><ul><li>  在客户端中启用 TCP 保持存活以防止失去连接 <a href="https://github.com/docker/cli/pull/415">docker / cli＃415</a></li><li>  在运行时将挂载卷设为可选<code>docker system prune</code>，并添加<code>--volumes</code>标志<a href="https://github.com/docker/docker-ce/pull/109">＃109</a></li><li>  在分配复制任务之前显示它们的进度<a href="https://github.com/docker/docker-ce/pull/97">＃97</a></li><li>  如果容器不存在，修复<code>docker wait</code>悬挂问题<a href="https://github.com/docker/docker-ce/pull/106">＃106</a></li><li>  如果<code>docker swarm ca</code>在没有<code>--rotate</code>标志的情况下被调用，则警告是否传递了其他标志<a href="https://github.com/docker/docker-ce/pull/110">＃110</a></li><li>  如果守护程序返回错误，则修复 API 版本协商不起作用 <a href="https://github.com/docker/docker-ce/pull/115">#115</a></li><li>  如果在系统修剪中将 “until” 过滤器与 “ –volumes” 结合使用，则打印错误<a href="https://github.com/docker/docker-ce/pull/154">＃154</a></li><li>  添加<code>--format</code>选项到<code>docker stack ls</code> <a href="https://github.com/moby/moby/pull/31557">＃31557</a></li><li>  在撰写的初始版本中添加对标签的支持 <a href="https://github.com/moby/moby/pull/32632">＃32632</a> <a href="https://github.com/moby/moby/pull/32972">＃32972</a></li><li>  添加<code>--format</code>选项到<code>docker history</code> <a href="https://github.com/moby/moby/pull/30962">＃30962</a></li><li>  添加<code>--format</code>选项到<code>docker system df</code> <a href="https://github.com/moby/moby/pull/31482">＃31482</a></li><li>  允许在堆栈文件中指定名称服务器和搜索域<a href="https://github.com/moby/moby/pull/32059">＃32059</a></li><li>  将<code>read_only</code>服务支持添加到<code>docker stack deploy</code> <a href="https://github.com/docker/cli/pull/73">＃docker / cli / 73</a></li><li>  显示 Swarm 集群和节点 TLS 信息<a href="https://github.com/docker/cli/pull/44">＃docker / cli / 44</a></li><li>  添加对位置设置的支持 <code>docker stack deploy</code> <a href="https://github.com/docker/cli/pull/35">#docker/cli/35</a></li><li>  添加新的<code>ca</code>子命令到<code>docker swarm</code>允许管理集群 CA <a href="https://github.com/docker/cli/pull/48">＃docker / cli / 48</a></li><li>  添加凭据规范<a href="https://github.com/docker/cli/pull/71">＃docker / cli / 71</a></li><li>  支持对 csv 格式的选项<code>--network</code>和<code>--network-add</code> <a href="https://github.com/docker/cli/pull/62">#docker/cli/62</a> <a href="https://github.com/moby/moby/pull/33130">#33130</a></li><li>  修复在 Windows 上堆栈绑定卷 <a href="https://github.com/docker/cli/pull/136">#docker/cli/136</a></li><li>  正确处理没有注册表信息的 Docker 守护程序<a href="https://github.com/docker/cli/pull/126">＃docker / cli / 126</a></li><li>  当使用 using –rollbac 时, 允许使用<code>--detach</code> and <code>--quiet</code> <a href="https://github.com/docker/cli/pull/144">#docker/cli/144</a></li><li>  从<code>docker login</code>中移除<code>--email</code> <a href="https://github.com/docker/cli/pull/143">#docker/cli/143</a></li><li>  调整<code>docker stats</code>内存输出<a href="https://github.com/docker/cli/pull/80">＃docker / cli / 80</a></li></ul><h4 id="集群相关-12"><a href="#集群相关-12" class="headerlink" title="集群相关"></a>集群相关</h4><ul><li>  忽略运行任务的 PullOptions <a href="https://github.com/docker/swarmkit/pull/2351">docker/swarmkit#2351</a></li><li>  不要将重复的平台信息添加到服务规格<a href="https://github.com/docker/docker-ce/pull/107">＃107</a></li><li>  集群更新和内存问题修复<a href="https://github.com/docker/docker-ce/pull/114">＃114</a></li><li>  更改获取网络请求以返回集群中的预定义网络 <a href="https://github.com/docker/docker-ce/pull/150">#150</a></li><li>  使用–data-path-addr 将 Swarm 控制面流量与应用程序数据流量隔离 <a href="https://github.com/moby/moby/pull/32717">＃32717</a></li><li>  允许在容器内指定一个秘密位置<a href="https://github.com/moby/moby/pull/32571">＃32571</a></li><li>  添加 Windows 加密支持 <a href="https://github.com/moby/moby/pull/32208">＃32208</a></li><li>  将 TLS 信息添加到集群信息和节点信息终端<a href="https://github.com/moby/moby/pull/32875">＃32875</a></li><li>  添加对服务的支持以携带任意配置对象<a href="https://github.com/moby/moby/pull/32336">＃32336</a>，<a href="https://github.com/docker/cli/pull/45">＃</a><a href="https://github.com/moby/moby/pull/32336">docker</a> <a href="https://github.com/docker/cli/pull/45">/ cli / 45</a>，<a href="https://github.com/moby/moby/pull/33169">＃33169</a></li><li>  添加 API 远程集群 CA 证书<a href="https://github.com/moby/moby/pull/32993">＃32993</a></li><li>  服务摘要提取现在在客户端处理 <a href="https://github.com/moby/moby/pull/32388">#32388</a>, <a href="https://github.com/moby/moby/pull/33239">#33239</a></li><li>  Placement 也考虑放到平台<a href="https://github.com/moby/moby/pull/33144">＃33144</a></li><li>  修复连接失败时可能挂起的问题<a href="https://github.com/docker/docker-ce/pull/19">＃docker-ce / 19</a></li><li>  修复了阻止外部 CA 被接受的问题<a href="https://github.com/moby/moby/pull/33341">＃33341</a></li><li>  修复混合版本集群中可能的编排异常<a href="https://github.com/docker/swarmkit/pull/2233">＃swarmkit / 2233</a></li><li>  避免在初始化期间分配重复的 IP <a href="https://github.com/docker/swarmkit/pull/2237">＃swarmkit / 2237</a></li></ul><h4 id="运行相关-13"><a href="#运行相关-13" class="headerlink" title="运行相关"></a>运行相关</h4><ul><li>  Devmapper: 确保 UdevWait 在调用 setCookie 之后被调用 <a href="https://github.com/moby/moby/pull/33732">moby/moby#33732</a></li><li>  Aufs: 确保差异层被正确地删除，以防止剩余的文件使用完存储空间 <a href="https://github.com/moby/moby/pull/34587">moby/moby#34587</a></li><li>  <code>healthcheck</code>停止时, 防止<code>goroutine</code> 泄露 <a href="https://github.com/docker/docker-ce/pull/90">#90</a></li><li>  不错误的重新标签时，重新标签不支持 <a href="https://github.com/docker/docker-ce/pull/92">＃92</a></li><li>  将 GRPC 连接的最大退避延迟限制为 2 秒<a href="https://github.com/docker/docker-ce/pull/94">＃94</a></li><li>  修复了由于某些内核中的错误而在指定内存 cgroup 时阻止容器运行的问题<a href="https://github.com/docker/docker-ce/pull/102">＃102</a></li><li>  修复暂停时容器不响应 SIGKILL 问题<a href="https://github.com/docker/docker-ce/pull/102">＃102</a></li><li>  改善了错误消息: 如果加载了不兼容的操作系统的映像<a href="https://github.com/docker/docker-ce/pull/108">＃108</a></li><li>  修复的手柄泄漏<code>go-winio[＃112](https://github.com/docker/docker-ce/pull/112)</code></li><li>  修复升级时的问题，阻止 Docker 在<code>--live-restore</code>启用时显示正在运行的容器<a href="https://github.com/docker/docker-ce/pull/117">＃117</a></li><li>  修复以下错误：使用机密的服务无法在使用<code>userns-remap</code>功能的守护程序上启动<a href="https://github.com/docker/docker-ce/pull/121">＃121</a></li><li>  修复错误处理并将<code>not-exist</code>错误移除<a href="https://github.com/docker/docker-ce/pull/142">＃142</a></li><li>  修复了显示不能用 SwaggerUI 加载 REST API Swagger <a href="https://github.com/docker/docker-ce/pull/156">#156</a></li><li>  添加构建和 engine 信息 Prometheus 指标<a href="https://github.com/moby/moby/pull/32792">＃32792</a></li><li>  更新容器到 d24f39e203aa6be4944f06dd0fe38a618a36c764 <a href="https://github.com/moby/moby/pull/33007">＃33007</a></li><li>  将 Runc 更新到 992a5be178a62e026f4069f443c6164912adbf09 <a href="https://github.com/moby/moby/pull/33007">＃33007</a></li><li>  为 devmapper 自动配置 blkdev 添加选项 <a href="https://github.com/moby/moby/pull/31104">＃31104</a></li><li>  将日志驱动程序列表添加到<code>docker info</code> <a href="https://github.com/moby/moby/pull/32540">＃32540</a></li><li>  添加 API 端点以允许检索镜像清单<a href="https://github.com/moby/moby/pull/32061">＃32061</a></li><li>  不删除容器从内存错误<code>forceremove</code> <a href="https://github.com/moby/moby/pull/31012">#31012</a></li><li>  添加对度量插件的支持<a href="https://github.com/moby/moby/pull/32874">＃32874</a></li><li>  当<code>prune</code>命令中使用了无效的过滤器时，返回错误<a href="https://github.com/moby/moby/pull/33023">＃33023</a></li><li>  添加守护程序选项以允许推送外部图层<a href="https://github.com/moby/moby/pull/33151">＃33151</a></li><li>  修复了阻止容器在死亡后重新启动的问题<a href="https://github.com/moby/moby/pull/32986">＃32986</a></li><li>  将集群事件添加到 Docker 事件流中。<a href="https://github.com/moby/moby/pull/32421">＃32421</a></li><li>  在 Windows 上添加对 DNS 搜索的支持<a href="https://github.com/moby/moby/pull/33311">＃33311</a></li><li>  升级到 Go 1.8.3 <a href="https://github.com/moby/moby/pull/33387">＃33387</a></li><li>  防止日记重新启动时发生容器崩溃 <a href="https://github.com/containerd/containerd/pull/930">＃containerd/ 930</a></li><li>  修复由于无效的环境变量而导致的运行状况检查失败<a href="https://github.com/moby/moby/pull/33249">＃33249</a></li><li>  禁止在停机期间重新启动安装容器的目录时，代替守护进程套接字创建目录<a href="https://github.com/moby/moby/pull/33330">＃30348</a></li><li>  如果容器的停止信号设置为<code>SIGKILL</code>吗, 则防止容器在停止时重新启动<a href="https://github.com/moby/moby/pull/33335">＃33335</a></li><li>  确保日志驱动程序将相同的文件名传递给 StartLogging 和 StopLogging 端点<a href="https://github.com/moby/moby/pull/33583">＃33583</a></li><li>  删除守护程序数据结构转储<code>SIGUSR1</code>以避免出现紧急情况<a href="https://github.com/moby/moby/pull/33598">＃33598</a></li></ul><h4 id="构造相关-11"><a href="#构造相关-11" class="headerlink" title="构造相关"></a>构造相关</h4><ul><li>  修复回退，当使用<code>ADD</code>从远程 URL 提取的存档<a href="https://github.com/docker/docker-ce/pull/89">＃89</a></li><li>  修复了对远程 “git @” 符号<a href="https://github.com/docker/docker-ce/pull/100">＃100 的处理</a></li><li>  修复复制<code>--from</code>冲突与强制拉取<a href="https://github.com/docker/docker-ce/pull/86">＃86</a></li><li>  添加<code>--iidfile</code>选项到 docker 构建。它允许指定保存结果镜像 ID 的位置</li><li>  允许在 git checkout URLs 中指定任何远程引用<a href="https://github.com/moby/moby/pull/32502">＃32502</a></li></ul><h4 id="日志相关-12"><a href="#日志相关-12" class="headerlink" title="日志相关"></a>日志相关</h4><ul><li>  修复 stderr 记录<code>journald</code>和<code>syslog</code> <a href="https://github.com/docker/docker-ce/pull/95">＃95</a></li><li>  修复日志读取器可以无限期阻止写入<a href="https://github.com/docker/docker-ce/pull/98">＃98</a></li><li>  修复<code>awslogs</code>驱动程序重复上一次事件<a href="https://github.com/docker/docker-ce/pull/151">＃151</a></li><li>  为 GCP 日志记录驱动程序添加监视的资源类型元数据<a href="https://github.com/moby/moby/pull/32930">＃32930</a></li><li>  将多行处理添加到 AWS CloudWatch 日志驱动程序<a href="https://github.com/moby/moby/pull/30891">＃30891</a></li></ul><h4 id="网络相关-12"><a href="#网络相关-12" class="headerlink" title="网络相关"></a>网络相关</h4><ul><li>  修复网络驱动程序未接收到的驱动程序选项的问题<a href="https://github.com/docker/docker-ce/pull/127">＃127</a></li><li>  通过节点本地网络（例如 macvlan，ipvlan，网桥，主机）添加支持群模式服务<a href="https://github.com/moby/moby/pull/32981">＃32981</a></li><li>  在创建服务时将驱动程序选项传递给网络驱动程序<a href="https://github.com/moby/moby/pull/33130">＃32981</a></li><li>  使用–data-path-addr 将 Swarm 控制面流量与应用程序数据流量 <a href="https://github.com/moby/moby/pull/32717">＃32717</a></li><li>  对服务进行了一些改进 <a href="https://github.com/docker/libnetwork/pull/1796">#docker/libnetwork/1796</a></li></ul><h4 id="插件相关"><a href="#插件相关" class="headerlink" title="插件相关"></a>插件相关</h4><ul><li>  插件删除失败更有保障 <a href="https://github.com/docker/docker-ce/pull/91">#91</a></li></ul><h4 id="安全相关-1"><a href="#安全相关-1" class="headerlink" title="安全相关"></a>安全相关</h4><ul><li>  编辑有关秘密创建秘密数据<a href="https://github.com/docker/docker-ce/pull/99">＃99 的</a></li><li>  允许使用默认 seccomp 配置文件设置的 UNAME26 位<a href="https://github.com/moby/moby/pull/32965">＃32965</a></li></ul><h4 id="发行相关"><a href="#发行相关" class="headerlink" title="发行相关"></a>发行相关</h4><ul><li>  在提取期间同时提供摘要时，选择标记之上的摘要<a href="https://github.com/moby/moby/pull/33214">＃33214</a></li></ul><h4 id="打包相关-6"><a href="#打包相关-6" class="headerlink" title="打包相关"></a>打包相关</h4><ul><li>  <code>container-selinux</code>可用时依靠 Centos / Fedora / RHEL <a href="https://github.com/moby/moby/pull/32437">＃32437</a></li></ul><h4 id="弃用-5"><a href="#弃用-5" class="headerlink" title="弃用"></a>弃用</h4><ul><li>  默认情况下禁用旧式注册表（v1）<a href="https://github.com/moby/moby/pull/33629">＃33629</a></li></ul><h3 id="版本号：17-05"><a href="#版本号：17-05" class="headerlink" title="版本号：17.05"></a>版本号：17.05</h3>  首次发布时间： 2017-05-04<h4 id="运行相关-14"><a href="#运行相关-14" class="headerlink" title="运行相关"></a>运行相关</h4><ul><li>  当容器退出时，确保运行状况探针已停止； Github 节点说明：； Github 节点说明：<a href="https://github.com/docker/docker/pull/32274">＃32274</a></li></ul><h4 id="网络相关-13"><a href="#网络相关-13" class="headerlink" title="网络相关"></a>网络相关</h4><ul><li>  允许用户替换和自定义入口网络；<a href="https://github.com/docker/docker/pull/31714">＃31714</a></li><li>  修复容器重启后容器中的 UDP 通信无法正常工作的情况； <a href="https://github.com/docker/docker/pull/32505">＃32505</a></li><li>  如果设置了其他数据根，则修复将文件写入<code>/var/lib/docker</code>的问题 ； Github 节点说明：<a href="https://github.com/docker/docker/pull/32505">＃32505</a></li></ul><h4 id="集群相关-13"><a href="#集群相关-13" class="headerlink" title="集群相关"></a>集群相关</h4><ul><li>  添加服务的更新 / 回滚顺序到（<code>--update-order</code>/ <code>--rollback-order</code>）<a href="https://github.com/docker/docker/pull/30261">＃30261</a></li><li>  添加对同步<code>service create</code>和<a href="https://github.com/docker/docker/pull/31144">＃31144 的</a>支持<code>service update Github节点说明：</code></li><li>  添加在健康检查 “宽限期”，通过支持<code>HEALTHCHECK --start-period</code>和<code>--health-start-period</code>标志 <code>docker service create</code>，<code>docker service update</code>，<code>docker create</code>，和<code>docker run</code>以支撑容器的初始启动时间 <a href="https://github.com/docker/docker/pull/28938">＃28938</a></li><li>  <code>docker service create</code>现在，在可能的情况下会忽略用户未指定的字段。允许在管理器中应用默认设置<a href="https://github.com/docker/docker/pull/32284">＃32284</a></li><li>  <code>docker service inspect</code>显示用户未指定的字段的默认值<a href="https://github.com/docker/docker/pull/32284">＃32284</a></li><li>  将<code>docker service logs</code>移出实验功能<a href="https://github.com/docker/docker/pull/32462">＃32462</a></li><li>  将对凭据规范和 SELinux 的支持添加到 API 服务 <a href="https://github.com/docker/docker/pull/32339">＃32339</a></li><li>  将<code>--entrypoint</code>标志添加到<code>docker service create</code>和<code>docker service update</code> <a href="https://github.com/docker/docker/pull/29228">＃29228</a></li><li>  添加<code>--network-add</code>到<code>--network-rm</code>和<code>docker service update</code> <a href="https://github.com/docker/docker/pull/32062">＃32062</a></li><li>  将<code>--credential-spec</code>标志添加到<code>docker service create</code>和<code>docker service update</code> <a href="https://github.com/docker/docker/pull/32339">＃32339</a></li><li>  添加<code>--filter mode</code>到<code>docker service ls</code> <a href="https://github.com/docker/docker/pull/31538">＃31538</a></li><li>  创建服务时，在客户端而不是在守护程序中解析网络 ID <a href="https://github.com/docker/docker/pull/32062">＃32062</a></li><li>  添加<code>--format</code>选项到<code>docker node ls</code><a href="https://github.com/docker/docker/pull/30424">＃30424</a></li><li>  添加<code>--prune</code>选项到<code>docker stack deploy</code>删除不再在 docker-compose 文件中定义的服务 <a href="https://github.com/docker/docker/pull/31302">#31302</a></li><li>  当使用<code>ingress</code> 将 <code>PORTS</code> 列添加到 <code>docker service ls</code> 中 <a href="https://github.com/docker/docker/pull/30813">#30813</a></li><li>  修复了使用环境变量时不必要的任务重新部署<a href="https://github.com/docker/docker/pull/32364">＃32364</a></li><li>  修复从 Docker 撰写文件进行部署时<code>docker stack deploy</code>不支持<code>endpoint_mode</code> <a href="https://github.com/docker/docker/pull/32333">＃32333</a></li><li>  如果无法创建群集组件允许从损坏的群集设置中恢复，然后继续启动。<a href="https://github.com/docker/docker/pull/31631">＃31631</a></li></ul><h4 id="构造相关-12"><a href="#构造相关-12" class="headerlink" title="构造相关"></a>构造相关</h4><ul><li>  添加多阶段构建支持<a href="https://github.com/docker/docker/pull/31257">＃31257</a> <a href="https://github.com/docker/docker/pull/32063">＃32063</a></li><li>  允许构建时在<code>FROM</code>中使用<code>ARG</code>参数 <a href="https://github.com/docker/docker/pull/31352">#31352</a></li><li>  添加用于指定构建目标的选项<a href="https://github.com/docker/docker/pull/32496">＃32496</a></li><li>  接受<code>-f -</code>从 <code>stdin</code>读取 Dockerfile，但使用本地上下文进行构建<a href="https://github.com/docker/docker/pull/31236">＃31236</a></li><li>  除非在 Dockerfile 中编写了相应的<code>ARG</code>指令，否则默认构建时间参数的值（例如<code>HTTP_PROXY</code>）将不再显示在 Docker 镜像历史记录中 。<a href="https://github.com/docker/docker/pull/31584">＃31584</a></li><li>  如果在父镜像中使用了 shell，则修复设置命令<a href="https://github.com/docker/docker/pull/32236">＃32236</a></li><li>  修复<code>docker build --label</code>标签包含单引号和空格的情况<a href="https://github.com/docker/docker/pull/31750">＃31750</a></li></ul><h4 id="客户端相关-13"><a href="#客户端相关-13" class="headerlink" title="客户端相关"></a>客户端相关</h4><ul><li>  将<code>--mount</code>标志添加到<code>docker run</code>和<code>docker create</code> <a href="https://github.com/docker/docker/pull/32251">＃32251</a></li><li>  添加<code>--type=secret</code>到<code>docker inspect</code> <a href="https://github.com/docker/docker/pull/32124">＃32124</a></li><li>  添加<code>--format</code>选项到<code>docker secret ls</code> <a href="https://github.com/docker/docker/pull/31552">＃31552</a></li><li>  添加 <code>--filter</code> 选项到 <code>docker secret ls</code> <a href="https://github.com/docker/docker/pull/30810">#30810</a></li><li>  添加<code>--filter scope=&lt;swarm|local&gt;</code>到<code>docker network ls</code> <a href="https://github.com/docker/docker/pull/31529">＃31529</a></li><li>  添加 <code>--cpus</code> 命令到 <code>docker update</code> <a href="https://github.com/docker/docker/pull/31148">#31148</a></li><li>  将标签过滤器添加到<code>docker system prune</code>和其他<code>prune</code>命令<a href="https://github.com/docker/docker/pull/30740">＃30740</a></li><li>  <code>docker stack rm</code>现在接受多个堆栈作为输入<a href="https://github.com/docker/docker/pull/32110">＃32110</a></li><li>  当客户端降级 API 版本改进<code>docker version --format</code>时，选项<a href="https://github.com/docker/docker/pull/31022">＃31022</a></li><li>  使用加密的客户端证书连接 docker 守护程序时提示<a href="https://github.com/docker/docker/pull/31364">＃31364</a></li><li>  成功的显示创建标签<code>docker build</code> <a href="https://github.com/docker/docker/pull/32077">＃32077</a></li><li>  清理撰写转换错误消息<a href="https://github.com/moby/moby/pull/32087">＃32087</a></li></ul><h4 id="日志相关-13"><a href="#日志相关-13" class="headerlink" title="日志相关"></a>日志相关</h4><ul><li>  添加对日志记录驱动程序插件的支持<a href="https://github.com/docker/docker/pull/28403">＃28403</a></li><li>  添加对显示单个任务日志的支持<code>docker service logs</code>，并添加<code>/task/&#123;id&#125;/logs</code>REST 端点<a href="https://github.com/docker/docker/pull/32015">＃32015</a></li><li>  <code>--log-opt env-regex</code>使用正则表达式添加选项以匹配环境变量<a href="https://github.com/docker/docker/pull/27565">＃27565</a></li></ul><h4 id="第三方库相关"><a href="#第三方库相关" class="headerlink" title="第三方库相关"></a>第三方库相关</h4><ul><li>  在 Ubuntu 17.04 Zesty amd64 是支持 docker 构建<a href="https://github.com/docker/docker/pull/32435">＃32435</a></li></ul><h4 id="守护进程相关"><a href="#守护进程相关" class="headerlink" title="守护进程相关"></a>守护进程相关</h4><ul><li>  修复如果<code>--api-enable-cors</code>未设置则忽略<code>--api-cors-header</code><a href="https://github.com/docker/docker/pull/32174">＃32174</a></li><li>  启动时清理 <a href="https://github.com/docker/docker/pull/31741">docker</a> tmp 目录 <a href="https://github.com/docker/docker/pull/31741">＃31741</a></li><li>  赞成使用<code>--graph</code>或<code>--data-root</code> <a href="https://github.com/docker/docker/pull/28696">＃28696</a></li></ul><h4 id="安全相关-2"><a href="#安全相关-2" class="headerlink" title="安全相关"></a>安全相关</h4><ul><li>  允许设置 SELinux 类型或 MCS 标签 是使用<code>--ipc=container:</code> 或者 <code>--ipc=host</code> <a href="https://github.com/docker/docker/pull/30652">#30652</a></li></ul><h4 id="弃用-6"><a href="#弃用-6" class="headerlink" title="弃用"></a>弃用</h4><ul><li>  弃用<code>--api-enable-cors</code>守护程序标志。该标志在 Docker 1.6.0 中被标记为不推荐使用，但未在不推荐使用的功能中列出<a href="https://github.com/docker/docker/pull/32352">＃32352</a></li><li>  删除 Ubuntu 12.04（Precise Pangolin）作为受支持的平台。Ubuntu 12.04 已停产，并且不再更新<a href="https://github.com/docker/docker/pull/32520">＃32520</a></li></ul><h3 id="版本号：17-04"><a href="#版本号：17-04" class="headerlink" title="版本号：17.04"></a>版本号：17.04</h3>  首次发布时间： 2017-04-05<h4 id="运行相关-15"><a href="#运行相关-15" class="headerlink" title="运行相关"></a>运行相关</h4><ul><li>  在不设置实时还原的情况下进行还原时，要处理已暂停的容器； <a href="https://github.com/docker/docker/pull/31704">＃31704</a></li><li>  不允许在 Dockerfile 中运行状况中检查选项中的秒数；<a href="https://github.com/docker/docker/pull/31177">#31177</a></li><li>  支持在 <code>secret update</code> 语句中命名和 id 前缀；<a href="https://github.com/docker/docker/pull/30856">#30856</a></li><li>  将二进制框架用于 websocket 附加终端；<a href="https://github.com/docker/docker/pull/30460">＃30460</a></li><li>  修复 Linux 挂载调用不允许传播类型更改的问题；<a href="https://github.com/docker/docker/pull/30416">＃30416</a></li><li>  修复<code>exec -i</code>中 ExecIds 泄漏失败的问题 ； <a href="https://github.com/docker/docker/pull/30340">＃30340</a></li><li>  当<code>danglingOnly=true</code>时，删除命名但未标记的镜像 ；<a href="https://github.com/docker/docker/pull/30330">#30330</a></li><li>  添加守护程序标志以将 no_new_priv 设置为非特权容器的默认值 ；<a href="https://github.com/docker/docker/pull/29984">＃29984</a></li><li>  添加守护程序选项<code>--default-shm-size</code> ； <a href="https://github.com/docker/docker/pull/29692">＃29692</a></li><li>  支持注册表镜像配置重新加载；<a href="https://github.com/docker/docker/pull/29650">＃29650</a></li><li>  构建镜像时忽略守护程序日志配置； <a href="https://github.com/docker/docker/pull/29552">＃29552</a></li><li>  将解析的机密名称或 ID 前缀从客户端移动到守护程序； <a href="https://github.com/docker/docker/pull/29218">＃29218</a></li><li>  允许将规则添加到<code>cgroup devices.allow</code>容器创建 / 运行；<a href="https://github.com/docker/docker/pull/22563">＃22563</a></li><li>  修复在允许<code>systemd daemon-reload</code>命令时，<code>cpu.cfs_quota_us</code>被重置的问题； <a href="https://github.com/docker/docker/pull/31736">＃31736</a></li></ul><h4 id="网络相关-14"><a href="#网络相关-14" class="headerlink" title="网络相关"></a>网络相关</h4><ul><li>  检查在<code>docker network connect</code> 中的<code>--ip</code>，<code>--ip6</code>和<code>--link-local-ip</code>参数；<a href="https://github.com/docker/docker/pull/30807">＃30807</a></li><li>  添加支持 <code>dns-search</code> ；<a href="https://github.com/docker/docker/pull/30117">#30117</a></li><li>  增加 - 详细选项 docker 网络检查，会所有群节点显示任务细节 ；<a href="https://github.com/docker/docker/pull/31710">#31710</a></li><li>  加入集群时清除旧的数据路径加密状态 ； <a href="https://github.com/docker/libnetwork/pull/1354">docker/libnetwork#1354</a></li><li>  确保 iptables 初始化只发生一次 ； <a href="https://github.com/docker/libnetwork/pull/1676">docker/libnetwork#1676</a></li><li>  修复 iptables 过滤规则的错误顺序； <a href="https://github.com/docker/libnetwork/pull/961">docker / libnetwork＃961</a></li><li>  在可附加网络上的服务记录中添加匿名容器别名 ； <a href="https://github.com/docker/libnetwork/pull/1651">docker/libnetwork#1651</a></li><li>  支持<code>com.docker.network.container_interface_prefix</code>驱动程序标签；<a href="https://github.com/docker/libnetwork/pull/1667">docker / libnetwork＃1667</a></li><li>  通过省略不使用的网络详细信息来提高网络列表的性能；<a href="https://github.com/docker/docker/pull/30673">＃30673</a></li></ul><h4 id="集群相关-14"><a href="#集群相关-14" class="headerlink" title="集群相关"></a>集群相关</h4><ul><li>  拓扑感知调度；<a href="https://github.com/docker/docker/pull/30725">＃30725</a></li><li>  故障时自动回滚服务；<a href="https://github.com/docker/docker/pull/31108">＃31108</a></li><li>  在同一节点上的辅助服务器和管理器通过 UNIX 套接字连接； <a href="https://github.com/docker/swarmkit/pull/1828">docker/swarmkit#1828</a>。<a href="https://github.com/docker/swarmkit/pull/1850">docker/swarmkit#1850</a>, <a href="https://github.com/docker/swarmkit/pull/1851">docker/swarmkit#1851</a></li><li>  改进运输包方案； <a href="https://github.com/docker/swarmkit/pull/1748">docker/swarmkit#1748</a></li><li>  降级 / 删除时没有自动关闭管理器的问题； <a href="https://github.com/docker/swarmkit/pull/1829">docker/swarmkit#1829</a></li><li>  使用 TransferLeadership 使主服务器降级更安全； <a href="https://github.com/docker/swarmkit/pull/1939">docker/swarmkit#1939</a></li><li>  减少默认监控周期； <a href="https://github.com/docker/swarmkit/pull/1967">docker/swarmkit#1967</a></li><li>  添加服务日志格式； <a href="https://github.com/docker/docker/pull/31672">＃31672</a></li><li>  修复服务日志 API，使其能够指定流； <a href="https://github.com/docker/docker/pull/31313">＃31313</a></li><li>  添加<code>--stop-signal</code>到<code>service create</code>和<code>service update</code>； <a href="https://github.com/docker/docker/pull/30754">＃30754</a></li><li>  添加<code>--read-only</code>到<code>service create</code>和<code>service update</code>； <a href="https://github.com/docker/docker/pull/30162">＃30162</a></li><li>  与注册表通信后更新上下文；<a href="https://github.com/docker/docker/pull/31586">＃31586</a></li><li>  （实验性）添加<code>--tail</code>和<code>--since</code>选项到<code>docker service logs</code>； <a href="https://github.com/docker/docker/pull/31500">#31500</a></li><li>  （实验性）添加<code>--no-task-ids</code>和<code>--no-trunc</code>选项到<code>docker service logs</code>； <a href="https://github.com/docker/docker/pull/31672">#31672</a></li></ul><h4 id="日志相关-14"><a href="#日志相关-14" class="headerlink" title="日志相关"></a>日志相关</h4><ul><li>  为容器日志实现可选的环形缓冲区； <a href="https://github.com/docker/docker/pull/28762">＃28762</a>。</li><li>  为 awslogs（CloudWatch）添加<code>--log-opt awslogs-create-group = &lt;true | false&gt;</code>，以根据需要支持创建日志组； <a href="https://github.com/docker/docker/pull/29504">#29504</a> 。</li><li>  将 gcplogs 日志记录驱动程序与 “静态” 二进制文件一起使用时，修复 segfault； <a href="https://github.com/docker/docker/pull/29478">＃29478</a>。</li></ul><h4 id="构造相关-13"><a href="#构造相关-13" class="headerlink" title="构造相关"></a>构造相关</h4><ul><li>  禁用构建容器的容器日志记录； <a href="https://github.com/docker/docker/pull/29552">＃29552。</a></li><li>  修复<code>**/</code>在<code>.dockerignore</code>的使用； <a href="https://github.com/docker/docker/pull/29043">＃29043</a>。</li></ul><h4 id="客户端相关-14"><a href="#客户端相关-14" class="headerlink" title="客户端相关"></a>客户端相关</h4><ul><li>  <code>docker stack ls</code>按照名称排序；<a href="https://github.com/docker/docker/pull/31085">＃31085</a>。</li><li>  用于指定绑定安装一致性的标志； <a href="https://github.com/docker/docker/pull/31047">＃31047</a>。</li><li>  docker CLI 的输出——帮助现在包装到终端宽度 ；<a href="https://github.com/docker/docker/pull/28751">＃28751</a>。</li><li>  废除 docker ps 中的镜像摘要；<a href="https://github.com/docker/docker/pull/30848">＃30848</a>。</li><li>  隐藏与 Windows 相关的命令选项； <a href="https://github.com/docker/docker/pull/30788">#30788</a> 。</li><li>  修正<code>docker plugin install</code>提示接受默认值为 “N” 的“ enter”； <a href="https://github.com/docker/docker/pull/30769">＃30769。</a></li><li>  添加<code>truncate</code>功能到 Go 模板；<a href="https://github.com/docker/docker/pull/30484">＃30484</a>。</li><li>  支持在<code>stack deploy</code>中的端口扩展语法； <a href="https://github.com/docker/docker/pull/30476">#30476</a> 。</li><li>  支持在<code>stack deploy</code>中的挂载扩展语法； <a href="https://github.com/docker/docker/pull/30597">#30597</a> <a href="https://github.com/docker/docker/pull/31795">#31795</a> 。</li><li>  在 dockers build 中提供<code>--add-host</code>语句； <a href="https://github.com/docker/docker/pull/30383">#30383</a> 。</li><li>  在<code>docker network ls --format</code>添加<code>docker network ls --format</code>占位符； <a href="https://github.com/docker/docker/pull/29900">#29900</a> 。</li><li>  更新<code>--secret-rm</code>和<code>--secret-add</code>的顺序； <a href="https://github.com/docker/docker/pull/29802">#29802</a> 。</li><li>  添加<code>--filter enabled=true</code>到<code>docker plugin ls</code>中； <a href="https://github.com/docker/docker/pull/28627">＃28627。</a></li><li>  添加<code>--format</code>到<code>docker service ls</code>； <a href="https://github.com/docker/docker/pull/28199">＃28199</a>。</li><li>  添加<code>publish</code>和<code>expose</code>过滤器到<code>docker ps --filter</code>； <a href="https://github.com/docker/docker/pull/27557">＃27557</a>。</li><li>  支持多个服务 ID <code>docker service ps</code> ； <a href="https://github.com/docker/docker/pull/25234">#25234</a> 。</li><li>  允许以<code>--availability=drain</code>加入集群； <a href="https://github.com/docker/docker/pull/24993">＃24993。</a></li><li>  启用 AppArmor 并且未定义其他配置文件时，Docker 检查现在显示 “docker-default”； <a href="https://github.com/docker/docker/pull/27083">＃27083</a>。</li></ul><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4>  <strong>Windows 相关</strong><ul><li>  阻止在非 Windows 守护程序上拉取 Windows 镜像； <a href="https://github.com/docker/docker/pull/29001">＃29001</a></li></ul><h3 id="版本号：17-03"><a href="#版本号：17-03" class="headerlink" title="版本号：17.03"></a>版本号：17.03</h3>  首次发布时间： 2017-05-29<h4 id="运行相关-16"><a href="#运行相关-16" class="headerlink" title="运行相关"></a>运行相关</h4><ul><li>将 go-connections 更新为 d217f8e 版本； <a href="https://github.com/docker/engine/pull/28">＃28</a></li><li>重新标记安全路径以避免在启用 selinux 的系统上被拒绝； <a href="https://github.com/moby/moby/pull/33236">＃33236</a>（ref <a href="https://github.com/moby/moby/pull/32529">＃32529</a></li><li>修复了一些需要的本地卷无法被重新标记的情况； <a href="https://github.com/moby/moby/pull/33236">＃33236</a>（ref <a href="https://github.com/moby/moby/pull/29428">＃29428</a>）</li><li>修复在升级插件 rootfs 时仍然挂载的问题 ；<a href="https://github.com/moby/moby/pull/33236">＃33236</a>（ref <a href="https://github.com/moby/moby/pull/32525">＃32525</a>）</li><li>修复卷不会默认为 rprivate 传播模式的问题 ； <a href="https://github.com/moby/moby/pull/33236">#33236</a> (ref <a href="https://github.com/moby/moby/pull/32851">#32851</a>)</li><li>修复无法检索卷驱动程序时可能出现的紧急情况； <a href="https://github.com/moby/moby/pull/33236">＃33236</a>（ref <a href="https://github.com/moby/moby/pull/32347">＃32347</a>）</li><li>在<code>docker info</code>中添加了警告，用于警示在不支持<code>d_type</code>的文件系统上使用<code>overlay</code>或者<code>overlay 2</code>驱动； <a href="https://github.com/moby/moby/pull/33236">#33236</a> (ref <a href="https://github.com/moby/moby/pull/31290">#31290</a>)</li><li>修复将挂载规范反向移植到旧卷的问题 ； <a href="https://github.com/moby/moby/pull/33207">＃33207</a></li><li>修复取消挂载失败后可能导致本地卷丢失数据的问题； <a href="https://github.com/moby/moby/pull/33120">＃33120</a></li><li>将 Runc 更新为 54296cf40ad8143b62dbcaa1d90e520a2136ddfe 版本； <a href="https://github.com/docker/docker/pull/31666">＃31666</a></li><li>忽略 cgroup2 挂载点； <a href="https://github.com/opencontainers/runc/pull/1266">opencontainers / runc＃1266</a></li><li>将容器更新为 4ab9917febca54791c5f071a9d1f404867857fcc 版本； <a href="https://github.com/docker/docker/pull/31662">＃31662</a> <a href="https://github.com/docker/docker/pull/31852">＃31852</a></li><li>在调用 restore() 之前注册 healtcheck 服务 ； <a href="https://github.com/docker/containerd/pull/609">docker/containerd#609</a></li><li>修复<code>docker exec</code>在自动升级后无法工作，重新加载设备配置文件的问题 ；<a href="https://github.com/docker/docker/pull/31773">＃31773</a></li><li>修复不使用 Overlay2 合并目录的卸载层；<a href="https://github.com/docker/docker/pull/31069">＃31069</a></li><li>在强制删除时不忽略 “volume in use” 错误 ；<a href="https://github.com/docker/docker/pull/31450">＃31450</a></li><li>修复 Docker 日志中的死锁； <a href="https://github.com/docker/docker/pull/30223">＃30223</a></li><li>修复 CPU 空闲等待日志写入的问题；<a href="https://github.com/docker/docker/pull/31070">＃31070</a></li><li>修复使用日志记录可能导致崩溃的问题； <a href="https://github.com/docker/docker/pull/31231">#31231</a> <a href="https://github.com/docker/docker/pull/31263">#31263</a></li><li>修复关闭未持有内存通道的紧急情况； ：<a href="https://github.com/docker/docker/pull/31274">＃31274</a></li><li>修复在<code>docker run</code>中使用<code>--volumes-from</code>重复挂载的情况； <a href="https://github.com/docker/docker/pull/29563">＃29563</a></li><li>  修复<code>--cache-from</code>不能缓存最后一步的情况； Github 节点说明：<a href="https://github.com/docker/docker/pull/31189">＃31189</a></li></ul><h4 id="网络相关-15"><a href="#网络相关-15" class="headerlink" title="网络相关"></a>网络相关</h4><ul><li>修复阻止网络创建的并发问题；<a href="https://github.com/moby/moby/pull/33273">＃33273</a></li><li>修正交叉数据中心群中叠加加密密钥旋转的错误 ；<a href="https://github.com/docker/docker/pull/30727">＃30727</a></li><li>修正主服务器频繁更换引起的叠加加密和网络控制平面通信失败的错误（“已安装的密钥中没有可以解密消息”）；<a href="https://github.com/docker/docker/pull/25608">＃25608</a></li><li>对使用覆盖网络和外部 kv-store 时，对系统响应性和数据路径编程进行了处理； Github 节点说明： <a href="https://github.com/docker/libnetwork/pull/1639">docker/libnetwork#1639</a>, <a href="https://github.com/docker/libnetwork/pull/1632">docker/libnetwork#1632</a> ……</li><li>丢弃进入加密覆盖网络的普通 vxlan 数据包 ；＃31170](<a href="https://github.com/docker/docker/pull/31170">https://github.com/docker/docker/pull/31170</a>)</li><li>在分配失败时释放网络附件 ；<a href="https://github.com/docker/docker/pull/31073">＃31073</a></li><li>  修正了多个已发布端口映射到相同目标端口时的端口分配问题 ; <a href="https://github.com/docker/swarmkit/pull/1835">docker/swarmkit#1835</a></li></ul><h4 id="集群相关-15"><a href="#集群相关-15" class="headerlink" title="集群相关"></a>集群相关</h4><ul><li>  修复任务可能会被意外关闭的情况；<a href="https://github.com/moby/moby/pull/33118">＃33118</a></li><li>  修复了尽管无法访问注册中心，但本地存在所需镜像却无法部署的情况；<a href="https://github.com/moby/moby/pull/33117">＃33117</a></li><li>  将 swarmkit 更新到 17756457ad6dc4d8a639a1f0b7a85d1b65a617bb 版本；<a href="https://github.com/docker/docker/pull/31807">＃31807</a></li><li>  调度器现在可以合理处理任务被分配给节点但未正常运行的情况；<a href="https://github.com/docker/swarmkit/pull/1980">docker/swarmkit#1980</a></li><li>  允许删除只被无效任务访问的网络； <a href="https://github.com/docker/swarmkit/pull/2018">docker/swarmkit#2018</a></li><li>  降低无法访问网络的分配频率； <a href="https://github.com/docker/swarmkit/pull/2021">docker/swarmkit#2021</a></li><li>  避免对不再运行的任务进行网络分配 ； <a href="https://github.com/docker/swarmkit/pull/2017">docker/swarmkit#2017</a></li><li>  统计内部网络分配器的分配情况 ；<a href="https://github.com/docker/swarmkit/pull/2019">docker/swarmkit#2019</a> <a href="https://github.com/docker/swarmkit/pull/2020">docker/swarmkit#2020</a></li><li>  关闭未曾启动容器引发的错误；<a href="https://github.com/docker/docker/pull/31279">＃31279</a></li><li>  修复主要主机在因故障问题进行切换时，任务状态变为 “NEW” 的情况；<a href="https://github.com/docker/swarmkit/pull/1938">docker/swarmkit＃1938</a></li><li>  修复在<code>docker service ls</code>中未全局服务创建的冗余任务而引发副本计数混乱的问题；<a href="https://github.com/docker/swarmkit/pull/1957">docker/swarmkit#1957</a></li><li>  修复在<code>task-history-limit</code>设置为 1 时使滚动更新变慢的问题;<a href="https://github.com/docker/swarmkit/pull/1948">docker/swarmkit＃1948</a>。</li><li>  当由于节点不再满足约束条件而被关闭时，在适当的地方重新启动任务；<a href="https://github.com/docker/swarmkit/pull/1958">docker/swarmkit＃1958</a>。</li><li>  （测试版本）</li></ul><h4 id="远程-API-和客户端相关"><a href="#远程-API-和客户端相关" class="headerlink" title="远程 API 和客户端相关"></a>远程 API 和客户端相关</h4><ul><li>  修复自动删除旧的 API；<a href="https://github.com/docker/docker/pull/31692">＃31692</a></li><li>  修复堆栈的默认网络自定义；<a href="https://github.com/docker/docker/pull/31258/">＃31258</a></li><li>  存在脱机 CPU 和较新的 Linux 的情况下，更正 CPU 使用率计算；<a href="https://github.com/docker/docker/pull/31802">＃31802</a></li><li>  修复远程 API 中服务健康检查为 {} 的问题 ；<a href="https://github.com/docker/docker/pull/30197">＃30197</a></li><li>  解决<code>docker stats --format</code>问题 ；<a href="https://github.com/docker/docker/pull/30776">＃30776</a></li></ul><h4 id="第三方库相关-1"><a href="#第三方库相关-1" class="headerlink" title="第三方库相关"></a>第三方库相关</h4><ul><li>  更新<code>bash</code>和<code>zsh</code>脚本；＃30823](<a href="https://github.com/docker/docker/pull/30823)%EF%BC%8C[%EF%BC%8330945](https://github.com/docker/docker/pull/30945)%E2%80%A6%E2%80%A6">https://github.com/docker/docker/pull/30823)，[＃30945](https://github.com/docker/docker/pull/30945)……</a></li><li>  在默认的 seccomp 配置文件中阻止过时的套接字系列 - 缓解未修补内核的 CVE-2017-6074；＃29076](<a href="https://github.com/docker/docker/pull/29076">https://github.com/docker/docker/pull/29076</a>)</li></ul><h4 id="其它-1"><a href="#其它-1" class="headerlink" title="其它"></a>其它</h4>  <strong>Windows 相关</strong><ul><li>  还原时清理 HCS；<a href="https://github.com/docker/docker/pull/31503">#31503</a></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 毕设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 毕设 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Cockpit 管理你的树莓派</title>
      <link href="/posts/29824.html"/>
      <url>/posts/29824.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址 <a href="https://linux.cn/article-13487-1.html">linux.cn</a></p></blockquote><h2 id="在树莓派-OS-上安装-Cockpit"><a href="#在树莓派-OS-上安装-Cockpit" class="headerlink" title="在树莓派 OS 上安装 Cockpit"></a>在树莓派 OS 上安装 Cockpit</h2><p>在树莓派 OS 上安装 Cockpit Web 控制台：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install cockpit</span></span><br></pre></td></tr></table></figure><p>Cockpit 只需要 60.4 KB 的磁盘空间。加上它的几个包依赖项，总使用量是 115MB。</p><p>安装过程将负责设置和启动服务。你可以使用 <code>systemctl</code> 命令来验证状态：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> systemctl status cockpit.socket</span></span><br><span class="line">● cockpit.socket - Cockpit Web Service Socket</span><br><span class="line">   Loaded: loaded (/lib/systemd/system/cockpit.socket; enabled; vendor preset: enabled)</span><br><span class="line">   Active: active (listening) since Tue 2021-05-04 10:24:43 EDT; 35s ago</span><br><span class="line">     Docs: man:cockpit-ws(8)</span><br><span class="line">   Listen: 0.0.0.0:9090 (Stream)</span><br><span class="line">  Process: 6563 ExecStartPost=/usr/share/cockpit/motd/update-motd  localhost (code=exited, status=0/SUCCESS)</span><br><span class="line">  Process: 6570 ExecStartPost=/bin/ln -snf active.motd /run/cockpit/motd (code=exited, status=0/SUCCESS)</span><br><span class="line">    Tasks: 0 (limit: 2181)</span><br><span class="line">   CGroup: /system.slice/cockpit.socket</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="使用-Cockpit"><a href="#使用-Cockpit" class="headerlink" title="使用 Cockpit"></a>使用 Cockpit</h3><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>默认的监听端口号是 9090。打开浏览器并输入地址，例如： <code>http://IP:9090</code>。</p><p><img src="https://images.961110.xyz/images/2021/10/23/cockpit.png"></p><p><em>Cockpit home page</em></p><p>使用树莓派的账户登录，但是需要有使用 <code>sudo</code> 的权限。<strong>一定要勾选 “为特权任务重用我的密码”。</strong></p><h4 id="管理你的树莓派"><a href="#管理你的树莓派" class="headerlink" title="管理你的树莓派"></a>管理你的树莓派</h4><p>Cockpit 的初始屏幕以 “System” 页开始，提供当前 CPU 和内存使用的详细信息和图表。</p><img src="https://images.961110.xyz/images/2021/10/23/cockpit940fb5d3fdcf1fa9.png" style="zoom:50%;" /><p><em>Initial Cockpit screen</em></p><p>可以从这个屏幕看到硬件细节。</p><p><img src="https://images.961110.xyz/images/2021/10/23/cockpitc1d145ff9daceb13.png"></p><p><em>Cockpit hardware details</em></p><p>通过点击每一项来展开左边的列（例如，日志、存储、服务等）。这些是标准的 Cockpit 部分，不言自明。让我快速描述一下每个部分。</p><ol><li><p>日志</p><p>这部分展示了日志。它们可以根据日期和严重程度来过滤。</p></li><li><p>存储</p><p>存储部分展示了已经安装的物理驱动器和 RAID 设备。例如大小、序列号等细节都被展示了出来。还展示了读 / 写活动和实际空间使用的图表。存储的具体日志显示在底部。</p></li><li><p>网络</p><p>这部分展示了发送和接收活动、IP 地址以及网络特定的日志。你还可以使用相应的按钮添加更多的网络设备，如绑定、网桥和 VLAN。</p></li><li><p>账户</p><p>这里展示了已有的账户。点击每个账户来管理，或使用创建新账户按钮来添加用户。账户也可以被删除。</p></li><li><p>服务</p><p>这部分可以让管理员查看系统所有服务的状态。点击任何服务都会转到一个包含启动、重启和禁用的标准任务的屏幕。</p></li><li><p>应用程序</p><p>通常，这个屏幕提供了各种用于管理功能的应用程序，例如 389 目录服务器或创建 Podman 容器。但在我的树莓派 OS 上，这个屏幕只显示 “没有安装或可用的应用程序”。在写这篇文章的时候，这个或许还没有实现。虽然，你可能会怀疑这类型的程序对于树莓派硬件来说是否太过沉重。</p></li><li><p>软件更新</p><p>对任何系统管理员来说，保持软件最新是最重要的任务之一。Cockpit 的软件更新部分可以检查并进行更新。</p></li></ol><p><img src="https://images.961110.xyz/images/2021/10/23/cockpit10383030be25b5ea.png"></p><p><em>Software updates in Cockpit</em></p><h4 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h4><p>Cockpit 最方便的特点之一是终端。你可以使用它，而不是打开一个单独的终端模拟器并使用 SSH。我使用终端来安装 <a href="https://opensource.com/article/20/1/screenfetch-neofetch">ScreenFetch</a>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install screenfetch</span></span><br></pre></td></tr></table></figure><p>使用 ScreenFetch 生成了这张截图：</p><p><img src="https://images.961110.xyz/images/2021/10/23/cockpit-shell.png"></p><p><em>Terminal in Cockpit</em></p><h3 id="使用-Cockpit-的中心控制"><a href="#使用-Cockpit-的中心控制" class="headerlink" title="使用 Cockpit 的中心控制"></a>使用 Cockpit 的中心控制</h3><p>Cockpit 在树莓派上的表现就像它在其他 Linux 系统上一样。你可以将它添加到仪表盘上进行集中控制。它允许企业在 Cockpit 作为管理仪表盘解决方案的任何地方，将基于树莓派的服务和系统整合到他们的整体 Linux 基础设施中。因为树莓派经常在高密度机架数据中心以无外接控制 headless 方式运行，而这些数据中心通常会缺乏 KVM 访问方式，这是非常方便的。</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> 教程 </tag>
            
            <tag> 配置 </tag>
            
            <tag> 监控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何搭建 GTA 5 私服 - FiveM 的搭建</title>
      <link href="/posts/17578.html"/>
      <url>/posts/17578.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址 <a href="https://leif.fun/articles/2019/11/14/1573715853549.html">leif.fun</a></p></blockquote><p>打开官网（<a href="https://fivem.net.cn/">中</a> <a href="https://fivem.net/">英</a>文皆可），点击 _下载服务端 (非商业)_，如图所示<br><img src="https://img.hacpai.com/file/2019/11/image-29f540e4.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"></p><p>网页跳转到官方说明文档<br><img src="https://img.hacpai.com/file/2019/11/image-2949be7b.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"></p><p>该说明文档提供了安装在 Windows 和 Linux 上的方法，下面逐一介绍。</p><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件:"></a>前提条件:</h3><p>1.<a href="https://aka.ms/vs/16/release/VC_redist.x64.exe">Visual C++ Redistributable 2019</a></p><p>2.<a href="https://git-scm.com/download/win">Git</a></p><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><ol><li><p>创建新文件夹为<code>D:\FxServer</code><br><img src="https://img.hacpai.com/file/2019/11/image-863a8272.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"></p></li><li><p>下载最新 Windows 端服务器文件：<a href="https://runtime.fivem.net/artifacts/fivem/build_server_windows/master/">artifacts server</a></p></li></ol><p><img src="https://img.hacpai.com/file/2019/11/image-579d6bad.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"></p><ol start="3"><li><p>解压下载的服务器文件到<code>FxServer</code>文件夹中<br><img src="https://img.hacpai.com/file/2019/11/image-5d5a8984.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"></p></li><li><p>克隆 <a href="https://github.com/citizenfx/cfx-server-data">cfx-server-data</a> 到<code>D:\FxServer</code>中，并重名名为<code>server-data</code>，且与服务器文件夹<code>server</code>同级. 命令：<code>git clone https://github.com/citizenfx/cfx-server-data.git server-data</code><br><img src="https://img.hacpai.com/file/2019/11/image-1a91e8d5.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"></p></li></ol><p><img src="https://img.hacpai.com/file/2019/11/image-5f964c0d.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"></p><ol start="5"><li>在<code>server-data</code>文件夹下创建<code>server.cfg</code>配置文件，文件内容来自 <a href="https://docs.fivem.net/server-manual/setting-up-a-server/#servercfgexample">example server.cfg</a>, 内容如下：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Only change the IP if you&#x27;re using a server with multiple network interfaces, otherwise change the port only.</span><br><span class="line">endpoint_add_tcp &quot;0.0.0.0:30120&quot;</span><br><span class="line">endpoint_add_udp &quot;0.0.0.0:30120&quot;</span><br><span class="line"></span><br><span class="line"># These resources will start by default.</span><br><span class="line">ensure mapmanager</span><br><span class="line">ensure chat</span><br><span class="line">ensure spawnmanager</span><br><span class="line">ensure sessionmanager</span><br><span class="line">ensure fivem</span><br><span class="line">ensure hardcap</span><br><span class="line">ensure rconlog</span><br><span class="line">ensure scoreboard</span><br><span class="line"></span><br><span class="line"># This allows players to use scripthook-based plugins such as the legacy Lambda Menu.</span><br><span class="line"># Set this to 1 to allow scripthook. Do note that this does _not_ guarantee players won&#x27;t be able to use external plugins.</span><br><span class="line">sv_scriptHookAllowed 0</span><br><span class="line"></span><br><span class="line"># Uncomment this and set a password to enable RCON. Make sure to change the password - it should look like rcon_password &quot;YOURPASSWORD&quot;</span><br><span class="line">#rcon_password &quot;&quot;</span><br><span class="line"></span><br><span class="line"># A comma-separated list of tags for your server.</span><br><span class="line"># For example:</span><br><span class="line"># - sets tags &quot;drifting, cars, racing&quot;</span><br><span class="line"># Or:</span><br><span class="line"># - sets tags &quot;roleplay, military, tanks&quot;</span><br><span class="line">sets tags &quot;default&quot;</span><br><span class="line"></span><br><span class="line"># A valid locale identifier for your server&#x27;s primary language.</span><br><span class="line"># For example &quot;en-US&quot;, &quot;fr-CA&quot;, &quot;nl-NL&quot;, &quot;de-DE&quot;, &quot;en-GB&quot;, &quot;pt-BR&quot;</span><br><span class="line">sets locale &quot;root-AQ&quot; </span><br><span class="line"># please DO replace root-AQ on the line ABOVE with a real language! :)</span><br><span class="line"></span><br><span class="line"># Set an optional server info and connecting banner image url.</span><br><span class="line"># Size doesn&#x27;t matter, any banner sized image will be fine.</span><br><span class="line">#sets banner_detail &quot;https://url.to/image.png&quot;</span><br><span class="line">#sets banner_connecting &quot;https://url.to/image.png&quot;</span><br><span class="line"></span><br><span class="line"># Set your server&#x27;s hostname</span><br><span class="line">sv_hostname &quot;FXServer, but unconfigured&quot;</span><br><span class="line"></span><br><span class="line"># Nested configs!</span><br><span class="line">#exec server_internal.cfg</span><br><span class="line"></span><br><span class="line"># Loading a server icon (96x96 PNG file)</span><br><span class="line">#load_server_icon myLogo.png</span><br><span class="line"></span><br><span class="line"># convars which can be used in scripts</span><br><span class="line">set temp_convar &quot;hey world!&quot;</span><br><span class="line"></span><br><span class="line"># Uncomment this line if you do not want your server to be listed in the server browser.</span><br><span class="line"># Do not edit it if you *do* want your server listed.</span><br><span class="line">#sv_master1 &quot;&quot;</span><br><span class="line"></span><br><span class="line"># Add system admins</span><br><span class="line">add_ace group.admin command allow # allow all commands</span><br><span class="line">add_ace group.admin command.quit deny # but don&#x27;t allow quit</span><br><span class="line">add_principal identifier.fivem:1 group.admin # add the admin to the group</span><br><span class="line"></span><br><span class="line"># Hide player endpoints in external log output.</span><br><span class="line">sv_endpointprivacy true</span><br><span class="line"></span><br><span class="line"># Server player slot limit (must be between 1 and 32, unless using OneSync)</span><br><span class="line">sv_maxclients 32</span><br><span class="line"></span><br><span class="line"># Steam Web API key, if you want to use Steam authentication (https://steamcommunity.com/dev/apikey)</span><br><span class="line"># -&gt; replace &quot;&quot; with the key</span><br><span class="line">set steam_webApiKey &quot;&quot;</span><br><span class="line"></span><br><span class="line"># License key for your server (https://keymaster.fivem.net)</span><br><span class="line">sv_licenseKey changeme</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>中文解释：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 一般情况下不用修改!</span><br><span class="line"># 只有使用多个服务器协议的时候才需要更改。默认的TCP和UDP端口为30120</span><br><span class="line">endpoint_add_tcp &quot;0.0.0.0:30120&quot;</span><br><span class="line">endpoint_add_udp &quot;0.0.0.0:30120&quot;</span><br><span class="line"></span><br><span class="line"># 默认启动资源。</span><br><span class="line">start mapmanager</span><br><span class="line">start chat</span><br><span class="line">start spawnmanager</span><br><span class="line">start sessionmanager</span><br><span class="line">start fivem</span><br><span class="line">start hardcap</span><br><span class="line">start rconlog</span><br><span class="line">start scoreboard</span><br><span class="line">start playernames</span><br><span class="line"></span><br><span class="line"># 允许玩家使用scripthook挂载的修改器，例如lambda菜单。</span><br><span class="line"># 设置为0可以禁用。</span><br><span class="line">sv_scriptHookAllowed 1</span><br><span class="line"></span><br><span class="line"># 取消前面的#可以启动RCON，记住你更改的密码。</span><br><span class="line">#rcon_password changeme#一般用不到</span><br><span class="line"></span><br><span class="line"># 服务器标签，中间用逗号隔开</span><br><span class="line"># 例如：</span><br><span class="line"># - sets tags &quot;drifting, cars, racing&quot;</span><br><span class="line"># 或者：</span><br><span class="line"># - sets tags &quot;roleplay, military, tanks&quot;</span><br><span class="line">sets tags &quot;default&quot;</span><br><span class="line"></span><br><span class="line"># 设置服务器横幅或者链接横幅的URL</span><br><span class="line"># 大小没有限制，任何图像都可以.</span><br><span class="line">#sets banner_detail &quot;http://url.to/image.png&quot;</span><br><span class="line">#sets banner_connecting &quot;http://url.to/image.png&quot;</span><br><span class="line"></span><br><span class="line"># 设置服务器名称</span><br><span class="line">sv_hostname &quot;My new FXServer!&quot;</span><br><span class="line"></span><br><span class="line"># 嵌套配置！一般不改。</span><br><span class="line">#exec server_internal.cfg</span><br><span class="line"></span><br><span class="line"># 服务器LOGO图标 (96x96 PNG文件)</span><br><span class="line">#load_server_icon myLogo.png</span><br><span class="line"></span><br><span class="line"># 可以在脚本中使用的封面。</span><br><span class="line">set temp_convar &quot;hey world!&quot;</span><br><span class="line"></span><br><span class="line"># #如果你不想服务器显示在FiveM网页服务器列表，可以把#号删掉。</span><br><span class="line">#sv_master1 &quot;&quot;</span><br><span class="line"></span><br><span class="line"># 只能让Steam或者第三方运营商进入你的FiveM服务器?</span><br><span class="line"># 不要忘记Social Club也是第三方提供商!</span><br><span class="line"># 一般不改</span><br><span class="line">#sv_authMaxVariance 1</span><br><span class="line">#sv_authMinTrust 5</span><br><span class="line"></span><br><span class="line"># 添加系统管理员。</span><br><span class="line">add_ace group.admin command allow # allow all commands</span><br><span class="line">add_ace group.admin command.quit deny # but don&#x27;t allow quit</span><br><span class="line">add_principal identifier.steam:1 group.admin # add the admin to the group</span><br><span class="line"></span><br><span class="line"># 在外部输出日志上不显示玩家的信息。</span><br><span class="line">sv_endpointprivacy true</span><br><span class="line"></span><br><span class="line"># 服务器人数设置 (必须在 1 到 32)</span><br><span class="line">sv_maxclients 32</span><br><span class="line"></span><br><span class="line"># 服务器密钥 (https://keymaster.fivem.net)</span><br><span class="line">sv_licenseKey changeme</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>需要修改的几项有：<br>_sv_hostname_：服务器名称，随便写<br>_load_server_icon_：服务器列表显示的图标，去掉 #表示开启，自定义图片必须是 96x96 分辨率的 png 图片而且放在<code>server-data</code>目录中与配置文件同级目录<br><em>add_principal identifier.steam</em>: 根据注册的账号 ID 添加管理员</p></blockquote><ol start="6"><li><p>去 <a href="https://forum.fivem.net/">FiveM 论坛</a>注册账户</p></li><li><p>再去获取<a href="https://keymaster.fivem.net/">服务器密钥</a>（序列号申请次数无上限）<br><img src="https://img.hacpai.com/file/2019/11/image-4d7563f5.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"></p></li></ol><p><img src="https://img.hacpai.com/file/2019/11/image-f00d3b0f.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"></p><ol start="8"><li><p>申请序列号之后将<code>server.cfg</code>配置文件最后一项的<code>changeme</code>部分替换成上一步申请的序列号即可<br><img src="https://img.hacpai.com/file/2019/11/image-f0df0149.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"></p></li><li><p>打开终端，输入下面两句命令即可启动 FiveM 服务器：</p></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd  /d D:\FXServer\server-data</span><br><span class="line">D:\FXServer\server\run.cmd +exec server.cfg</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img.hacpai.com/file/2019/11/image-92cad1ac.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"></p><blockquote><p>注意：若觉得每次启动服务器麻烦，可以新建一个 bat 文件，将上述两句命令粘贴进去，每次启动服务器的时候双击 bat 文件即可</p></blockquote><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>由于 Linux 搭建方法与 Windows 大同小异，故整理了一个自动化部署脚本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#下载服务器文件</span><br><span class="line">wget https://runtime.fivem.net/artifacts/fivem/build_proot_linux/master/1688-c814f804e64c28952269bc5abbac92d7c956f844/fx.tar.xz</span><br><span class="line"></span><br><span class="line">#下载资源文件</span><br><span class="line">git clone https://github.com/citizenfx/cfx-server-data.git server-data</span><br><span class="line"></span><br><span class="line">#创建文件夹</span><br><span class="line">mkdir -p /usr/local/src/FiveM/server</span><br><span class="line"></span><br><span class="line">#解压服务器文件到指定文件夹</span><br><span class="line">tar -xf fx.tar.xz -C /usr/local/src/FiveM/server</span><br><span class="line"></span><br><span class="line">#复制资源文件到指定文件夹</span><br><span class="line">cp -r server-data /usr/local/src/FiveM/</span><br><span class="line"></span><br><span class="line">#创建配置文件</span><br><span class="line">cat &lt;&lt;EOF &gt;/usr/local/src/FiveM/server-data/server.cfg</span><br><span class="line"># Only change the IP if you&#x27;re using a server with multiple network interfaces, otherwise change the port only.</span><br><span class="line">endpoint_add_tcp &quot;0.0.0.0:30120&quot;</span><br><span class="line">endpoint_add_udp &quot;0.0.0.0:30120&quot;</span><br><span class="line"></span><br><span class="line"># These resources will start by default.</span><br><span class="line">ensure mapmanager</span><br><span class="line">ensure chat</span><br><span class="line">ensure spawnmanager</span><br><span class="line">ensure sessionmanager</span><br><span class="line">ensure fivem</span><br><span class="line">ensure hardcap</span><br><span class="line">ensure rconlog</span><br><span class="line">ensure scoreboard</span><br><span class="line"></span><br><span class="line"># This allows players to use scripthook-based plugins such as the legacy Lambda Menu.</span><br><span class="line"># Set this to 1 to allow scripthook. Do note that this does _not_ guarantee players won&#x27;t be able to use external plugins.</span><br><span class="line">sv_scriptHookAllowed 0</span><br><span class="line"></span><br><span class="line"># Uncomment this and set a password to enable RCON. Make sure to change the password - it should look like rcon_password &quot;YOURPASSWORD&quot;</span><br><span class="line">#rcon_password &quot;&quot;</span><br><span class="line"></span><br><span class="line"># A comma-separated list of tags for your server.</span><br><span class="line"># For example:</span><br><span class="line"># - sets tags &quot;drifting, cars, racing&quot;</span><br><span class="line"># Or:</span><br><span class="line"># - sets tags &quot;roleplay, military, tanks&quot;</span><br><span class="line">sets tags &quot;default&quot;</span><br><span class="line"></span><br><span class="line"># A valid locale identifier for your server&#x27;s primary language.</span><br><span class="line"># For example &quot;en-US&quot;, &quot;fr-CA&quot;, &quot;nl-NL&quot;, &quot;de-DE&quot;, &quot;en-GB&quot;, &quot;pt-BR&quot;</span><br><span class="line">sets locale &quot;root-AQ&quot; </span><br><span class="line"># please DO replace root-AQ on the line ABOVE with a real language! :)</span><br><span class="line"></span><br><span class="line"># Set an optional server info and connecting banner image url.</span><br><span class="line"># Size doesn&#x27;t matter, any banner sized image will be fine.</span><br><span class="line">#sets banner_detail &quot;https://url.to/image.png&quot;</span><br><span class="line">#sets banner_connecting &quot;https://url.to/image.png&quot;</span><br><span class="line"></span><br><span class="line"># Set your server&#x27;s hostname</span><br><span class="line">sv_hostname &quot;FXServer, but unconfigured&quot;</span><br><span class="line"></span><br><span class="line"># Nested configs!</span><br><span class="line">#exec server_internal.cfg</span><br><span class="line"></span><br><span class="line"># Loading a server icon (96x96 PNG file)</span><br><span class="line">#load_server_icon myLogo.png</span><br><span class="line"></span><br><span class="line"># convars which can be used in scripts</span><br><span class="line">set temp_convar &quot;hey world!&quot;</span><br><span class="line"></span><br><span class="line"># Uncomment this line if you do not want your server to be listed in the server browser.</span><br><span class="line"># Do not edit it if you *do* want your server listed.</span><br><span class="line">#sv_master1 &quot;&quot;</span><br><span class="line"></span><br><span class="line"># Add system admins</span><br><span class="line">add_ace group.admin command allow # allow all commands</span><br><span class="line">add_ace group.admin command.quit deny # but don&#x27;t allow quit</span><br><span class="line">add_principal identifier.fivem:1 group.admin # add the admin to the group</span><br><span class="line"></span><br><span class="line"># Hide player endpoints in external log output.</span><br><span class="line">sv_endpointprivacy true</span><br><span class="line"></span><br><span class="line"># Server player slot limit (must be between 1 and 32, unless using OneSync)</span><br><span class="line">sv_maxclients 32</span><br><span class="line"></span><br><span class="line"># Steam Web API key, if you want to use Steam authentication (https://steamcommunity.com/dev/apikey)</span><br><span class="line"># -&gt; replace &quot;&quot; with the key</span><br><span class="line">set steam_webApiKey &quot;&quot;</span><br><span class="line"></span><br><span class="line"># License key for your server (https://keymaster.fivem.net)</span><br><span class="line">sv_licenseKey changeme</span><br><span class="line"></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将脚本中的<code>changeme</code>替换成服务器密钥即可部署</p><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>使用如下命令启动：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local/src/FiveM/server-data </span><br><span class="line">/usr/local/src/FiveM/server/run.sh +exec server.cfg</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>切记，不可用<code>/usr/local/src/FiveM/server/run.sh +exec /usr/local/src/FiveM/server-data/server.cfg</code>命令启动，会失败，具体原因未知</p></blockquote><h3 id="开机自启"><a href="#开机自启" class="headerlink" title="开机自启"></a>开机自启</h3><p>为了做到开机自启，我采用了 Supervisor 的方式 (使用 systemctl 方式会无限重启，原因未知)：<br>先创建一个启动服务的脚本<code>/usr/local/src/FiveM/start.sh</code>:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local/src/FiveM/server-data &amp;&amp; /usr/local/src/FiveM/server/run.sh +exec server.cfg</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后在 Supervisor 的配置文件夹<code>/etc/supervisor/conf.d/</code>中新建 FiveM 的启动文件<code>fivem.conf</code>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[program:fivem]</span><br><span class="line">command=/usr/bin/bash /usr/local/src/FiveM/start.sh</span><br><span class="line">directory=/usr/local/src/FiveM</span><br><span class="line">user=root</span><br><span class="line">stdout_logfile=/var/log/fivem.log</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br><span class="line">redirect_stderr=true</span><br><span class="line">stopsignal=QUIT</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后使用<code>supervisorctl reload</code>，选择<code>y</code>即可开机自启 FiveM 服务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@centos ~]# supervisorctl status</span><br><span class="line">fivem                            RUNNING   pid 3316, uptime 5:24:59</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实时日志如下 (每三分钟发一次心跳)：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@centos ~]# tail /var/log/fivem.log -f</span><br><span class="line">Sending heartbeat to live-internal.fivem.net:30110</span><br><span class="line">Sending heartbeat to live-internal.fivem.net:30110</span><br><span class="line">Sending heartbeat to live-internal.fivem.net:30110</span><br><span class="line">Sending heartbeat to live-internal.fivem.net:30110</span><br><span class="line">Sending heartbeat to live-internal.fivem.net:30110</span><br><span class="line">Sending heartbeat to live-internal.fivem.net:30110</span><br><span class="line">Sending heartbeat to live-internal.fivem.net:30110</span><br><span class="line">Sending heartbeat to live-internal.fivem.net:30110</span><br><span class="line">Sending heartbeat to live-internal.fivem.net:30110</span><br><span class="line">Sending heartbeat to live-internal.fivem.net:30110</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>连接情况 (若是云服务器或者是非本机的电脑需要添加 30120 的 TCP 和 UDP 入站规则)：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@VM_0_7_centos ~]# lsof -i:30120</span><br><span class="line">COMMAND    PID USER   FD   TYPE   DEVICE SIZE/OFF NODE NAME</span><br><span class="line">ld-musl-x 3317 root   28u  IPv4 36571478      0t0  TCP VM_0_7_centos:30120-&gt;150.116.85.124:55130 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   31u  IPv4 36470180      0t0  TCP *:30120 (LISTEN)</span><br><span class="line">ld-musl-x 3317 root   33u  IPv6 36470181      0t0  UDP *:30120</span><br><span class="line">ld-musl-x 3317 root   35u  IPv4 36476879      0t0  TCP VM_0_7_centos:30120-&gt;201.75.45.121:52624 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   36u  IPv4 36477004      0t0  TCP VM_0_7_centos:30120-&gt;67.166.27.29:57882 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   37u  IPv4 36509773      0t0  TCP VM_0_7_centos:30120-&gt;adria.kvarteto.net:50084 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   38u  IPv4 36483951      0t0  TCP VM_0_7_centos:30120-&gt;cable-188-2-205-27.dynamic.sbb.rs:52447 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   39u  IPv4 36484090      0t0  TCP VM_0_7_centos:30120-&gt;49.230.56.194:50631 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   40u  IPv4 36571801      0t0  TCP VM_0_7_centos:30120-&gt;176.148.208.253:58608 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   41u  IPv4 36484632      0t0  TCP VM_0_7_centos:30120-&gt;179.219.232.155:55005 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   42u  IPv4 36488632      0t0  TCP VM_0_7_centos:30120-&gt;client-201.230.158.233.speedy.net.pe:13723 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   43u  IPv4 36489318      0t0  TCP VM_0_7_centos:30120-&gt;112.201.139.65.pldt.net:ema-sent-lm (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   44u  IPv4 36504202      0t0  TCP VM_0_7_centos:30120-&gt;cpc69049-oxfd25-2-0-cust839.4-3.cable.virginm.net:55972 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   45u  IPv4 36509900      0t0  TCP VM_0_7_centos:30120-&gt;106.203.63.106:64732 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   46u  IPv4 36490560      0t0  TCP VM_0_7_centos:30120-&gt;177.155.219.25:58726 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   47u  IPv4 36510686      0t0  TCP VM_0_7_centos:30120-&gt;187.21.113.230:51463 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   48u  IPv4 36509557      0t0  TCP VM_0_7_centos:30120-&gt;pc-252-52-100-190.cm.vtr.net:50904 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   49u  IPv4 36492966      0t0  TCP VM_0_7_centos:30120-&gt;170.254.133.248:4657 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   50u  IPv4 36512199      0t0  TCP VM_0_7_centos:30120-&gt;93-86-107-145.dynamic.isp.telekom.rs:58530 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   51u  IPv4 36523715      0t0  TCP VM_0_7_centos:30120-&gt;c-71-193-90-215.hsd1.mn.comcast.net:64846 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   52u  IPv4 36515098      0t0  TCP VM_0_7_centos:30120-&gt;37.236.124.65:60517 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   53u  IPv4 36524821      0t0  TCP VM_0_7_centos:30120-&gt;ppp-223-24-144-28.revip6.asianet.co.th:11693 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   54u  IPv4 36522366      0t0  TCP VM_0_7_centos:30120-&gt;c-98-192-236-150.hsd1.de.comcast.net:58986 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   55u  IPv4 36522517      0t0  TCP VM_0_7_centos:30120-&gt;190.200.255.39:17832 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   56u  IPv4 36525992      0t0  TCP VM_0_7_centos:30120-&gt;cm-27-145-135-149.revip12.asianet.co.th:52631 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   57u  IPv4 36531724      0t0  TCP VM_0_7_centos:30120-&gt;73.126.70.158:50722 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   58u  IPv4 36555357      0t0  TCP VM_0_7_centos:30120-&gt;cpc139088-jarr15-2-0-cust109.16-2.cable.virginm.net:52928 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   59u  IPv4 36531740      0t0  TCP VM_0_7_centos:30120-&gt;c-174-50-61-97.hsd1.la.comcast.net:52188 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   60u  IPv4 36551137      0t0  TCP VM_0_7_centos:30120-&gt;187.21.84.137:65142 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   61u  IPv4 36555172      0t0  TCP VM_0_7_centos:30120-&gt;77.202.162.69:54845 (ESTABLISHED)</span><br><span class="line">ld-musl-x 3317 root   62u  IPv4 36563973      0t0  TCP VM_0_7_centos:30120-&gt;199.199.246.200:63485 (ESTABLISHED)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注意：因为我是放在云服务器上的，所以刚搭建完没多久就有客户端连接上来了</p></blockquote><p>资源占用情况：<br><img src="https://img.hacpai.com/file/2019/11/image-cfe46be4.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Linux </tag>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派安装字体</title>
      <link href="/posts/32391.html"/>
      <url>/posts/32391.html</url>
      
        <content type="html"><![CDATA[<h2 id="安装字体"><a href="#安装字体" class="headerlink" title="安装字体"></a>安装字体</h2><p>1、下载字体</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://assets.ubuntu.com/v1/0cef8205-ubuntu-font-family-0.83.zip</span><br></pre></td></tr></table></figure><p>或者复制字体到linux上</p><p>2、用命令将要的字体复制到 <code>/usr/share/fonts/TrueType</code> 目录下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cp -r ubuntu-font-family-0.83/ /usr/share/fonts/truetype/</span><br></pre></td></tr></table></figure><p>3、修改字体权限，使root以外的用户可以使用这些字体。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chmod 755 /usr/share/fonts/truetype/ubuntu-font-family-0.83/ -R</span><br></pre></td></tr></table></figure><p>4、建立字体缓存，命令：<code>cd /usr/share/fonts/TrueType</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkfontscale</span><br><span class="line">mkfontdir </span><br><span class="line">fc-cache -fv </span><br></pre></td></tr></table></figure><p>5、重启，即可使用。</p><h2 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h2><p>没有这两个命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkfontscale</span><br><span class="line">mkfontdir </span><br></pre></td></tr></table></figure><p>需要安装一下两个包</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使mkfontscale和mkfontdir命令正常运行</span></span><br><span class="line">sudo apt-get install ttf-mscorefonts-installer</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使fc-cache命令正常运行</span></span><br><span class="line">sudo apt-get install fontconfig</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://leif.fun/articles/2019/08/27/1566889848431.html">树莓派安装字体 - 琴声已散丶弦犹微振 (leif.fun)</a></li><li><a href="https://blog.csdn.net/soulmate_P/article/details/87856420?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-1.no_search_link&spm=1001.2101.3001.4242.1">Linux(Ubuntu，Cent OS)环境安装mkfontscale mkfontdir命令以及中文字库_soulmate_P的博客-CSDN博客</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> 教程 </tag>
            
            <tag> 配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派（raspberry）启用 root 账户</title>
      <link href="/posts/48985.html"/>
      <url>/posts/48985.html</url>
      
        <content type="html"><![CDATA[<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>树莓派使用的 linux 是 debian 系统，所以树莓派启用 root 和 debian 是相同的。</p><p>debian 里 root 账户默认没有密码，但账户锁定。</p><p>当需要 root 权限时，由默认账户经由 sudo 执行，Raspberry pi 系统中的 Raspbian</p><p>默认用户是 pi 密码为 raspberry</p><p>重新开启 root 账号，可由 pi 用户登录后，在命令行下执行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo passwd root</span><br></pre></td></tr></table></figure><p>执行此命令后系统会提示输入两遍的 root 密码，输入你想设的密码即可，然后在执行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo passwd --unlock root</span><br></pre></td></tr></table></figure><p>这样就可以解锁 root 账户了。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://leif.fun/articles/2019/08/27/1566891673134.html">树莓派（raspberry）启用root账户 - 琴声已散丶弦犹微振 (leif.fun)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> 教程 </tag>
            
            <tag> 配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zsh终端配置</title>
      <link href="/posts/3295.html"/>
      <url>/posts/3295.html</url>
      
        <content type="html"><![CDATA[<h2 id="安装zsh"><a href="#安装zsh" class="headerlink" title="安装zsh"></a>安装zsh</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get update #更新软件源索引</span><br><span class="line">sudo apt-get install zsh #安装zsh</span><br></pre></td></tr></table></figure><p>zsh安装完成后，执行:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/shells</span><br></pre></td></tr></table></figure><p>不出意外的话，终端应该会返回包含<code>/bin/zsh</code>或<code>/usr/bin/zsh</code>字样的结果了。</p><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><p>使用oh-my-zsh来配置zsh，oh-my-zsh是一个快速&amp;自动化配置zsh的项目，项目地址:<a href="https://github.com/robbyrussell/oh-my-zsh">https://github.com/robbyrussell/oh-my-zsh</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh #下载并执行oh-my-zsh自动配置脚本</span><br></pre></td></tr></table></figure><p>执行此命令后，脚本将会下载zsh所需的资源和配置文件至<code>~/oh-my-zsh/</code>目录，并将根据你的系统环境变量完成对zsh的配置。</p><p>接着，我们可以执行以下命令将zsh切换为此用户的默认Shell(可能需要用户的密码):</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chsh -s /bin/zsh #无需加sudo</span><br></pre></td></tr></table></figure><p>退出终端并再次登录终端，这时命令指示符应该有变化了，说明zsh的基础配置完成。</p><h2 id="进阶配置"><a href="#进阶配置" class="headerlink" title="进阶配置"></a>进阶配置</h2><p>通过更改<code>~/.zshrc</code>文件来对zsh进行进一步的配置:</p><h3 id="更改主题"><a href="#更改主题" class="headerlink" title="更改主题"></a>更改主题</h3><p>对应的主题应该都有介绍，链接：<a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Themes">https://github.com/ohmyzsh/ohmyzsh/wiki/Themes</a></p><p>我这里安装的是powerlevel10k，安装步骤如下：</p><p>项目链接：<a href="https://github.com/romkatv/powerlevel10k">https://github.com/romkatv/powerlevel10k</a></p><img src="https://images.961110.xyz/images/2021/10/22/powerlevel10k.png" alt="image-20211022132355307" style="zoom:50%;" /><p>根据官方教程即可进行相应配置，或者输入<code>p10k configure</code>进行配置。</p><img src="https://images.961110.xyz/images/2021/10/22/p10k-configure.png" alt="image-20211022132701167" style="zoom:50%;" /><p>根据提示输入选项即可。</p><p>zsh配置文件中主题相关的配置如下图</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ZSH_THEME=&quot;powerlevel10k/powerlevel10k&quot;    #将zsh的主题更改为powerlevel10k</span><br></pre></td></tr></table></figure><h3 id="自动纠错"><a href="#自动纠错" class="headerlink" title="自动纠错"></a>自动纠错</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENABLE_CORRECTION=&quot;true&quot;    #(去掉ENABLE前的&quot;#&quot;)打开zsh的自动纠错功能</span><br></pre></td></tr></table></figure><p>当纠错功能开启后，当你键入的命令被zsh判定为”可能错误的命令”时，将会提示你是否将此命令重定向为”zsh认为可能正确的命令”，比如键入<code>iconfig</code>命令时，zsh将会返回以下提示:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zsh: correct &#x27;iconfig&#x27; to &#x27;ifconfig&#x27; [nyae]?</span><br></pre></td></tr></table></figure><p>键入 y 即可将刚刚输入的iconfig命令重定向到ifconfig命令</p><h3 id="命令别名"><a href="#命令别名" class="headerlink" title="命令别名"></a>命令别名</h3><p>将以下内容添加到文件的末尾以重定向默认命令或添加自定义命令:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Alias Settings</span><br><span class="line">alias ll=&#x27;ls -all&#x27;</span><br><span class="line">alias vi=&#x27;vim&#x27;</span><br><span class="line">alias ps=&#x27;ps -A&#x27;</span><br><span class="line">alias ifconfig=&#x27;sudo ifconfig&#x27;</span><br></pre></td></tr></table></figure><p>其中，<code>alias ifconfig=&#39;sudo ifconfig&#39;</code>这一句比较重要，如果不加此内容，在当前用户下可能会出现无法执行ifconfig命令的情况。</p><p>如在终端中执行<code>ll</code>命令，相当于执行<code>ls -all</code>文件，执行<code>ps</code>命令则相当于执行<code>ps -A</code>命令:</p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>安装插件时可能因为网络问题无法连接到github仓库，可以到gitee上看看有没有对应的克隆库，替换一下即可。</p><h4 id="Autojump"><a href="#Autojump" class="headerlink" title="Autojump"></a>Autojump</h4><p>我们还可以安装Autojump插件，以实现快捷定位常用目录(需要在安装之前配置Python环境):</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">git clone git://github.com/joelthelion/autojump.git #从Github克隆Autojump项目</span><br><span class="line"></span><br><span class="line">cd autojump</span><br><span class="line">sudo chmod 755 install.py</span><br><span class="line"></span><br><span class="line">./install.py #执行安装脚本，安装Autojump</span><br></pre></td></tr></table></figure><p>在脚本执行结果的末尾，你将会看到类似这样的内容(实际内容可能不一样):</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[[ -s /home/pi/.autojump/etc/profile.d/autojump.sh ]] &amp;&amp; source /home/pi/.autojump/etc/profile.d/autojump.sh</span><br><span class="line">autoload -U compinit &amp;&amp; compinit -u</span><br></pre></td></tr></table></figure><p>复制终端中这段内容，添加到<code>~/.zshrc</code>文件末尾即可启用Autojump。接着，我们可以执行以下命令重载<code>.zshrc</code>文件以更新zsh配置:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source .zshrc #重载zsh配置文件</span><br></pre></td></tr></table></figure><p>启用Autojump插件后，插件将记录你经常定位的目录，存储到数据库中，当之后想要访问此目录时，只需要键入:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">j &lt;目录简称&gt;</span><br></pre></td></tr></table></figure><p>即可快速定位。比如<code>/var/www/html</code>是我经常定位的目录。如果我想快捷访问此目录，只需要键入:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">j html</span><br></pre></td></tr></table></figure><p>即可快速定位。</p><h4 id="Tab补全命令忽略大小写"><a href="#Tab补全命令忽略大小写" class="headerlink" title="Tab补全命令忽略大小写"></a>Tab补全命令忽略大小写</h4><p>如果安装了autojump插件，并且已经配置好，只需在.zshrc增加下面一行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zstyle &#x27;:completion:*&#x27; matcher-list &#x27;m:&#123;[:lower:][:upper:]&#125;=&#123;[:upper:][:lower:]&#125;&#x27; &#x27;m:&#123;[:lower:][:upper:]&#125;=&#123;[:upper:][:lower:]&#125; l:|=* r:|=*&#x27; &#x27;m:&#123;[:lower:][:upper:]&#125;=&#123;[:upper:][:lower:]&#125; l:|=* r:|=*&#x27; &#x27;m:&#123;[:lower:][:upper:]&#125;=&#123;[:upper:][:lower:]&#125; l:|=* r:|=*&#x27;</span><br></pre></td></tr></table></figure><p>如果没有安装，增加下面两行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">autoload -Uz compinit &amp;&amp; compinit -u</span><br><span class="line">zstyle &#x27;:completion:*&#x27; matcher-list &#x27;m:&#123;[:lower:][:upper:]&#125;=&#123;[:upper:][:lower:]&#125;&#x27; &#x27;m:&#123;[:lower:][:upper:]&#125;=&#123;[:upper:][:lower:]&#125; l:|=* r:|=*&#x27; &#x27;m:&#123;[:lower:][:upper:]&#125;=&#123;[:upper:][:lower:]&#125; l:|=* r:|=*&#x27; &#x27;m:&#123;[:lower:][:upper:]&#125;=&#123;[:upper:][:lower:]&#125; l:|=* r:|=*&#x27;</span><br></pre></td></tr></table></figure><h4 id="sudo插件"><a href="#sudo插件" class="headerlink" title="sudo插件"></a>sudo插件</h4><p>开启sudo插件后，如果遇到上一条命令因为未在命令头部添加sudo命令而保存的情况时，只需要双击”Esc”键，即可自动为刚才键入的最后一条命令补全sudo。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plugins=(git sudo)    #为zsh添加git和sudo插件</span><br></pre></td></tr></table></figure><h4 id="highlighting插件"><a href="#highlighting插件" class="headerlink" title="highlighting插件"></a>highlighting插件</h4><p>命令高亮插件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://gitee.com/unrogue007/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure><p>在<code>.zshrc</code>配置文件的插件配置项增加高亮插件即可。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plugins=(git sudo zsh-syntax-highlighting )</span><br></pre></td></tr></table></figure><h4 id="autosuggestions插件"><a href="#autosuggestions插件" class="headerlink" title="autosuggestions插件"></a>autosuggestions插件</h4><p>命令提示插件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure><p>在<code>.zshrc</code>配置文件的插件配置项增加高亮插件即可。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plugins=(git sudo zsh-syntax-highlighting zsh-autosuggestions)</span><br></pre></td></tr></table></figure><p><strong>别忘了<code>source .zshrc</code> 重载zsh配置文件</strong></p><h3 id="隐藏用户名或者主机名"><a href="#隐藏用户名或者主机名" class="headerlink" title="隐藏用户名或者主机名"></a>隐藏用户名或者主机名</h3><p>修改<code>vim ~/.zshrc</code>文件,在文件底部增加</p><ul><li><p>隐藏用户名和主机名</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">prompt_context() &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>只保留用户名，隐藏主机名</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">prompt_context() &#123;</span><br><span class="line">  if [[ &quot;$USER&quot; != &quot;$DEFAULT_USER&quot; || -n &quot;$SSH_CLIENT&quot; ]]; then</span><br><span class="line">    prompt_segment black default &quot;%(!.%&#123;%F&#123;yellow&#125;%&#125;.)$USER&quot;</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>只保留主机名，隐藏用户名</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">prompt_context() &#123;</span><br><span class="line">  if [[ &quot;$USER&quot; != &quot;$DEFAULT_USER&quot; || -n &quot;$SSH_CLIENT&quot; ]]; then</span><br><span class="line">    prompt_segment black default &quot;%(!.%&#123;%F&#123;yellow&#125;%&#125;.)$HOST&quot;</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>修改后记得执行 <code>source ~/.zshrc</code></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://mlapp.cn/310.html">树莓派折腾记:安装并配置zsh | 美丽应用 (mlapp.cn)</a></li><li><a href="https://www.jianshu.com/p/3158a2116fdf">ZSH的配置 - 简书 (jianshu.com)</a></li><li><a href="https://blog.csdn.net/a_zhon/article/details/111397861">Mac上终端使用zsh，设置不区分大小写进行Tab补全_我们不生产代码，我们只是代码的搬运工-CSDN博客</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> 教程 </tag>
            
            <tag> zsh </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派安装Clash代理</title>
      <link href="/posts/60310.html"/>
      <url>/posts/60310.html</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>到<a href="https://github.com/Dreamacro/clash/releases">官方Releases页面</a>下，选择合适的版本下载。</p><p>我这里下载的是<a href="https://github.com/Dreamacro/clash/releases/download/v1.7.1/clash-linux-armv8-v1.7.1.gz">clash-linux-armv8-v1.7.1.gz</a></p><h3 id="解压并安装"><a href="#解压并安装" class="headerlink" title="解压并安装"></a>解压并安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gzip -dv clash-linux-armv8-v1.7.1.gz</span><br><span class="line"></span><br><span class="line">sudo mkdri /usr/local/bin/clash</span><br><span class="line"></span><br><span class="line">mv clash-linux-armv8-v1.7.1 /usr/local/bin/clash</span><br><span class="line"></span><br><span class="line">sudo chmod a+x /usr/local/bin/clash</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 首次运行，初始化一下config目录</span></span><br><span class="line">clash</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载配置文件（如果是root用户安装clash的那么配置文件应放在/root/.config/clash目录下）</span></span><br><span class="line">sudo wget -O /home/pi/.config/clash/config.yaml https://xxxx.xx/xxx</span><br></pre></td></tr></table></figure><p>配置文件可以在购买渠道获得，我电脑上也在用，所以直接复制过来了，就是URL下对应的链接。</p><img src="https://images.961110.xyz/images/2021/10/22/clash.png" alt="image-20211022172216860" style="zoom:50%;" /><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">port: 7890</span><br><span class="line">socks-port: 7891</span><br><span class="line">allow-lan: false</span><br><span class="line">mode: Rule</span><br><span class="line">log-level: info</span><br><span class="line">external-controller: 0.0.0.0:9091</span><br></pre></td></tr></table></figure><p>port为代理的端口<br>allow-lan为是否开启局域网访问<br>external-controller为Clash控制端口与允许访问该端口的设备</p><p><strong>这里mode先设置为Global，方便之后测试。</strong></p><h3 id="配置开机启动"><a href="#配置开机启动" class="headerlink" title="配置开机启动"></a>配置开机启动</h3><p>官方教程：<a href="https://github.com/Dreamacro/clash/wiki/clash-as-a-daemon#systemd">https://github.com/Dreamacro/clash/wiki/clash-as-a-daemon#systemd</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将配置文件复制到/etc/clash文件夹中</span></span><br><span class="line">sudo mkdir /etc/clash</span><br><span class="line"></span><br><span class="line">cp /home/pi/.config/clash/config.yaml /etc/clash/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 虽然前面的步骤中没见过这个文件，但是它是自动生成的</span></span><br><span class="line">cp /home/pi/.config/clash/Country.mmdb /etc/clash/</span><br></pre></td></tr></table></figure><p>在systemd配置目录中新建配置文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/systemd/system/clash.service</span><br></pre></td></tr></table></figure><p>输入一下内容</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Clash daemon, A rule-based proxy in Go.</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">Restart=always</span><br><span class="line">ExecStart=/usr/local/bin/clash -d /etc/clash</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>启动开机自启</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable clash</span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> systemctl start clash</span></span><br></pre></td></tr></table></figure><p>检查状态</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl status clash</span><br></pre></td></tr></table></figure><p>开启代理</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export http_proxy=127.0.0.1:7890</span><br><span class="line">export https_proxy=127.0.0.1:7890</span><br></pre></td></tr></table></figure><p>取消代理</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unset http_proxy</span><br><span class="line">unset https_proxy</span><br></pre></td></tr></table></figure><p>验证代理是否成功</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl cip.cc</span><br></pre></td></tr></table></figure><p><img src="https://images.961110.xyz/images/2021/10/22/30f1e33fa6233494f9b97eb22427568e.png" alt="image-20211022174912273" style="zoom:50%;" /><img src="https://images.961110.xyz/images/2021/10/22/115f7af8cbbf091d4478c60fb8631461.png" alt="image-20211022174955495" style="zoom: 50%;" /></p><p>如果提示未安装curl，输入以下命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt install curl</span><br></pre></td></tr></table></figure><p>如果代理成功，则会显示代理的IP及地址。</p><p>代理成功，可以把代理模式改回 Rule 模式</p><h3 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h3><p>通过一下网站可以管理Clash</p><p><a href="http://clash.razord.top/#/settings">http://clash.razord.top/#/settings</a></p><img src="https://images.961110.xyz/images/2021/10/22/clashe8aa2ec8d51bee0e.png" alt="image-20211022174624218" style="zoom:50%;" /><p>Host填写树莓派的IP，端口填写clash配置文件中<code>external-controller</code>填写的端口。</p><img src="https://images.961110.xyz/images/2021/10/22/clash49c32381cceff753.png" alt="image-20211022174803075" style="zoom:50%;" /><p>在设置页面也可以控制全局代理还是规则代理还是直连。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="http://events.jianshu.io/p/f0daa2d9eae6">树莓派4B 通过Clash实现代理 - 简书 (jianshu.io)</a></li><li><a href="https://www.cnblogs.com/rogunt/p/15127947.html">在Linux终端中使用Clash（clash for linux) - Rogunt - 博客园 (cnblogs.com)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> 教程 </tag>
            
            <tag> 代理 </tag>
            
            <tag> 科学上网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux通过dd命令备份及还原SD卡</title>
      <link href="/posts/2965.html"/>
      <url>/posts/2965.html</url>
      
        <content type="html"><![CDATA[<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>dd：用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换。</p><p>参数：</p><ol><li>if=文件名：输入文件名，缺省为标准输入。即指定源文件。&lt; if=input file &gt;</li><li>of=文件名：输出文件名，缺省为标准输出。即指定目的文件。&lt; of=output file &gt;</li></ol><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li><p>将读卡器连接到Linux虚拟机中；</p></li><li><p>使用<code>sudo fdisk -l</code>命令列出所有存储设备，找到SD对应的盘符，/dev/sdb</p><img src="https://images.961110.xyz/images/2021/10/21/fdisk--l.png" alt="image-20211021164046598" style="zoom:50%;" /></li><li><p>输入<code>sudo dd if=/dev/sdb status=progress | gzip &gt; /path2backup/backup.gz</code>将镜像备份到指定目录，并用gzip压缩</p></li><li><p>要恢复的话，输入<code>gzip -dc /path2backup/backup.gz | dd of=/dev/sdb</code></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> 教程 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派4B启动配置</title>
      <link href="/posts/59454.html"/>
      <url>/posts/59454.html</url>
      
        <content type="html"><![CDATA[<h2 id="镜像及工具"><a href="#镜像及工具" class="headerlink" title="镜像及工具"></a>镜像及工具</h2><h3 id="系统镜像"><a href="#系统镜像" class="headerlink" title="系统镜像"></a>系统镜像</h3><h4 id="Raspberry-Pi-OS"><a href="#Raspberry-Pi-OS" class="headerlink" title="Raspberry Pi OS"></a>Raspberry Pi OS</h4><p>官方镜像，基于Debian的一个发行版，针对树莓派做了优化。</p><p>一共提供了三个版本，镜像大小逐个递减。</p><ol><li>Raspberry Pi OS with desktop and recommended software：有图形界面，内置各种软件，比如博主的世界、Python、游戏等；</li><li>Raspberry Pi OS with desktop：有图形界面、浏览器，没有一些乱七八糟的软件；</li><li>Raspberry Pi OS Lite：无图形界面，有核心依赖，比如Python等。</li></ol><p>需要图形化界面的更推荐Raspberry Pi OS with desktop这个版本，不大不小。不过<strong>官网默认提供的是32bit的版本</strong>，树莓派RaspBerry4B的CPU是博通的BCM2711，一颗ARM Cortex-A72架构的64位处理器，所以使用64位系统才能更好释放性能。</p><blockquote><p><a href="https://downloads.raspberrypi.org/raspios_armhf/images/">32bit镜像官网链接</a></p><p><a href="https://downloads.raspberrypi.org/raspios_arm64/images">64bit镜像官网链接</a></p><p><a href="https://www.raspberrypi.com/software/operating-systems/">镜像的官方介绍及各个版本</a></p></blockquote><h3 id="SD卡格式化工具"><a href="#SD卡格式化工具" class="headerlink" title="SD卡格式化工具"></a>SD卡格式化工具</h3><p>SD Card Formatter</p><p><a href="https://www.sdcard.org/downloads/formatter/sd-memory-card-formatter-for-windows-download/">官网下载链接</a></p><h3 id="写镜像工具"><a href="#写镜像工具" class="headerlink" title="写镜像工具"></a>写镜像工具</h3><p>Win32DiskImager</p><p><a href="https://sourceforge.net/projects/win32diskimager/files/latest/download">官方下载链接</a></p><h3 id="远程桌面工具"><a href="#远程桌面工具" class="headerlink" title="远程桌面工具"></a>远程桌面工具</h3><h5 id="VNC-Viewer"><a href="#VNC-Viewer" class="headerlink" title="VNC Viewer"></a>VNC Viewer</h5><p><a href="https://www.realvnc.com/en/connect/download/viewer/">官方下载链接</a></p><h2 id="刷写系统"><a href="#刷写系统" class="headerlink" title="刷写系统"></a>刷写系统</h2><h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><p>此处博主下载的是64位的最新镜像，官方文件名为：2021-05-07-raspios-buster-arm64</p><p>下载之后可以Windows 10终端里输入下面命令来计算SHA256进行完整性校验。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">certutil -hashfile 镜像存放路径\2021-05-07-raspios-buster-arm64.zip SHA256</span><br></pre></td></tr></table></figure><p>BTW，可选哈希算法参数有MD2 MD4 MD5 SHA1 SHA256 SHA384 SHA512</p><p><img src="https://images.961110.xyz/images/2021/10/19/Raspberry-Pi-OS-with-desktop-.png" alt="image-20211016201407578" style="zoom:50%;" /><img src="https://images.961110.xyz/images/2021/10/19/Raspberry-Pi-OS-with-desktop-dc4e0e6197208ff1.png" alt="image-20211016201252081" style="zoom:50%;" /></p><p>两个不同的下载通道都可以看到SHA256的值，最好校验一下。</p><p>校验无误后，解压得到<code>.img</code>镜像文件，待会写到SD卡中。</p><h3 id="格式化SD卡"><a href="#格式化SD卡" class="headerlink" title="格式化SD卡"></a>格式化SD卡</h3><p>选择好SD卡对应的盘符，选择Quick format，点击右下角Format，稍等片刻即可。<strong>注意不要选择错了盘符，否则后果不堪设想。</strong></p><p><img src="https://images.961110.xyz/images/2021/10/19/SD-Card-Formatter.png" alt="image-20211016201935243" style="zoom: 67%;" /><img src="https://images.961110.xyz/images/2021/10/19/SD.png" alt="image-20211016202211668" style="zoom:67%;" /></p><h3 id="刷写镜像"><a href="#刷写镜像" class="headerlink" title="刷写镜像"></a>刷写镜像</h3><p>选择刚刚解压出来的镜像文件，选择好盘符，然后点击写入即可，完成速度取决于SD卡及读卡器的速度。</p><p><img src="https://images.961110.xyz/images/2021/10/19/f28e57496b9b60234c05963587aebae3.png" alt="image-20211016202444369" style="zoom:67%;" /><img src="https://images.961110.xyz/images/2021/10/19/1163840ac01b2da689eb0dc2686f4eb3.png" alt="image-20211016203816344" style="zoom:67%;" /></p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="开启ssh"><a href="#开启ssh" class="headerlink" title="开启ssh"></a>开启ssh</h4><p>写入镜像后，会有一个boot分区，在boot分区下新建一个<strong>删掉格式后缀</strong>的名为ssh的<strong>文件</strong>，以便启动后使用ssh连接树莓派。</p><h4 id="通过网线共享电脑的网络"><a href="#通过网线共享电脑的网络" class="headerlink" title="通过网线共享电脑的网络"></a>通过网线共享电脑的网络</h4><blockquote><p>设置–&gt;状态–&gt;高级网络设置：更改适配器选项–&gt;选择电脑联网的适配器–&gt;右键选择属性，点击共享–&gt;打开下图中的选项–&gt;选择树莓派要连接的适配器–&gt;确定</p></blockquote><img src="https://images.961110.xyz/images/2021/10/19/2d3ddc0a200c6e2f6386bbfe718cb969.png" alt="image-20211017133126324" style="zoom:50%;" /><p>此种方式的默认的网关IP是192.168.137.1，所以分配给树莓派的IP是192.168.137.XXX，具体查看方式见下文。</p><h4 id="通过配置WiFi上网"><a href="#通过配置WiFi上网" class="headerlink" title="通过配置WiFi上网"></a>通过配置WiFi上网</h4><p>在boot分区新建一个wpa_supplicant.conf文件，内容如下:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">country=CN</span><br><span class="line">ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev</span><br><span class="line">update_config=1</span><br><span class="line"></span><br><span class="line">network=&#123;</span><br><span class="line">       ssid=&quot;XXXXXXX&quot;</span><br><span class="line">       psk=&quot;password&quot;</span><br><span class="line">       key_mgmt=WPA-PSK</span><br><span class="line">       priority=1</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>ssid</code>就是WIFI名，<code>psk</code>就是WiFi密码，<code>key_mgmt</code>就是WiFi的加密方式，一般在路由器管理界面的WiFi设置中可以看到。</p><p>和一般的不同，这里**<code>priority</code>值越大，优先级越大**。</p><h4 id="连接风扇"><a href="#连接风扇" class="headerlink" title="连接风扇"></a>连接风扇</h4><img src="https://images.961110.xyz/images/2021/10/19/4B-.jpg" alt="树莓派4B 连接风扇" style="zoom:50%;" /><p>树莓派4B的GPIO口外侧是偶数口，内侧是奇数口，如图示从左到右需要依次增大。风扇需要连接在第4和6号引脚上，正极（红线）连接在4号引脚，负极（黑线）连接在6号引脚。</p><h3 id="通电"><a href="#通电" class="headerlink" title="通电"></a>通电</h3><h4 id="状态检查"><a href="#状态检查" class="headerlink" title="状态检查"></a>状态检查</h4><p>插入SD卡，插入网线，连接电源自动开机：</p><ul><li>红灯常亮：未能检测到TF卡；</li><li>双灯常亮：未能检测到系统；</li><li>绿灯闪烁：系统运行正常。、</li></ul><p>等个几十秒进行下一步</p><h4 id="通过网线联网，查看树莓派Raspberry-4B的IP"><a href="#通过网线联网，查看树莓派Raspberry-4B的IP" class="headerlink" title="通过网线联网，查看树莓派Raspberry 4B的IP"></a>通过网线联网，查看树莓派Raspberry 4B的IP</h4><p>打开cmd或其他shell工具，通过<code>arp -a</code>查看本机的arp表，找到接口为192.168.137.1下的内容</p><p>可以看到树莓派Raspberry 4B获得的IP: 192.168.137.XXX</p><h4 id="通过配置WiFi上网，查看树莓派Raspberry-4B的IP"><a href="#通过配置WiFi上网，查看树莓派Raspberry-4B的IP" class="headerlink" title="通过配置WiFi上网，查看树莓派Raspberry 4B的IP"></a>通过配置WiFi上网，查看树莓派Raspberry 4B的IP</h4><p>进入路由器后台，查看接入网络的设备列表，记录其IP即可。</p><p>此处博主通过Windows 10开启移动热点，树莓派连接上WIFI之后可以直接看到IP地址</p><img src="https://images.961110.xyz/images/2021/10/21/Windows104a0509f4c0915e31.png" alt="image-20211021162133259" style="zoom:50%;" /><img src="https://images.961110.xyz/images/2021/10/21/Windows10851671f235bebad9.png" alt="image-20211021162217862" style="zoom:50%;" /><h3 id="ssh连接"><a href="#ssh连接" class="headerlink" title="ssh连接"></a>ssh连接</h3><p>获取IP后，直接 <code>ssh pi@IP</code> 即</p><p>密码是 raspberry</p><h3 id="VNC连接"><a href="#VNC连接" class="headerlink" title="VNC连接"></a>VNC连接</h3><h4 id="开启VNC"><a href="#开启VNC" class="headerlink" title="开启VNC"></a>开启VNC</h4><p>使用ssh登录之后，输入<code>sudo raspi-config</code>进行配置</p><p><img src="https://images.961110.xyz/images/2021/10/21/config.png" alt="image-20211021162433139" style="zoom: 40%;" /><img src="https://images.961110.xyz/images/2021/10/21/VNC.png" alt="image-20211021161625685" style="zoom:45%;" /></p><p>此种方式是<strong>开机自动开启</strong>VNC服务的。</p><p>在终端输入<code>vncserver</code>开启NVC服务的方式，每次启动必须手动执行才可以。</p><h4 id="使用VNC连接"><a href="#使用VNC连接" class="headerlink" title="使用VNC连接"></a>使用VNC连接</h4><img src="https://images.961110.xyz/images/2021/10/21/VNC7439f5bdc8e20c2c.png" alt="image-20211021162832932" style="zoom: 50%;" /><p>直接输入树莓派的IP地址即可。</p><h3 id="使用微软远程桌面连接"><a href="#使用微软远程桌面连接" class="headerlink" title="使用微软远程桌面连接"></a>使用微软远程桌面连接</h3><h4 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装 xrdp</span></span><br><span class="line">sudo apt-get install xrdp</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动xrdp</span></span><br><span class="line">sudo /etc/init.d/xrdp start</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将Xrdp服务添加到系统默认启动服务中</span></span><br><span class="line">sudo update-rc.d xrdp defaults</span><br></pre></td></tr></table></figure><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>打开Windows远程桌面，输入树莓派4B的IP，连接即可。默认用户名：pi，默认密码：raspberry。</p><h3 id="安装中文字体"><a href="#安装中文字体" class="headerlink" title="安装中文字体"></a>安装中文字体</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get -y install fonts-wqy-zenhei</span><br></pre></td></tr></table></figure><h3 id="安装虚拟键盘"><a href="#安装虚拟键盘" class="headerlink" title="安装虚拟键盘"></a>安装虚拟键盘</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install matchbox-keyboard</span><br></pre></td></tr></table></figure><p>安装之后可以在附件中找到快捷方式。</p><img src="https://images.961110.xyz/images/2021/10/23/fc94eb07ca8e02d7fc2d1b1e7170f0fe.png" alt="image-20211023170143928" style="zoom: 50%;" /><h2 id="更换软件源"><a href="#更换软件源" class="headerlink" title="更换软件源"></a>更换软件源</h2><h3 id="Debian系统源"><a href="#Debian系统源" class="headerlink" title="Debian系统源"></a>Debian系统源</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure><p>清空原文件中的内容，填入清华大学的源</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster main contrib non-free</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster main contrib non-free</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-updates main contrib non-free</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-updates main contrib non-free</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-backports main contrib non-free</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-backports main contrib non-free</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian-security buster/updates main contrib non-free</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/debian-security buster/updates main contrib non-free</span><br></pre></td></tr></table></figure><h3 id="树莓派软件源"><a href="#树莓派软件源" class="headerlink" title="树莓派软件源"></a>树莓派软件源</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /etc/apt/sources.list.d/raspi.list /etc/apt/sources.list.d/raspi.list.bak</span><br></pre></td></tr></table></figure><p>清空原文件中的内容，填入清华大学的源</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui</span><br></pre></td></tr></table></figure><h3 id="刷新软件包信息"><a href="#刷新软件包信息" class="headerlink" title="刷新软件包信息"></a>刷新软件包信息</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><h3 id="版本信息"><a href="#版本信息" class="headerlink" title="版本信息"></a>版本信息</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pi@raspberrypi:~ $ uname -a</span><br><span class="line">Linux raspberrypi 5.10.63-v8+ #1459 SMP PREEMPT Wed Oct 6 16:42:49 BST 2021 aarch64 GNU/Linux</span><br><span class="line"></span><br><span class="line">pi@raspberrypi:~ $ cat /proc/version</span><br><span class="line">Linux version 5.10.63-v8+ (dom@buildbot) (aarch64-linux-gnu-gcc-8 (Ubuntu/Linaro 8.4.0-3ubuntu1) 8.4.0, GNU ld (GNU Binutils for Ubuntu) 2.34) #1459 SMP PREEMPT Wed Oct 6 16:42:49 BST 2021</span><br><span class="line"></span><br><span class="line">pi@raspberrypi:~ $ lsb_release -a</span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID: Debian</span><br><span class="line">Description:    Debian GNU/Linux 10 (buster)</span><br><span class="line">Release:        10</span><br><span class="line">Codename:       buster</span><br></pre></td></tr></table></figure><h3 id="重要部件信息"><a href="#重要部件信息" class="headerlink" title="重要部件信息"></a>重要部件信息</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pi@raspberrypi:~ $ lscpu</span><br><span class="line">Architecture:        aarch64</span><br><span class="line">Byte Order:          Little Endian</span><br><span class="line">CPU(s):              4</span><br><span class="line">On-line CPU(s) list: 0-3</span><br><span class="line">Thread(s) per core:  1</span><br><span class="line">Core(s) per socket:  4</span><br><span class="line">Socket(s):           1</span><br><span class="line">Vendor ID:           ARM</span><br><span class="line">Model:               3</span><br><span class="line">Model name:          Cortex-A72</span><br><span class="line">Stepping:            r0p3</span><br><span class="line">CPU max MHz:         1500.0000</span><br><span class="line">CPU min MHz:         600.0000</span><br><span class="line">BogoMIPS:            108.00</span><br><span class="line">Flags:               fp asimd evtstrm crc32 cpuid</span><br><span class="line"></span><br><span class="line">pi@raspberrypi:~ $ lsusb</span><br><span class="line">Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub</span><br><span class="line">Bus 001 Device 002: ID 2109:3431 VIA Labs, Inc. Hub</span><br><span class="line">Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub</span><br><span class="line"></span><br><span class="line">pi@raspberrypi:~ $ sudo ifconfig -a</span><br><span class="line">eth0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        ether e4:5f:01:64:3c:12  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 5  bytes 284 (284.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 5  bytes 284 (284.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">wlan0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.137.208  netmask 255.255.255.0  broadcast 192.168.137.255</span><br><span class="line">        inet6 fe80::9ac0:acda:640d:1cf0  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether e4:5f:01:64:3c:14  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 38498  bytes 48445286 (46.2 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 21303  bytes 3907714 (3.7 MiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> 教程 </tag>
            
            <tag> 配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker安装chevereto图床并解除上传图片大小限制、自定义图片上传用户和相册</title>
      <link href="/posts/36360.html"/>
      <url>/posts/36360.html</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>直接用官方的推荐安装方式，修改后的docker-compose.yaml如下</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mariadb</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">database:/var/lib/mysql:rw</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">private</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">xxx</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">chevereto</span></span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="string">jason</span></span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="string">xxx</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">chevereto:</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nmtan/chevereto</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">private</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">CHEVERETO_DB_HOST:</span> <span class="string">db</span></span><br><span class="line">      <span class="attr">CHEVERETO_DB_USERNAME:</span> <span class="string">jason</span></span><br><span class="line">      <span class="attr">CHEVERETO_DB_PASSWORD:</span> <span class="string">xxx</span></span><br><span class="line">      <span class="attr">CHEVERETO_DB_NAME:</span> <span class="string">chevereto</span></span><br><span class="line">      <span class="attr">CHEVERETO_DB_PREFIX:</span> <span class="string">chv_</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/home/Jason/chv_images:/var/www/html/images:rw</span>  <span class="comment">#将照片存放路径映射到了本地存储中</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span><span class="string">:80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">private:</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">database:</span></span><br><span class="line">  <span class="attr">chevereto_images:</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后<code>docker-compose up -d</code>就可以启动，通过8080端口访问chevereto。</p><h2 id="解除上传图片的大小限制"><a href="#解除上传图片的大小限制" class="headerlink" title="解除上传图片的大小限制"></a>解除上传图片的大小限制</h2><h3 id="复制到服务器本地路径下"><a href="#复制到服务器本地路径下" class="headerlink" title="复制到服务器本地路径下"></a>复制到服务器本地路径下</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">docker cp  containerID:<span class="regexp">/var/</span>www/html/.htaccess /volume1/docker/</span><br></pre></td></tr></table></figure><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /volume1/docker/.htaccess</span><br><span class="line"></span><br><span class="line"># Disable server signature</span><br><span class="line">ServerSignature Off</span><br><span class="line"></span><br><span class="line"># Disable directory listing (-indexes), Multiviews (-MultiViews) and enable Follow system links (+FollowSymLinks)</span><br><span class="line">Options -Indexes</span><br><span class="line">Options -MultiViews</span><br><span class="line"></span><br><span class="line">&lt;IfModule mod_rewrite.c&gt;</span><br><span class="line"></span><br><span class="line">    RewriteEngine On</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    RewriteRule . index.php [L]</span><br><span class="line">    #修改上传文件大小增加以下 配置  最大支持 32M 根据自己情况配置</span><br><span class="line">    php_value post_max_size 64M</span><br><span class="line">    php_value upload_max_filesize 32M</span><br><span class="line"></span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure><h3 id="复制到容器目录里面"><a href="#复制到容器目录里面" class="headerlink" title="复制到容器目录里面"></a>复制到容器目录里面</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">docker cp /volume1/docker/.htaccess containerID:<span class="regexp">/var/</span>www/html/</span><br></pre></td></tr></table></figure><h2 id="修改上传API"><a href="#修改上传API" class="headerlink" title="修改上传API"></a>修改上传API</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp containerID:/var/www/html/app/routes/route.api.php ./</span><br></pre></td></tr></table></figure><p>将PHP文件复制出来，相应位置增加如下代码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$version</span> = <span class="variable">$handler</span>-&gt;request[<span class="number">0</span>];</span><br><span class="line"><span class="variable">$action</span> = <span class="variable">$handler</span>-&gt;request[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增下面两行</span></span><br><span class="line"><span class="variable">$user</span> = <span class="variable">$_REQUEST</span>[<span class="string">&#x27;user&#x27;</span>];</span><br><span class="line"><span class="variable">$album</span> = <span class="variable">$_REQUEST</span>[<span class="string">&#x27;album&#x27;</span>];</span><br></pre></td></tr></table></figure><p>更改如下代码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将这行代码增加 user 和 album 两个参数</span></span><br><span class="line"><span class="variable">$uploaded_id</span> = CHV\Image::uploadToWebsite(<span class="variable">$source</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更改后的代码如下</span></span><br><span class="line"><span class="variable">$uploaded_id</span> = CHV\Image::uploadToWebsite(<span class="variable">$source</span>, <span class="variable">$user</span>, <span class="keyword">array</span>(<span class="string">&#x27;album_id&#x27;</span>=&gt;<span class="variable">$album</span>));</span><br></pre></td></tr></table></figure><p>将修改后的文件复制到容器中替换</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp ./route.api.php  containerID:/var/www/html/app/routes/route.api.php</span><br></pre></td></tr></table></figure><h2 id="配置Typora和PicGo"><a href="#配置Typora和PicGo" class="headerlink" title="配置Typora和PicGo"></a>配置Typora和PicGo</h2><p>在PicGo中下载插件web-uploader，填入如下配置</p><img src="https://images.961110.xyz/images/2021/10/20/image-20211020120134965.png" alt="image-20211020120134965" style="zoom: 50%;" /><ul><li>API地址：http或https(根据自身情况)://域名/api/1/upload</li><li>POST参数名：source</li><li>JSON路径：image.url</li><li>自定义Body：<code>&#123;&quot;key&quot;:&quot;your key&quot;, &quot;user&quot;:&quot;username&quot;, &quot;album&quot;:&quot;albumid&quot;&#125;</code></li></ul><p>key在用户名–&gt;仪表盘–&gt;设置–&gt;API可以找到</p><img src="https://images.961110.xyz/images/2021/10/20/image-20211020120705106.png" alt="image-20211020120705106" style="zoom:50%;" /><p>username就在chevereto网站右上角<img src="https://images.961110.xyz/images/2021/10/20/image-20211020120603290.png" alt="image-20211020120603290"></p><p>albumid在用户的相册详细信息中可以找到。</p><img src="https://images.961110.xyz/images/2021/10/20/image-20211020120843573.png" alt="image-20211020120843573" style="zoom: 50%;" /><p>配置完成后设置为默认图床，进行上传测试。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://blog.csdn.net/qq_25005601/article/details/110532477?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&spm=1001.2101.3001.4242">Typora + PicGo 自动上传图片到 Chevereto 图床_张大炮来巡山-CSDN博客</a></li><li><a href="https://blog.csdn.net/qq_19564393/article/details/108506062">修改Chevereto的API上传相册和用户_飞逝17的博客-CSDN博客</a></li><li><a href="https://blog.csdn.net/weixin_29343153/article/details/113534943">docker修改文件夹权限_群晖通过Docker安装图床工具Chevereto的步骤_藏美者阿远的博客-CSDN博客</a></li><li><a href="https://www.orcy.net.cn/775.html">Docker容器报错处理:AH00558: apache2: Could not reliably determine the server’s fully qualified domain name, using 172.17.0.5. Set the ‘ServerName’ directive globally to suppress this message – 下一朵云 (orcy.net.cn)</a></li><li><a href="https://cloud.tencent.com/developer/article/1645239">群晖Docker安装chevereto图床</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Docker </tag>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lambda表达式</title>
      <link href="/posts/40489.html"/>
      <url>/posts/40489.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h2><p>lambda 表达式有如下的一些优点：</p><ul><li>  声明式的编程风格：就地匿名定义目标函数或函数对象，不需要额外写一个命名函数或函数对象。</li><li>  简洁：避免了代码膨胀和功能分散，让开发更加高效。</li><li>  在需要的时间和地点实现功能闭包，使程序更加灵活。</li></ul><p>lambda 表达式定义了一个匿名函数，并且可以捕获一定范围内的变量。lambda 表达式的语法形式简单归纳如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[capture](params) opt -&gt; ret &#123;body;&#125;;</span><br></pre></td></tr></table></figure><p>其中 <code>capture</code> 是捕获列表，<code>params</code> 是参数列表，<code>opt</code> 是函数选项，<code>ret</code> 是返回值类型，<code>body</code> 是函数体。</p><ol><li>捕获列表 []: 捕获一定范围内的变量</li><li>参数列表 (): 和普通函数的参数列表一样，如果没有参数参数列表可以省略不写。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = []()&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;<span class="comment">// 没有参数, 参数列表为空</span></span><br><span class="line"><span class="keyword">auto</span> f = []&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;<span class="comment">// 没有参数, 参数列表省略不写</span></span><br></pre></td></tr></table></figure></li><li>opt 选项， <code>不需要可以省略</code><ul><li>  mutable: 可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）</li><li>exception: 指定函数抛出的异常，如抛出整数类型的异常，可以使用 throw ();</li></ul></li><li>返回值类型：在 C++11 中，lambda 表达式的返回值是通过返回值后置语法来定义的。</li><li>函数体：函数的实现，这部分不能省略，但函数体可以为空。</li></ol><h2 id="2-捕获列表"><a href="#2-捕获列表" class="headerlink" title="2. 捕获列表"></a>2. 捕获列表</h2><p>lambda 表达式的捕获列表可以捕获一定范围内的变量，具体使用方式如下：</p><ul><li>  <code>[]</code> - 不捕捉任何变量</li><li>  <code>[&amp;]</code> - 捕获外部作用域中所有变量，并作为引用在函数体内使用 (<code>按引用捕获</code>)</li><li><code>[=]</code> - 捕获外部作用域中所有变量，并作为副本在函数体内使用 (<code>按值捕获</code>)<ul><li>  <code>拷贝的副本在匿名函数体内部是只读的</code></li></ul></li><li>  <code>[=, &amp;foo]</code> - 按值捕获外部作用域中所有变量，并按照引用捕获外部变量 foo</li><li>  <code>[bar]</code> - 按值捕获 bar 变量，同时不捕获其他变量</li><li>  <code>[&amp;bar]</code> - 按引用捕获 bar 变量，同时不捕获其他变量</li><li><code>[this]</code> - 捕获当前类中的 this 指针<ul><li>  让 lambda 表达式拥有和当前类成员函数同样的访问权限</li><li>  <strong>如果已经使用了 &amp; 或者 =, 默认添加 this 指针</strong></li></ul></li></ul><p>下面通过一个例子，看一下初始化列表的具体用法：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> x1 = [] &#123;<span class="keyword">return</span> m_number; &#125;;                      <span class="comment">// error，没有捕获外部变量，不能使用类成员 m_number</span></span><br><span class="line">        <span class="keyword">auto</span> x2 = [=] &#123;<span class="keyword">return</span> m_number + x + y; &#125;;             <span class="comment">// ok，以值拷贝的方式捕获所有外部变量</span></span><br><span class="line">        <span class="keyword">auto</span> x3 = [&amp;] &#123;<span class="keyword">return</span> m_number + x + y; &#125;;             <span class="comment">// ok，以引用的方式捕获所有外部变量</span></span><br><span class="line">        <span class="keyword">auto</span> x4 = [<span class="keyword">this</span>] &#123;<span class="keyword">return</span> m_number; &#125;;                  <span class="comment">// ok，捕获 this 指针，可访问对象内部成员</span></span><br><span class="line">        <span class="keyword">auto</span> x5 = [<span class="keyword">this</span>] &#123;<span class="keyword">return</span> m_number + x + y; &#125;;          <span class="comment">// error，捕获 this 指针，可访问类内部成员，没有捕获到变量 x，y，因此不能访问。</span></span><br><span class="line">        <span class="keyword">auto</span> x6 = [<span class="keyword">this</span>, x, y] &#123;<span class="keyword">return</span> m_number + x + y; &#125;;    <span class="comment">// ok，捕获 this 指针，x，y</span></span><br><span class="line">        <span class="keyword">auto</span> x7 = [<span class="keyword">this</span>] &#123;<span class="keyword">return</span> m_number++; &#125;;                <span class="comment">// ok，捕获 this 指针，并且可以修改对象内部变量的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m_number = <span class="number">100</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>在匿名函数内部，需要通过 lambda 表达式的捕获列表控制如何捕获外部变量，以及访问哪些变量。默认状态下 lambda 表达式无法修改通过复制方式捕获外部变量，如果希望修改这些外部变量，需要通过引用的方式进行捕获。</p></blockquote><h2 id="3-返回值"><a href="#3-返回值" class="headerlink" title="3. 返回值"></a>3. 返回值</h2><p>一般情况下，不指定 lambda 表达式的返回值，编译器会根据 return 语句自动推导返回值的类型，但需要注意的是 <code>labmda表达式不能通过列表初始化自动推导出返回值类型。</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ok，可以自动推导出返回值类型</span></span><br><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">int</span> a) -&gt; <span class="keyword">int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+<span class="number">10</span>;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">int</span> a)&#123;</span><br><span class="line">    <span class="keyword">return</span> a+<span class="number">10</span>;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error，不能推导出返回值类型</span></span><br><span class="line"><span class="keyword">auto</span> f1 = []()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;<span class="comment">// 基于列表初始化推导返回值，错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-函数本质"><a href="#4-函数本质" class="headerlink" title="4. 函数本质"></a>4. 函数本质</h2><p>使用 lambda 表达式捕获列表捕获外部变量，如果希望去修改按值捕获的外部变量，那么应该如何处理呢？这就需要使用 mutable 选项，<code>被mutable修改是lambda表达式就算没有参数也要写明参数列表，并且可以去掉按值捕获的外部变量的只读（const）属性。</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f1 = [=] &#123;<span class="keyword">return</span> a++; &#125;;              <span class="comment">// error, 按值捕获外部变量, a是只读的</span></span><br><span class="line"><span class="keyword">auto</span> f2 = [=]()<span class="keyword">mutable</span> &#123;<span class="keyword">return</span> a++; &#125;;     <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>最后再剖析一下为什么通过值拷贝的方式捕获的外部变量是只读的:</p><ol><li> <code>lambda表达式的类型在C++11中会被看做是一个带operator()的类，即仿函数。</code></li><li> <code>按照C++标准，lambda表达式的operator()默认是const的，一个const成员函数是无法修改成员变量值的。</code></li></ol><p>mutable 选项的作用就在于取消 operator () 的 const 属性。</p><p>因为 lambda 表达式在 C++ 中会被看做是一个仿函数，因此<code>可以使用std::function和std::bind来存储和操作lambda表达式</code>：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 包装可调用函数</span></span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>)&gt; f1 = [](<span class="keyword">int</span> a) &#123;<span class="keyword">return</span> a; &#125;;</span><br><span class="line">    <span class="comment">// 绑定可调用函数</span></span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>)&gt; f2 = <span class="built_in">bind</span>([](<span class="keyword">int</span> a) &#123;<span class="keyword">return</span> a; &#125;, placeholders::_1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数调用</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">f1</span>(<span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">f2</span>(<span class="number">200</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于没有捕获任何变量的 lambda 表达式，还可以转换成一个普通的函数指针：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> func_ptr = <span class="built_in"><span class="keyword">int</span></span>(*)(<span class="keyword">int</span>);</span><br><span class="line"><span class="comment">// 没有捕获任何外部变量的匿名函数</span></span><br><span class="line">func_ptr f = [](<span class="keyword">int</span> a)&#123;</span><br><span class="line">    <span class="keyword">return</span> a;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 函数调用</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">1314</span>);</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://subingwen.cn/cpp/lambda/">Lambda表达式 | 爱编程的大丙 (subingwen.cn)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> C++ </tag>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux进程管理</title>
      <link href="/posts/25357.html"/>
      <url>/posts/25357.html</url>
      
        <content type="html"><![CDATA[<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h3><p><img src="https://images.961110.xyz/images/2021/10/20/Linux0.12.png" alt="Linux0.12创建进程的流程"></p><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p><img src="https://images.961110.xyz/images/2021/10/20/Linux0.1211029ed5dd197bbc.png" alt="Linux0.12进程调度流程图"></p><h3 id="退出进程"><a href="#退出进程" class="headerlink" title="退出进程"></a>退出进程</h3><p><img src="https://images.961110.xyz/images/2021/10/20/exit.c.png" alt="Linux0.12退出进程流程图"></p><p>退出进程</p><h2 id="进程0和进程1"><a href="#进程0和进程1" class="headerlink" title="进程0和进程1"></a>进程0和进程1</h2><h3 id="进程-0"><a href="#进程-0" class="headerlink" title="进程 0"></a>进程 0</h3><p> 首先，进程 0 也叫做空闲进程，是一个内核进程，它的主要作用是进入一个死循环，为了解决 cpu 空闲时刻的问题，所做的工作就是在 cpu 空闲时给 cpu 一个死循环从而使 cpu 工作。特殊性在于它是系统创建的第一个进程。</p><h3 id="进程-1"><a href="#进程-1" class="headerlink" title="进程 1"></a>进程 1</h3><p>进程 1 也叫做 init 进程，开始时它在内核态所做的工作就是挂载根文件系统，将根文件系统挂载上之后，进行一系列的环境配置，最后创建用户交互 shell环境</p><p> 进程 1 的最主要的作用就是对操作系统来说，其他所有的用户进程都是由进程 1 直接或间接创建的，也就是说所有的用户进程都是进程 1 的子孙进程。</p><h2 id="孤儿进程、孤儿进程组、僵尸进程"><a href="#孤儿进程、孤儿进程组、僵尸进程" class="headerlink" title="孤儿进程、孤儿进程组、僵尸进程"></a>孤儿进程、孤儿进程组、僵尸进程</h2><h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p>其父进程已经终止的进程。但是它会被 init 进程 “收养”，init 进程 ID 为 1，因此被收养的孤儿进程的父进程会更新为 1。</p><h3 id="孤儿进程组"><a href="#孤儿进程组" class="headerlink" title="孤儿进程组"></a>孤儿进程组</h3><p>一个进程组中的所有进程的父进程要么是该进程组的一个进程，要么不是该进程组所在的会话中的进程。 一个进程组不是孤儿进程组的条件是，该组中有一个进程其父进程在属于同一个会话的另一个组中。</p><p>一个进程组到其组外的父进程之间的联系依赖于该父进程和其子进程两者，所以会有两种产生孤儿进程组的情况：</p><ol><li>父进程终止</li><li>子进程终止</li></ol><p>在任何一种情況下，如果进程的终止导致进程组变成孤儿进程组，那么进程组中的所有进程就会与它们的作业控制 shell 断开联系，作业控制 shell 将不再具有该进程组存在的任何信息。而该进程组中处于停止状态的进程将会永远消失。为了解决这个问题，含有停止状态进程的新近产生的孤儿进程组就需要接收到一个SIGHIUP信号和一个SIGCONT信号，用于指示它们已经从它们的会话（session）中断开联系。SIGHUP信号将导致进程组中成员被终止，除非它们捕获或忽略了SIGHUP信号。而SIGCONT信号将使那些没有被SIGHUP信号终止的进程继续运行。但在大多数情況下，如果组中有一个进程处于停止状态，那么组中所有的进程可能都处于停止状态。</p><h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p>子进程先于父进程退出，而父进程并没有调用 wait 或 waitpid 获取子进程的状态信息并释放子进程资源，那么其的进程描述符仍然保存在系统中。</p><h2 id="进程、进程组、会话、前台进程组、后台进程组"><a href="#进程、进程组、会话、前台进程组、后台进程组" class="headerlink" title="进程、进程组、会话、前台进程组、后台进程组"></a>进程、进程组、会话、前台进程组、后台进程组</h2><h3 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h3><p>一个或者多个进程的集合。</p><p>每个进程组都有一个唯一的进程组标识号gid，一个称为组长的进程，gid等于组长进程的pid。</p><h3 id="会话（Session）"><a href="#会话（Session）" class="headerlink" title="会话（Session）"></a>会话（Session）</h3><p>一个或多个进程组的集合。</p><p>通常情况下，用户登录后所执行的所有程序都属于一个会话期，而其登录 shell 则是<strong>会话首进程</strong>，并且它所使用的终端就是会话期的控制终端，因此会话期首进程通常也被称为<strong>控制进程</strong>。当用户退出登录时，所有属于这个会话期的进程都将被终止。</p><h3 id="前台进程组"><a href="#前台进程组" class="headerlink" title="前台进程组"></a>前台进程组</h3><p>会话中拥有控制终端的一个进程组。</p><h3 id="后台进程组"><a href="#后台进程组" class="headerlink" title="后台进程组"></a>后台进程组</h3><p>会话期中除前台进程组外的其他进程组。</p><p><img src="https://images.961110.xyz/images/2021/10/20/Untitled.png" alt="进程、进程组和会话期之间的关系"></p><p>进程、进程组和会话期之间的关系</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 任务(进程)数据结构，或称为进程描述符 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line"><span class="comment">/* these are hardcoded - don&#x27;t touch */</span></span><br><span class="line"><span class="comment">/* 硬编码字段 */</span></span><br><span class="line"><span class="keyword">long</span> state;<span class="comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span></span><br><span class="line"><span class="comment">/* 任务运行状态 -1 不可运行，0 可运行(就绪)， &gt;0 已停止 */</span></span><br><span class="line"><span class="keyword">long</span> counter;<span class="comment">/* 任务运行时间计数(递减)(滴答数)，运行时间片 */</span></span><br><span class="line"><span class="keyword">long</span> priority;<span class="comment">/* 优先级 */</span></span><br><span class="line"><span class="keyword">long</span> signal;<span class="comment">/* 信号位图 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sigaction</span>[32];</span><span class="comment">/* 信号执行属性结构,对应信号将要执行的操作和标志信息 */</span></span><br><span class="line"><span class="keyword">long</span> blocked;<span class="comment">/* 进程信号屏蔽码(对应信号位图) */</span> <span class="comment">/* bitmap of masked signals */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* various fields */</span></span><br><span class="line"><span class="comment">/* 可变字段 */</span></span><br><span class="line"><span class="keyword">int</span> exit_code;<span class="comment">/* 退出码 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> start_code;<span class="comment">/* 代码段地址 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> end_code;<span class="comment">/* 代码段长度（字节数） */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> end_data;<span class="comment">/* 代码段加数据段的长度 （字节数）*/</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> brk;<span class="comment">/* 总长度(字节数) */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> start_stack;<span class="comment">/* 堆栈段地址 */</span></span><br><span class="line"><span class="keyword">long</span> pid;<span class="comment">/* 进程标识号(进程号) */</span></span><br><span class="line"><span class="keyword">long</span> pgrp;<span class="comment">/* 进程组号 */</span></span><br><span class="line"><span class="keyword">long</span> session;<span class="comment">/* 会话号 */</span></span><br><span class="line"><span class="keyword">long</span> leader;<span class="comment">/* 会话首领 */</span></span><br><span class="line"><span class="keyword">int</span>groups[NGROUPS];<span class="comment">/* 进程所属组号（一个进程可属于多个组） */</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * pointers to parent process, youngest child, younger sibling,</span></span><br><span class="line"><span class="comment"> * older sibling, respectively.  (p-&gt;father can be replaced with </span></span><br><span class="line"><span class="comment"> * p-&gt;p_pptr-&gt;pid)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p_pptr</span>;</span><span class="comment">/* 指向父进程的指针 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p_cptr</span>;</span><span class="comment">/* 指向最新子进程的指针 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p_ysptr</span>;</span><span class="comment">/* 指向比自己后创建的相邻进程的指针 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p_osptr</span>;</span><span class="comment">/* 指向比自己早创建的相邻进程的指针 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> uid;<span class="comment">/* 用户id */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> euid;<span class="comment">/* 有效用户id */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> suid;<span class="comment">/* 保存的设置用户id */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> gid;<span class="comment">/* 组id */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> egid;<span class="comment">/* 有效组id */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> sgid;<span class="comment">/* 保存的设置组id */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> timeout;<span class="comment">/* 内核定时超时值 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> alarm;<span class="comment">/* 报警定时值(滴答数) */</span></span><br><span class="line"><span class="keyword">long</span> utime;<span class="comment">/* 用户态运行时间(滴答数) */</span></span><br><span class="line"><span class="keyword">long</span> stime;<span class="comment">/* 内核态运行时间(滴答数) */</span></span><br><span class="line"><span class="keyword">long</span> cutime;<span class="comment">/* 子进程用户态运行时间 */</span></span><br><span class="line"><span class="keyword">long</span> cstime;<span class="comment">/* 子进程内核态运行时间 */</span></span><br><span class="line"><span class="keyword">long</span> start_time;<span class="comment">/* 进程开始运行时刻 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rlim</span>[<span class="title">RLIM_NLIMITS</span>];</span><span class="comment">/* 进程资源使用统计数组 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> flags;<span class="comment">/* 各进程的标志，还未使用*/</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> used_math;<span class="comment">/* 是否使用了协处理器的标志 */</span></span><br><span class="line"><span class="comment">/* file system info */</span></span><br><span class="line"><span class="keyword">int</span> tty;<span class="comment">/* -1 if no tty, so it must be signed */</span></span><br><span class="line"><span class="comment">/* 进程使用tty终端的子设备号。-1表示没有使用 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> umask;<span class="comment">/* 文件创建属性屏蔽位 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">pwd</span>;</span><span class="comment">/* 当前工作目录i节点结构指针 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">root</span>;</span><span class="comment">/* 根目录i节点结构指针 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">executable</span>;</span><span class="comment">/* 执行文件i节点结构指针 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">library</span>;</span><span class="comment">/* 被加载库文件i节点结构指针 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> close_on_exec;<span class="comment">/* 执行时关闭文件句柄位图标志 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">filp</span>[<span class="title">NR_OPEN</span>];</span><span class="comment">/* 文件结构指针表，最多32项。表项号即是文件描述符的值 */</span></span><br><span class="line"><span class="comment">/* ldt for this task 0 - zero 1 - cs 2 - ds&amp;ss */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> <span class="title">ldt</span>[3];</span><span class="comment">/* 局部描述符表, 0 - 空，1 - 代码段cs，2 - 数据和堆栈段ds&amp;ss */</span></span><br><span class="line"><span class="comment">/* tss for this task */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tss_struct</span> <span class="title">tss</span>;</span><span class="comment">/* 进程的任务状态段信息结构 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">任务状态</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_RUNNING0<span class="comment">/* 任务正在运行或已准备就绪 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_INTERRUPTIBLE1<span class="comment">/* 任务处于可中断等待状态 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_UNINTERRUPTIBLE2<span class="comment">/* 任务处于不可中断等待状态 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_ZOMBIE3<span class="comment">/* 任务处于僵死状态，已经停止，但父进程还没发出信号 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_STOPPED4<span class="comment">/* 任务已停止 */</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGHUP 1<span class="comment">/* Hang Up-- 挂起控制终端或进程 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGINT 2<span class="comment">/* Interrupt -- 来自键盘的中断 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGQUIT 3<span class="comment">/* Quit-- 来自键盘的退出 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGILL 4<span class="comment">/* Illeagle-- 非法指令 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGTRAP 5<span class="comment">/* Trap -- 跟踪断点 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGABRT 6<span class="comment">/* Abort-- 异常结束 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGIOT 6<span class="comment">/* IO Trap-- 同上 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGUNUSED 7<span class="comment">/* Unused-- 没有使用 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGFPE 8<span class="comment">/* FPE-- 协处理器出错 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGKILL 9<span class="comment">/* Kill-- 强迫进程终止 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGUSR110<span class="comment">/* User1-- 用户信号 1，进程可使用 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGSEGV11<span class="comment">/* Segment Violation -- 无效内存引用 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGUSR212<span class="comment">/* User2    -- 用户信号 2，进程可使用 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGPIPE13<span class="comment">/* Pipe-- 管道写出错，无读者 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGALRM14<span class="comment">/* Alarm-- 实时定时器报警 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGTERM15<span class="comment">/* Terminate -- 进程终止 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGSTKFLT16<span class="comment">/* Stack Fault -- 栈出错（协处理器） */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGCHLD17<span class="comment">/* Child-- 子进程停止或被终止 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGCONT18<span class="comment">/* Continue-- 恢复进程继续执行 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGSTOP19<span class="comment">/* Stop-- 停止进程的执行 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGTSTP20<span class="comment">/* TTY Stop-- tty 发出停止进程，可忽略 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGTTIN21<span class="comment">/* TTY In-- 后台进程请求输入 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGTTOU22<span class="comment">/* TTY Out-- 后台进程请求输出 */</span></span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://blog.csdn.net/qq_29503203/article/details/54618275">https://blog.csdn.net/qq_29503203/article/details/54618275</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 进程管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《智能网联汽车技术》读书笔记</title>
      <link href="/posts/29265.html"/>
      <url>/posts/29265.html</url>
      
        <content type="html"><![CDATA[<h3 id="第一章-智能网联汽车概述"><a href="#第一章-智能网联汽车概述" class="headerlink" title="第一章 智能网联汽车概述"></a>第一章 智能网联汽车概述</h3><p>这一章主要讲了智能网联汽车的一些基本概念、分级以及分阶段的发展目标。</p><h3 id="第二章-中国智能网联汽车发展及标准法规演变趋势"><a href="#第二章-中国智能网联汽车发展及标准法规演变趋势" class="headerlink" title="第二章 中国智能网联汽车发展及标准法规演变趋势"></a>第二章 中国智能网联汽车发展及标准法规演变趋势</h3><p>这一章主要介绍了智能网联汽车的发展路线，产业生态、主机厂、用户接受度的发展趋势，各企业的布局，国内外的系列政策。</p><h3 id="第三章-智能网联汽车产业链及商业模式"><a href="#第三章-智能网联汽车产业链及商业模式" class="headerlink" title="第三章 智能网联汽车产业链及商业模式"></a>第三章 智能网联汽车产业链及商业模式</h3><p>这一章主要介绍了智能网联汽车产业链、价值链、商业化技术服务和商业模式。</p><h3 id="第四章-驾驶场景数据技术"><a href="#第四章-驾驶场景数据技术" class="headerlink" title="第四章 驾驶场景数据技术"></a>第四章 驾驶场景数据技术</h3><p>这一张主要介绍了驾驶场景数据的采集、分类、处理、存储和应用的一系列流程，以及所用到的硬件设备的标定方法。</p><h3 id="第五章-驾驶场景虚拟仿真技术"><a href="#第五章-驾驶场景虚拟仿真技术" class="headerlink" title="第五章 驾驶场景虚拟仿真技术"></a>第五章 驾驶场景虚拟仿真技术</h3><p>这一章主要介绍了仿真测试系统、仿真平台、仿真数据体系、虚拟试验场建设、仿真测试工具和仿真验证与评价。</p><h3 id="第六章-自动驾驶感知融合算法实现与应用"><a href="#第六章-自动驾驶感知融合算法实现与应用" class="headerlink" title="第六章 自动驾驶感知融合算法实现与应用"></a>第六章 自动驾驶感知融合算法实现与应用</h3><p>这一章主要介绍了自动驾驶的相关算法，包括感知、融合、算法验证等，以及会用到的硬件设备，比如激光雷达、毫米波雷达、超声波雷达、摄像头等。</p><h3 id="第七章-自动驾驶工程技术验证与实现"><a href="#第七章-自动驾驶工程技术验证与实现" class="headerlink" title="第七章 自动驾驶工程技术验证与实现"></a>第七章 自动驾驶工程技术验证与实现</h3><p>这一章主要介绍了工程验证的关键技术包括环境感知、决策规划的相关技术，以及车辆改装、功能实现方法和软硬件发展思路。</p><p><img src="https://images.961110.xyz/images/2021/10/20/6a4a580a242f4d97ebe64463412dc677.png" alt="《智能网联汽车技术》关键技术点"></p><p>《智能网联汽车技术》关键技术点</p>]]></content>
      
      
      <categories>
          
          <category> 智能网联汽车 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 智能网联汽车 </tag>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核模块</title>
      <link href="/posts/62642.html"/>
      <url>/posts/62642.html</url>
      
        <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>Linux的内核模块机制允许开发者动态的向内核添加功能，常见的文件系统、驱动程序等都可以通过模块的方式添加到内核而无需对内核重新编译，这在很大程度上减少了操作的复杂度。</p><p>模块机制使内核预编译时不必包含很多无关功能，把内核做到最精简，后期可以根据需要进行添加。针对驱动程序，因为涉及到具体的硬件，很难使通用的，且其中可能包含了各个厂商的私密接口，厂商几乎不会允许开发者把源代码公开，模块机制很好的解决了这个冲突。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>使用模块的优点：</p><ol><li>使得内核更加紧凑和灵活</li><li>修改内核时，不必全部重新编译整个内核，可节省不少时间，避免人工操作的错误。系统中如果需要使用新模块，只要编译相应的模块然后使用特定用户空间的程序将模块插入即可。</li><li>模块可以不依赖于某个固定的硬件平台。</li><li>模块的目标代码一旦被链接到内核，它的作用和静态链接的内核目标代码完全等价。 所以，当调用模块的函数时，无须显式的消息传递。</li></ol><p>缺点：</p><ol><li>由于模块所占用的内存是不会被换出的，所以链接进内核的模块会给整个系统带来一定的性能和内存利用方面的损失。</li><li>装入内核的模块就成为内核的一部分，可以修改内核中的其他部分，因此，模块的使用不当会导致系统崩溃。</li><li>为了让内核模块能访问所有内核资源，内核必须维护符号表，并在装入和卸载模块时修改符号表。</li><li>模块会要求利用其它模块的功能，所以，内核要维护模块之间的依赖性。</li></ol><h3 id="内核符号表"><a href="#内核符号表" class="headerlink" title="内核符号表"></a>内核符号表</h3><p>内核符号表是一个用来存放所有模块可以访问的那些符号以及相应地址的特殊的表。模块的连接就是将模块插入到内核的过程。模块所声明的任何全局符号都成为内核符号表的一部分。内核模块根据系统符号表从内核空间中获取符号的地址，从而确保在内核空间中正确地运行。存放路径：<code>/proc/kallsyms</code></p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h3><ol><li><p>模块装载到内核中，首先调用初始化函数<code>proc_module_init()</code><br>打印初始化提示信息；</p></li><li><p>在查看<code>proc_info</code>文件之前，如右图可见文件是空的，说明代码里的<code>proc_info_show()</code>是在文件被查看时调用的；</p></li><li><p><code>proc_info_show()</code>在执行时首先打印提示信息，然后通过<code>seq_printf()</code>函数分别写入内核版本号和进程数；</p><p>内核版本号保存在结构体ustname中，可以直接调用，proc下verison也是</p></li><li><p>模块卸载的时候，调用出口函数<code>proc_module_exit()</code>，打印退出提示信息。</p></li></ol><p><img src="https://images.961110.xyz/images/2021/10/20/proc_info.png" alt="proc_info文件内容为空"></p><p><img src="https://images.961110.xyz/images/2021/10/20/proc_info69158ed329c16d70.png" alt="proc_info文件里的内容"></p><h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><p><code>create_proc_entry()</code>这个函数在3.x或4.x的时候已经被弃用，用<code>proc_create()</code>代替即可。</p><p><img src="https://images.961110.xyz/images/2021/10/20/my_module.png" alt="my_module模块编译出错"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">proc_dir = proc_mkdir(<span class="string">&quot;my_proc&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">proc_info = proc_create(<span class="string">&quot;proc_info&quot;</span>, <span class="number">0644</span>, proc_dir, &amp;proc_module_fops);</span><br></pre></td></tr></table></figure><h2 id="size-t"><a href="#size-t" class="headerlink" title="size_t"></a>size_t</h2><p>size_t的提出主要是为了解决可移植性问题，方便在处理器位数不同的平台使用。</p><p>size_t一般用来计数，代表C中任何对象所能达到的最大长度，比如：</p><ol><li><code>void *malloc(size_t n);</code> </li><li><code>void *memcpy(void *s1, void const *s2, size_t n);</code></li><li><code>size_t strlen(char const *s);</code></li></ol><p>习惯性地用<code>int</code>类型肯定是有问题的，因为<code>int</code>是带符号的，而且并不一定能覆盖到对象的最大长度。</p><p>int类型对应平台的大小是这样的：</p><ul><li>16位系统中，int型为16位大小，2字节</li><li>32位系统中，int型为32位大小，4字节</li><li>64位系统中，int型为32位大小，4字节</li></ul><p>long类型对应平台的大小是这样的：</p><ul><li>16位系统中，long型为32位大小，4字节</li><li>32位系统中，long型为32位大小，4字节</li><li>64位系统中，long型为64位大小，8字节</li></ul><p>因此猜想size_t在16位架构上应该是2字节，32位架构上是4字节，在64位架构上是8字节。</p><p>size_t在32位架构中被定义为<code>typedef unsigned int size_t;</code>而在64位架构中被定义为<code>typedef unsigned long size_t;</code>符合猜想，16位架构中的定义可能也是<code>typedef unsigned int size_t;</code></p><h2 id="seq-file-操作函数"><a href="#seq-file-操作函数" class="headerlink" title="seq_file 操作函数"></a>seq_file 操作函数</h2><p><code>seq_file</code> 系列函数是为了方便内核导出信息到 sysfs、debugfs、procfs 实现的。简化了文件操作的实现，内部维护缓冲区，内部的当前位置，不用驱动开发者自己实现缓冲区操作，对于驱动开发人员只需要实现相关的数据操作函数回调即可。<br>它包含了如下一些接口：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seq_open</span><span class="params">(struct file *file, <span class="keyword">const</span> struct seq_operations *op)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seq_release</span><span class="params">(struct inode *inode, struct file *file)</span></span>;</span><br><span class="line"><span class="comment">//seq_read 操作是系列函数中最为重要的一个函数，它负责从内部buffer缓冲区中读取数据并 copy_to_user 返回给应用层</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">seq_read</span><span class="params">(struct file *file, <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> size, <span class="keyword">loff_t</span> *ppos)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seq_write</span><span class="params">(struct seq_file *seq, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">loff_t</span> <span class="title">seq_lseek</span><span class="params">(struct file *file, <span class="keyword">loff_t</span> offset, <span class="keyword">int</span> whence)</span>；</span></span><br></pre></td></tr></table></figure><p>在实验过程中就是通过封装好的函数，把内核版本号和进程数写到proc文件里的。</p><h2 id="Linux内核模块参数传递及函数调用"><a href="#Linux内核模块参数传递及函数调用" class="headerlink" title="Linux内核模块参数传递及函数调用"></a>Linux内核模块参数传递及函数调用</h2><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>模块的参数传递也是一个宏，定义在<code>linux/moduleparam.h</code>中，type支持<code>byte, short, ushort,int, uint, long, ulong, bool</code></p><ul><li><p>单个参数传递<code>moudle_param(name,type,perm)</code></p></li><li><p>参数组传递<code>module_param_array(name, type, nump, perm)</code></p><p><strong><code>name</code>数组必须静态分配</strong></p></li><li><p>源文件内外参数名可以不同：<br><code>module_param_named(name, variable, type, perm)</code></p><p>  其中<code>name</code>是外部可见的参数名，<code>variable</code>是源文件内部的全局变量名</p></li><li><p>另一种字符串传递方法<code>module_param_string(name, string, len, perm)</code><br>name是外部的参数名，string是内部的变量名，len是以string命名的buffer大小（可以小于buffer的大小，但是没有意义）。</p></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *msg;</span><br><span class="line">module_param(msg, charp, <span class="number">0644</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> para[<span class="number">8</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> n_para = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> species[BUF_LEN]；</span><br><span class="line">module_param_string(specifies, species, BUF_LEN, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">module_param_array(para , <span class="keyword">int</span> , &amp;n_para , S_IRUGO);</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">module_init</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">module_exit</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在装载模块时指定参数即可</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sudo insmod <span class="keyword">module</span>.ko msg=<span class="string">&quot;test&quot;</span> para=<span class="number">4</span>，<span class="number">5</span>，<span class="number">6</span>，<span class="number">1</span>，<span class="number">8</span> specifies=<span class="string">&quot;test_string&quot;</span></span><br></pre></td></tr></table></figure><h3 id="模块间函数调用"><a href="#模块间函数调用" class="headerlink" title="模块间函数调用"></a>模块间函数调用</h3><p>模块的函数导出到符号表才可以供其他函数使用，需要用到宏：<code>EXPORT_SYMBOL(sym)</code>，该宏在<code>linux/export.h</code>里面。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fun1.c</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;fun() is called\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">EXPORT_SYMBOL(fun);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fun2.c</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;fun_1.h&quot;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mod_init</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;mod_init() start\n&quot;</span>);</span><br><span class="line">    fun();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fun_1.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> KERNEL_FUN_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNEL_FUN_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><img src="https://images.961110.xyz/images/2021/10/20/45bb76418d7ff50f34511fb7e26d23a3.png" alt="实验结果"></p><p>根据日志可以看出，被调用的函数已经打印出了提示信息。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><p>两个不同的模块不能导出相同的的函数，否则会在装载模块的时候报错。</p><p>在<code>/proc/kallsyms</code> 文件中保存对应着内核符号表，它记录了符号以及符号所在的内存地址，所以不能导出相同的函数。</p></li></ol><p><img src="https://images.961110.xyz/images/2021/10/20/79d0e8fb90a66cdebe819d07db6b492a.png" alt="导出相同函数报错"></p><p>导出相同函数报错</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核裁剪</title>
      <link href="/posts/2771.html"/>
      <url>/posts/2771.html</url>
      
        <content type="html"><![CDATA[<h3 id="Kconfig和menuconfig文件"><a href="#Kconfig和menuconfig文件" class="headerlink" title="Kconfig和menuconfig文件"></a>Kconfig和menuconfig文件</h3><p>内核源码的每一级目录下都会有 <strong>Kconfig</strong> 文件，文件里的<code>menu</code>对应<code>make menuconfig</code>中的菜单项，菜单中包含若干子选项，由 <code>source</code>引入各级子目录下的 <code>Kconfig</code>文件，由此构成了<code>menuconfig</code>。</p><p><img src="https://images.961110.xyz/images/2021/10/20/Kconfigmenuconfig.png" alt="Kconfig和menuconfig文件.png"></p><p>每一个子选项在代码中对应的是一个个的<code>config</code></p><p>其中选项中<code>bool</code>代表二选一(编译、不编译)</p><p><code>trastate</code>代表三选一(编译、不编译、编译成模块)</p><p><code>depends on</code>代表其依赖的配置。</p><p><img src="https://images.961110.xyz/images/2021/10/20/config.png" alt="config的构成.png"></p><h3 id="config文件"><a href="#config文件" class="headerlink" title=".config文件"></a>.config文件</h3><p><code>menuconfig</code>又会生成源码根目录下的<code>.config</code>文件，由各个<code>Kconfig</code>中的<code>config</code>宏定义构成。</p><h3 id="makefile文件"><a href="#makefile文件" class="headerlink" title="makefile文件"></a>makefile文件</h3><p>编译内核依赖的makefile文件会根据<code>.config</code>文件来决定是否将对应部分编译进内核。</p><h3 id="四者的关系图如下"><a href="#四者的关系图如下" class="headerlink" title="四者的关系图如下"></a>四者的关系图如下</h3><p><img src="https://images.961110.xyz/images/2021/10/20/menuconfig-Kconfig-.config-makefile.png" alt="menuconfig相关文件的关系"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 内核裁剪 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM目标代码优化</title>
      <link href="/posts/64925.html"/>
      <url>/posts/64925.html</url>
      
        <content type="html"><![CDATA[<h2 id="速度优化"><a href="#速度优化" class="headerlink" title="速度优化"></a>速度优化</h2><h3 id="通用优化方法"><a href="#通用优化方法" class="headerlink" title="通用优化方法"></a>通用优化方法</h3><p><strong>减少计算强度</strong></p><ol><li>左右位移代替乘除2运算: <code>i = i * 5 = (i &lt;&lt; 2) + 1</code> ，位移有桶形位移器，执行比乘除快。</li><li>乘法代替乘方运算: <code>i = pow(i, 3) = i * i * i</code>，ARM中有乘法器，所以比调用函数更快。</li><li>与运算代替求余运算: <code>i = i % 8 = i &amp; 0x07</code>，ARM中没有求余指令，但是有与指令。</li></ol><p><strong>优化循环终止条件</strong></p><p>使用减计数代替惯用的加计数，使用<code>i != 0</code>作循环终止条件。加法计数在循环判断的时候是用CMP和BLE实现的，而用<code>i != 0</code>可以用BNE一条指令代替。</p><p><strong>使用<code>inline</code>函数</strong></p><p><code>inline</code>函数主要节省了调用函数所占用的时间。缺点就是被频繁调用时，代码量将增大，以空间换时间。</p><p><strong>利用已有结果</strong></p><p><code>tmp = a * b;</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i = a * b + c;</span><br><span class="line">j = a * b * d;</span><br></pre></td></tr></table></figure><p><strong>避免循环</strong></p><p>拆开小循环</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">x[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">x[<span class="number">0</span>] = <span class="number">0</span>; x[<span class="number">1</span>] = <span class="number">1</span>; x[<span class="number">2</span>] = <span class="number">2</span>;...;x[<span class="number">9</span>] = <span class="number">9</span>;</span><br></pre></td></tr></table></figure><h3 id="处理器相关的优化方法"><a href="#处理器相关的优化方法" class="headerlink" title="处理器相关的优化方法"></a>处理器相关的优化方法</h3><p><strong>保持流水线畅通</strong></p><p>将循环拆解来<strong>减小跳转指令在循环指令中所占的比重。</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memcopy</span><span class="params">(<span class="keyword">char</span> *to, <span class="keyword">char</span> *from, <span class="keyword">unsigned</span> <span class="keyword">int</span> nbytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p_to = (<span class="keyword">int</span> *)to;</span><br><span class="line"><span class="keyword">int</span> *p_from = (<span class="keyword">int</span> *)from;</span><br><span class="line"><span class="keyword">while</span>(nbytes) &#123;</span><br><span class="line">*p_to++ = *p_from++;</span><br><span class="line">*p_to++ = *p_from++;</span><br><span class="line">*p_to++ = *p_from++;</span><br><span class="line">*p_to++ = *p_from++;</span><br><span class="line">nbytes - = <span class="number">16</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过优化后，一次循环可以处理16 个字节。</p><p><strong>使用寄存器变量</strong></p><p>整型、指针、浮点等类型的变量都可以分配寄存器；一个结构的部分或者全部也可以分配寄存器。给循环体中需要频繁访问的变量分配寄存器也能在一定程度上提高程序效率。</p><h3 id="指令集相关的优化方法"><a href="#指令集相关的优化方法" class="headerlink" title="指令集相关的优化方法"></a>指令集相关的优化方法</h3><p><strong>避免除法</strong></p><p>ARM7 指令集中没有除法指令，其除法是通过调用 C 库函数实现的。一个32 位的除法通常需要20~140 个时钟周期。</p><ul><li>例如<code>if((x/y) &gt; z)</code>可变通为<code>if(x &gt; (y × z))</code></li><li>在能满足精度，且存储器空间冗余的情况下， 也可考虑使用查表法代替除法。</li><li>当除数为2 的幂次方时， 应用移位操作代替除法。</li></ul><p><strong>在后来支持硬件除法的芯片（Cortex-M3）中，用<code>SDIV</code>指令代替了库函数的调用。</strong></p><p><strong>利用条件执行</strong></p><p>ARM 指令集的一个重要特征就是<strong>所有的指令均可包含一个可选的条件码</strong>。当程序状态寄存器(PSR)中的条件码标志满足指定条件时，指令才能执行，因此可以省去单独的判断指令。</p><p><strong>使用合适的变量类型</strong></p><p>在操作char、short型的ARM局部变量，往往比操作32 位变量需要更多指令，所以应该尽可能地避免使用。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wordinc</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">ADD a1,a1,#<span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> a + <span class="number">1</span>; MOV pc,lr</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">short</span> <span class="title">shortinc</span><span class="params">(<span class="keyword">short</span> a)</span> </span>&#123;</span><br><span class="line">ADD a1,a1,#<span class="number">1</span></span><br><span class="line">MOV a1,a1,LSL #<span class="number">16</span></span><br><span class="line"><span class="keyword">return</span> a + <span class="number">1</span>; MOV a1,a1,ASR #<span class="number">16</span>ARM</span><br><span class="line">&#125; MOV pc,<span class="function">lr</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">charinc</span><span class="params">(<span class="keyword">char</span> a)</span></span>&#123;</span><br><span class="line">ADD a1,a1,#<span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> a + <span class="number">1</span>; </span><br><span class="line">AND a1,a1,#&amp;ff</span><br><span class="line">&#125; MOV pc,lr</span><br></pre></td></tr></table></figure><h3 id="存储器相关的优化方法"><a href="#存储器相关的优化方法" class="headerlink" title="存储器相关的优化方法"></a>存储器相关的优化方法</h3><p><strong>用查表代替计算</strong></p><p>用空间换速度：例如需要频繁计算正弦或余弦函数值时，可预先将函数值计算出来置于内存中供以后ARM查找。</p><p><strong>充分利用片内RAM</strong></p><p>一些厂商出产的ARM 芯片内集成有一定容量的RAM，处理器对片内RAM 的访问速度要快于对外部RAM 的访问。</p><h3 id="编译器相关的优化方法"><a href="#编译器相关的优化方法" class="headerlink" title="编译器相关的优化方法"></a>编译器相关的优化方法</h3><p>根据编译器提供的优化选项进行设置。多数编译器都支持对程序速度和程序大小的优化，有些编译器还允许用户选择可供优化的内容及优化的程度。</p><h2 id="尺寸优化"><a href="#尺寸优化" class="headerlink" title="尺寸优化"></a>尺寸优化</h2><h3 id="使用多寄存器操作指令"><a href="#使用多寄存器操作指令" class="headerlink" title="使用多寄存器操作指令"></a>使用多寄存器操作指令</h3><p>ARM 指令集中的多寄存器操作指令LDM/STM 可以加载/ 存储多个寄存器，这在保存/ 恢复寄存器组的状态及进行大块数据复制时非常有效。例如要将寄存器R4~R12 及R14 的内容保存到堆栈中，若用<code>STR</code> 指令共需要10 条，而一条<code>STMEA R13!, &#123;R4 ?? R12, R14&#125;</code> 指令就能达到相同的目的，虽然在执行速度上不一定有提高。</p><h3 id="合理安排变量顺序"><a href="#合理安排变量顺序" class="headerlink" title="合理安排变量顺序"></a>合理安排变量顺序</h3><p>ARM程序中的32 位/16 位变量必须按字/ 半字对齐</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>  i1 ~ i4;</span><br><span class="line"><span class="keyword">char</span> c1 ~ c4;</span><br><span class="line"></span><br><span class="line">按照i1、c1、i2、c2、i3、c3、i4、c4的顺序排列的话，<span class="number">8</span>位的<span class="keyword">char</span>型变量实际上占用的是一个<span class="number">32</span>位寄存器，空间浪费</span><br><span class="line">所以应将 <span class="keyword">int</span> 型变量和 <span class="keyword">char</span> 型变量按类似i1、i2、i3、i4、c1、c2、c3、c4 的顺序连续存放。</span><br></pre></td></tr></table></figure><h3 id="使用Thumb指令"><a href="#使用Thumb指令" class="headerlink" title="使用Thumb指令"></a>使用Thumb指令</h3><p>16 位的 Thumb 指令是ARM 体系结构的扩充。Thumb 指令集是大多数常用32 位ARM 指令压缩成16 位宽指令的集合。</p>]]></content>
      
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> ARM </tag>
            
            <tag> 代码优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>租房注意事项</title>
      <link href="/posts/40489.html"/>
      <url>/posts/40489.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、重中之重"><a href="#一、重中之重" class="headerlink" title="一、重中之重"></a>一、重中之重</h2><ol><li>租 转租房一定要三方（你、转租人、房东）都在场，最好直接跟房东签协议。</li><li>房东、二房东的身份证复印件和房本要留底，可以写仅供租房使用。</li><li>不租隔断间，敲墙听音；</li><li>下面所有细节都要在合同上落实好</li><li>仔细看合同！！！！！</li><li>别轻易交定金。</li><li>核对电子版跟签的纸质版是否有细节上的变动。</li></ol><h2 id="二、细节"><a href="#二、细节" class="headerlink" title="二、细节"></a>二、细节</h2><h3 id="筛选小区"><a href="#筛选小区" class="headerlink" title="筛选小区"></a>筛选小区</h3><h4 id="便利性"><a href="#便利性" class="headerlink" title="便利性"></a>便利性</h4><ol><li>有无商场</li><li>有无超市、菜市场</li><li>周围外卖情况（直接在外卖软件上看）</li><li>周围打车情况（直接在打车软件上看）</li><li>有无社区医院、药店</li></ol><h4 id="整体环境"><a href="#整体环境" class="headerlink" title="整体环境"></a>整体环境</h4><ol><li>小区封闭或开放</li><li>有无保安</li><li>进出小区是否刷卡</li><li>绿化情况</li><li>一梯几户： 户数多，层数高，电梯排队时间长</li><li>老人多还是年轻人多</li></ol><h4 id="房屋性质"><a href="#房屋性质" class="headerlink" title="房屋性质"></a>房屋性质</h4><ol><li>城中村</li><li>回迁房</li><li>商住两用： 燃气一般不通、商水商电、物业参差不齐</li></ol><h4 id="预备资金"><a href="#预备资金" class="headerlink" title="预备资金"></a>预备资金</h4><p>押一付三+中介费=五个月的房租</p><h3 id="筛选房子"><a href="#筛选房子" class="headerlink" title="筛选房子"></a>筛选房子</h3><h4 id="楼层及位置"><a href="#楼层及位置" class="headerlink" title="楼层及位置"></a>楼层及位置</h4><ul><li>一楼  不安全</li><li>顶楼  电梯不方便、可能房顶漏水</li><li>楼下别有KTV、Club</li></ul><h4 id="季节性因素"><a href="#季节性因素" class="headerlink" title="季节性因素"></a>季节性因素</h4><ul><li>夏季<ol><li>房顶漏不漏水</li><li>潮不潮</li></ol></li><li>冬季<ol><li>屋内温度</li></ol></li></ul><h4 id="杂费缴纳"><a href="#杂费缴纳" class="headerlink" title="杂费缴纳"></a>杂费缴纳</h4><ol><li>物业费</li><li>取暖费</li><li>卫生费</li><li>水、电、网、燃气费</li></ol><h4 id="网络需求"><a href="#网络需求" class="headerlink" title="网络需求"></a>网络需求</h4><p>通哪些运营商的网络</p><ol><li>移动</li><li>电信</li><li>联通</li></ol><p>手机信号如何</p><h4 id="水、电、燃气、物业费等交割"><a href="#水、电、燃气、物业费等交割" class="headerlink" title="水、电、燃气、物业费等交割"></a>水、电、燃气、物业费等交割</h4><ol><li>签合同之前确定水、电、燃气表的读数</li><li>有无拖欠物业费等</li></ol><h4 id="问题家电"><a href="#问题家电" class="headerlink" title="问题家电"></a>问题家电</h4><ol><li>所有家电、家具都试用一遍，确定状态 有问题的家电可以要求房东更换：<ul><li>给换，Yeah！</li><li>不给换，说自己买：<ul><li>旧家电房东搬走，OK！</li><li>不搬走？不租！房东肯定事儿多！</li></ul></li></ul></li></ol><h4 id="证据留存"><a href="#证据留存" class="headerlink" title="证据留存"></a>证据留存</h4><ol><li>房子的状态、家具、家电都拍照或者录视频记录，退房时候以免万一</li></ol><h4 id="房屋朝向"><a href="#房屋朝向" class="headerlink" title="房屋朝向"></a>房屋朝向</h4><p>一定坐北朝南！</p><h4 id="卫生问题"><a href="#卫生问题" class="headerlink" title="卫生问题"></a>卫生问题</h4><ol><li>有无蟑螂、老鼠</li><li>通风好不好</li><li>下水道有没有反味、通不通畅</li><li>噪音</li></ol><h4 id="换锁芯"><a href="#换锁芯" class="headerlink" title="换锁芯"></a>换锁芯</h4><p>交房之后换锁芯，旧锁芯保留，退房的时候换上</p><h4 id="押金"><a href="#押金" class="headerlink" title="押金"></a>押金</h4><p>抱着不要的心态，调整好心态，但是要争取挽回可能的损失。</p><h2 id="小注意事项"><a href="#小注意事项" class="headerlink" title="小注意事项"></a>小注意事项</h2><ol><li>哥哥、姐姐叫起来，大家都出来混的，强龙不压地头蛇。</li><li>记得砍价，也许房租可以便宜一二百；中介费也是可谈的。 中介说走过路过不要错过的时候，记得还价！记住TA是要赚你的钱的，主动权应该在你手上，你可以说不是非这个房子不可，又不是赶着住，希望TA能再压低价格，如果可以了明天就可以签。</li><li>锁定一个心意的房子之后，中介说已经租出去了，要带着去看其他的房子。直接Say NO！</li><li>多花一点钱，比平时上下班多花一个小时更舒服。</li><li>合租可以看TA的工作是否规律、有无不良习惯、房子是否整洁、厕所是否干净</li><li>先看实拍图，再实地看房。</li><li>要看房本、身份证。</li><li>合同详细内容可以百度做功课。</li><li>给中介转中介费的时候要有第三方在，或者全程录音，而且转账账号要念出来让他确认。</li><li>从中介或者二房东租房要看其委托书或合同的委托或租赁时长，以免中途被赶出去。</li><li>不用租房贷。</li><li>到地铁口、超市等距离要看地图实际距离；</li><li>58同城上可以在线签合同，应该是没有什么问题的</li><li>租好房之后如果房子比较脏，可以在58或者其他平台上找找保洁，价格可以接受的话请保洁还是很划算的。</li></ol><h2 id="法律小知识"><a href="#法律小知识" class="headerlink" title="法律小知识"></a>法律小知识</h2><ol><li>业主负责维修 家电、家具合理的老化磨损应由业主负责，而非租客赔偿</li><li>买卖不破租赁 房子换了房东，我们依然有权依照合同约定期限继续居住</li><li>出现纠纷需要仲裁，仲裁费用由对方出</li><li>转租需征得业主同意</li><li>装修需经业主同意</li><li>甲醛超标可要求赔偿</li><li>不付租金房东有权赶走租客</li><li>续租需补签续租合同</li></ol><h2 id="合同相关"><a href="#合同相关" class="headerlink" title="合同相关"></a>合同相关</h2><ol><li>房主违约赔偿规则</li><li>租户违约赔偿规则</li><li>是否可以转租、装修、养宠物</li><li>物业费 如果包括，要清楚的写到合同上—房租 xx 元/月（含物业费）<br> 如果不包括，一定要问清楚物业费是怎么算的，具体到一平米多少钱还要写清楚你交的物业是你房间的平方米数，还是包括公摊面积（比如客厅，厕所）</li><li>电费<ul><li>你们租户自己交电费（支付宝就能交，房东有水电卡）</li><li>房东交按收据收钱</li><li>看总电表，按 x 毛度算钱</li></ul></li></ol><figure class="half">    <img src="https://images.961110.xyz/images/2021/10/20/98745486c5106dcec004682626f2af82.jpg">    <img src="https://images.961110.xyz/images/2021/10/20/26b7a5b950bfb95c45a6164ec43549ae.jpg"></figure><h2 id="六、参考链接"><a href="#六、参考链接" class="headerlink" title="六、参考链接"></a>六、参考链接</h2><ol><li><a href="https://b23.tv/hfMNvq">https://b23.tv/hfMNvq</a></li><li><a href="https://b23.tv/1sNxTj">https://b23.tv/1sNxTj</a></li><li><a href="https://b23.tv/koKZX7">https://b23.tv/koKZX7</a></li><li><a href="https://b23.tv/ug2GjJ">https://b23.tv/ug2GjJ</a></li><li><a href="https://www.zhihu.com/question/375266600">https://www.zhihu.com/question/375266600</a></li><li><a href="https://zhuanlan.zhihu.com/p/112314408">https://zhuanlan.zhihu.com/p/112314408</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 生活 </tag>
            
            <tag> 租房 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MAC使用VNC连接Centos7服务器</title>
      <link href="/posts/44617.html"/>
      <url>/posts/44617.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在windows 中，很多人选择安装xmanager+xshell，然后远程连接linux，就能直接调用软件的GUI界面。于是也在Mac上尝试远程调用Centos7的界面，但是使用XQuartz软件+ssh -X命令的方式(教程网址在最后引用里有)并不管用，百度了半天才发现可以使用VNC连接Centos7，故进行了总结。</p><h2 id="安装（Centos7）"><a href="#安装（Centos7）" class="headerlink" title="安装（Centos7）"></a>安装（Centos7）</h2><h3 id="安装x-window（已有图形界面则跳过此步骤）"><a href="#安装x-window（已有图形界面则跳过此步骤）" class="headerlink" title="安装x-window（已有图形界面则跳过此步骤）"></a>安装x-window（已有图形界面则跳过此步骤）</h3><p>以root用户输入以下命令安装x-window</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">yum check-update</span><br><span class="line">yum groupinstall <span class="string">&quot;X Window System&quot;</span></span><br><span class="line">yum install gnome-classic-session gnome-terminalnautilus-open-terminal control-center liberation-mono-fonts</span><br><span class="line"></span><br><span class="line">### 设置默认启动图形界面</span><br><span class="line">unlink /etc/systemd/system/<span class="keyword">default</span>.target</span><br><span class="line">ln -sf /lib/systemd/system/graphical.target/etc/systemd/system/<span class="keyword">default</span>.target</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><p>重启完成后，Centos7就会有图形化界面了。</p><h3 id="安装VNC-Server"><a href="#安装VNC-Server" class="headerlink" title="安装VNC Server"></a>安装VNC Server</h3><p>输入以下命令检查vnc server是否安装</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">yum info tigervnc-server</span><br></pre></td></tr></table></figure><p>已经安装好会有以下vnc server的信息</p><img src="https://images.961110.xyz/images/2021/10/20/tigervnc-server.png" alt="tigervnc-server安装" style="zoom: 67%;" /><p>没有安装好则以root用户运行以下命令来安装vncserver</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">yum install tigervnc-server</span><br></pre></td></tr></table></figure><h3 id="配置相关文件"><a href="#配置相关文件" class="headerlink" title="配置相关文件"></a>配置相关文件</h3><p>需要在 /etc/systemd/system/ 目录里创建一个配置文件，可以将 /lib/systemd/sytem/vncserver@.service 拷贝一份配置文件范例过来。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cp /lib/systemd/system/vncserver@.service  /etc/systemd/system/vncserver@:<span class="number">1.</span>service</span><br></pre></td></tr></table></figure><p>编辑/etc/systemd/system/vncserver@:1.service,替换成自己的用户名。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#普通用户用下面两句</span><br><span class="line">ExecStart=/sbin/runuser -l &lt;user_name&gt; -c<span class="string">&quot;/usr/bin/vncserver %i&quot;</span></span><br><span class="line">PIDFile=/home/&lt;user_name&gt;/.vnc/%H%i.pid</span><br><span class="line"></span><br><span class="line"><span class="meta">#root用户用下面两句</span></span><br><span class="line">ExecStart=/sbin/runuser -l root -c <span class="string">&quot;/usr/bin/vncserver %i&quot;</span></span><br><span class="line">PIDFile=/root/.vnc/%H%i.pid</span><br></pre></td></tr></table></figure><p>修改完的文件内容如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Remote desktop service (VNC)</span><br><span class="line">After=syslog.target network.target</span><br><span class="line"></span><br><span class="line">Type=forking</span><br><span class="line"></span><br><span class="line"># Clean any existing files in /tmp/.X11-unix environment</span><br><span class="line"></span><br><span class="line">ExecStartPre=/bin/sh -c <span class="string">&#x27;/usr/bin/vncserver -kill %i &gt; /dev/null 2&gt;&amp;1 || :&#x27;</span></span><br><span class="line"></span><br><span class="line">ExecStart=/sbin/runuser -l root -c <span class="string">&quot;/usr/bin/vncserver %i -geometry 800x600&quot;</span></span><br><span class="line"></span><br><span class="line">PIDFile=/root/.vnc/%H%i.pid</span><br><span class="line"></span><br><span class="line">ExecStop=/bin/sh -c <span class="string">&#x27;/usr/bin/vncserver -kill %i &gt; /dev/null 2&gt;&amp;1 || :&#x27;</span></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>更新systemctl以使其生效</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>最后还要设置一下用户的 VNC 密码。要设置某个用户的密码，必须要有能通过 sudo 切换到用户的权限。PS：密码要≥六位</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">su user_name</span><br><span class="line">vncpasswd</span><br></pre></td></tr></table></figure><p>执行如下语句，让防火墙放行vnc服务</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --add-service vnc-server</span><br><span class="line"></span><br><span class="line">systemctl restart firewalld.service</span><br></pre></td></tr></table></figure><p>或者设置防火墙放行对应端口</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --zone=<span class="keyword">public</span> --add-port=<span class="number">5901</span>/tcp</span><br><span class="line"></span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>如果命令报错，可能是由于安装了python3的解释器，python是指向python3的，而原来的系统firewall-cmd 是命令脚本是使用python2的，而python3没有对应包，所以需要修改firewall-cmd命令脚本，让它依旧使用python2，这样就不会有问题了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sudo vim /usr/bin/firewall-cmd</span><br></pre></td></tr></table></figure><p>第一行python改为python2</p><p><img src="https://images.961110.xyz/images/2021/10/20/python.png" alt="更改python解释器"></p><p>接着把vnc添加到开机自启动</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">systemctl enable vncserver@:<span class="number">1.</span>service</span><br></pre></td></tr></table></figure><p>最后启动服务</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">systemctl start vncserver@:<span class="number">1.</span>service</span><br></pre></td></tr></table></figure><p>启动时可能会报如下错误</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">job <span class="keyword">for</span> vncserver@:<span class="number">1.</span>service failed because a configured resourcelimit was exceeded.</span><br></pre></td></tr></table></figure><p>执行# systemctl status vncserver@:1.service，发现一条信息：</p><p>localhost.localdomain systemd[1]: PID file /root/.vnc/localhost.localdomain:1.pid not readable (yet?) after start.</p><p>检查 /root/.vnc/，发现没有localhost.localdomain:1.pid</p><p>解决方法：</p><p>原来目录/tmp/下有一个/.X11-unix目录会占用这个pid序号资源。<br>把这个目录改名/.X11-unix.bak后，再次尝试启动后成功。</p><p>执行的代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mv /tmp/.X11-unix /tmp/.X11-unix.bak</span><br><span class="line"></span><br><span class="line">systemctl start vncserver@\:<span class="number">1.</span>service</span><br></pre></td></tr></table></figure><p>如果提示Too many open files 且启动不成功，重启一下机器即可</p><p>注意：非正常关机启动后，会报</p><p>PID 4286 read from file /root/.vnc/localhost.localdomain:1.pid does not exist or is a zombie</p><p>或者 PID file /root/.vnc/localhost.localdomain:2.pid not readable (yet?) after start.</p><p>解决方法：cd /tmp/.X11-unix</p><p>Rm -rf *</p><h3 id="多用户连接"><a href="#多用户连接" class="headerlink" title="多用户连接"></a>多用户连接</h3><p>如果需要更多的用户连接，需要创建配置文件和端口，添加一个新的用户和端口。创建/etc/systemd/system/vncserver@:*.service，替换配置文件里的用户名和之后步骤里相应的文件名、端口号。</p><p>VNC 服务本身使用的是 5900 端口。鉴于有不同的用户使用 VNC ，每个人的连接都会获得不同的端口。第一个 VNC 服务会运行在 5901（5900 + 1）端口上，之后的依次增加，运行在 5900 + x 号端口上。其中 x 是指之后用户的配置文件名 vncserver@:x.service 里面的 x 。</p><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><p>关闭 VNC 服务</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">systemctl stop vncserver@:<span class="number">1.</span>service</span><br></pre></td></tr></table></figure><p>禁止 VNC 服务开机启动</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">systemctl disable vncserver@:<span class="number">1.</span>service</span><br></pre></td></tr></table></figure><p>关闭防火墙</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br></pre></td></tr></table></figure><h2 id="安装（MAC）"><a href="#安装（MAC）" class="headerlink" title="安装（MAC）"></a>安装（MAC）</h2><h3 id="安装VNC-Viewer"><a href="#安装VNC-Viewer" class="headerlink" title="安装VNC Viewer"></a>安装VNC Viewer</h3><p>链接：<a href="https://www.realvnc.com/download/file/viewer.files/VNC-Viewer-6.19.923-MacOSX-x86_64.dmg">https://www.realvnc.com/download/file/viewer.files/VNC-Viewer-6.19.923-MacOSX-x86_64.dmg</a></p><p>启动输入IP:Port进行连接</p><img src="https://images.961110.xyz/images/2021/10/20/VNCViewer.png" alt="VNCViewer" style="zoom:67%;" /><p>输入之前设置的密码即可</p><p><img src="https://images.961110.xyz/images/2021/10/20/VNC.png" alt="VNC连接"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://blog.csdn.net/dobell/article/details/55047811">https://blog.csdn.net/dobell/article/details/55047811</a>（mac如何ssh连接linux(ubuntu) GUI图形界面）</li><li><a href="https://blog.csdn.net/weixin_38280090/article/details/84259489">https://blog.csdn.net/weixin_38280090/article/details/84259489</a>（Linux VNC server 安装配置）</li><li><a href="https://blog.csdn.net/smile_caijx/article/details/78797234">https://blog.csdn.net/smile_caijx/article/details/78797234</a>（在Linux中如何开启VNC服务）</li><li><a href="https://linux.cn/article-5335-1.html">https://linux.cn/article-5335-1.html</a>（怎样在 CentOS 7.0 上安装和配置 VNC 服务器）</li><li><a href="https://blog.csdn.net/qq_42999398/article/details/88750280">https://blog.csdn.net/qq_42999398/article/details/88750280</a>（centos7 firewall-cmd 命令报错）</li><li><a href="https://blog.csdn.net/liliangkuba/article/details/99684420">https://blog.csdn.net/liliangkuba/article/details/99684420</a>（解决vncserver报错：PID file /root/.vnc/localhost.localdomain:1.pid not readable）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Linux </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
